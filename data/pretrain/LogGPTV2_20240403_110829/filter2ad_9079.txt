# MMD-0051-2016 – 小型ELF远程后门程序揭秘
|
##### 译文声明
本文是翻译文章，文章来源：360安全播报
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
**背景知识**
****
2014年的9月份,在我对shellshock漏洞进行分析和研究的过程中,我对MMD-0027-2014(利用ShellShock漏洞来加载ELF
payload,并对目标主机进行攻击)进行了分析。如果大家想要了解关于这一案例的具体信息,请点击[这里](http://blog.malwaremustdie.org/2014/09/linux-elf-bash-0day-fun-has-only-just.html)获取。
今天,我发现了一个非常有趣的ELF
x86-32实例,而在我发现它的几个小时之后,便有相关人员报告了这一感染源。但他们并不清楚其中的ELF代码是否包含有恶意代码,而且也无法识别处这种恶意软件的类别,他们只知道这个感染载体与ShellShock有关。所以我打算对这个感染载体进行分析,我希望我的研究成果能够为安全社区在分析同类病毒样本时提供有效的帮助。
我们在英特尔32位架构的计算机中对ELF代码进行了静态编译,ELF代码的编译结果如下图所示:
**恶意文件样本分析**
我的兴趣爱好之一就是去发现并验证shellcode,在得到了ELF文件的十六进制代码之后,我便准备对ELF文件头进行解析。从其代码中我发现,从“31 db
f7 e3 53 43 53 6a 02 b0 66”开始,到“cd 80 ff e1”结束,这部分数据就是我所要找的shellcode。
可能有的读者并不了解什么是shellcode,Shellcode实际是一段代码(也可以是填充数据),是用来发送到服务器利用特定漏洞的代码,一般而言,攻击者可以利用shellcode来获取目标主机的控制权限。另外,Shellcode一般是作为数据发送给受攻击服务器的。
Shellcode是溢出程序和蠕虫病毒的核心,提到它自然就会和漏洞联想在一起,毕竟Shellcode只对没有打补丁的主机有用武之地,但是网络上数以万计带着漏洞顽强运行着的服务器仍然给攻击者们提供了丰盛的晚餐。除此之外,漏洞利用中最关键的是Shellcode的编写了。
在与我之前所研究过的样本进行了分析比对之后,我发现这个shellcode更加的简短。我认为这段shellcode很可能只是一部分代码,攻击者可能出于某种原因,只截取了一部分进去,或者说这只是攻击者所采用的部分攻击模块。但无论这段代码到底有怎样的功能,我都决定要对其进行深入地研究,当然了,我肯定会使用到Radare的。可能有的读者并不了解Radare,Radare
是一款高级的命令行 Hex (十六进制)编辑器。它不仅随附了许多有用的工具,包括
rasm(汇编/反汇编)、radiff(bindiffer)、rax(base 转换)、rasc、rabin、rahase 等,而且可运行于
Linux、Windows、Maemo、iTouch/iPhone 等多种平台。
其代码和具体的操作码如下图所示:
粗略一看,这段shellcode与我之前所分析过的shellcode有些相似,但它还是略有不同的,而且它比之前的那段shellcode还要简短。接下来,我们将对其工作运行机制进行详细的分析和描述。
**恶意操作代码解析**
我对代码进行了拆解,并将它们分为了“调用”和“处理”这两个类别。具体结果如下图所示:
上图所显示的第三行代码至第二十五行代码(参考地址0x08048054至0x0804807a)所要表达的意思是:
首先,这段ELF
shellcode会调用socket,并使用socket(PF_INET)将网络通信链接与特定的IP地址和端口号进行绑定设置(如上图所示,这一部分均采用硬编码操作),这样一来,程序就成功建立了与远程设备进行网络通信的后端连接了。值得一提的是,我在其他的恶意软件或者恶意shellcode中也见过类似的处理机制。经过了上述分析之后,我发现这一实例与我在2014年9月所分析的实例(我在文章开头给出了链接地址)从某种程度上来说是有一些相似的。
除此之外,剩下的那些代码也有很多有趣的地方。
在地址0x0804807c处,代码会将内存空间(堆存储)设置为7,这也就意味着系统堆栈会将PROT_READ,
PROT_WRITE和PROT_EXEC标志设为可读,可写,和可执行。从上图中我们可以看到,从地址0x0804807e至0x0804808d的代码与此项设置有关,代码会调用相关的C函数来位内存空间进行初始化操作。
从这里开始,我似乎闻到了一丝危险的气息。我们接下来的操作将会对这一恶意行为进行详细的分析。在地址0x0804808f处,代码会重新获取socket,并且会从socket中读取相关数据(具体可参考0x08048095),然后将数据写入堆内存(可读/可写/可执行)中。
接下来,地址0x08048099中最后一行代码会跳转到ECX寄存器,而该寄存器包含有指向堆内存中存储数据的指针。没错,这也就意味着,无论堆内存中存储了什么样的数据,我们都可以直接执行它们了。
这个后门程序的适用范围非常的广,因为攻击者可以随意向受感染的主机中安装和发送任何的恶意内容。我希望各位安全研究人员能够关注这个后门。除此之外,我还认为攻击者能够利用这个后门,并通过shell向目标主机注入ELF代码。而且在黑客社区中已经有黑客这样做了,所以我也希望大家能够对此有一定的了解,不要向一些系统管理员一样,连自己的服务器被病毒感染了都不知道。
**后门的行为分析**
当后门在受感染的服务器中运行时,系统管理员可以在内核空间中观察到恶意软件所进行的操作,具体情况如下图所示:
出于安全方面的考虑,我对上图所显示的代码进行了一些切割处理。
**恶意软件的命名**
在此,我必须要对某些反病毒软件进行声讨,有的反病毒软件将这个恶意软件定义为一种“下载器”,但如果你对它的代码进行了分析,你就会发现其代码根本不会进行任何的下载操作。实际上,它是一个后门程序。利用这个后门,远程攻击者就可以通过TCP连接来触发受感染主机中的恶意代码并执行。
有的反病毒软件将这个恶意软件取名为“GetShell”,
因为通过这个后门程序进入受感染主机的绝大部分都是shell代码,所以这个名字倒也可取。但是请注意:这个恶意软件并没有使用GET方法来接收主机信息,它只会与主机建立一条IP连接,然后等待。除此之外,这个恶意软件的payload也不一定需要是shell代码,它可以是一个rootkit或者其他的恶意程序。
而有的防毒软件将这个恶意软件命名为“ShellLoader”,这真是太离谱了,这个名字与这款恶意软件压根没有任何的关系。首先,其代码并没有加载任何东西;其次,shellloader
ELF恶意软件的运行机制与其完全不懂,请不要混淆这两者的概念。
在此,我要恭喜那些能够对这款恶意软件正确命名的反病毒产品供应商,你们做得非常棒!
**恶意软件样本**
如果大家对此感兴趣的话,可以点击[这里](https://www.virustotal.com/en/file/cb95458e646859b32a88ed9778a5f9c7500d2a81eae31f0f9d70fc6b10511634/analysis/1454487250/)获取来这款恶意软件的样本。