# MMD-0051-2016 – 小型ELF远程后门程序揭秘

##### 译文声明
本文为翻译文章，原文来源：360安全播报。具体内容和含义以原文为准。

## 背景知识
2014年9月，在对ShellShock漏洞进行分析的过程中，我研究了MMD-0027-2014案例（利用ShellShock漏洞加载ELF payload并对目标主机发起攻击）。有关该案例的详细信息，请参阅[这里](http://blog.malwaremustdie.org/2014/09/linux-elf-bash-0day-fun-has-only-just.html)。

最近，我发现了一个非常有趣的ELF x86-32样本。在我发现它的几个小时后，有报告指出这一感染源的存在。然而，报告者并不清楚该ELF代码是否包含恶意代码，也无法确定其具体类型，只知道它与ShellShock漏洞有关。因此，我决定对其进行深入分析，希望我的研究成果能够帮助安全社区更好地理解类似的恶意软件样本。

我们在英特尔32位架构的计算机上对ELF代码进行了静态编译，结果如下图所示：

## 恶意文件样本分析
我的兴趣之一是发现并验证shellcode。在获取到ELF文件的十六进制代码后，我开始解析ELF文件头。从代码中可以看出，从“31 db f7 e3 53 43 53 6a 02 b0 66”开始，到“cd 80 ff e1”结束的部分就是我要找的shellcode。

对于不熟悉shellcode的读者，shellcode是一段用于发送到服务器以利用特定漏洞的代码。通常情况下，攻击者利用shellcode来获取目标主机的控制权。此外，shellcode是溢出程序和蠕虫病毒的核心，主要针对未打补丁的主机。

与之前研究过的样本相比，这段shellcode更为简短。我认为它可能只是整个攻击模块的一部分。无论其具体功能如何，我都决定对其进行深入研究，并使用Radare工具。Radare是一款高级命令行Hex编辑器，支持多种平台，随附了许多有用的工具，如rasm、radiff等。

代码及其操作码如下图所示：

初步观察表明，这段shellcode与我之前分析过的相似，但更短。接下来，我们将详细分析其工作原理。

## 恶意操作代码解析
我对代码进行了拆解，分为“调用”和“处理”两类。结果如下图所示：

从第三行到第二十五行代码（地址0x08048054至0x0804807a）表示：
1. 首先，ELF shellcode会调用socket，并使用socket(PF_INET)将网络通信绑定到特定的IP地址和端口号（硬编码）。这样就建立了与远程设备的网络连接。
2. 在地址0x0804807c处，代码将内存空间设置为7，意味着系统堆栈将PROT_READ, PROT_WRITE和PROT_EXEC标志设为可读、可写和可执行。从地址0x0804807e至0x0804808d的代码与此设置相关，调用C函数初始化内存空间。
3. 在地址0x0804808f处，代码重新获取socket，并从中读取数据（地址0x08048095），然后将数据写入堆内存（可读/可写/可执行）。
4. 地址0x08048099的最后一行代码跳转到ECX寄存器，该寄存器包含指向堆内存中存储数据的指针。这意味着可以执行堆内存中的任何数据。

这个后门程序非常灵活，攻击者可以向受感染主机安装和发送任意恶意内容。我希望安全研究人员能够关注这个后门，并了解黑客社区已经有人利用这种方式注入ELF代码。

## 后门的行为分析
当后门在受感染服务器上运行时，系统管理员可以在内核空间中观察到恶意软件的操作，具体情况如下图所示（出于安全考虑，部分代码已做切割处理）。

## 恶意软件的命名
有些反病毒软件将此恶意软件定义为“下载器”，但实际上它是一个后门程序，允许远程攻击者通过TCP连接触发和执行受感染主机中的恶意代码。有的将其命名为“GetShell”，因为大多数通过后门进入的都是shell代码。但请注意，该恶意软件并不使用GET方法接收主机信息，仅建立IP连接并等待。还有的防毒软件将其命名为“ShellLoader”，这是错误的，因为它并不加载任何东西。

在此，我要祝贺那些正确命名该恶意软件的反病毒产品供应商，你们做得非常好！

## 恶意软件样本
感兴趣的读者可以点击[这里](https://www.virustotal.com/en/file/cb95458e646859b32a88ed9778a5f9c7500d2a81eae31f0f9d70fc6b10511634/analysis/1454487250/)获取该恶意软件样本。