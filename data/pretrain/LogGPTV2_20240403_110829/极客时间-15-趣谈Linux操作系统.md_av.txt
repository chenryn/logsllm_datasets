#  define TOP_OF_KERNEL_STACK_PADDING 16
# else
#  define TOP_OF_KERNEL_STACK_PADDING 8
# endif#else
# define TOP_OF_KERNEL_STACK_PADDING 0#endif也就是说，32 位机器上是 8，其他是 0。这是为什么呢？因为压栈 pt_regs有两种情况。我们知道，CPU 用 ring 来区分权限，从而 Linux可以区分内核态和用户态。因此，第一种情况，我们拿涉及从用户态到内核态的变化的系统调用来说。因为涉及权限的改变，会压栈保存SS、ESP 寄存器的，这两个寄存器共占用 8 个 byte。另一种情况是，不涉及权限的变化，就不会压栈这 8 个byte。这样就会使得两种情况不兼容。如果没有压栈还访问，就会报错，所以还不如预留在这里，保证安全。在64 位上，修改了这个问题，变成了定长的。好了，现在如果你 task_struct 在手，就能够轻松得到内核栈和内核寄存器。
## 通过内核栈找 task_struct那如果一个当前在某个 CPU 上执行的进程，想知道自己的 task_struct在哪里，又该怎么办呢？这个艰巨的任务要交给 thread_info 这个结构。    struct thread_info {struct task_struct*task;/* main task structure */__u32flags;/* low level flags */__u32status;/* thread synchronous flags */__u32cpu;/* current CPU */mm_segment_taddr_limit;unsigned intsig_on_uaccess_error:1;unsigned intuaccess_err:1;/* uaccess failed */};这里面有个成员变量 task 指向 task_struct，所以我们常用current_thread_info()-\>task 来获取 task_struct。    static inline struct thread_info *current_thread_info(void){return (struct thread_info *)(current_top_of_stack() - THREAD_SIZE);}而 thread_info 的位置就是内核栈的最高位置，减去 THREAD_SIZE，就到了thread_info 的起始地址。但是现在变成这样了，只剩下一个 flags。    struct thread_info {        unsigned long           flags;          /* low level flags */};那这时候怎么获取当前运行中的 task_struct 呢？current_thread_info有了新的实现方式。在 include/linux/thread_info.h 中定义了 current_thread_info。    #include #define current_thread_info() ((struct thread_info *)current)#endif那 current 又是什么呢？在 arch/x86/include/asm/current.h 中定义了。    struct task_struct;  DECLARE_PER_CPU(struct task_struct *, current_task);  static __always_inline struct task_struct *get_current(void){return this_cpu_read_stable(current_task);}  #define current get_current到这里，你会发现，新的机制里面，每个 CPU 运行的 task_struct 不通过thread_info 获取了，而是直接放在 Per CPU 变量里面了。多核情况下，CPU是同时运行的，但是它们共同使用其他的硬件资源的时候，我们需要解决多个 CPU之间的同步问题。Per CPU 变量是内核中一种重要的同步机制。顾名思义，Per CPU 变量就是为每个CPU 构造一个变量的副本，这样多个 CPU各自操作自己的副本，互不干涉。比如，当前进程的变量 current_task就被声明为 Per CPU 变量。要使用 Per CPU 变量，首先要声明这个变量，在arch/x86/include/asm/current.h 中有：    DECLARE_PER_CPU(struct task_struct *, current_task);然后是定义这个变量，在 arch/x86/kernel/cpu/common.c 中有：    DEFINE_PER_CPU(struct task_struct *, current_task) = &init_task;也就是说，系统刚刚初始化的时候，current_task 都指向 init_task。当某个 CPU 上的进程进行切换的时候，current_task被修改为将要切换到的目标进程。例如，进程切换函数 \_\_switch_to 就会改变current_task。    __visible __notrace_funcgraph struct task_struct *__switch_to(struct task_struct *prev_p, struct task_struct *next_p){......this_cpu_write(current_task, next_p);......return prev_p;}当要获取当前的运行中的 task_struct 的时候，就需要调用this_cpu_read_stable 进行读取。    #define this_cpu_read_stable(var)       percpu_stable_op("mov", var)好了，现在如果你是一个进程，正在某个 CPU 上运行，就能够轻松得到task_struct 了。