title:A Framework for Evaluating Software on Reduced Margins Hardware
author:Konstantinos Parasyris and
Panos K. Koutsovasilis and
Vassilis Vassiliadis and
Christos D. Antonopoulos and
Nikolaos Bellas and
Spyros Lalis
2018 48th Annual IEEE/IFIP International Conference on Dependable Systems and Networks
A Framework for Evaluating Software
on Reduced Margins Hardware
Konstantinos Parasyris, Panos Koutsovasilis, Vassilis Vassiliadis,
Christos D. Antonopoulos, Nikolaos Bellas, Spyros Lalis
Department of Electrical and Computer Engineering
Email: {koparasy, pkoutsovasilis, vasiliad, cda, nbellas, lalis}@uth.gr
University of Thessaly
IR drops, aging, and so on. Even identical chips with the same
microarchitecture, using the same technology libraries and
executing identical code may exhibit different behavior [5].
Therefore, using simulation-based or software fault injection
to study the effects of timing errors may be inaccurate, since
it cannot capture all the complex effects that take place when
the CPU is stressed beyond its nominal operating points.
Recently, a number of commercial platforms have been
released, on which it is technically possible to set the operating
frequency and voltage beyond nominal values. This makes it
possible to evaluate the effects of reduced margins on software
reliability while running the software natively at full speed [1],
[6], [7], [8]. Building on the availability of such platforms,
we present eXtended Margins eXperiment Manager (XM2),
a framework for conducting experiments on real hardware at
non-nominal conﬁgurations. XM2 can be used (i) to study,
analyze and understand how and under what circumstances
modern CPU microarchitectures fail when executing code at
unsafe margins (sections VI-A and VI-B), and (ii) to evaluate
energy gains when operating the CPU with reduced, but still
safe margins (section VI-C). This is possible in modern CPUs
as has already been shown recently for ARMv8 cores [1]
(iii) to evaluate the resilience of applications – or the whole
software stack – to errors, in a realistic setup.
XM2 adopts a reusable, platform-neutral approach that
can scale in simultaneous multi-board, multi-CPU and multi-
process execution campaigns with or without operating system
support. The framework supports user-deﬁned methods for the
collection and classiﬁcation of the different execution out-
comes, and can manage very large campaigns, thus relieving
the user from manually initiating, controlling and monitoring
the experiments. We evaluate and illustrate different use cases
and the versatility of XM2 with two completely different
platform setups: a bare-metal ARM Cortex A53 processor,
and a x86-64 Skylake Xeon processor running a full operating
system stack.
Abstract—To improve power efﬁciency, researchers are exper-
imenting with dynamically adjusting the voltage and frequency
margins of systems to just above the minimum required for
reliable operation. Traditionally, manufacturers did not allow
reducing these margins. Consequently, existing studies use system
simulators, or software fault-injection methodologies, which are
slow, inaccurate and cannot be applied on realistic workloads.
However recent CPUs allow the operation outside the nominal
voltage/frequency envelope. We present eXtended Margins eXper-
iment Manager (XM2) which enables the evaluation of software
on systems operating outside their nominal margins. It supports
both bare-metal and OS-controlled execution using an API to
control the fault injection procedure and provides automatic
management of experimental campaigns. XM2 requires, on av-
erage , 5.6% extra lines of code and increases the application
execution time by 2.5%. To demonstrate the ﬂexibility of XM2, we
perform three case studies: two employing bare-metal execution
on a raspberry PI, and one featuring a full-ﬂedged software stack
(including OS) on an Intel Skylake Xeon processor.
I. INTRODUCTION
As technology feature size scales and transistor variability
increases, chip manufacturers resort to extra provisioning in
terms of increased voltage margins and reduced operating
frequency to guarantee correct CPU operation even under the
worst possible combination of operating conditions. But such
voltage and frequency guardbanding also leads to signiﬁcant
power and energy overheads.
To address this problem, researchers have been investigating
a variety of undervolting and overclocking techniques for
statically or dynamically shaving-off excessive margins [1],
[2], [3], [4]. The effects on system reliability are typically
modeled using system fault simulators, or by injecting faults
(such as bit ﬂips) at the application level during execution.
These approaches have two major drawbacks. First, system
simulators are slow and have a limited capability for executing
large workloads with realistic input sets. Simulation speed is
important because a large number of fault injection campaigns
is usually required in order to study a fault scenario and to
reach conclusions with a high level of statistical conﬁdence.
Second, timing errors caused by undervolting/overclocking are
difﬁcult to model analytically, and are extremely sensitive
to a large number of parameters, such as the number and
distribution of paths in a CPU, the micro-architectural design
of the CPU, the contents of the instruction and data streams,
the manufacturing process, and even the ambient temperature,
The rest of the document is structured as follows: section II
describes the requirements to enable the functionality of XM2.
Section III outlines the user interface, and section IV the
design and implementation of our tool. Section V presents,
evaluates and discusses the usability of XM2. Section VI
presents the case studies. Section VII gives an overview of
related work. Finally, section VIII concludes the paper.
2158-3927/18/$31.00 Â©2018 IEEE
DOI 10.1109/DSN.2018.00043
330
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:25:41 UTC from IEEE Xplore.  Restrictions apply. 
)
V
(
e
g
a
t
l
o
V
y
l
p
p
u
S
1.4
1.3
1.2
1.1
1.0
0.9
0.8
600
750
(fr,Vr)
Overclock
(fu  ,Vu  )
2
2 
Undervolt
(fu  ,Vu  )
1
1 
Target System
Target System
Target System
User Application
XM   Library
2
Slave Daemon
Reliability Configurator (V,f)
TCP/IP
Hardware Platform
Monitoring System
Ethernet
Monitoring Hardware Platform
TCP/IP
Coordinator
Classifier
Coordinator
Classifier
DataBase
Input Files
Master Daemon
expConf
Fig. 2. System architecture of XM2. It comprises a single monitoring system
and multiple target systems. The components corresponding to dark gray
boxes are supplied by the user. XM2 includes a built-in classiﬁer of results,
however the latter can be substituted by a user-provided one.
The TCP functionality is provided either by the OS, or directly
by the aforementioned library when running on bare metal.
Remote reset support: When operating at extended con-
ﬁgurations, errors leading to full system failure are likely.
Therefore, the target system needs to offer a hardware interface
for a full/clean reset.
III. TOOL DESIGN AND CONFIGURATION
An experimental characterization campaign on top of un-
reliable hardware typically involves the execution of multi-
ple experiments under the same conﬁguration (in terms of
the underlying hardware, its voltage/frequency conﬁguration,
the input set of the application etc). After each experiment
terminates, its results are checked and classiﬁed, depending
on potential effects of faults. This experimental procedure
continues until the number of experiments is sufﬁcient to
provide statistically signiﬁcant results.
Figure 2 presents a high level overview of XM2. It
is
structured in a distributed way, comprising a single monitoring
system, and one or more target systems of the same hard-
ware architecture. The monitoring system deploys a Master
900
1050
Frequency (MHz)
1200
1350
1500
Fig. 1. The green points represent nominal (reliable) Voltage/Frequency con-
ﬁgurations for an ARM Cortex A53. The red area below the line corresponds
to the unreliable conﬁguration space that can be exploited by XM2.
II. PLATFORM REQUIREMENTS
In modern CPUs there are different sources of unreliabil-
ity, which can be categorized according to the transient or
permanent nature of the resulting errors [9]. Interestingly,
transient errors may be induced in an attempt to improve
energy efﬁciency or performance, by explicitly setting the
supply voltage or the operating CPU frequency outside the
manufacturer-deﬁned working envelope. Scaling the supply
voltage below and increasing CPU frequency above nominal
values is referred to as undervolting and overclocking, respec-
tively. Figure 1 illustrates the conﬁguration space.
XM2 facilitates the design and implementation of experi-
mental campaigns to characterize either the hardware itself,
or the resilience of software operating on top of overclocked
or undervolted hardware. XM2 can be used on top of differ-
ent hardware platforms and software stack conﬁgurations. It
assumes the following support from the underlying hardware
and software of the platform used for the experiments:
Hardware support: The hardware must provide support
for controlling and scaling the system operating point (voltage,
frequency) beyond the normal working envelope. Modern Intel
x86-64 CPUs offer such capabilities, starting from the Haswell
family, through the programmable Fully Integrated Voltage
Regulator (FIVR) [10]. Several processors based on ARM
architectures offer similar functionality. The AppliedMicro X-
Gene 2 [1] chip does so through the SLIMpro management
processor included in the chip. The ARM Cortex A53 pro-
cessor in Raspberry PI 3b boards can be set to operate in
non-nominal conditions via a conﬁguration ﬁle.
Compiler support for common function attributes: Every
application using XM2 must be linked with a thin library,
used to notify external systems about the execution status
of the application. It also undertakes the management of
the application and supports data exchange with external
systems. The library exploits the common function attributes
constructor and destructor provided by the gcc compiler.
Connectivity: We assume that the target (tested) system can
support TCP connections to other systems. These are used to
orchestrate the execution campaign, to supply input data, and
to collect results of the computation from the target system.
331
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:25:41 UTC from IEEE Xplore.  Restrictions apply. 
daemon which spawns a Coordinator thread for each target
system. Every target system spawns a Slave daemon, which
receives commands from the Coordinator and orchestrates
the experimental campaign locally, through the library which
manages/invokes the application.
A. Conﬁguration File
We employ a conﬁguration ﬁle that allows the user to
deﬁne an experimental campaign by using a single ﬁle called
expConf. The user deﬁnes the following parameters:
Target Application: An absolute path to the binary ﬁle
which will be executed on the target system.
Target System: The Internet Protocol (IP) or Media Access
Control (MAC) addresses of the target system(s).
Input File: Input of the application to be executed on the
target system(s). XM2 supports only a single input ﬁle per
application. If the application requires multiple inputs, they
need to be combined into one ﬁle by the user.
Operating Conﬁguration: The voltage and frequency set-
tings for the reliable (N ominal) and unreliable (unRel)
conﬁguration of the target system. Applying aggressive over-
clocking or undervolting settings increases the frequency of
errors. Notably, the user can change simultaneously both the
frequency and the supply voltage in the unRel conﬁguration.
Result Classiﬁcation: XM2 comes with a default clas-
siﬁer, which characterizes the outcome of each experiment
as:
(i) Exact: if the result is identical to that of a nominal
execution; (ii) SDC: if the result differs from that of a
nominal execution; (iii) Data Abort: if the CPU raised a data
abort trap due to accessing a non existent physical memory
address; (iv) Illegal Instruction: if the CPU raised a trap
because it detected an non-existent opcode; (v) CPU Crash:
if the execution time exceeds, by far, the time of a nominal
execution.
Nominal outputs for the same target may differ, for example
in multi-threaded applications which use ﬂoating point arith-
metic. To be ﬂexible, XM2 allows users to provide their own
classiﬁers that implement a customized comparison between
the golden results and the application output. For example,
one can use a deviation threshold to detect erroneous results.
Termination Criteria: The user may deﬁne a custom binary
which is used by the XM2 to determine when to terminate a
campaign. The XM2 invokes the user deﬁned binary using as
input the number of experiments classiﬁed in each category.
The default termination checker terminates a campaign simply
when reaching a predeﬁned number of experiments, which can
be set by the user via the expConf ﬁle.
Nominal Experiments: The user deﬁnes the number of
experiments to be performed by XM2 in Nominal setting.
These experiments are used to proﬁle the execution time of the
application and to obtain the error-free (golden) output ﬁles.
B. Run-time Library API
API TO THE RUN-TIME LIBRARY OF XM2.
TABLE I
void readInput(void *ptr, size t sz,size t nmemb):
Receives nmemb * sz bytes from the input ﬁle available at the
Coordinator ﬁlesystem and stores them to the memory region
pointed to by ptr.
void writeOutput(void *ptr,size t sz,size t nmemb)
Sends nmemb * sz bytes from the memory region pointed to by ptr
to the Coordinator.
void switchToRel()
Switch to N ominal state. The implementation of the function is
architecture dependent. It is blocking – the Slave daemon needs to
acknowledge the state switch to the Coordinator.
void switchToUnRel()
Switch to unRel state. Similar semantics as switchToRel.
node, as well as hardware switching between the Nominal and
unRel states. Table I lists the primitives of the API.
C. Example
Listing 1 provides an example of the expConf conﬁguration
ﬁle. The ﬁle initially assigns a name to the target system
and speciﬁes it using its IP and the MAC address. In this
example there are two target systems (PC A, PC B). The
speciﬁed Nominal operating point is used by XM2 to compute
error-free outputs (golden) as well as to determine the normal
execution time of the application for each target system. The
conﬁguration ﬁle also includes a list of unRel conﬁgurations.
A separate experimental campaign will be executed for each
of those conﬁgurations.
The conﬁguration ﬁle also provides the paths to the applica-
tion binary and the input ﬁle. The keyword Monitor indicates
that these ﬁles reside in the monitoring ﬁlesystem and need
to be fetched over the network. In this example, the user also
speciﬁes the Classiﬁer binary, which will be used to classify
the outcome of each experiment/run. The user speciﬁes the
number of experiments (10) to be performed by XM2 in the
Nominal conﬁguration to obtain the golden output ﬁle. Finally,
the user deﬁnes the maximum number (500) of experiments
to be performed on each unRel conﬁgurations.
Listing 2 outlines the modiﬁed source code of a mini-
application implementing a Sobel ﬁlter. Lines 4,5,7 and 8
contain function calls to the run-time library of our tool.
Finally, Listing 3 outlines a classiﬁer which categorizes experi-
ments as Exact, Acceptable, SDC. Exact experiments are those
that produce a bit-wise exact copy of the result of the error-
free execution. Acceptable experiments produce outputs with a
PSNR higher than 50.0 dB in comparison with a golden output.
All other experiments are categorized as SDC. Note that the
classiﬁer is not invoked if the application terminates abruptly
due to a runtime error or a crash. In this case, the framework
automatically classiﬁes the experiment as CPU Crash, Illegal
Instruction, or Data Abort.
IV. FLOW OF A FAULT INJECTION CAMPAIGN
The run-time library that accompanies XM2 needs to be
linked with the target application. It offers an API that enables
the application to control data exchange with the Coordinator
Figure 3 illustrates a simpliﬁed time-line of a fault injection
campaign controlled by our tool. Initially, the user provides
the expConf ﬁle to the Master Daemon. The daemon creates
332
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:25:41 UTC from IEEE Xplore.  Restrictions apply. 
” T a r g e t S y s t e m : {
” idName ” : ”PC A”
” T a r g e t S y s t e m : {
” idName ” : ”PC B”
. . . . }
” A p p l i c a t i o n ” : {
{
}
” IP Address ” : ” 10 . . . . ” ,
”MAC a d d r e s s ” : ”AA:BB:CC:DD: EE : FF” ,
” Nominal ” :
” unRel ” :
[
[ 1 . 2 , 1200 ] ,
[ 1 . 2 , 1320 ] , [ 1 . 2 , 1330 ] , [ 1 . 0 , 1320 ] ]}
” P a t h ” : [ ” p a t h T o E x e c u t a b l e ” , ” Monitor ” ]
” I n p u t F i l e s ” : [ [ ” p a t h T o I n p u t ” , 262144 , ” Monitor ” ] ]
” C l a s s i f i e r ” : ” / p a t h / t o / p s n r . exe ”
” T e r m i n a t i o n ” : { ” d e f a u l t ” : {500}} ,
” NominalExp ” : {10}}
Listing 1. An example expConf ﬁle using the json format.
1 # i n c l u d e 
2 v o i d s o b e l ( u n s i g n e d c h a r∗ in , u n s i g n e d c h a r ∗ o u t ) ;
c h a r∗ a r g v [ ] ) {
s i z e o f ( c h a r ) , SIZE ) ;
3
4
5
6
7
8
9
i n t main (
in ,
argc ,
i n t
r e a d I n p u t (
switchToUnRel ( ) ;
s o b e l ( in , o u t ) ;
s w i t c h T o R e l ( ) ;
w r i t e O u t p u t ( out ,
r e t u r n 0
10 }
s i z e o f ( c h a r ) , SIZE ) ;
Listing 2. Source code of the application extended with calls to the run-time
API.
f l o a t PSNR( u n s i g n e d c h a r∗ gld , u n s i g n e d c h a r ∗ t s t ) ;
i n t main (
c h a r∗ a r g v [ ] ) {
argc ,
i n t
r e s = PSNR( gold , t e s t ) ;
i s i n f ( r e s ) & 1 )
1 # i n c l u d e 
2
3
4
5
6
7
8
9
10
11
f l o a t
i f
(
p r i n t f ( ” Ex a c t
p r i n t f ( ” A c c e p t a b l e \%f\n ” , r e s ) ;
p r i n t f ( ”SDC \%f\n ” , r e s ) ;
i n f \n ” ) ;
r e s > 5 0 . 0 )
r e t u r n 0
e l s e
e l s e
i f
(
12 }
Listing 3. Source code of a custom classiﬁer.
a new database and spawns a Coordinator thread for each of
the target systems. The Coordinator connects to the respective
Slave daemon on the target system using the TCP protocol,
and transfers the Nominal conﬁguration, the application binary
and inputs to the target system. The inputs will be used when
the target application uses the readInput function.
The Slave daemon performs the Nominal number of exper-
iments as speciﬁed in the expConf (without transitioning to
the unRel state). The purpose of this step is to produce error-
free golden outputs as well as to proﬁle the time required to
execute the application under nominal conditions. The golden
ﬁle is used by the classiﬁer for comparison against the outputs
of unreliably executed code.
At this point the actual experimental campaigns start. The
Coordinator sends the conﬁguration parameters of the unRel
state to the Slave. These parameters will be used for all subse-
quent experiments. The Slave then spawns the application. Any
requests to read input data by the application using the XM2
Master
Coordinator 
Slave / User application
Create database
Spawn 
Coordinators
Connect to Slave / send 
binaries / send 
Nominal configuration
Produce golden 
output
Experimental campaign
Initiate experiment / 
send unRel 
configuration
Send input data
Start application
Inform state 
switching to unRel
Continue application 
in UnRel
Inform application 
switch to Rel