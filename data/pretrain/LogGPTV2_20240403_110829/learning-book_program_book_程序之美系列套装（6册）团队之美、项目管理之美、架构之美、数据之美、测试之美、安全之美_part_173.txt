面向资源的方式让我们在需要时可以强制实现协议，但这并不是必
需的。通过分离事物的名称和形式结构，我们可以复用同样的逻辑
名称，支持多种类型的交互。我们可以更新后台而不会影响原有的
客户端。如果我们要改变一个模型，所有已有的客户端用第1版的
消息结构向一个URLPOST消息，那么我们可以在后台添加对第2版
消息结构，同时在需要时让业务照常进行。如果我们想停止支持老
的消息结构也可以，但我们可以选择什么时间这样做。这种灵活性
是面向资源的架构有助于我们重新控制业务后端的原因之一：后端
系统的改变不一定要求前端也更新。如果用一个RESTful接口将遗
留系统包装起来，我们就可以继续使用它，直到有足够的业务理由
来改变它为止。当然，其他技术也支持我们用这种方式包装遗留系
统。但正是使用逻辑名称的这种一般方式让我们有更大的机会来避
免中间件的不断改变，让情况变得不同。
970
---
## Page 972
为了努力促进水平的可伸缩性，RESTful方式要求请求是无状态
的。这意味着生成响应需要的所有信息都要放在请求中。这让我们
能够通过负载均衡机制，由任意多台后端服务器来处理请求。在面
对增加的负载时，可以添加更多的硬件来解决问题，任何服务器都
可以接收并处理请求。虽然伸缩性是这种架构方式的目标，但将无
状态的请求应用于GET请求的语义还带来了另一个大的副作用：我
们可以设想对任意请求的结果进行缓存的可能性。响应者的地址
（URL的主要部分）加上请求的全部状态（URL层次路径加上查询
参数）构成了结果集的一个复合散列键（例如，数据库查询、对一
部分数据进行转换等）。你不会不花力气就享受到缓存的好处，但
利用这种可能性的环境忽然就变得很容易想到了。NetKermel面向资
源环境的一个突出特征就是它充分而全面地利用了这种可能性带
来的好处，实现了一种架构上的记忆化L，而你几乎不要做什么额
外的工作。我们将在稍后的5.6节中进一步讨论。
对所有我们感兴趣的事物使用通用的命名机制，用一个逻辑处理过
程来支持事物随时间的变化或在不同上下文中的变化，这样我们就
几乎拥有了一个引领组织机构信息管理所需的基础设施。我们最后
需要的一个工具就是要能够表示我们所寻找的事物的元数据。这就
是“资源描述框架（RDF）"想要解决的问题。W3C的建议使用了一
个图式模型，支持对命名实体信息的并放式表述。谁创建了它？何
导址存在关系数据库中的现有数据，这让我们可以描述任何想描述
的数据，不必将它们转换成新的格式。这是普遍的预期，也是大家
报怨的原因，因为RDF在实践中撑不住。我们通常会让数据留在原
处，然后在有意义的层面上进行集成。
在下面的列表中，我们看到了某个RDF的N3表达式，描述了与特定
资源相关的创建者、标题、版权日期和许可证。这个例子向我们展
示了3个来自“都柏林核心元数据倡议”-的术语和1个来自Creative
Commons2l社区的术语。我们可以自由使用来自任何词汇表的术
语，或在需要描述新的内容时创建新的术语：
@prefix dc: ,
prefix cc: ,
dc: creator
971
---
## Page 973
dc: title
"Brian Sletten's Homepage",
dc:
dateCopyrighted
" 2008 - 04 - 26T14 : 22Z" ,
cc: license
.
我们现在不仅能够使用任何想用的术语，也可以在将来任何时候添
加新的术语和关系，不影响原有的关系。这种“无schema"的方式对
于修改过XML或关系数据库schema的人来说，具有很大的吸引力。
它也代表了这样一个数据模型，即不仅能够在不可避免的社会、过
程和技术变化中生存下来，而且拥抱这些变化。
这个RDF可以存储在triplestore或其他数据库中，通过SPARQL或类
似的语言进行查询。大多数支持语义的容器现在都支持这种存储和
查询RDF的方式。包括Mulgara SemanticStore[&l、SesameEngine[2]
、TalisPlateformLoL、甚至Oracle10g以后的版本。图中的节点可以
通过模式匹配条件来选择，所以我们可以针对资源问这样的问题：
最近6个月中创建的CreativeCommons许可证的素材”。表示“由谁创
建”具有哪种许可证"这样的术语是在相关的词汇表中列出的，但很
容易转成我们所提到的目标。数据模型的灵活性以及查询语言的表
达能力使得描述、发现和调用RESTfui的服务变得相当简单。这当
然比通过UDDI这样的迟钝的、高阻抗的技术来发现和调用服务要舒
服得多。
能够寻址和解析任意资源，能够以不同格式取得这些资源，能够以
并放世界和混合词汇的方式描述它们，我们就可以将这些思想应用
于企业了。我们将描述一种信息驱动的架构，支持在数据组成的网
上"冲浪”，就像在文档组成的网上“冲浪”一样。
_http://lists.w3.org/Archives/Public/www-tag/2005Jun/0039
972
---
## Page 974
[2]http://rest.blueoxen.net/cgi-bin/wiki.pl?RestTriangle
[3]_http://en.wikipedia.org/wiki/REST.
[4],http://1060.org.
[5]http://en.wikipedia.org/wiki/Memoization
[6]_http://dublincore.org.
[Z]_http://creativecommons.org/ns
[8]_http://mulgara.org
[2]_http://open rdf.org
[10]_http://talis.com
5.4面向资源的架构
面向资源的架构的标识是向命名的资源发起逻辑请求的过程。这些
请求由某种引擎解释，转成该资源的物理表现形式（如HTML页
面、XML格式、JSON对象等）。参见图5-4。
这张图展示了面向资源的架构（ROA）的基本交互方式。逻辑请求
由一个面向资源的引擎来命名、解析，并将结果返回给请求者。命
名的请求可能被解释为一个数据库查询，或是某项信息管理功能
（如RESTful服务）。响应请求的可能是一个Servlet、一个RestletI!l
一个NetKernel模块，或某些可以寻址、能够理解该请求的功能，
而对此信息感兴趣的人基本上不关心这些响应请求的程序。这个逻
辑步骤隐藏了所有的可能性和技术选择，没有向客户透露一点不必
要的细节。它确实不能支持所有的交互方式，但你可能会惊讶于有
多少东西可以舒服地藏在URL后面。
973
---
## Page 975
逻辑请求
面向资源
的引擎
物理表现形式
图5-4：面向资源的架构
请考虑这个地址：http://server/getemployees&type=salaried。许多人
会认为创建这样的地址就是在采用REST。遗憾的是，这不是一个
这根本不是REST！），因为它混合了名词和动词。这就是我常说
的"通过URL来寻址行为"或"通过URL来实现RPC”。用REST的方式
来区分名词和动词没有什么神奇的，它只是能让我们识别我们关心
的事物。前面提到的URL不能够用于更新雇员列表，因为POST一条
雇员记录到"/getemployees"没有什么意义。相反，如果URL是
http://server/employee/salaried，那么向它发起GET请求将得到相同的
信息，而它将成为“领薪雇员"这个业务概念的长期有效地址，正如
http://server/employee/hourly可以指按小时付薪的所有雇员一样。我
们可以选择不更新这些信息资源，因为它们代表的是对后台数据库
的查询。但是，在/employee信息空间内是一致的，我们可以选择通
过其他方式来导航。http://server/employee/12345678代表了一个具有
特定ID的雇员，而http://server/employee可能代表所有的雇员。向后
面一个URLPOST一条记录可以代表雇用了某人。向包含具体雇员
ID的URLPUT一条记录可以代表在岗位变更、升职或加薪之后更新
雇员记录。向该地址发出DELETE请求可以表示这个命名资源在该
组织机构中已经不再感兴趣了（他们或者辞职，或者被解雇了）。
这突出了REST和SOAP之间的一个主要区别，如果人们混淆了这两
种方式的意图，就会导致困惑。REST是关于信息管理的，而不
定是通过URL来调用任意的行为。当人们开始挠头思考4个动词是否
足够完成他们想做的事情时，他们想的也许不是信息，而是在想调
用的行为。如果你打算通过URL来实现RPC，你也可以使用SOAP。
如果你将重要的业务概念作为可以寻址的信息资源，并且可以在不
974
---
## Page 976
同环境下进行操作或表示为不同的形式，那么你就在利用REST的
长处，可能看到我们在Web上看到的某些好处。即使后台系统使用
SOAP来满足请求，你也可以设想RESTful接口带来的好处。提供这
样的地址不仅让用户能够“在数据上冲浪”，还可以引入缓存结果的
能力，消除变更WSDL协议所带来的某些痛苦。客户端会通过一些
逻辑连接，再翻译成SOAP消息，然后生成响应结果。响应的内容
可以从返回的信息中抽取出来。我们根本不需要宣传这一事实，就
能够在这个过程中实现架构迁移的策略。
正如图5-5所示，同样名称的资源可能在不同环境下返回不同的物理
格式，却保留相同的标识符。我们可以设想，某种类型的公司报表
在信息空间中的组织方式支持按时间浏览（例如，先按年再按
月）。假设只有一种类型的报表，那么http://server/report/2008/02就
是一个相当不错的、可以长期使用的名称。将来任何时候都不会改
变这一事实：我们有一份2008年2月的报告。我们可能在某种场景
下需要XML形式的数据，在另一场景下需要Excel表格，或者渲染成
JPEG图像包含在汇总报告中。我们不希望在每种场景下使用不同的
名称，所以我们通过内容协商来指定我们的格式偏好。面向资源的
引擎需要知道如何响应一种请求类型，但这是很容易支持的。将来
可能出现一些现有客户端都不支持的数据格式。已有的客户端不会
需要修改，因为我们会在服务器上添加支持，然后某些其他客户端
会利用它。这种面对变化的弹性是Web设计中固有的，也是我们在
企业系统中希望实现的。客户端和服务器可以在解析过程中，针对
命名的资源协商一种特定的格式。这让同样名称的资源在不同环境
下表现为不同的结构（例如，在中间层使用XML，在浏览器中使用
JSON）。针对每种格式，如果需要，结构化的格式可以由服务器实
现缓存。
975
---
## Page 977
GEThttp://server/report/2008/02
report>
客户端
缓存
服务器
c/report
text/xml
GEThttp://server/report/2008/02
1010111
客户端
0100010
1001011
缓存
服务器
1100110
application/vnd.ms-excel