types of kernel objects can be used to overwrite vulnerable
ones can no longer be determined. By contrast, physmap-
based attack is simple and intuitive. The only thing an
attacker needs to do is to iteratively calling mmap. One
generic exploit can be achieved by physmap-based attack.
Uncontrollable content: If a use-after-free vulnerability
is desired to be exploited, not only a vulnerable object is
needed to be overwritten but also the content of that object
has to be under control. Previous techniques may have lim-
ited choices of kernel objects to make collisions and at many
times these candidates may be the internal ones and attack-
ers cannot set proper payload they want in freed memory,
which makes an exploitation hard to complete afterwards.
When it comes to physmap-based attack, all these mem-
ory used to overwrite vulnerable objects are generated by
calling mmap in user programs and the content is naturally
under control.
Multi-threading support: Previous techniques may need
relatively accurate prediction on kernel heap layout. But
when an attack program is executing meanwhile many other
tasks scheduled on the core may inﬂuence memory layout
of the kernel heap, which brings much uncertainty. This
factor sharply decreases the success rate of kernel attacks
based on previous techniques. By contrast, with the help
of object spraying and physmap spraying in physmap-based
attack, large amount of instances are created and almost all
of the kernel space is occupied. That reduces the side eﬀects
brought from other scheduled tasks to the lowest extent.
In a word, physmap-based attack is able to deal with
much more kinds of use-after-free vulnerabilities in Linux
kernel and have full control of data in freed memory.
It
has a wider application and higher stability. Two unavoid-
able disadvantages it suﬀers are memory cost and time cost,
which can all be acceptable in practice.
5.2.4 Limitations
Not all the kernel objects which have use-after-free vul-
nerabilities are able to be overwritten by physmap-based
attack on various platforms due to several reasons. Firstly,
if a vulnerable object is going to be reused quickly after it
has already been freed, then it is hard to re-occupy the ob-
ject since the physmap spraying relatively takes time. And
the immediate re-use of that object before overwriting is
done may lead to kernel crashes. Secondly, if a vulnerable
object is for internal use in kernel and it is not easy for an
attacker to create a second instance of this kind of object,
then even if we spray these vulnerable objects and place
them uniformly in kernel space, the success rate of memory
collisions based on physmap-based attack still decreases.
Thirdly, when applying physmap-based attack, attackers
require a certain amount of directly mapped memory to do
spraying and make the physmap grow in order to touch vul-
nerable kernel objects. If the size of current usable physical
memory is not enough, then the success rate of the attack
goes down.
6. EVALUATION
6.1 Testing with Linux Kernel
In this section, we evaluate the performance of object-
based attack and physmap-based attack by applying them
to exploit our malicious kernel module mentioned in Sec-
tion 2.1 in Linux kernel. The experiments are carried out
on both 32-bit and 64-bit Ubuntu 14.04 with 2GB RAM.
Note that when testing object-based attack based on colli-
sions between objects of diﬀerent sizes, the size of the vul-
nerable object in our module is set to be 576 as mentioned
in Section 3.3.
Table 1 shows the success rate of object-based attack and
physmap-based attack to compromise kernel by exploiting
the malicious kernel module with basic memory require-
ments for diﬀerent steps. Note that object-based attack of
type 1 leverages memory collisions between objects of the
same size and object-based attack of type 2 leverages mem-
ory collisions between objects of diﬀerent sizes.
As shown in the experimental results in Table 1, object-
based attack of type 1 performs better than object-based
attack of type 2 as expected. Object-based attack of type
2 cannot be applied for a stable kernel exploitation due to
its low success rate. And memory collision attack performs
worse on 64-bit Linux platforms since much more entropy
of the kernel memory layout is introduced. It can also be
seen that physmap-based attack cost most memory com-
pared to other types of attack in total. And it needs extra
memory for spraying vulnerable objects and making them
dispersedly allocated in kernel space.
As described before, object-based attack choose kernel
objects as candidates to overwrite vulnerable objects. How-
ever, due to the limitations on resources a user cannot create
too many kernel objects inside kernel. For example, a user
can only create certain amount of socket connections, which
means that limited kmalloc-size buﬀers during sendmmsg
can be created in one time. Thus the memory requirement
for kernel spraying in object-based attack has to in a certain
Attack Types
System
Memory Req.
for Padding
Memory Req.
for Bug-freed Objects
Memory Req.
for Spraying
Success Rate
Object-based 1
Object-based 2
Physmap-based
32-bit
64-bit
32-bit
64-bit
32-bit
64-bit
NaN
NaN
NaN
NaN
32MB
32MB
64KB
96MB
168KB
160MB
512KB
512KB
64KB
128KB
128KB
256KB
1536MB
1536MB
99%
80%
60%
40%
99%
85%
Table 1: Memory Collisions Attack in Linux kernel
range as shown in Table 1, which decreases stability of an
attack.
Since the size of the vulnerable object in the malicious
kernel module remains the same, both object-based attack
and physmap-based attack take eﬀect in the experiments.
However, the strong powerful of physmap-based attack can
be seen in the next section.
6.2 Testing with Android Kernel
In this section we evaluate our memory collision attack on
Android devices with a use-after-free vulnerability (CVE-
2015-3636) [4] which is credited to the author. We leverage
this vulnerability to implement PingPongRoot, a universal
exploit that achieves privilege escalation on most popular
Android devices (Android version >= 4.3) including those
with 64-bit processors.
6.2.1 PingPongRoot
PingPongRoot exploits the CVE-2015-3636 use-after-free
vulnerability, which is related to a vulnerable PING sock
object in the kernel. By specifying sa family as AP UNSPEC
and making connections to a PING socket twice, the refer-
ence count of that PING sock object becomes zero, and thus
the kernel frees it. However, that leads to a dangling ﬁle
descriptor related to the PING sock object in a user pro-
gram (The vulnerability can only be triggered on Android
devices. For Linux PC, a common user does not have the
privilege to create a PING socket). Therefore, attackers can
operate on this ﬁle descriptor in a user program and make
the kernel reuse the freed PING sock object, which leads to
code execution in the kernel.
The vulnerable PING sock object has diﬀerent sizes on
diﬀerent devices, thus PingPongRoot applies physmap-based
attack instead of object-based attack to exploit such a vul-
nerability with high reliability. We demonstrate the ex-
ploitation of PingPongRoot on a representative Android
device, Google Nexus 7 running Android Lollipop system.
The exploit is conducted by following the steps described
in Section 4. At ﬁrst, D PING sockets are created for de-
fragmentation. Then we iteratively spray PING sockets in
group. For each group, every N PING sockets are allo-
cated in newly-created processes. Note that all of these N
PING sockets have to be created in other processes instead
of the current process because of the resources limitation
on each process. After these processes ﬁnish the allocat-
ing work, they hang up there not to cause kernel to release
these PING sockets. Then M (N (cid:28) M ) PING sockets are
created in the current process. These sockets are treated as
vulnerable targets and later memory collisions will happen
between these objects and the physmap.
According to physmap-based attack described in Section 4,
all M PING sockets are released by triggering the use-after-
free vulnerability. Then all the processes created at the be-
ginning of our exploit are terminated. That causes kernel
to recycle the resource of the terminated processes, thus all
N PING sockets are freed by kernel allocators.
After that, mmap is repeatedly invoked. Each mmap al-
locates 256MB memory in user space. For every 8 dwords of
the mmaped memory, the 7th dword is rewritten as a valid
address in user space. All the other dwords are overwritten
to be the magic values. By calling ioctl on those M vulner-
able PING sockets with the argument SIOCGSTAMPNS,
the member sk stamp of a PING socket object can be read
out to user space. Check it with pre-deﬁned magic value to
see whether a PING sock object is covered by the physmap
or not.
If no memory collision happens among those M
ones with the physmap, back to the beginning of the exploit
and spray more groups of padding objects with vulnerable
objects. Otherwise, a vulnerable kernel object successfully
covered by the physmap is achieved and the exploit contin-
ues.
In fact, the 7th dword of a PING socket object is the
member sk prot. It is a structure used to store the proper-
ties of PING protocol and it has a member which is a func-
tion pointer called close. When a PING socket is closed
in a user program, then this function pointer is to be in-
voked. Due to the re-ﬁlling of the vulnerable PING socket
object, the 7th dword of it is currently a virtual address in
user space. That means the whole sk prot structure is con-
trolled by the attacker. The function pointers in the fake
sk prot are set to the address of kernel shellcode placed in
user space. Then close is called on the dangling ﬁle descrip-
tor related with that vulnerable object. The fake function
pointer is invoked and our shellcode is executed in kernel
context, which leads to a temporary privilege escalation on
Android Lollipop.
6.2.2 Experimental Results
Our PingPongRoot exploit achieves privilege escalation
on hundreds of Android devices and the performance of our
attack is shown in Table 2.
The universal property and reliability of physmap-based
attack is veriﬁed based on the following observations from
Table 2. Firstly, most popular Android devices on market
of all kinds of brands including Samsung, SONY, Google
Nexus, HTC, Huawei, and Xiaomi are exploited by
physmap-based attack with high root success rates. Note
that the size of the vulnerable PING sock objects varies on
diﬀerent phones and tablets, but our generic exploit does
not take that into considerations. Only RAM size aﬀects
our exploit settings. Secondly, the exploit settings are not
changed much when attacking 64-bit Android kernel com-
pared with the settings applied for attacking 32-bit Android
kernel. Practically, physmap-based attack is veriﬁed to be
eﬀective also in 64-bit Android kernel. In a word, physmap-
based attack is a universal and powerful solution to exploit-
ing use-after-free vulnerabilities in Linux-based kernel.
System
RAM Size
Device
Android 32-bit
Android 64-bit
1G
2G
3G
2G
3G
Huawei Honor 4
Xiaomi Hongmi Note
Google Nexus 5/7
Samsung Galaxy S4/S5
HTC One M8
Huawei Mate 7/Ascend P7
Xiaomi M3
Samsung Galaxy Note 3
Sony Z2/Z3
Huawei Honor 6
Xiaomi M4
Google Nexus 9
Samsung Galaxy S6/S6 Edge
HTC One M9
Memory
Memory
Memory
for Padding
for Spraying
for Bug-freed Objects
128MB
640MB
64KB
Success Rate
85%∼90%
128MB
1024MB
64KB
98%
128MB
1536MB
128MB
128MB
1024MB
1536MB
64KB
64KB
64KB
98%
90%
85%∼90%
Table 2: Performance of Physmap-based Attack on Android Devices