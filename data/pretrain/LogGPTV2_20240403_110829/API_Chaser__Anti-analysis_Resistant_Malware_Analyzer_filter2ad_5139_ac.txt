only one-byte taint tag space for one byte on physical memory. We extended
it to a four-byte taint tag space for one byte to store a pointer to an API Tag
data structure. Therefore, we need memory space four times as large as physical
memory for a shadow memory. For example, if the size of physical memory is
256M bytes, the size of shadow memory is 1G bytes.
The shadow disk is a binary-tree data structure for storing taint tags set
on data on a disk. The entries for the structure contain information related to
tainted data on a disk, such as sector number, oﬀset, size, taint tag buﬀer and
pointers represented by the nodes of binary-tree. A taint tag entry for one-byte
data on a disk has four-byte space, so we need four times as large memory space
as a disk for a shadow disk. However, the size of a disk is much larger than the
one of physical memory, so it is diﬃcult to allocate enough memory space for
storing taint tags of all data on a disk beforehand. Thus, we design the memory
space for the shadow disk to be dynamically allocated as needed. Argos does not
have a shadow disk, so we newly implemented it for API Chaser.
In API Chaser, the virtual DMA controller transfers taint tags between
shadow memory and a shadow disk. API Chaser monitors DMA commands
at the virtual DMA controller, and when it ﬁnds a request for transferring data,
it acquires the data location from the request and conﬁrms whether the trans-
ferred data has taint tags. If it does, the virtual DMA controller transfers the
mov [edi], eaxhost code for `mov [edi], eax`Argos Taint HandlerGuest CodeHost native CodeaVirtual CPUIf eax is tainted;set the taint of eax on [edi]mov [edi], eaxhost code for `mov [edi], eax`API Chaser Taint HandleraVirtual CPUIf eax is tainted;set the taint of eax on [edi]else { if mov is taintedset malware-tags on [edi]}call API1mov edi, edi...host code for `call API1`host code for `mov edi, edi `host code for `... `call  API1 handleraa0aVirtual CPUTag(a)(b)(c)aaapi-tagmalware-tag13
taint tags between a shadow memory and a shadow disk. Argos does not have
this mechanism either, so we newly implemented it for API Chaser, too.
5.4 API Argument Handler
To obtain more detailed information of API calls, we extract argument informa-
tion passed to them when they are called and when the execution is returned
from them. To do this, we prepare an API argument handler for each API. We
extract the argument information, such as the number of arguments, variable
types, size, and whether it is an input or output argument, from the Windows
header ﬁles provided by Windows SDK. In case of undocumented APIs, we ex-
tract the information of them from the web site [17] and source code of React
OS [18]. We register an API argument handler to an API Tag data structure
when we create the data structure for setting api-tags on instructions of each
API. The handler is invoked from the virtual CPU when it detects an API call
invoked from malware and outputs the detailed argument information related to
the API.
6 Experiments
To show the eﬀectiveness of API Chaser, we conducted two experiments for
evaluating the accuracy and the performance of API Chaser. The purposes of
the experiments are to show that API Chaser is able to capture API calls invoked
from real-world malware with various anti-analysis techniques and its overhead
is within practical range.
6.1 Experimental Procedure
In the experiment for accuracy, we prepared several malware executables which
have various anti-analysis functions and we used them for evaluating the resis-
tance of API Chaser against hook evasion and target evasion. As a comparative
environment, we prepared two diﬀerent implementations of API Chaser which
respectively use existing techniques to detect API callings or identify target
code. We executed some malware on API Chaser and these comparative envi-
ronments for ﬁve minutes, acquired API logs which were respectively output by
each environment, and then compared them. When there were some diﬀerences
between these logs, we revealed the causes of the diﬀerences by manually ana-
lyzing malware and investigating the infected environment using IDA [16] and
The Volatility Framework [19]to determine whether the fault was in API Chaser
or in the comparative environments.
In the performance experiment, we also prepared a vanilla Qemu and two
diﬀerent implementations of API Chaser: API Chaser without monitoring API,
and one without argument handling. We executed ﬁve Windows standard com-
mands on them, measured the runtime duration of these commands, and com-
pared them.
All experiments were conducted on a computer with Intel Xeon CPU X5670
2.93GHz, 12G memory and SSD 512G. API Chaser runs on Ubuntu Linux 10.10,
and the guest OS was Windows XP Service Pack 3. The guest OS was allocated
256M bytes for its physical memory. We targeted 6,862 APIs in major Windows
system DLLs.
14
Table 1. Results of Hook Evasion Resistance Test
Virus Name
API Chaser Type I Unmatched
Reason
Anti-analysis
Win32.Virut.B
Themida
Infostealer.Gampass
Packed.Mystic!gen2
6,361
43,994
38,382
97,364
4,852
41,028
1,397
97,363
1,509
2,966
37,485
1
F.N. of Type I API Hook
F.N. of Type I Stolen Code
F.N. of Type I Sliding Call
F.N. of Type I Sliding Call
Themida: calc.exe packed by Themida[20]. F.N.: False Negative.
6.2 Accuracy Experiment
We evaluated API Chaser from the viewpoint of its resistance against hook
evasion and target evasion.
Hook Evasion Resistance We used four real-world malware with hook evasion
functions and executed them on both API Chaser and a comparative environ-
ment(Type I). Type I is another implementation of API Chaser with diﬀerent
approach to detect API calls. It detects API calls by comparing an address
pointed by an instruction pointer to addresses where APIs should be resided,
which is a common existing technique. The other components of Type I are same
as API Chaser.
Results Table 1 lists the results of this test. We manually investigated the causes
of the diﬀerences in captured API calls and revealed that all of them was caused
by false negatives of Type I. We explain the details of the two cases, Themida and
Mystic!gen2, though the others also had the same reason for their diﬀerences. In
the case of Themida, API Chaser captured 2,966 more API calls than Type I. All
the unmatched API calls were detected in dynamically allocated and writable
memory area. On the other hand, all the matched API calls were detected in
memory area where system DLLs were mapped. We manually conﬁrmed that all
API calls, except for API calls with no arguments, which API Chaser detected
had valid argument information. Thus, these were not false positives of API
Chaser, but false negatives of Type I. As we mentioned, API Chaser can detect
the stolen API call by propagating taint tags set on an API to the stolen instruc-
tions, while Type I cannot because it does not track the movement of the stolen
instructions. This capability contributes to the resistance of API Chaser against
hook evasion techniques. In the case of Packed.Mystic!gen2, we conﬁrmed that
it used sliding call technique. The following code snippet is the one of a sliding
call in this malware.
0x00408175 push ebp
0x00408176 mov ebp, esp
0x00408178 sub esp, 20h
0x0040817B cmp dword ptr [eax], 8B55FF8Bh
0x00408181 jnz loc_40818C
0x00408187 add eax, 2
0x0040818C add eax, 6
0x00408191 jmp eax ;to API+2 or API+6
The cmp instruction at 0x0040817B conﬁrms the existence of the following
four bytes, 0x8B, 0xFF, 0x55, and 0x8B at the address stored in eax, which points
to the head of an API. These four bytes may indicate the assembler instructions,
"mov edi, edi; push ebp; mov ebp, esp;", which is a prologue for a hotpatch-
enabled API [21]. In fact, the total size of the three assembler instructions is a
Table 2. Results of Target Evasion Resistance Test (Tracking)
15
Result
Virus Name
Win32.Virut.B
Trojan.FakeAV
Infostealer.Gampass
Spyware.perfect
Trojan.Gen
Changing the name of rundll32.exe to jahjah06.exe
Description of Anti-analysis behaviors
Infecting (cid:12)les with CreateFileMapping
Injecting code with WriteProcessMemory
Injecting code with WriteProcessMemory
✓
✓
✓
✓
✓
✓
✓
Injecting a dropped DLL via AppInit DLLs registry key ✓
✓
Injecting a dropped DLL with SetWindowsHookEx
Injecting code with WriteProcessMemory
and the injected code loads a dropped DLL
Changing its name to svchost.exe
✓indicates that API Chaser can correctly track and identify anti-analysis behaviors without being
Executing a dropped EXE as a service
Backdoor.Sdbot
evaded.
total of six bytes. If the malware ﬁnds these four bytes at the entry of the API, it
jumps to a location at six bytes after the entry of the API to avoid monitoring.
API Chaser sets taint tags on all instructions in each API, so it was able to
detect the execution of the instruction at API entry + 0x6 and identiﬁed it as
an API call from the malware.
Target Evasion Resistance We prepared six real-world malware with target
evasion functions. With these malware, we evaluated the following two capabili-
ties of API Chaser: tracking the movement of target code and identifying target
code in a code-injected process or executable. As for the tracking capability, we
conﬁrmed that API Chaser can capture API calls from a process or executable
code-injected by the six malware. With regard to the identifying capability, we
prepared another comparative environment(Type II). Type II environment is dif-
ferent from API Chaser in identifying target code and tracking code injection. It
identiﬁes its target depending on PID and tracks code-injection based on invo-
cation of speciﬁc API calls and DLL loading events. For example, Type II hooks
the invocations of WriteProcessMemory API calls and extracts PID of the desti-
nation process of the writing from its arguments. Then, it includes the PID into
its monitoring targets. The components of Type II except for those for identifying
and tracking target code are the same as API Chaser.
Results Table 2 lists the results of the tracking test. API Chaser successfully
tracked all the behaviors of injected code without being evaded. We consider that
Type II can also track them if it knows how target malware evades and prepares
mechanisms for tracking the behaviors beforehand. However, it is practically dif-
ﬁcult to know all code injection methods and prepare for them before executing
target malware because there are many unpublished functions in Windows and
third party softwares. On the other hand, API Chaser can track code injection by
propagating taint tags set on target malware. Since API Chaser does not depend
on individual code injection mechanisms, we can say, it is more generic than the
existing approach depending on each injection method for tracking them.
Table 3 lists the results of the identifying test. We manually investigated the
causes of the unmatched API calls and revealed that the all the unmatched API
calls were caused from false positives of Type II. That is, API Chaser successfully
identiﬁed all API calls invoked from injected code in a benign process and elim-
inates API calls invoked from benign part of code in the process. We explain
16
Table 3. Results of Target Evasion Resistance Test (Code Identiﬁcation)
Virus Name
Injected Process API Chaser Type II Unmatched
Reason
Win32.Virut.B
Win32.Virut.B
Trojan.FakeAV
Infostealer.Gampass
Spyware.perfect
Trojan.Gen
notepad.exe
winlogon.exe
explorer.exe
explorer.exe
notepad.exe
notepad.exe
315
184
20
3,020
783
1,782
147,646
149,408
4,792
230
7,511
3,222
2,705
599
1,762