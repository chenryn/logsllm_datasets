30.
*@param array
待调整的堆
31.
*/
32.
public static void heapSort(int[] array）{
33.
//1．把无序数组构建成最大堆
34.
35.
downAdjust(array, i, array.length);
36.
---
## Page 239
37.
System.out.println(Arrays.toString(array));
38.
//2.循环删除堆顶元素，移到集合尾部，调整堆产生新的堆顶
39.
for（int i= array.length-1;i>θ;i--）{
40.
//最后1个元素和第1个元素进行交换
41.
int temp = array[i];
42.
array[i]= array[0];
43.
array[o]=temp;
44.
//"下沉"调整最大堆
45.
downAdjust(array,0,i）;
46.
47. }
48.
49.
50. public static void main(String[] args) {
51.
int[] arr =new int[] {1,3,2,6,5,7,8,9,10,0};
52.
heapSort(arr);
53.
System.out.println(Arrays.toString(arr));
54.}
原来如此，现在明白了！那么堆
排序的时间复杂度和空间复杂度各是多少呢？
---
## Page 240
毫无疑问，空间复杂度是0(1)，因为
并没有开辟额外的集合空间。t至于时间复杂度，我们来分析一
下。
二叉堆的节点“下沉"调整（downAdjust方法）是堆排序算法的基础，这
个调节操作本身的时间复杂度在上一章讲过，是O(logn)。
我们再来回顾一下堆排序算法的步骤。
1.把无序数组构建成二叉堆。
2.
循环删除堆顶元素，并将该元素移到集合尾部，调整堆产生新的堆
顶。
第1步，把无序数组构建成二叉堆，这一步的时间复杂度是0(m)。
第2步，需要进行n-1次循环。每次循环调用一次downAdjust方法，所以
第2步的计算规模是(n-1)xlogn，时间复杂度为O(nlogn)。
两个步骤是并列关系，所以整体的时间复杂度是O(nlogn)。
最后一个问题，从宏观上看，堆
排序和快速排序相比，有什么区别和联系呢？
---
## Page 241
先说说相同点，堆排序和快速排序的
平均时间复杂度都是O(mlogn），并且都是不稳定排序。至于不同
点，快速排序的最坏时间复杂度是0(n²），而堆排序的最坏时间复
杂度稳定在O(nlogn）。
此外，快速排序递归和非递归方法的
平均空间复杂度都是0(logn)，而堆排序的空间复杂度是0(1)。
好了，关于堆排序算法，我们就介绍
到这里。感谢大家！
4.5计数排序和桶排序
4.5.1
线性时间的排序
---
## Page 242
大黄，我们已经学了快速排
序、堆排序这样时间复杂度是
O(logn)的排序算法，应该没
有比这更快的排序算法了吧？
不，事实上更快的算法是存
在的。在理想情况下，某些
算法甚至可以做到线性的时
问复杂度。
哇，什么样的排序算法可以这么
厉害？
让我们先来回顾一下以前所学的排序
算法，无论是冒泡排序，还是快速排序，都是基于元素之间的比较
---
## Page 243
来进行排序的。
例如冒泡排序。
如下图所示，因为8>3，所以8和3的位置交换。
56
3
9217
例如堆排序。
如下图所示，因为10>7，所以10和7的位置交换。
2
3
10
排序当然要先比较呀，难道还有不需要
比较的排序算法？
---
## Page 244
有一些特殊的排序并不基于元素比
较，如计数排序、桶排序、基数排序。
以计数排序来说，这种排序算法是利
用数组下标来确定元素的正确位置的。
4.5.2
初识计数排序
还是不明白，元素下标怎么能用来帮助
排序呢？
---
## Page 245
那让我们来看一个例子。
假设数组中有20个随机整数，取值范围为0～10，要求用最快的速度把
这20个整数从小到大进行排序。
如何给这些无序的随机整数进行排序呢？
考虑到这些整数只能够在0、1、2、3、4、5、6、7、8、9、10这11个数
中取值，取值范围有限。所以，可以根据这有限的范围，建立一个长度
为11的数组。数组下标从0到10，元素初始值全为0。
0000000
01010010
2
6
10
假设20个随机整数的值如下所示。
9，3,5，4，9，1，2，7,8，1，3，6,5，3，4，0,10,9，7,9
下面就并始遍历这个无序的随机数列，每一个整数按照其值对号入座，
同时，对应数组下标的元素进行加1操作。
例如第1个整数是9，那么数组下标为9的元素加1。
000
101
0
010l
业
0
1
2
3
5
6
7
8
10
第2个整数是3，那么数组下标为3的元素加1。
---
## Page 246
0001
00010
3
10
继续遍历数列并修改数组.
最终，当数列遍历完毕时，数组的状态如下。
12132212141
0
123456
78
该数组中每一个下标位置的值代表数列中对应整数出现的次数。
有了这个统计结果，排序就很简单了。直接遍历数组，输出数组元素的
下标值，元素的值是几，就输出几次。
0，1，1，2，3，3，3，4，4，5，5，6，7,7,8，9,9,9，9,10
显然，现在输出的数列已经是有序的了。
这就是计数排序的基本过程，它适用
于一定范围内的整数排序。在取值范围不是很大的情况下，它的性
能甚至快过那些时间复杂度为O(nlogn）的排序。
---
## Page 247
明白了，计数排序还真是个神奇
的算法！那么，用代码怎么实现呢？
我写了一个计数排序的初步实现代
码，我们来看一下。
1. public static int[] countSort(int[] array) {
2.
//1.得到数列的最大值
3.
int max = array[o];
4.
for(int i=1; i max){
6.
max = array[i];
7.
8.
9.
//2.根据数列最大值确定统计数组的长度
10.
int[] countArray = new int[max+1];
11.
//3.遍历数列，填充统计数组
---
## Page 248
12.
for(int i=0;i<array.length; i++){
13.
countArray[array[i]]++;
14.
15.
//4.遍历统计数组，输出结果
16.
int index = 0;
17.
int[] sortedArray = new int[array.length];
18.
for(int i=0;i<countArray.length;i++){
19.
for(int j=θ; j<countArray[i]; j++){
20.
sortedArray[index++]= i;
21.
}
22.
23.
return sortedArray;
24.}
25.
26.
27. public static void main(String[] args) {
28.
int[] array = new int[] {4,4,6,5,3,2,8,1,7,5,6,0,10};
29.
int[] sortedArray = countSort(array);
30.
System.out.println(Arrays.toString(sortedArray));
31.}
这段代码在开头有一个步骤，就是求数列的最大整数值max。后面创建
的统计数组countArray，长度是max+1，以此来保证数组的最后一个下
标是max。
4.5.3
计数排序的优化
---
## Page 249
从实现功能的角度来看，这段代码可
以实现整数的排序。但是这段代码也存在一些问题，你发现了吗？
哦，让我想想.
对了！我们只以数列的最大值来决定
统计数组的长度，其实并不严谨。例如下面的数列。
7616966606668616696
---
## Page 250
这个数列的最大值是99，但最小的整
数是90。如果创建长度为100的数组，那么前面从0到89的空间位置
就都浪费了！
怎么解决这个问题呢？
很简单，只要不再以输入数列的最大值+1作为统计数组的长度，而是
以数列最大值-最小值+1作为统计数组的长度即可。
同时，数列的最小值作为一个偏移量，用于计算整数在统计数组中的下
标。
以刚才的数列为例，统计出数组的长度为99-90+1=10，偏移量等于数列
的最小值90。
对于第1个整数95，对应的统计数组下标是95-90=5，如图所示。
7616666066686166S6
---
## Page 251
是的，这确实对计数排序进行了优
化。此外，朴素版的计数排序只是简单地按照统计数组的下标输出
元素值，并没有真正给原始数列进行排序。
如果只是单纯地给整数排序，这样做
并没有问题。但如果在现实业务里，例如给学生的考试分数进行排
序，遇到相同的分数就会分不清谁是谁。
什么意思呢？让我们看看下面的例子。
姓名
成绩
小灰
06
大黄
66
小红
95
小
94
小绿
95
给出一个学生成绩表，要求按成绩从低到高进行排序，如果成绩相同，
则遵循原表固有顺序。
---
## Page 252
那么，当我们填充统计数组以后，只知道有两个成绩并列为95分的同
学，却不知道哪一个是小红，哪一个是小绿。
有两个成络为95分的
否是小绿在前呢？
学生，究小红在前
明白你的例子了，但为什么我的成绩最
低呀....那么，这种分数相同的情况要怎么解决？
在这种情况下，需要稍微改变之前的
逻辑，在填充完统计数组以后，对统计数组做一下变形。
仍然以刚才的学生成绩表为例，将之前的统计数组变形成下面的样子。
---
## Page 253
0+10+10+11+12+20+40+40+41+4
11112 4 4 4 4 5
0
1234
567
68
这是如何变形的呢？其实就是从统计数组的第2个元素开始，每一个元
素都加上前面所有元素之和。
为什么要相加呢？初次接触的读者可能会觉得莫名其妙。
这样相加的目的，是让统计数组存储的元素值，等于相应整数的最终排
序位置的序号。例如下标是9的元素值为5，代表原始数列的整数9，最
终的排序在第5位。
接下来，创建输出数组sortedArray，长度和输入数列一致。然后从后向
前遍历输入数列。
第1步，遍历成绩表最后一行的小绿同学的成绩。
小绿的成绩是95分，找到countArray下标是5的元素，值是4，代表小绿
的成绩排名位置在第4位。
同时，给countArray下标是5的元素值减1，从4变成3，代表下次再遇到
95分的成绩时，最终排名是第3。
---
## Page 254
姓名显结
小医
90
大菌
66
小红
G6
小
94
小佳
4-1
CountArray
1
2
3
小绿
SortedArray
95
0
1
2
3
第2步，遍历成绩表倒数第2行的小白同学的成绩。
小白的成绩是94分，找到countArray下标是4的元素，值是2，代表小白
的成绩排名位置在第2位。
同时，给countArray下标是4的元素值减1，从2变成1，代表下次再遇到
94分的成绩时（实际上已经遇不到了），最终排名是第1。
姓名成绩
小层
90
大茜
66
小红
95
小白
小
56
2-1
Count Array
2
Q
小
小绿
Sorted Aray
94
S6
1
2
3
第3步，遍历成绩表倒数第3行的小红同学的成绩。
小红的成绩是95分，找到countArray下标是5的元素，值是3（最初是4，
减1变成了3），代表小红的成绩排名位置在第3位。
---
## Page 255
同时，给countArray下标是5的元素值减1，从3变成2，代表下次再遇到
95分的成绩时（实际上已经遇不到了），最终排名是第2。
小民
大茜
90
99
小红
95
小
94
小绿
95
3-1
CountArray
小口小红小组
Sorted Array
16
95
95
0
1
这样一来，同样是95分的小红和小绿就能够清楚地排出顺序了，也正因
为此，优化版本的计数排序属于稳定排序。
后面的遍历过程以此类推，这里就不再详细描述了。
还真是够绕的，不过大体上明白
了。那么，优化之后的计数排序如何用代码实现呢？
---
## Page 256
说起来复杂，其实代码很简洁，让我
们来看一看。
1.public static int[] countSort(int[] array){
2.