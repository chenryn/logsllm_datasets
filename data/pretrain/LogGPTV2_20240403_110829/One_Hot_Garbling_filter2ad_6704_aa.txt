title:One Hot Garbling
author:David Heath and
Vladimir Kolesnikov
One Hot Garbling
David Heath
Georgia Tech
USA
PI:EMAIL
Vladimir Kolesnikov
Georgia Tech
USA
PI:EMAIL
ABSTRACT
Garbled Circuit (GC) is the main practical 2PC technique, yet despite
great interest in its performance, GC notoriously resists improve-
ment. Essentially, we only know how to evaluate GC functions
gate-by-gate using encrypted truth tables; given input labels, the
GC evaluator decrypts the corresponding output label.
Interactive protocols enjoy more sophisticated techniques. For
example, we can expose to a party a (masked) private value. The
party can then perform useful local computation and feed the re-
sulting cleartext value back into the MPC. Such techniques are not
known to work for GC.
We show that it is, in fact, possible to improve GC efficiency,
while keeping its round complexity, by exposing masked private
values to the evaluator. Our improvements use garbled one-hot en-
codings of values. By using this encoding we improve a number of
interesting functions, e.g., matrix multiplication, integer multiplica-
tion, field element multiplication, field inverses and AES S-Boxes,
integer exponents, and more. We systematize our approach by pro-
viding a framework for designing such GC modules.
Our constructions are concretely efficient. E.g., we improve bi-
nary matrix multiplication inside GC by more than 6Ã— in terms of
communication and by more than 4Ã— in terms of WAN wall-clock
time.
Our improvement circumvents an important GC lower bound
and may open GC to further improvement.
CCS CONCEPTS
â€¢ Security and privacy â†’ Cryptography; â€¢ Theory of compu-
tation â†’ Cryptographic protocols.
KEYWORDS
Secure 2PC; Garbled Circuits
ACM Reference Format:
David Heath and Vladimir Kolesnikov. 2021. One Hot Garbling. In Proceed-
ings of the 2021 ACM SIGSAC Conference on Computer and Communications
Security (CCS â€™21), November 15â€“19, 2021, Virtual Event, Republic of Korea.
ACM, New York, NY, USA, 20 pages. https://doi.org/10.1145/3460120.3484764
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea
Â© 2021 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-8454-4/21/11...$15.00
https://doi.org/10.1145/3460120.3484764
1 INTRODUCTION
Garbled circuits (GCs) allow two mutually untrusting parties to
compute arbitrary functions of their private inputs while revealing
only the functionsâ€™ outputs. Today, cryptographers view GC as
a cryptographic primitive rather than a protocol. The primitive
can be plugged into many protocols and is foundational in secure
multiparty computation (MPC).
The GC primitive only allows the circuit generator ğº and evalu-
ator ğ¸ to communicate a constant number of times. This restriction
makes GC difficult to improve. Indeed, since Yao first described GC,
only a handful of fundamental improvements have been made.
GCs are usually structured as encryptions of Boolean circuits
composed of XOR and AND gates. Most prior work has focused
on improving these gates. The most relevant cost is bandwidth
consumption: ğº must send to ğ¸ an â€˜encryptionâ€™ of the circuit, and
this transmission is typically understood to be the GC bottleneck.
The widely used half-gates [ZRE15] garbling requires ğº send to
ğ¸ two ciphertexts per AND gate; XOR gates are communication
free [KS08]. [ZRE15] also established a matching lower bound on
AND gate communication that is difficult to circumvent1.
Thus, it is natural to target GC evaluation of more complex
functions. Thus, searching for complex functions that can be quickly
computed in GC became a natural research direction. Nevertheless,
only two core-GC improvements have subsequently been found:
Arithmetic GCs [BMR16] show that Free XOR [KS08] can be
generalized to achieve free additive homomorphisms for arbitrary
fields. Using this technique, we can efficiently add arithmetic values
inside GC. Unfortunately, both multiplying field values and con-
verting between fields is expensive, since these operations require
ğº to send to ğ¸ a number of ciphertexts proportional to the size of
the field. Thus, arithmetic GCs only improve communication in
very specific scenarios.
Stacked garbling [HK20a] improves the performance of GCs
for functions that include conditional branching. The technique
shows that ğº needs to send a number of ciphertexts proportional
to only the longest program execution path, not to the entire cir-
cuit. Stacked garbling dramatically improves some functions, but
requires that these functions feature exclusive conditional behavior.
Our work. We show that a number of useful functions can be
greatly improved by operating over a garbled one-hot encoding.
Specifically, suppose the GC holds two bit vectors ğ‘ âˆˆ {0, 1}ğ‘›
and ğ‘ âˆˆ {0, 1}ğ‘š. Moreover, suppose ğ¸ knows ğ‘ in cleartext. Our
central primitive allows ğº and ğ¸ to compute the following 2ğ‘› Ã— ğ‘š
1â€œThree-halvesâ€ [RR21], a recent improvement to half gates developed concurrently
with our work, requires only 1.5 ciphertexts per AND gate. This new approach cir-
cumvents the letter, but not the spirit, of the [ZRE15] lower bound by operating on
portions of garbled labels. The core of the lower bound still holds and implies further
improvements will be difficult.
Session 2D: Secure Multiparty ComputationCCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea574Application
128 Ã— 128 binary matrix mult.
32-bit mult.
GF(28) mult.
AES S-Box
32-bit ğ‘¥ ğ‘¦ for public ğ‘¥
32-bit ğ‘¥ mod ğ‘ for public ğ‘
Comm. Improvement
6.2Ã—
1.5Ã—
2.2Ã—
1.1Ã—
11.8Ã—
3.3Ã—
Figure 1: Use cases that we implemented where a one-hot
encoding improves over a standard Boolean circuit imple-
mented with [ZRE15]. We list communication reduction as
compared to a standard circuit. See Section 7 for details.
matrix inside the GC extremely efficiently:
0
0
0
(1)
0
ğ‘0
0
0
ğ‘1
0
0
0
Â· Â· Â·
...
Â· Â· Â·
Â· Â· Â·
Â· Â· Â·
...
Â· Â· Â·
0
ğ‘ğ‘šâˆ’1
0
0
zero row.
In this matrix, row ğ‘, viewed as ğ‘ âˆˆ {0, 2ğ‘›âˆ’1}, is the only non-
At first glance, this primitive, which we call a one-hot outer
product, may seem incredibly contrived and niche. It is not.
This primitive can be used to implement a number of important
functions. We use it to improve the GC bandwidth consumption of
matrix multiplication, integer multiplication, field multiplication,
field inverses and AES S-Boxes, integer exponents, and more. We
believe other efficient applications of the technique are likely.
We develop a framework for designing such ready-to-use mod-
ules. Once designed, these modules are freely composable in GC.
1.1 Contribution
Non-interactivity is a key advantage of GC, as compared to other
MPC techniques, such as GMW. However, non-interactivity also
severely limits the set of GC building blocks. Essentially, we only
know how to evaluate GC functions by using encrypted truth tables;
given input labels, ğ¸ decrypts the corresponding output label.
In this work, we show that it is possible to improve GC efficiency
by exposing masked private values to ğ¸. By doing so, we circumvent
the [ZRE15] GC lower bound, and open GC for further improvement.
In more detail, we:
(1) Introduce a new GC gate primitive that computes a one-
hot outer product (see Equation (1)) for only 2(ğ‘› âˆ’ 1) + ğ‘š
ciphertexts.
(2) Provide numerous constructions that utilize this new primi-
tive to implement improved GC modules (see Figure 1 and
Section 7).
(3) Formalize a framework that allows new one-hot-based mod-
ules to be easily plugged in. Once implemented, these new
modules can be used as if they are ordinary gates.
(4) Implement our approach in C++ and provide experimental
evaluation (see Section 7).
1.2 High Level Intuition
Let H(Â·) denote the function that maps a bit vector to its corre-
sponding one-hot encoding. That is, for ğ‘ âˆˆ {0, 1}ğ‘›, H(ğ‘) is a
length-2ğ‘› bit vector that is zero everywhere, except at index ğ‘,
where it is one. Let ğ‘ âˆˆ {0, 1}ğ‘› and ğ‘ âˆˆ {0, 1}ğ‘š be two bit vectors
and suppose ğ¸ holds garblings of these two values. Our lowest
level primitive allows ğ¸ to efficiently construct a garbling of the
following matrix (see also Equation (1)):
H(ğ‘) âŠ— ğ‘
where âŠ— denotes the vector outer product operation. This matrix
has dimension 2ğ‘› Ã— ğ‘š, yet the parties construct the output using
only O(ğ‘› + ğ‘š)ğœ… bits of communication, for security parameter ğœ….
Our construction does have one limitation: ğ¸ must know ğ‘. Nev-
ertheless, we build a number of useful GC constructions from this
low-level primitive, even if ğ¸ does not know the input.
Our constructions use two key ideas:
First, the garbled one-hot encoding of a value is, in a sense, â€˜fully
homomorphicâ€™. Namely, let T (ğ‘“ ) denote the truth table (represented
as a matrix) for arbitrary function ğ‘“ . The following equality holds:
T (ğ‘“ )âŠº Â· H(ğ‘) = ğ‘“ (ğ‘)
Thus, if ğ‘“ is public and ğ¸ knows ğ‘, then we can map a garbling of
H(ğ‘) to a garbling of ğ‘“ (ğ‘) without communication. Specifically, the
parties locally construct and apply T (ğ‘“ )âŠº via Free XOR [KS08].
Second, we can reveal in cleartext to ğ¸ masked intermediate
circuit values. This way, ğ¸ learns nothing, yet can use the above
one-hot primitive to compute ğ‘“ of masked ğ‘. In many useful cases
we can use simple algebra to cheaply undo the masking and obtain
ğ‘“ (ğ‘) inside GC, where ğ¸ does not know ğ‘.
2 RELATED WORK
Ours is in a line of works that improve the practical performance
of GC. We review other works in this line. Our emphasis is commu-
nication reduction, which is the GC bottleneck.
Practical GC research has long focused on efficient evaluation
of AND/XOR gates. [NPS99] gave the first GC communication
improvement: garbled row reduction. Much later [KS08], gave the
important Free XOR optimization which eliminated the communica-
tion cost of XOR gates. Garbled gates were slowly improved [PSSW09,
KMR14], and the half-gates technique [ZRE15] reduced AND gate
communication cost to only two ciphertexts. Subsequently, [GLNP18]
showed that similar costs (two ciphertexts per AND and one per
XOR) are possible even when assuming only one-way functions, as
opposed a circular correlation robust hash function. Very recently,
a new â€œthree-halvesâ€ garbling technique showed that only 1.5 ci-
phertexts are needed per AND gate [RR21]. However, â€œthree-halvesâ€
has not yet been implemented, so we focus our comparison on the
widely-available half-gates technique. We mention that [RR21]â€™s
construction uses Free XOR based GC labels, and so is compatible
with and complementary to our technique: one-hot gates can be
composed with 1.5 ciphertext AND gates in a single circuit.
Not only have there been few core-GC improvements, but those
improvements have also been small. For example, half-gates im-
proved over the prior state-of-the-art [KMR14] by only 1 âˆ’ 1.5Ã—
(1.5Ã— is for the pessimal case where [KMR14]â€™s heuristics fail).
Session 2D: Secure Multiparty ComputationCCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea575Recently, GC performance improvement has proceeded in two