• Penalty maintenance The distance penalty between C1
and C2 changes when any size of C1 and C2 changes. In
this case, all entries in h containing a cluster whose size
changes should be updated or nulliﬁed.
We use a version control to mark the latest and depre-
cated versions of clusters inh. The version of a cluster C
is recorded as its current size (an integer). It is stored in
v[O] where O is the event co-occurrence matrix of C. v
is a hashtable that assigns 0 to an entry when the entry
is accessed for the ﬁrst time. A heap entry contains two
clusters, their versions and their distance when pushed
to h (line 9 and line 24). An entry is abandoned if any
of its two clusters are found deprecated at the moment
the entry is popped from h (line 17).
• Borderline behavior treatment It may generate a false
positive when i) dist(b, C1) =dist (b, C2), ii) b is trained
only in C1 during Intra-cluster Modeling, and iii)
a similar behavior instance b(cid:2)
is tested against C2 in
operation Occurrence Frequency Analysis (intra-
cluster detection).
To treat this type of borderline behaviors correctly, our
clustering algorithm duplicates b in every cluster, which
b may belong to (line 30-44). This operation also in-
creases cluster sizes and results in suﬃcient training in
Intra-cluster Modeling.
4.2 Co-occurrence Analysis (Detection)
This operation performs inter-cluster detection to seek
montage anomalies. A behavior instance b is tested against
all normal clusters C to check whether the co-occurred events
in b are consistent with co-occurred events found in a single
cluster. An alarm is raised if no such cluster is found. Other-
wise, b and its most closely ﬁtted clusters Cb = {C1, . . . , Ck}
are passed to Occurrence Frequency Analysis for intra-
cluster detection.
An incoming behavior instance b ﬁts in a cluster C if
Ob OR OC = OC where OC and Ob are the event co-occurrence
matrices of C and b. The detection process searches for all
clusters in which b ﬁts. If this set of clusters is not empty,
distances between b and each cluster in this set are calcu-
lated using (3). The clusters with the nearest distance (there
could be more than one cluster) are selected as Cb.
4.3
Intra-cluster Modeling (Training)
Within a cluster C, our approach analyzes behavior in-
stances through their transition frequency matrices {Fb | b ∈
C}. The matrices are vectorized into data points in a high-
dimensional detection space where each dimension records
the occurrence frequency of a speciﬁc event across proﬁles.
Two analysis methods reveal relations among frequencies.
The probabilistic method. We employ a one-class
SVM, i.e., ν-SVM [38], to seek a frontier F that envelops
all behavior instances {b | b ∈ C}.
a) Each frequency value is preprocessed with a logarith-
mic function f (x) = log2 (x + 1) to reduce the variance
between extreme values (empirically proved necessary).
b) A subset of dimensions are selected through frequency
variance analysis (FVA)3 or principle component analy-
sis (PCA)4 before data points are consumed by ν-SVM.
This step manages the curse of dimensionality, a com-
mon concern in high-dimensional statistical learning.
c) We pair the ν-SVM with a kernel function, i.e., radial
basis function (RBF)5, to search for a non-linearly F
that envelops {b | b ∈ C} tightly. The kernel function
transforms a non-linear separating problem into a lin-
early separable problem in a high-dimensional space.
The deterministic method. We employ variable range
analysis to measure frequencies of events with zero or near
zero variances across all program behaviors {b | b ∈ C}.
Frequencies are discrete integers. If all frequencies of an
event in diﬀerent behavior instances are the same, PCA sim-
ply drops the corresponding dimension. In some clusters, all
behavior instances (across all dimensions) in C are the same
or almost the same. Duplicated data points are treated as a
single point, and they cannot provide suﬃcient information
to train probabilistic models, e.g., one-class SVM.
Therefore, we extract deterministic rules for events with
zero or near zero variances. This model identiﬁes the fre-
quency range [fmin, fmax] for each of such events. fmin can
equal to fmax.
4.4 Occurrence Frequency Analysis (Detection)
This operation performs intra-cluster detection to seek
frequency anomalies:
i) deviant relations among multiple
event occurrence frequencies, and/or ii) aberrant occurrence
3FVA selects dimensions/events with larger-than-threshold
frequency variances across all behavior instances in C.
4PCA selects linear combinations of dimensions/events with
larger-than-threshold frequency variances, which is a gener-
alization of FVA.
5Multiple functions have been tested for selection.
406frequencies. Given a program behavior instance b and its
closely ﬁtted clusters Cb = {C1, . . . , Ck} discovered in Co-
occurrence Analysis, this operation tests b in every Ci (0 ≤
i ≤ k) and aggregates the results using (5).
∃C ∈ C Nclt(b, C) ⇒ b is normal
(5)
The detection inside C is performed with 3 rules, and the
result is aggregated into Nclt(b, C).
(cid:2)
normal by all 3 rules
Nclt(b, C) =
True
False anomalous by any rule
(6)
• Rule 1: normal if the behavior instance b passes the prob-
abilistic model detection. The frequency transition ma-
trix F of b is vectorized into a high-dimensional data
point and tested against the one-class SVM model built
in Intra-cluster Modeling. This operation computes
the distance d between b and the frontier F established in
the ν-SVM. If b is within the frontier or b is on the same
side as normal behavior instances, then d >0. Other-
wise, d  FPRu,
a smallerk is selected until FPR ≤ FPRu.
6.2 Discovering Real-World Attacks
We reproduce three known aberrant path attacks to test
the detection capability of our approach. Our detection ap-
proach detects all attack attempts with less than 0.0001 false
positive rate. The overview of the attacks and detection re-
sults are presented in Table 2.
6.2.1 Flag Variable Overwritten Attack
Flag variable overwritten attack is a non-control data at-
tack. An attacker tampers with decision-making variables.
The exploit takes eﬀect when the manipulated data aﬀects
the control ﬂow at some later point of execution.
We reproduce the ﬂag variable overwritten attack against
sshd introduced by Chen et al. [5]. We describe the attack
in Sect. 2.1, bullet (a) and in Fig. 1. We simplify the attack
procedure by placing an inline virtual exploit in sshd right
after the vulnerable routine packet_read():
if (user[0] == ’e’ && user[1] == ’v’
&& user[2] == ’e’) authenticated = 1;
This inline virtual exploit produces the immediate conse-
quence of a real exploit – overwriting authenticated.
It
does not interfere with our tracing/detection because no
call instruction is employed. For each attack attempt, 128
random commands are executed after a successful login.
Our approach (conﬁgured at FPRu 0.0001) successfully
detects all attack attempts in inter-cluster detection (Co-
occurrence Analysis)8. We present normal and attack
traces inside the execution window (selected routine
do_authentication()) in Fig. 5 to illustrate the detection.
7The distance can be positive or negative. More details are
speciﬁed in Rule 1 (Sect. 4.4).
8One-class SVM in Occurrence Frequency Analysis
only detects 3.8% attack attempts if used alone.
408Table 2: Overview of reproduced attacks and detection results.
Attack Name