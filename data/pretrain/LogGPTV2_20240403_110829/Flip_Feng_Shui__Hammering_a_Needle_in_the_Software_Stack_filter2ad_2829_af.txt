poisoned NUL
http://
[24] Justin N. Ferguson. Understanding the heap by
breaking it. In Black Hat USA, 2007.
[25] Francesco Gadaleta, Yves Younan, and Wouter
Joosen. ESSoS’10, 2010.
[26] Daniel Kahn Gillmor.
pem2openpgp - translate
PEM-encoded RSA keys to OpenPGP certiﬁcates.
Accessed on 17.2.2016.
[14] Eric Brier, Benoît Chevallier-Mames, Mathieu
Ciet, and Christophe Clavier. Why one should also
secure RSA public key elements. CHES’06, 2006.
[27] GitHub Developer – Public Keys.
https://
developer.github.com/v3/users/keys/. Ac-
cessed on 17.2.2016.
[15] Nicolas Carlini, Antonio Barresi, Mathias Payer,
David Wagner, and Thomas R. Gross. Control-ﬂow
Bending: On the Effectiveness of Control-ﬂow In-
tegrity. SEC’15, 2015.
[16] Cristian Constantinescu. Trends and Challenges in
VLSI Circuit Reliability. IEEE Micro, 23(4), 2003.
[17] D. Cooper, S. Santesson, S. Farrell, S. Boeyen,
R. Housley, and W. Polk. RFC 5280 - Inter-
net X.509 Public Key Infrastructure Certiﬁcate and
Certiﬁcate Revocation List (CRL) Proﬁle. Techni-
cal report, May 2008.
[18] Yvo Desmedt, Peter Landrock, Arjen K. Lenstra,
Kevin S. McCurley, Andrew M. Odlyzko,
Rainer A. Rueppel, and Miles E. Smid. The Eu-
rocrypt ’92 Controversial Issue: Trapdoor Primes
and Moduli (Panel). Eurocrypt’92, 1992.
[19] The Sage Developers. Sage Mathematics Soft-
ware (Version). http://www.sagemath.org. Ac-
cessed on 17.2.2016.
[20] Karl Dickman. On the frequency of numbers con-
taining prime factors of a certain relative magni-
tude. Arkiv forr Matematik, Astronomi och Fysik,
1930.
[21] Whitﬁeld Difﬁe and Martin E. Hellman. New di-
rections in cryptography. IEEE Transactions on In-
formation Theory, 22(6), 1976.
[28] Sudhakar Govindavajhala and Andrew W. Appel.
Using Memory Errors to Attack a Virtual Machine.
SP ’03, 2003.
[29] Daniel Gruss, David Bidner, and Stefan Mangard.
Practical Memory Deduplication Attacks in Sand-
boxed Javascript. ESORICS’15. 2015.
[30] Daniel Gruss, Clementine Maurice, and Stefan
Mangard. Rowhammer.js: A Remote Software-
Induced Fault Attack in JavaScript. DIMVA’16,
2016.
[31] Danny Harnik, Benny Pinkas, and Alexandra
Shulman-Peleg. Side Channels in Cloud Services:
Deduplication in Cloud Storage. IEEE Security and
Privacy Magazine, special issue of Cloud Security,
8, 2010.
[32] Gorka Irazoqui, Mehmet Sinan IncI, Thomas
Eisenbarth, and Berk Sunar. Know Thy Neigh-
bor: Crypto Library Detection in Cloud. PETS’15,
2015.
[33] Vasileios P. Kemerlis, Michalis Polychronakis, and
Angelos D. Keromytis. Ret2Dir: Rethinking Ker-
nel Isolation. SEC’14, 2014.
[34] Yoongu Kim, Ross Daly, Jeremie Kim, Chris
Fallin, Ji Hye Lee, Donghyuk Lee, Chris Wilker-
son, Konrad Lai, and Onur Mutlu. Flipping Bits in
Memory Without Accessing Them: An Experimen-
tal Study of DRAM Disturbance Errors. ISCA’14,
2014.
[22] Paul Erdös and Mark Kac. The Gaussian Law of
Errors in the Theory of Additive Number Theo-
retic Functions. American Journal of Mathematics,
62(1), 1940.
[35] Thorsten Kleinjung, Kazumaro Aoki, Jens Franke,
Arjen K. Lenstra, Emmanuel Thomé, Joppe W.
Bos, Pierrick Gaudry, Alexander Kruppa, Pe-
ter L. Montgomery, Dag Arne Osvik, Herman
16  25th USENIX Security Symposium 
USENIX Association
16
J. J. te Riele, Andrey Timofeev, and Paul Zimmer-
mann. Factorization of a 768-bit RSA modulus.
CRYPTO’10, 2010.
[48] Kaveh Razavi, Gerrit van der Kolk, and Thilo Kiel-
Prebaked uVMs: Scalable, Instant VM
mann.
Startup for IaaS Clouds. ICDCS ’15, 2015.
[36] Donald E. Knuth and Luis Trabb-Pardo. Analysis
of a Simple Factorization Algorithm. Theoretical
Computer Science, 3(3), 1976.
[37] Dmitrii Kuvaiskii, Rasha Faqeh, Pramod Bhato-
tia, Pascal Felber, and Christof Fetzer. HAFT:
Hardware-assisted Fault Tolerance. EuroSys’16,
2016.
[38] Hendrik W. Lenstra. Factoring Integers with Ellip-
tic Curves. Annals of Mathematics, 126, 1987.
[39] Dwayne Litzenberger.
PyCrypto
Python Cryptography Toolkit).
//www.dlitz.net/software/pycrypto/.
Accessed on 17.2.2016.
- The
https:
[40] Fangfei Liu, Yuval Yarom, Qian Ge, Gernot Heiser,
and Ruby B. Lee. Last-level cache side-channel at-
tacks are practical. SP’15, 2015.
[41] Tarjei Mandt. Kernel Pool Exploitation on Win-
dows 7. In Black Hat Europe, 2011.
[42] Alfred Menezes, Paul C. van Oorschot, and
Scott A. Vanstone. Handbook of Applied Cryptog-
raphy. 1996.
[43] R. Owens and Weichao Wang. Non-interactive
OS ﬁngerprinting through memory de-duplication
technique in virtual machines. IPCCC’11, 2011.
[44] Peter Pessl, Daniel Gruss, Clementine Maurice,
Michael Schwarz, and Stefan Mangard. DRAMA:
Exploiting DRAM Addressing for Cross-CPU At-
tacks. SEC’16, 2016.
[45] Stephen C. Pohlig and Martin E. Hellman. An
improved algorithm for computing logarithms over
GF(p) and its cryptographic signiﬁcance (cor-
resp.). IEEE Transactions on Information Theory,
24(1), 1978.
[49] Ronald L. Rivest, Adi Shamir, and Leonard M.
Adleman. A method for obtaining digital signatures
and public-key cryptosystems. Commun. ACM,
21(2), 1978.
[50] Jurgen Schmidt.
JIT Spraying: Exploits to beat
DEP and ASLR. In Black Hat Europe, 2010.
[51] Mark Seaborn. Exploiting the DRAM Rowhammer
Bug to Gain Kernel Privileges. In Black Hat USA,
2015.
[52] Jean-Pierre Seifert. On authenticated computing
and RSA-based authentication. CCS’05, 2005.
[53] Noam Shalev, Eran Harpaz, Hagar Porat, Idit Kei-
dar, and Yaron Weinsberg. CSR: Core Surprise
Removal in Commodity Operating Systems. AS-
PLOS’16, 2016.
[54] Prateek Sharma and Purushottam Kulkarni. Sin-
gleton: System-wide Page Deduplication in Virtual
Environments. HPDC’12, 2012.
[55] Alexander Sotirov. Heap Feng Shui in JavaScript.
In Black Hat Europe, 2007.
[56] Kuniyasu Suzaki, Kengo Iijima, Toshiki Yagi, and
Cyrille Artho. Memory Deduplication As a Threat
to the Guest OS. EUROSEC’11, 2011.
[57] Paul C. van Oorschot and Michael J. Wiener. On
Difﬁe-Hellman key agreement with short expo-
nents. Eurocrypt’96, 1996.
[58] Yuanzhong Xu, Weidong Cui, and Marcus Peinado.
Controlled-Channel Attacks: Deterministic Side-
Channels for Untrusted Operating Systems. SP’15,
2015.
Appendix A Cryptanalysis
of
Difﬁe-
Hellman with Bit Flips
[46] Shashank Rachamalla, Dabadatta Mishra, and Pu-
rushottam Kulkarni. Share-o-meter: An empirical
analysis of KSM based memory sharing in virtual-
ized systems. HiPC’13, 2013.
[47] Paruj Ratanaworabhan, Benjamin Livshits, and
Benjamin Zorn. NOZZLE: A Defense Against
Heap-spraying Code Injection Attacks. SEC’09,
2009.
This section describes how one can break Difﬁe-Hellman
by ﬂipping a bit in the modulus. Similar to RSA, Difﬁe-
Hellman cryptosystem performs computations modulo
In the Difﬁe-Hellman key agreement scheme [21],
n.
however, the modulus n is prime or s = γ1 = 1.
It is
very common to choose strong primes, which means that
q = (n − 1)/2 is also prime; this is also the approach
taken by OpenSSH. Subsequently a generator g is cho-
sen of order q. In the Difﬁe-Hellman protocol the client
USENIX Association  
25th USENIX Security Symposium  17
17
chooses a random x ∈ [1,n− 1] and computes gx mod n
and the server chooses a random y ∈ [1,n− 1] and com-
putes gy mod n. After exchanging these values, both par-
ties can compute the shared secret gxy mod n. The best
known algorithm to recover the shared secret is to solve
the discrete logarithm problem to ﬁnd x or y using the
GNFS, which has complexity O(Ln[1/3,1.92]). For a
512-bit modulus n, the pre-computation cost is estimated
to be about 10 core-years; individual discrete logarithms
mod n can subsequently be found in 10 minutes [3]. The
current record is 596 bits [13]; again 1024 bits seems to
be within reach of intelligence agencies [3].
By ﬂipping a single bit of n, the parties compute
gx mod n(cid:29) and gy mod n(cid:29). It is likely that recovering x or
y is now much easier. If we ﬂip the LSB, n(cid:29) = n− 1 = 2q
with q prime and g will be a generator. In the other cases
n(cid:29) is a t-bit or (t − 1)-bit odd integer; we conjecture that
its factorization has the same form as that of a random
odd integer of the same size. It is not necessarily the case
the g is a generator mod n(cid:29), but with very high probabil-
ity g has large multiplicative order.
The algorithm to compute a discrete logarithm in Zn(cid:29)
to recover x from y = gx mod n(cid:29) requires two steps.
1. Step 1 is to compute the factorization of n(cid:29). This
is the same problem as the one considered in Sec-
tion 3.
2. Step 2 consists in computing the discrete logarithm
of gx mod n(cid:29): this can be done efﬁciently by com-
puting the discrete logarithms modulo gx mod p(cid:29) ˜γi
i
and by combining the result using the Chinese re-
mainder theorem. Note that except for the small
primes, the ˜γi are expected to be equal to 1 with
high probability. Discrete logarithms mod p(cid:29) ˜γi
can
i
in turn be computed starting from discrete loga-
rithms mod p(cid:29)i ( ˜γi steps are required).
If p(cid:29)i − 1 is
j=1 qδ j
smooth (that is, it is of the form p(cid:29)i = ∏r
j with
q j small), the Pohlig-Hellman algorithm [45] can
solve this problem in time O(cid:31)∑r
j=1 δ j√q j(cid:30). If n(cid:29)
has prime factors p(cid:29)i for which p(cid:29)i − 1 is not smooth,
we have to use for those primes GNFS with com-
plexity O(Lp(cid:29)i
[1/3,1.92]).
The analysis is very similar to that of Section 3, with as
difference that for RSA we can use ECM to ﬁnd all small
prime factors up to the second largest one p(cid:29)2. With a
simple primality test we verify that the remaining integer
is prime and if so the factorization is complete. How-
ever, in the case of the discrete logarithm algorithm we
have to perform in Step 2 discrete logarithm computa-
tions modulo the largest prime p(cid:29)1. This means that if
n(cid:29) would prime (or a small multiple of a prime), Step 1
would be easy but we have not gained anything with the
bit ﬂip operation. It is known that the expected bitlength
of the largest prime factor p(cid:29)1 of n(cid:29) is 0.624·t [36] (0.624
is known as the Golomb–Dickman constant). A second
number theoretic result by Dickman shows that the prob-
ability that all the prime factors p(cid:29)i of an integer n(cid:29) are
smaller than n(cid:29)1/u has asymptotic probability u−u [20].
For t = 1024, the expected size of the largest prime
factor p(cid:29)1 of n(cid:29) is 639 bits and in turn the largest prime
factor of p(cid:29)1−1 is expected to be 399 bits (1024·0.6242).
Note that p(cid:29)1 − 1 can be factored efﬁciently using ECM
as in the RSA case. If p(cid:29)1 − 1 has 639 bits, the proba-
bility that it is smooth (say has factors less than 80 bits)
is 8−8 = 2−24, hence Pohlig-Hellman cannot be applied.
We have to revert to GNFS for a 399-bit integer. How-
ever, with probability 2−2 = 1/4 all the factors of n(cid:29) are
smaller than 512 bits: in that case the largest prime fac-
tor of p(cid:29)1 − 1 is expected to be 319 bits, but again with
probability 1/4 all prime factors are smaller than 256 bits.
Hence with probability 1/16 GNFS could solve the dis-
crete logarithm in less than 1 core hour.
For t = 2048, the expected size of the largest prime
factor p(cid:29)1 of n(cid:29) is 1278 bits and the largest prime factor
of p(cid:29)1 − 1 is expected to be 797 bits – this is well beyond
the current GNFS record. However, with probability 3·
10−3 = 0.037 all prime factors of n(cid:29) are smaller than 638
bits. Factoring p(cid:29)1 − 1 is feasible using ECM, given that
the its second largest prime factor is expected to be 134
bits. The largest prime factor of p(cid:29)1 − 1 is expected to
be 398 bits. The discrete logarithm problem modulo the
largest factor can be solved using GNFS in about 1 core-
month. With probability 4· 10−4 = 3.9· 10−3 all prime
factors of n(cid:29) are smaller than 512 bits, and in that case the
largest prime factor of p(cid:29)1 − 1 is expected to be 319 bits,
which means that GNFS would require a few core-hours.
Even if it would not be feasible to compute the com-
plete discrete logarithm there are special cases: if x or
y have substantially fewer than t bits, it is sufﬁcient to
recover only some of the discrete logarithms mod p(cid:29)i and
the hardest discrete logarithm p1 can perhaps be skipped;
for more details, see [3, 57].
The main conclusion is that breaking discrete loga-
rithms with the bit ﬂip attack is more difﬁcult than factor-
izing, but for 1024 bits an inexpensive attack is feasible,
while for 2048 bits the attack would require a moderate
computational effort, the results of which are widely ap-
plicable. It is worth noting that this analysis is applicable
to the DH key agreement algorithm in use by OpenSSH,
defaulting to 1536-bit DH group moduli in the current
OpenSSH (7.2), bitﬂipped variants of which can be pre-
computed by a moderately equipped attacker, and ap-
plied to all OpenSSH server installations. The conse-
quences of such an attack are decryption of a session,
including the password if used, adding another attractive
facet to attacks already demonstrated in this paper.
18  25th USENIX Security Symposium 
USENIX Association
18