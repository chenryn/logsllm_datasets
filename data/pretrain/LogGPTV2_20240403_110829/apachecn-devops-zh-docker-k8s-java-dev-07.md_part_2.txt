 "containers": [{
 "name": "rest_service",
 "image": "rest_service",
 "ports": [{"containerPort": 8080}],
 }]
 }
}
```
容器的`image`是 Docker 映像名称。`containerPort`从 REST 服务容器中公开该端口，这样我们就可以在 Pod 的 IP 上连接到服务。默认情况下，正如您从[第 1 章](01.html)*到 Docker* 的介绍中所记得的那样，`image`中定义的入口点是将要运行的内容。
意识到豆荚的生命是脆弱的是非常重要的。因为 Pods 被视为无状态的、独立的单位，如果其中一个不健康或者只是被更新的版本所取代，Kubernetes 大师不会怜悯它——它只是杀死它并处置它。
事实上，Pods 有一个严格定义的生命周期。以下列表描述了 Pod 生命的各个阶段:
*   `pending`:这个阶段意味着 Pod 已经被 Kubernetes 系统接受，但是一个或多个 Docker 容器映像还没有创建。Pods 可以在这个阶段停留一段时间，例如，如果映像需要从互联网上下载。
*   `running`:Pod 已经被放到一个节点上，并且 Pod 的所有 Docker 容器都已经被创建。
*   `succeeded`:Pod 中的所有 Docker 容器都已终止，状态为成功。
*   `failed`:Pod 中的所有 Docker 容器都已终止，但至少有一个容器以故障状态终止或被系统终止。
*   `unknown`:这通常表示与 Pod 主机的通信有问题；由于某种原因，无法检索 Pod 的状态。
当一个豆荚被拖垮时，不仅仅是因为它失败了。更多时候，如果我们的应用需要处理增加的负载，我们需要运行更多的 Pods。另一方面，如果负载减少或者根本没有负载，运行大量的 Pods 就没有意义了——我们可以处理掉它们。当然，我们可以手动启动和停止 Pods，但自动化总是更好。这就引出了复制集的概念。
# 复制集
复制集是通过使用复制来扩展应用时使用的概念。Kubernetes 复制对什么有用？通常，您会出于几个原因想要复制您的容器(实际上是您的应用)，包括:
*   **扩展**:当负载增加并且对于现有实例的数量变得太重时，Kubernetes 使您能够轻松地扩展您的应用，根据需要创建额外的实例。
*   **负载均衡**:我们可以轻松地将流量分配给不同的实例，防止单个实例或节点过载。由于 Kubernetes 的架构，负载平衡开箱即用，非常方便。
*   **可靠性和容错**:通过拥有一个应用的多个版本，如果一个或多个出现故障，您可以防止出现问题。如果系统替换任何失败的容器，这一点尤其正确。
复制适用于许多用例，包括基于微服务的应用，其中多个独立的小型服务提供非常具体的功能，或者基于任何组件都可能随时发生故障的理论的云原生应用。复制是实现它们的完美解决方案，因为多个实例自然适合该体系结构。
副本集确保在任何给定时间运行指定数量的 Pod 克隆(称为副本)。如果有太多，他们将被关闭。如果需要更多，例如他们中的一些人因为错误或崩溃而死亡，或者可能有更高的负载，一些更多的 Pods 将被复活。复制集由部署使用。让我们看看什么是部署。
# 部署
部署负责创建和更新应用的实例。创建部署后，Kubernetes 主节点会将应用实例调度到集群中的各个节点上。部署是更高层次的抽象；它在进行 Pod 编排、创建、删除和更新时管理复制集。部署为 Pods 和复制集提供声明性更新。该部署允许轻松更新副本集，并能够回滚到以前的部署。
您只需指定需要的副本数量和要在每个 Pod 中运行的容器，部署控制器就会加速它们。YAML 文件中的示例部署清单定义如下所示:
```
apiVersion: 1.0
kind: Deployment
metadata:
 name: rest_service-deployment
spec:
 replicas: 3
 template:
 metadata:
 labels:
 app: rest_service
 spec:
 containers:
 - name: rest_service
 image: rest_service
 ports:
 - containerPort: 8080
```
在前面的例子中，部署控制器将创建一个包含三个运行我们的 Java REST 服务的 Pods 的复制集。
部署是一种控制结构，负责吊舱的上升或下降。部署通过创建或关闭副本来处理一个或一组 Pod 的状态。部署还管理对 Pods 的更新。部署是一个更高的抽象，它创建复制集资源。副本设置监视 Pods，并确保始终运行正确数量的副本。当您想要更新 Pod 时，您需要修改部署清单。此修改将创建一个新的复制集，该复制集将被放大，而以前的复制集将被缩小，不提供应用的停机部署。
部署的主要目的是进行滚动更新和回滚。滚动更新是以串行、逐个的方式将应用更新到较新版本的过程。通过一次更新一个实例，您可以保持应用正常运行。如果您只是同时更新所有实例，您的应用很可能会出现宕机。此外，执行滚动更新允许您在过程中捕获错误，以便您可以在影响所有用户之前回滚。
部署还允许我们轻松回滚。要进行回滚，我们只需设置要回滚到的版本。Kubernetes 将放大相应的复制集，缩小当前的复制集，这将导致回滚到我们服务的指定版本。事实上，我们将在[第 8 章](08.html)*中大量使用部署，使用带有 Java 的 Kubernetes】，向集群推出我们服务的更新。*
复制是 Kubernetes 的一大特色。如你所见，豆荚的生命是微妙而短暂的。因为 Pods 和它们的克隆体总是来来去去，我们需要一些永久的和有形的东西，一些将永远存在的东西，这样我们的应用的用户(或者其他 Pods)就可以发现和调用。这就引出了 Kubernetes 服务的概念。现在让我们关注他们。
# 服务
Kubernetes 服务将一个或多个 Pods 分组到一个内部或外部进程中，该进程需要长时间运行并可从外部访问，例如我们的 Java REST API 端点或数据库主机。这就是我们给 Pods 贴的标签变得非常重要的地方；服务通过寻找特定的标签来找到要分组的 Pods。我们使用标签选择器来选择带有特定标签的 Pods，并将服务或复制集应用于它们。其他应用可以通过 Kubernetes 服务发现找到我们的服务。
服务是 Kubernetes 的抽象，它为一个或多个 Pods 提供网络连接。虽然(正如您在关于 Docker 网络的一章中所记得的)，默认情况下，Docker 使用主机专用网络，但是容器只有在它们位于同一台主机上时才能与其他容器通信。在 Kubernetes 中，集群 Pods 可以与其他 Pods 通信，无论它们降落在哪个主机上。这是可能的，因为服务。每个服务都有自己的 IP 地址和端口，在服务的生命周期内保持不变。服务具有集成的负载平衡器，可将网络流量分配给所有 Pods。虽然 Pod 的生命可能是脆弱的，因为它们会根据您的应用需求而加速或减速，但服务是一个更恒定的概念。每个 Pod 都有自己的 IP 地址，但是当它死亡时，另一个 Pod 被赋予生命，IP 地址可能会有所不同。这可能会成为一个问题——如果一组 Pods 向 Kubernetes 集群中的其他 Pods 提供功能，一个 Pods 可能会失去对另一个 Pods 的 IP 地址的跟踪。服务，通过拥有一个终身分配的 IP 地址，解决了这个问题。服务抽象实现了解耦。假设我们的 Java REST 服务运行在 Spring Boot 应用之上。我们需要一种方法将 HTTP 请求，如`GET`或`POST`，从互联网路由到我们的 Docker 容器。我们将通过设置一个 Kubernetes 服务来实现这一点，该服务使用负载平衡器将来自公共 IP 地址的请求路由到其中一个容器。我们将把带有 REST 服务的容器组合成一个 Pod，并命名它，比如说，我们的小 REST 服务。然后，我们将定义一个 Kubernetes 服务，它将为我们的小 REST 服务箱中的任何容器提供港口`8080`服务。Kubernetes 然后将使用负载平衡器在指定的容器之间划分流量。让我们总结一下 Kubernetes 的服务特性:
*   服务是持久的和永久的
*   他们提供发现
*   它们提供负载平衡
*   它们暴露了一个稳定的网络 IP 地址
*   他们发现 Pods 可以通过标签的使用进行分组
我们已经说过，有一个内置的服务发现机制。Kubernetes 支持两种查找服务的主要模式:环境变量和 DNS。服务发现是找出如何连接到服务的过程。Kubernetes 包含一个用于此目的的内置 DNS 服务器:kube-dns。
# cube-dns
Kubernetes 提供了一个 DNS 集群插件，每次集群启动时都会自动启动。DNS 服务本身作为集群服务运行——它的 SkyDNS——是一个分布式服务，用于通告和发现建立在`etcd`之上的服务(您将在本章后面了解 etcd 是什么)。它利用域名系统查询来发现可用的服务。它支持正向查找(A 记录)、服务查找(SRV 记录)和反向 IP 地址查找(PTR 记录)。实际上，服务是 Kubernetes 分配 DNS 名称的唯一对象类型；Kubernetes 生成一个内部 DNS 条目，解析为服务的 IP 地址。服务以`service-name.namespace-name.svc.cluster.local`的形式被分配一个域名系统记录。这将解析为服务的群集 IP。例如，对于名为`my-rest-service`的服务，DNS 插件将确保该服务可通过`my-rest-service.default.svc.cluster.local`主机名用于集群中的其他 Pods(和其他服务)。基于域名系统的服务发现提供了一种灵活且通用的方式来连接整个集群中的服务。
Note that when using the `hostNetwork=true` option, Kubernetes will use the host's DNS servers and will not use the cluster's DNS server.
在我们的 Kubernetes 之旅中，还有一个概念会不时出现——命名空间。让我们看看它是干什么用的。
# 命名空间
名称空间在 Kubernetes 中充当分组机制。Pods、卷、复制集和服务可以在一个名称空间内轻松协作，但是该名称空间提供了与集群其他部分的隔离。这种隔离的可能用例是什么？名称空间允许您在同一个集群中管理不同的环境。例如，您可以在同一计算机群集中拥有不同的测试和试运行环境。
这可能会节省基础设施中的一些资源，但也可能是危险的；如果没有名称空间，推出新版本的软件来测试环境是有风险的，让预发布版本在同一个集群上运行。通过使名称空间可用，您可以在同一个集群中的不同环境上操作，而不用担心影响其他环境。
因为 Kubernetes 使用`default`命名空间，所以使用命名空间是可选的，但建议使用。