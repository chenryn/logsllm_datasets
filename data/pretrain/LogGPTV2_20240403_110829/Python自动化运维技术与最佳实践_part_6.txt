sy8,exit ()
def readfile (filename) :
文件读取分员函数
tEy:
text=fileHandle.read (1 split1ines ()
读取后以行进行分隔
fleHandle.close ()
return text
except IoError as error:
print (*Read file Error:′+str(error) )
sys,exit ()
if texfilel==** or textfile2=*";
print *Usage: simple3.py filenamel filename2*
sys.exit ()
text1_lines = readmle (textrilel)
调用xeadfile 通数。获取分员后的字符事
text2_1ines = readfile (textflle2)
d = difnib.BtnlDiff()
创建HtmlDiff（）类对象
print d.make_file (text1_lines, text2_lines)
通过make_file方法输出HTML格式的比对结果
运行如下代码：
从图2-3中可以看出nginx.conf.v1与nginx.conf.v2配置文件存在的差异。
票2.1节示例参考官网文档http:/docs.python.org/2/ibrary/diffib.html。
---
## Page 42
第2章业务服务监控详解21
/sgi.rg//bo
magiae
ks
 45
2.2文件与自录差异对比方法
当我们进行代码审计或校验备份结果时，往往需要检查原始与目标目录的文件一致性，
Python的标准库已经自带了满足此需求的模块filecmp。filecmp可以实现文件、目录、遍历
子目录的差异对比功能。比如报告中输出目标目录比原始多出的文件或子目录，即使文件同
名也会判断是否为同一个文件（内容级对比）等，Python2.3或更高版本默认自带filecmp模
块，无需额外安装，下面进行详细介绍。
2.2.1模块常用方法说明
filecmp提供了三个操作方法，分别为cmp（单文件对比）、cmpfiles（多文件对比）、
dircmp（目录对比），下面逐一进行介绍：
口单文件对比，采用filecmp.cmp(fl,f2[, shallow])方法，比较文件名为f1和f2的文件，
相同返回True，不相同返回False，shallow默认为True，意思是只根据os.statO方法
返回的文件基本信息进行对比，比如最后访问时间、修改时间、状态改变时间等，会
---
## Page 43
22第一部分基础篇
忽略文件内容的对比。当shallow为False时，则os.statO与文件内容同时进行校验。
示例：比较单文件的差异。
(/duoat/s/auou/- *11/dge9/eeg/awou/) duo duoag e/8/amou/。 *T3/duo/sa/auou/) duodmoat>>filecmp,cmpfiles (#/home/test/filecmp/dir1*, */home/test/filecmp/diz2*, [*f1*,*f2*,
‘f3*,′f4*,*f5*])
([*f1′, *f2'],[′f3′],[*f4*, *f5′])
口目录对比，通过dircmp(a,b[，ignore[，hide]）类创建一个目录比较对象，其中a和b是
参加比较的目录名。ignore代表文件名忽略的列表，并默认为[RCS，"CVS，tags]；
hide代表隐藏的列表，默认为[os.curdir，os.pardir]。dircmp类可以获得目录比较的详
细信息，如只有在a目录中包括的文件、a与b都存在的子目录、匹配的文件等，同
时支持递归。
dircmp提供了三个输出报告的方法：
口reportO.比较当前指定目录中的内容；
口report_partial_closureO，比较当前指定目录及第一级子目录中的内容；
---
## Page 44
第2章业务服务监控详解23
口report_ful_closureO.递归比较所有指定目录的内容。
为输出更加详细的比较结果，dircmp类还提供了以下属性：
lef，左目录，如类定义中的a；
right，右目录，如类定义中的 b；
lef_list，左目录中的文件及目录列表；
口right_list，右目录中的文件及目录列表；
口common，两边目录共同存在的文件或目录；
口lef_only，只在左目录中的文件或目录；
口right_only，只在右目录中的文件或目录；
 common_dirs，两边目录都存在的子目录；
口common_files，两边目录都存在的子文件；
口common_funny，两边目录都存在的子目录（不同目录类型或os.statO记录的错误）；
 same_iles，匹配相同的文件；
口diff_files，不匹配的文件；
口funny_files，两边目录中都存在，但无法比较的文件；
口subdirs，将common_dirs目录名映射到新的dircmp对象，格式为字典类型。
示例：对比dir1与dir2的目录差异。
通过调用dircmpO方法实现目录差异对比功能，同时输出目录对比对象所有属性信息。
[ /home/test/filecmp/ simple1.py ]
a=*/hone/test/filecmp/dix1*
lnport filecmp
b=*/hone/test/filecmp/dir2*
定义左目录
定义右目录
dirobj=filecmp,dircmp (a,b, [*test -py′1)
目录比较，忽略test，py 文件
输出对比结果数据报表，详细说明请参考il1ocmp类方法及属性信惠
dirobj -report ()
dirobj -report_partial_closure ()
dirobj -report_ful1_elosure ()
print *zight_1ist:*+ str (dirob)-right_1lst)
print *left_1ist:*+ str (dirobj -left_1ist)
print *common:"+ str (dirobj .comnon)
print “left_only:*+ str (dirobj .left_only)
print *right_only:*+ str (dirobj -zight_only)
print *common_dirs:*+ stz (dirobj -comhon_d1rs)
print *common_files:*+ str (dirobj -common_iles)
print *common_funny:*+ str(dirob] common_funny)
print *same_ile;*+ str (dirobj ,same_lles)
print *diff_fles:*+ str (dirobj -diff_fles)
print *funny_files:*+ str (dirobj .funny_files)
---
## Page 45
24第一部分基础篇
为方便理解，通过tree命令输出两个目录的树结构，如图2-4所示。
-f1
a2
14
est.py
f3
est.py
图2-4通过tree命令输出的两个目录
运行前面的代码并输出，结果如下：
 python sinplel,py
diff /home/test/filecmp/dir1 /home/test/filecmp/dir2
Only in /hone/test/6lecnp/dir1 : [*f4′}
Only in /hone/test/filecnp/diz2 : [′aa*, 'f5′]
Identical fles : ['f1′,
Differing files : [*f3′]
*f2*]
Comnon subdirectories : ['a′)
---report_partial_closure-
d1ft /home/test/filecmp/dir1 /home/test/filecmp/dir2
Only in /home/test/flecmp/dir1 : [*f4′]
Only in /home/test/filecmp/dir2 : [*aa*, *f5*]
Identical files : ['f1',
*r2*1
Differing files : [*f3′]
Comnon subdirectories : ['a*]
diff /home/test/filecmp/dir1/a /home/test/tilecmp/dir2/a
Identical files 1 [*al']
Comnon subdirectories : [*b′]
diff /home/test/filecmp/dir1 /home/test/filecmp/diz2
-"=report_full_closure-.
Only in /home/test/filecmp/dir1 : ['f4′]
[s.*,e,1 :zxp/duoo/so/oou/ ut &uo
Identical files : [*f1′,
*f2'1
Differing fles : [*3′]
Connon subdirectories : ['a′]
diff /home/test/filecmp/dir1/a /home/test/filecmp/dir2/a
Identical files : [*al′]
Common subdirectories : ['b′]
diff /home/test/filecmp/dir1/a/b /home/test/filecmp/dix2/a/b
Identical files :[*b1',*b2′, *b3′]
---
## Page 46
第2章业务服务监控详解25
right_list:[′a′,*aa′,'f1*,*f2', 'f3',*f5′]
comnon:[′a′, *f1*,*f2', 'f3]
left_only: [*f4′]
rlght_only:[*aa*, *s*]
[3,*,23.'.3.]:eetu"uouuoo
[,e,]:satp uouuo0
comnon_funny: [1
sane_file: [*f1*,
*'f2′]
diff_files: [*f3′]
funny_files: []
2.2.2实践：校验源与备份目录差异
有时候我们无法确认备份目录与源目录文件是否保持一致，包括源目录中的新文件或
目录、更新文件或目录有无成功同步，定期进行校验，没有成功则希望有针对性地进行补备
份。本示例使用了filecmp模块的lef_only、diff_files方法递归获取源目录的更新项，再通过
shutil.copyfile、os.makedirs方法对更新项进行复制，最终保持一致状态。详细源码如下：
[ /home/test/filecmp/simple2.py 1
1/usr/bin/env python
ieport flecmp
inport os, sys
inport shuti1
inport re
holderlist=[1
def conparene (dir1, dir2) :
逆归获取更新项函数
dircomp=filecnp . dircmp (dir1, dir2)
only_in_one=dircomp.left_only
源日录新文件或日录
diff_in_one=dircomp,diff_files
不匹配文件，源目录文件已发生变化
dirpath=os ,path,abspath (dir1)
定文源目录绝对路径
更新文件书或目录进加到 holderli.st
[holder1ist -appendfos -path,abspath (os.path. join (dic1, x)1) foz × 1n only_in_one]
[holderlist,append (o8,path.abspath (os -path.Join (dirl,x))) for x in diff_in_one]
if len (dirconp,common_dirs) > 0:
判断是否存在相同子目录，以便递归
for iten in dircomp.common_dirs1
通归子目录
compareme (os -path.abspath (os-path.join (dir1, item) ) , \
os-path,abspath (os-path.join (dir2, iten)))
return bolderlist
def main() :
if len(sys.argv) > 2:
要求输入源目录与备份目录
dir1=sys-argv[1]
dir2=sys.argv[2]
else:
print *Usage: *, 8y8,argv[0], *datadir backupdir*
sys.exit()
---
## Page 47
26第一部分基础简
source_files=compareme (dir1, dir2)
对比源目录与备份目示
dir1=os.path abspath (dir1)
if not dix2.endsvith(*/*): dir2=dir2+*/*
备份目录路径加*/”特
dir2=os,path abspath (d1r2)
createdir_bool=False
for item in source_fles1
destination_dir=re,sub (dir1, dir2, item)
遍历返阿的整异文件成目录清单
将源目录差异路经港单对应替换成
备份目录
destination_files , append (dest.ination_dir)
if os.path.isdir (item) :
如果差异路径为目录且不存在，则在备份目录中创建
If not os.path.exists (destination_dir) :
08,makedirs (destination_dir)
createdir_bool=True
再次调用compareme函数标记
if createdir_bool:
重新调用compa.reme 函数。重新遍历新创建日录的内容
destination_files= []
source_files=[1
source_files=conpareme (dir1, diz2)
foriteminsource_5les：获取源目承差异路径单，对应替换成备分目录
destination_dir=re,sub (dirl, dir2, item)
destination_files-append (destination_dir)
print *update Item:*
print source_files
输出更新项列表清单
copy_pair=zip (souroe_files, destinatlon_iles)
将源日录与备份日录文件请单拆分成元组
for item in copy_pair1
if os-path.1sfle (1ten[0}):
判断是否为文件，是则进行复制操作
shuti1.copyfile (iten[0], item[1])
1,ute.  oueu” JT
main ()
更新源目录dir1中的f4、code/f3文件后，运行程序结果如下：
# python simple2-py /home/test/filecmp/dir1 /home/test/filecmp/dir2
[*/home/test/filecmp/dir1/f4*, '/home/test/flecmp/dir1/code/f3*]
update item:
 python simple2-py /home/test/filecmp/dir1 /home/test/fllecmp/d1r2
update iten:
[】
再次运行时已经没有更新项了
 2.2.2 节示 例参考 http:/linuxfreelancer.com/how-do-you-compare-two-folders-and-copy
the-difference-to-a-third-folder.
---
## Page 48
2.3发送电子邮件模块smtplib
电子邮件是最流行的互联网应用之一。在系统管理领域，我们常常使用邮件来发送告警
信息、业务质量报表等，方便运维人员第一时间了解业务的服务状态。本节通过Python的
smtplib模块来实现邮件的发送功能，模拟一个smtp客户端，通过与smtp服务器交互来实
现邮件发送的功能，这可以理解成Foxmail的发邮件功能，在第一次使用之前我们需要配置
smtp主机地址、邮箱账号及密码等信息，Python2.3或更高版本默认自带smtplib模块，无需
额外安装。下面详细进行介绍。
2.3.1smtplib模块的常用类与方法
SMTP 类定义: smtplib.SMTP([host[, port[, local_hostname[, timeout]]), 作 为 SMTP 9
构造函数，功能是与smtp服务器建立连接，在连接成功后，就可以向服务器发送相关请求，
比如登录、校验、发送、退出等。host参数为远程smtp主机地址，比如smtp.163.com；port
为连接端口，默认为25；local_hostname 的作用是在本地主机的FQDN（完整的域名）发送
HELO/EHLO（标识用户身份）指令，timeout为连接或尝试在多少秒超时。SMTP类具有如
下方法：
SMTP.connect([host[，port]])方法，连接远程 smtp 主机方法，host 为远程主机地址，
port为远程主机smtp端口，默认25，也可以直接使用host:port形式来表示，例如：