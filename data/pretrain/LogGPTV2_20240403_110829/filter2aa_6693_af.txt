.B int\c
\& 数值, 不需要 参数, 或 指定 两个 参数.
.TP
.B \-Wreturn\-type
如果 函数 定义了 返回类型, 而 默认 类型 是 \c
.B int\c
\& 型, 编译器 就 发出 警告. 同时 警告 那些 不带 返回值 的 \c
.B return\c
\& 语句, 如果 他们 所属的 函数 并非 \c
.B void\c
\& 类型.
.TP
.B \-Wunused
如果 某个 局部变量 除了 声明 就 没再 使用, 或者 声明了 静态函数 但是 没有
定义, 或者 某条 语句 的 运算结果 显然 没有 使用, 编译器 就 发出 警告.
.TP
.B \-Wswitch
如果 某条 \c
.B switch\c
\& 语句 的 参数 属于 枚举类型, 但是 没有 对应的 \c
.B case\c
\& 语句 使用 枚举元素, 编译器 就 发出 警告. ( \c
.B default\c
\& 语句 的 出现 能够 防止 这个 警告.) 超出 枚举 范围 的 \c
.B case\c
\& 语句 同样 会 导致 这个 警告.
.TP
.B \-Wcomment
如果 注释起始序列 `\|\c
.B /\(**\c
\&\|' 出现在 注释 中, 编译器 就 发出 警告.
.TP
.B \-Wtrigraphs
警告 任何 出现的 trigraph (假设 允许 使用 他们).
.TP
.B \-Wformat
检查 对 \c
.B printf\c
\& 和 \c
.B scanf\c
\& 等 函数 的 调用, 确认 各个 参数 类型 和 格式串 中的 一致.
.TP
.B \-Wchar\-subscripts
警告 类型 是
.BR char 
的 数组 下标. 这是 常见 错误, 程序员 经常 忘记 在 某些 机器 上 char 有 符号.
.TP
.B \-Wuninitialized
在 初始化 之前 就 使用 自动变量.
.Sp
这些警告 只可能 做 优化编译 时 出现, 因为 他们 需要 数据流信息, 只有
做 优化 的 时候 才 估算 数据流信息. 如果 不指定 `\|\c
.B \-O\c
\&\|' 选项, 就不会 出现 这些警告.
.Sp
这些警告 仅针对 等候 分配 寄存器 的 变量. 因此 不会 发生在 声明为 \c
.B volatile\c
\& 的 变量 上面, 不会 发生在 已经 取得 地址 的 变量, 或 长度 不等于 
1, 2, 4, 8 字节 的 变量. 同样 也不会 发生在 结构, 联合 或 数组 上面, 
即使 他们 在 寄存器 中.
.Sp
注意, 如果 某个变量 只 计算了 一个 从未使用过 的 值, 这里 可能 不会 警告.
因为 在 显示 警告 之前, 这样 的 计算 已经 被 数据流分析 删除 了.
.Sp
这些警告 作为 可选项 是因为 GNU CC 还没有 智能到 判别 所有的 情况, 知道
有些 看上去 错误 的 代码 其实 是 正确的. 下面 是 一个 这样的 例子:
.Sp
.nf
{
  int x;
  switch (y)
    {
    case 1: x = 1;
      break;
    case 2: x = 4;
      break;
    case 3: x = 5;
    }
  foo (x);
}
.Sp
.fi
如果 \c
.B y\c
\& 始终是 1, 2 或 3, 那么 \c
.B x\c
\& 总会被 初始化, 但是 GNU CC 不知道 这一点. 下面 是 另一个 普遍案例:
.Sp
.nf
{
  int save_y;
  if (change_y) save_y = y, y = new_y;
  .\|.\|.
  if (change_y) y = save_y;
}
.Sp
.fi
这里 没有 错误, 因为 只有 设置了 \c
.B save_y\c
\& 才 使用 他.
.Sp
把 所有 不返回 的 函数 定义为
.B volatile\c
\& 可以 避免 某些 似是而非的 警告.
.TP
.B \-Wparentheses
在 某些 情况 下 如果 忽略了 括号, 编译器 就 发出 警告.
.TP
.B \-Wtemplate\-debugging
当 在 C++ 程序 中 使用 template 的 时候, 如果 调试 (debugging) 没有 完全 生效,
编译器 就 发出 警告. (仅用于 C++).
.TP
.B \-Wall
结合 所有 上述 的 `\|\c
.B \-W\c
\&\|' 选项. 通常 我们 建议 避免 这些 被警告的 用法，我们 相信,
恰当 结合 宏 的 使用 能够 轻易 避免 这些 用法。
.PP
剩下的 `\|\c
.B \-W.\|.\|.\c
\&\|' 选项 不包括 在 `\|\c
.B \-Wall\c
\&\|' 中, 因为 我们 认为 在 必要情况 下, 这些 被 编译器 警告 的 程序结构, 
可以 合理的 用在 "干净的" 程序 中.
.TP
.B \-Wtraditional
如果 某些 程序结构 在 传统 C 中 的 表现 和 ANSI C 不同, 编译器 就 发出 警告.
.TP
\ \ \ \(bu
宏参 出现在 宏体 的 字符串常量 内部. 传统 C 会 替换 宏参, 而 ANSI C 
则 视其为 常量 的 一部分.
.TP
\ \ \ \(bu
某个函数 在 块(block) 中 声明为 外部, 但在 块 结束后 才 调用.
.TP
\ \ \ \(bu
.B switch\c
\& 语句 的 操作数 类型 是 \c
.B long\c
\&.
.PP
.TP
.B \-Wshadow
一旦 某个 局部变量 屏蔽了 另一个 局部变量, 编译器 就 发出 警告.
.TP
.BI "\-Wid\-clash\-" "len"
一旦 两个 确定的 标识符 具有 相同的 前 \c
.I len
个 字符, 编译器 就 发出 警告. 他 可以 协助 你 开发 一些 将要在
某些 过时的, 危害大脑的 编译器 上 编译 的 程序.
.TP
.B \-Wpointer\-arith
任何 语句 如果 依赖于 函数类型 的 大小(size) 或者 \c
.B void\c
\& 类型 的 大小, 编译器 就 发出 警告.  GNU C 为了 便于 计算 \c
.B void \(**\c
\& 指针 和 函数指针, 就把 这些 类型 的 大小 定义 为 1.
.TP
.B \-Wcast\-qual
一旦 某个 指针 强制类型转换 以便 移除 类型修饰符 时, 编译器 就 发出 警告.
例如, 如果 把 \c
.B const char \(**\c
\& 强制转换 为 普通的 \c
.B char \(**\c
\& 时, 警告 就会 出现.
.TP
.B \-Wcast\-align
一旦 某个 指针类型 强制转换 时, 导致 目标 所需的 地址对齐 (alignment)  
增加, 编译器 就 发出 警告.
例如, 某些 机器 上 只能 在 2 或 4 字节 边界 上 访问 整数, 如果 在 
这种 机型 上 把 \c
.B char \(**\c
\& 强制转换 成 \c
.B int \(**\c
\& 类型, 编译器 就 发出 警告.
.TP
.B \-Wwrite\-strings
规定 字符串常量 的 类型 是 \c
.B const char[\c
.I length\c
.B ]\c
\&, 因此, 把 这样的 地址 复制给 non-\c
.B const\c
\& \c
.B char \(**
指针 将 产生 警告.  
这些 警告 能够 帮助 你 在 编译期间 发现 企图 写入 字符串常量 的 代码,
但是 你 必须 非常 仔细 的 在 声明 和 原形 中 使用 \c
.B const\c
\&, 否则 他们 只能 带来 麻烦; 所以 我们 没有 让 `\|\c
.B \-Wall\c
\&\|' 提供 这些 警告.
.TP
.B \-Wconversion
如果 某函数原形 导致 的 类型转换 和 无函数原形 时的 类型转换 不同,
编译器 就 发出 警告.
这里 包括 定点数 和 浮点数 的 互相转换, 改变 定点数 的 宽度 或 符号,
除非 他们 和 缺省声明 (default promotion) 相同.
.TP
.B \-Waggregate\-return
如果 定义 或 调用 了 返回 结构 或 联合 的 函数, 编译器 就 发出 警告.
(从 语言角度 你 可以 返回 一个 数组, 然而 同样 会 导致 警告.)
.TP
.B \-Wstrict\-prototypes
如果 函数 的 声明 或 定义 没有 指出 参数类型, 编译器 就 发出 警告.
(如果 函数 的 前向引用说明 指出了 参数类型, 则 允许 后面 使用 旧式风格
的 函数定义, 而 不会产生 警告.)
.TP
.B \-Wmissing\-prototypes
如果 没有 预先 声明 函数原形 就 定义了 全局函数, 编译器 就 发出 警告.
即使 函数定义 自身 提供了 函数原形 也会 产生 这个 警告. 他 的 目的
是 检查 没有 在 头文件 中 声明 的 全局函数.
.TP
.B \-Wmissing\-declarations
如果 没有 预先 声明 就 定义了 全局函数, 编译器 就 发出 警告.
即使 函数定义 自身 提供了 函数原形 也会 产生 这个 警告. 这个选项 的 目的
是 检查 没有 在 头文件 中 声明 的 全局函数.
.TP
.B \-Wredundant-decls
如果 在 同一个 可见域 某定义 多次 声明, 编译器 就 发出 警告, 即使 这些
重复声明 有效 并且 毫无差别.
.TP
.B \-Wnested-externs
如果 某 \c
.B extern\c
\& 声明 出现在 函数 内部, 编译器 就 发出 警告.
.TP
.B \-Wenum\-clash
对于 不同 枚举类型 之间 的 转换 发出 警告 (仅适用于 C++).
.TP
.B \-Wlong\-long
如果 使用了
.B long long \c
类型 就 发出 警告. 该 警告 是 缺省项. 使用 `\|\c
.B \-Wno\-long\-long\c
\&\|' 选项 能够 防止 这个 警告.  `\|\c
.B \-Wlong\-long\c
\&\|' 和 `\|\c
.B \-Wno\-long\-long\c
\&\|' 仅 在 `\|\c
.B \-pedantic\c
\&\|' 之下 才起作用.
.TP
.B \-Woverloaded\-virtual
(仅适用于 C++.) 在继承类中, 虚函数 的 定义 必须 匹配 虚函数 在 基类
中 声明 的 类型特征 (type signature).
当 继承类 声明了 某个函数, 它 可能 是个 错误的 尝试 企图 定义一个 虚函数,
使用 这个 选项 能够 产生 警告:
就是说, 当 某个函数 和 基类 中的 虚函数 同名, 但是 类型特征 不符合 基类
的 任何 虚函数, 编译器 将发出 警告.
.TP
.B \-Winline
如果 某函数 不能 内嵌(inline), 无论 是 声明为 inline 或者是 指定了
.B \-finline\-functions
选项, 编译器 都将 发出 警告.
.TP
.B \-Werror
视 警告 为 错误; 出现 任何 警告 即 放弃 编译.
.SH "调试选项 (DEBUGGING OPTION)"
GNU CC 拥有 许多 特别选项, 既可以 调试 用户的 程序, 也可以 对 GCC 排错:
.TP
.B \-g
以 操作系统 的 本地格式 (stabs, COFF, XCOFF, 或 DWARF).
产生 调试信息. GDB 能够 使用 这些 调试信息.
.Sp
在 大多数 使用 stabs 格式 的 系统 上, `\|\c
.B \-g\c
\&\|' 选项 启动 只有 GDB 才使用 的 额外调试信息; 这些信息 使 GDB 调试
效果 更好, 但是 有可能 导致 其他 调试器 崩溃, 或 拒绝 读入 程序.
如果 你 确定 要 控制 是否 生成 额外的 信息, 使用`\|\c
.B \-gstabs+\c
\&\|', `\|\c
.B \-gstabs\c
\&\|',
`\|\c
.B \-gxcoff+\c
\&\|', `\|\c
.B \-gxcoff\c
\&\|', `\|\c
.B \-gdwarf+\c
\&\|', 或 `\|\c
.B \-gdwarf\c
\&\|'
(见下文).
.Sp
和 大多数 C 编译器 不同, GNU CC 允许 结合使用 `\|\c
.B \-g\c
\&\|' 和 `\|\c
.B \-O\c
\&\|' 选项. 优化的 代码 偶尔 制造 一些 惊异的 结果: 某些 声明过的 变量
根本 不存在; 控制流程 直接 跑到 没有 预料到的 地方; 某些语句 因为 计算结果
是 常量 或 已经确定 而 没有 执行; 某些语句 在 其他 地方 执行, 因为 他们
被移到 循环 外面 了.
.Sp
然而 它 证明了 调试 优化的输出 是 可能的. 对 可能 含有 错误 的 程序
使用 优化器 是 合理的.
.PP
如果 GNU CC 支持 输出 多种 调试信息, 下面的 选项 则 非常有用.
.TP
.B \-ggdb
以 本地格式 (如果支持) 输出 调试信息, 尽可能 包括 GDB 扩展.
.TP
.B \-gstabs
以 stabs 格式 (如果支持) 输出 调试信息, 不包括 GDB 扩展.
这是 大多数 BSD 系统 上 DBX 使用 的 格式.
.TP