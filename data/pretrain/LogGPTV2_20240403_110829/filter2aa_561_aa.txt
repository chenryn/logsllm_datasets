quickbreach@defcon26:~#  ./smbetray.py  --help
Backdooring & Breaking Signatures
William Martin (@QuickBreach)
> whoami
• William Martin
• OSCP
• Penetration Tester
• Supervisor at RSM US LLP in 
Charlotte, NC
• Second time presenting at 
DEFCON
• Twitter: @QuickBreach
> Who is this talk for?
• Red teamers looking to learn more about Active 
Directory, SMB security, and pick up new attacks against 
insecure SMB connections
• Blue teamers that want to stop the red teamers from 
using what they learn
• Anyone curious about how SMB signing actually works
> Overview
• Brief recap on what SMB is
• NTLMv2 Relay attack
• Investigate what SMB signing actually is
• How else we can attack SMB?
• Introduce SMBetray
• Demo & tool release
• Countermeasures
• Credits
Recap on SMB
SMB server = 
Any PC receiving the SMB connection, 
not necessarily a Windows Server OS. Eg,
a Windows 7 box can be the SMB server, 
as every Windows OS runs an SMB server
by default
SMB client = 
The PC/Server connecting to the SMB 
server 
> Terminology clarification
> Recap on SMB
(Source: https://docs.microsoft.com/en-us/windows/desktop/fileio/microsoft-smb-protocol-and-cifs-protocol-
overview)
> Recap on SMB
SMB listens on TCP port 445 and allows for file sharing and 
management over the network, with features including:
• Mapping network drives
• Reading & writing files to shares
• Authentication support
• Providing access to MSRPC named pipes
> What is SMB?
> Recap on SMB
Attackers love it for:
• Pass-the-hash
• System enumeration (authenticated, or null sessions) 
• Spidering shares & hunting for sensitive data, such as for the 
cpassword key in SYSVOL xml files
> Current attacks against SMB
> Current attacks against SMB
> Current attacks against SMB
> Current attacks against SMB
> Current attacks against SMB
> Current attacks against SMB
> Current attacks against SMB
> Current attacks against SMB
What is SMB signing?
> What is SMB signing?
> What is SMB signing?
> What is SMB signing?
> What is SMB signing?
> What is SMB signing?
What I knew in the beginning:
• Protects the integrity of SMB messages between the client 
and server, preventing any tampering
• Is required by default on all domain controllers
• Occurs after authenticated session setup
• Stops my favorite attack
> What is SMB signing?
Lessons were learned – core concepts:
At the end of the authentication phase in an authenticated 
session, the client and server will possess the same 16-byte 
SessionBaseKey.
Depending on the dialect, the client and server may use this 
SessionBaseKey to generate subsequent keys each purposed for 
specific actions such as signing and encrypting SMB packets. Only 
those in possession of the keys can generate the appropriate 
signatures.
> Sample signature
> What is SMB signing?
So, where does this SessionBaseKey come from – especially 
if we can manipulate the entire authentication process?
Answer: The creation of the SessionBaseKey depends on 
the authentication mechanism used.
> A walk through the NTLMv2 process
> NTLMSSP Negotiate
“Hello, I want to authenticate using NTLM”
•
No username/password/domain information in message
•
“Negotiate Key Exchange” is usually set. This means after the client authenticates 
and generates a SessionBaseKey, the client will generate a new random one, RC4 
encrypt it with the old one, and send it to the server to use going forward.
> NTLMSSP Challenge
“Cool, hash your password & 
other data with this 
challenge”
Contains:
•
Server challenge
•
Server information
> NTLMSSP AUTH  (Challenge-Response)
“Sure, here’s everything”
Contains:
•
Client username
•
Client domain
•
Client challenge
•
NtProofString
•
ResponseServerVersion
•
HiResponseServerVersion
•
A Timestamp (aTime)
•
Encrypted new 
SessionBaseKey 
(Probably)
Great…so how is the SessionBaseKey generated?
> First – A Brief HMAC/CMAC Refresher
HMACs are keyed-hash message authentication code algorithms. Only those 
in possession of the private key, and the data, can generate the appropriate 
hash. These are used to verify the integrity of a message. CMACs are similar 
to HMACs with the exception that they’re based on cipher block algorithms 
like AES rather than hashing algorithms like MD5.
Message 
= “Pineapple belongs on pizza”
SecretKey
= “IwillDieOnThisHill”
HMAC_MD5(SecretKey, Message) = “34c5092a819022f7b98e51d3906ee7df”
> SessionBaseKey Generation
Let’s generate the SessionBaseKey from an NTLMv2 authentication 
process
Step #1:
NTResponse = HMAC_MD5(User’s NT Hash, username + domain)
> SessionBaseKey Generation
Step #2:
basicData
= 
serverChallenge + responseServerVersion +
hiResponseServerVersion +  '\x00' * 6 + 
aTime + clientChallenge + '\x00' * 4 +
serverInfo + '\x00' * 4
NtProofString
= HMAC_MD5(NTResponse, basicData)
> SessionBaseKey Generation
Step #3 (Last Step):
SessionBaseKey
= HMAC_MD5(NTResponse, NtProofString)
> SessionBaseKey Generation
Put together:
NTResponse
= HMAC_MD5(User’s NT Hash, username + domain)
basicData
= 
serverChallenge + responseServerVersion +
hiResponseServerVersion +  '\x00' * 6 + 
aTime + clientChallenge + '\x00' * 4 +
serverInfo + '\x00' * 4
NtProofString
= HMAC_MD5(NTResponse, basicData)
SessionBaseKey
= HMAC_MD5(NTResponse, NtProofString)
So what information do we NOT have?
> SessionBaseKey Generation
Put together:
NTResponse
= HMAC_MD5(User’s NT Hash, username + domain)
basicData
= 
serverChallenge + responseServerVersion +
hiResponseServerVersion +  '\x00' * 6 + 
aTime + clientChallenge + '\x00' * 4 +
serverInfo + '\x00' * 4
NtProofString
= HMAC_MD5(NTResponse, basicData)
SessionBaseKey
= HMAC_MD5(NTResponse, NtProofString)
NTLM key logic:
User’s password -> Users’ NT Hash -> (Combined with 
challenge & auth data)  -> SMB SessionBaseKey
If the user’s password is known, SMB signatures can be forged
> SessionBaseKey Generation
> SessionBaseKey Generation
If “Negotiate Key Exchange” is set, then the client generates an entirely 
random new SessionBaseKey, RC4 encrypts it with the original 
SessionBaseKey, and sends it in the NTLMSS_AUTH request in the 
“SessionKey” field. 
NTLM key logic with “Negotiate Key Exchange” :
User’s password -> Users’ NT Hash -> (Combined with 
challenge & auth data)  -> SMB SessionBaseKey -> SMB 
Exchanged SessionKey (becomes new SessionBaseKey)
> SessionBaseKey Generation
To fill in the blanks from the NTLMv2 relay attack presented 
earlier
> The (now obvious) missing piece of the puzzle
The DC takes in the challenge and the challenge response 
to generate the SessionBaseKey, and then sends it to the 
server through a required secure & encrypted channel. 
This secure channel is established by the NETLOGON 
service on a domain connected PC at startup, and the 
underlying authentication protecting it is the password for 
the machine account itself.
> The (now obvious) missing piece of the puzzle
But wait, what about Kerberos?
> What about Kerberos?
The SessionBaseKey is the ServiceSessionKey in the TGS 
response. 
Key logic:
User’s plaintext password -> Kerberos Session Key -> Service 
Session Key (inside TGS)
> What about Kerberos?
If mutual authentication is used, the server will reply with a 
new SessionBaseKey which is encrypted with the previous 
one.
Key logic:
User’s plaintext password -> Kerberos Session Key -> Service 
Session Key (inside TGS) -> New Service Session Key (inside 
AP_REP)
> Signing the packet
Once we have the SessionBaseKey, we can sign the packet
SMB 1.0
Signature 
= HMAC_MD5(SessionBaseKey, SMBPacket)
SMB 2.0.2 &  2.1.0
Only the first 16 bytes of the hash make up the signature
Signature 
= HMAC_SHA256(SessionBaseKey, SMBPacket)
SMB 3.0.0, 3.0.2 & 3.1.1
A special signing key is derived from the SessionBaseKey
Signature 
= CMAC_AES128(SigningKey, SMBPacket)
> Attacking SMB
So, what happens when we know the SessionBaseKey, or 
when signing is not required at all per the default settings?
HTTP before HTTPS
> Attacking SMB
> Attacking SMB
-
If encryption is not used
• Steal copies of files passed over the wire in cleartext
-
If signing is not used
• Replace every file with an identical LNK that executes our code
• Swap out the contents of any legitimate file with our own 
malicious one of the same file-type
• Inject fake files into directory listings (for social engineering)
-
If signing is used, and the attacker knows the key
• All above + backdoor any logon scripts & SYSVOL data we can
(Defaults) SMB1:
Client supports it, server doesn’t. 
Unless they both support it, or one 
requires it, no signing will be used.
(Defaults) SMB2/3:
Server & client support it, but don’t 
require it. Unless someone requires 
it, signing is not used.
> Attacking SMB
(Defaults) SMB1:
No encryption support
(Defaults) SMB2/3:
Encryption was introduced in SMB3