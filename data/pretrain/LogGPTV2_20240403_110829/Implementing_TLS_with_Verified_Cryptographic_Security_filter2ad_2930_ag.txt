that the adversary power is not unduly constrained by typing,
we give another, simply-typed API that exports only functions
on basic types such as int and bytes and we typecheck its im-
plementation against the main typed API. Cryptographically,
this amounts to proving game-based security for adversaries
A with oracle access to the TLS API. We apply Theorem 5
to restricted TLS users (DSb, UTLS · A) deﬁned as follows:
• DSb is a ﬁxed, typed implementation of DataStream that
deﬁnes data as an abstract type with oracle functions for
creating data from ranges rg and bytes v within that
range, and extracting bytes from data, and that, for Safe
indexes, passes to TLS either v (when b = 0) or a max-
sized array of zero bytes (when b = 1).
• U T LS is a ﬁxed, typed implementation of our basic TLS
API IUTLS that maintains a private table from integers to
current states of TLS connections and that exports the
same functionalities as the TLS API with base types.
• A ranges over all p.p.t. programs such that we have
ITCP, IUTLS (cid:2) A; although we still formally require that
A be typed, this does not restrict its power, inasmuch as
IUTLS only exports functions on plain data types.
We arrive at a usual cryptographic game (on a large amount
of code) in which (1) A needs to distinguish between real
encryptions and encryptions of zero; and (2) A attempts to
break application integrity.
Theorem 6 (Game-Based Security): Let T be TLS-secure.
For all p.p.t. adversaries A with access to the oracles deﬁned
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:52:05 UTC from IEEE Xplore.  Restrictions apply. 
by the challenger UTLS and TCP, we have (1) DS0 · TCP · T ·
UTLS·A ≈ DS1·TCP·T·UTLS·A and (2) DS0·TCP·T·UTLS·A
is asymptotically safe.
D. Veriﬁed TLS Applications
Ad hoc client authentication Our ﬁrst sample applica-
tion illustrates a typical pattern: an anonymous client and a
server establish a TLS connection, then proceed with client-
authentication at the application level, relying on shared secret
bytes, which may represent a username–password pair, a
token, or a secure cookie.
Our sample application security is that, whenever the client
sends the authenticator and whenever the server accepts an
authenticator as valid, (1) the client and server share a secure
session; and (2) the adversary gains no information about
the authenticator (hence the client identity). For simplicity, in
contrast with our general theorem, we use a strong ciphersuite,
a single honest server certiﬁcate, and a secure token repository
with tokens that ﬁt in a single fragment, so we can specify our
application code as:
val client: url → username → token → c:Connection option
val server : unit → u:username ∗ c:Connection
{ ∃token. Valid(u,token) ∧ Login(CI(c).id in,u,token) } option
To model (1), the client assumes the event Login(CI(c).
id out,username, token) before sending out his token, and the
post-condition of server guarantees that the user is registered
and authenticated. Application-level authentication holds only
inasmuch as the adversary does not guess the authenticator,
with a probability that depends on its min-entropy. We capture
this assumption by coding an ideal token functionality that
guarantees that honestly generated and coerced (guessed)
authenticators never collide.
type token
val create : unit → tk:token{Honest(tk)}
val register : u:string → tk:token{Honest(tk)} → unit{Valid(u,tk)}
val verify : u:string → tk:token → b:bool{b ⇒ Valid(u,tk)}
val coerce : bytes → tk:token{not(Honest(tk))}
We deﬁne a DataStream module that sends tokens (within
a given length range) as data at the beginning of the stream:
(;id,emptyStream,(minTkLen,maxTkLen)) data =
tk:token{∃u. Valid(u,tk) ⇒ Login(id,u,tk)}
so that type abstraction ensures both (1) and (2). F7 shows
that our DataStream and application code modules are well
typed, using the TLS API and the ideal token interface. This
sufﬁces to show that our application is secure, except for the
(small) probability that an adversary guesses the authenticator,
and the negligible probability that an adversary can break
our TLS idealization. Using our length hiding TLS API for
authenticators enables us to get this simple guarantee; without
it trafﬁc analysis might help guessing attacks, for example, if
the token were a compressed HTTP session cookie [24].
Secure RPC Our second application is an RPC library that
relies on TLS to exchange multiple requests and responses
after mutual authentication. By typechecking our code and
applying Theorem 5, we easily obtain secrecy, authenticity,
and correlation between requests and responses. The full
paper presents an RPC DataStream module that deﬁnes data
concretely as bytes, with a reﬁnement that says that it must
be a fragment of either a serialized request or a serialized
response (to handle fragmentation if their size exceeds 16K).
By type abstraction, TLS guarantees that RPC will handle and
deliver message fragments in accordance with the DataStream
interface: messages will be kept secret and will arrive in the
right order with strong authentication.
VII. LIMITATIONS AND FUTURE WORK
We implemented, tested, and cryptographically veriﬁed a
reference implementation of TLS. By writing a few hundred
lines of F# and F7 code on top of our API, we also conﬁrmed
that applications can rely on our theorems to prove end-to-end
security while ignoring the low-level details of the RFCs.
Still, our implementation and security theorems come with
caveats. We do not yet support some algorithms and cipher-
suites (e.g. ECDH, AES-GCM) and we still have to optimize
our code for performance (see §II-D). Its security also relies
on a large, unveriﬁed TCB: the F7 typechecker, the F# com-
piler, the .NET runtime, and the core cryptographic libraries.
Besides, we do not formally account for side channels attacks
based e.g. on timing, even though our implementation tries
to mitigate them; proving the absence of such attacks would
require speciﬁc tools (see e.g. [2]).
Our veriﬁcation method enabled us to develop modular
security proofs for a 5KLOC program, based on precise
cryptographic assumptions on core primitives. Most proofs
are by automatic typechecking, but writing type annotations
requires attention and care, and the resulting interfaces amount
to 2.5KLOC. Some proofs also rely on usage restrictions (e.g.
Deﬁnition 4) that are not established by typing, but could be
veriﬁed using more advanced afﬁne type systems [54]. We
focus on the standard model of cryptography, resulting in
rather strong assumptions for the Handshake, similar to those
of Jager et al. [33] for the DHE key exchange. Relaxing these
assumptions and developing concrete security bounds [8] for
our implementation is left as important future work.
REFERENCES
[1] T. Acar, M. Belenkiy, M. Bellare, and D. Cash. Cryptographic
agility and its relation to circular encryption. In EUROCRYPT,
pages 403–422, 2010.
[2] A. Askarov, D. Zhang, and A. C. Myers. Predictive black-box
mitigation of timing channels. In CCS, pages 297–307, 2010.
JavaSPI: A
framework for security protocol implementation. International
J. of Secure Software Engineering, 2:34–48, 2011.
[3] M. Avalle, A. Pironti, D. Pozza, and R. Sisto.
[4] M. Backes and B. Pﬁtzmann.
Symmetric Encryption in a
Simulatable Dolev-Yao Style Cryptographic Library. In CSFW,
pages 204–218, 2004.
[5] M. Backes, C. Hritcu, M. Maffei, and T. Tarrach. Type-checking
implementations of protocols based on zero-knowledge proofs.
In FCS, 2009.
[6] M. Backes, M. Maffei, and D. Unruh. Computational sound
veriﬁcation of source code. In CCS, 2010.
[7] M. Backes, C. Hrit¸cu, and M. Maffei. Union and intersection
types for secure protocol implementations. In TOSCA’11, pages
1–28, 2012.
458
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:52:05 UTC from IEEE Xplore.  Restrictions apply. 
[8] M. Bellare, A. Desai, E. Jokipii, and P. Rogaway. A concrete
In FOCS, pages
security treatment of symmetric encryption.
394–403, 1997.
[9] J. Bengtson, K. Bhargavan, C. Fournet, A. D. Gordon, and
S. Maffeis. Reﬁnement types for secure implementations. ACM
TOPLAS, 33(2):8, 2011.
[10] K. Bhargavan, C. Fournet, and A. D. Gordon. Modular veri-
ﬁcation of security protocol code by typing. In POPL, pages
445–456, 2010.
[11] K. Bhargavan, C. Fournet, R. Corin, and E. Z˘alinescu. Veriﬁed
Cryptographic Implementations for TLS. ACM TISSEC, 15(1):
1–32, 2012.
[12] B. Blanchet. An efﬁcient cryptographic protocol veriﬁer based
on Prolog rules. In CSFW, pages 82–96, 2001.
[13] B. Blanchet. A computationally sound mechanized prover for
security protocols. In IEEE S&P, pages 140–154, 2006.
[14] D. Bleichenbacher. Chosen ciphertext attacks against protocols
based on RSA encryption standard PKCS #1. In CRYPTO’98,
pages 1–12, 1998.
[15] B. Brumley, M. Barbosa, D. Page, and F. Vercauteren. Practical
realisation and elimination of an ECC-related software bug
attack. In CT-RSA, 2011.
[16] D. Brumley and D. Boneh. Remote timing attacks are practical.
In USENIX Security, pages 1–14, 2003.
[17] B. Canvel, A. P. Hiltgen, S. Vaudenay, and M. Vuagnoux.
Password interception in a ssl/tls channel. In CRYPTO, pages
583–599, 2003.
[18] S. Chaki and A. Datta. ASPIER: An automated framework
for verifying security protocol implementations. In CSF 2009,
pages 172–185, 2009.
[19] L. de Moura and N. Bjørner. Z3: An efﬁcient SMT solver. In
TACAS, volume 4963, 2008.
[20] G. D´ıaz, F. Curtero, V. Valero, and F. Pelayo. Automatic
veriﬁcation of the TLS handshake protocol. In SAC, pages 789–
794, 2004.
[21] T. Dierks and C. Allen. The TLS Protocol Version 1.0. RFC
2246, 1999.
[22] T. Dierks and E. Rescorla. The Transport Layer Security (TLS)
Protocol Version 1.1. RFC 4346, 2006.
[23] T. Dierks and E. Rescorla. The Transport Layer Security (TLS)
Protocol Version 1.2. RFC 5246, 2008.
[24] T. Duong and J. Rizzo. The CRIME attack. 2012. Ekoparty.
[25] K. P. Dyer, S. E. Coull, T. Ristenpart, and T. Shrimpton. Peek-
a-boo, I still see you: Why efﬁcient trafﬁc analysis countermea-
sures fail. In IEEE S&P, pages 332–346, 2012.
[26] P.-A. Fouque, D. Pointcheval, and S. Zimmer. Hmac is a
randomness extractor and applications to tls. In ASIACCS, pages
21–32, 2008.
[27] C. Fournet, M. Kohlweiss, and P.-Y. Strub. Modular code-based
cryptographic veriﬁcation. In ACM CCS, pages 341–350, 2011.
[28] A. Freier, P. Karlton, and P. Kocher. The secure sockets layer
(SSL) protocol version 3.0 – 1996. RFC 6101, 2011.
[29] S. Gajek, M. Manulis, O. Pereira, A.-R. Sadeghi, and
J. Schwenk. Universally composable security analysis of TLS.
In ProvSec, pages 313–327, 2008.
[30] M. Georgiev, S. Iyengar, S. Jana, R. Anubhai, D. Boneh, and
V. Shmatikov. The most dangerous code in the world: validating
SSL certiﬁcates in non-browser software. In CCS, pages 38–49,
2012.
[31] S. Goldwasser, S. Micali, and R. L. Rivest. A digital signature
scheme secure against adaptive chosen-message attacks. SIAM
J. Comput., 17(2):281–308, 1988.
[32] C. He, M. Sundararajan, A. Datta, A. Derek, and J. C. Mitchell.
In
A modular correctness proof of IEEE 802.11i and TLS.
CCS’05, pages 2–15, 2005.
[33] T. Jager, F. Kohlar, S. Sch¨age, and J. Schwenk. On the security
of TLS-DHE in the standard model. In CRYPTO, pages 273–
293, 2012.
[34] J. Jonsson and J. B. S. Kaliski. On the security of RSA
encryption in TLS. In CRYPTO, pages 127–142, 2002.
[35] J. J¨urjens. Security analysis of crypto-based java programs using
automated theorem provers. In ASE’06, pages 167–176, 2006.
[36] A. Kamil and G. Lowe. Analysing TLS in the strand spaces
model. Technical report, Oxford University Computing Labo-
ratory, 2008.
[37] J. Kelsey. Compression and information leakage of plaintext.
In Fast Software Encryption, pages 95–102. IACR, 2002.
[38] V. Klima, O. Pokorny, and T. Rosa. Attacking RSA-based
sessions in SSL/TLS. In CHES, pages 426–440, 2003.
[39] H. Krawczyk. The order of encryption and authentication
In
for protecting communications (or: How secure is SSL?).
CRYPTO’01, 2001.
[40] R. K¨usters and M. Tuengerthal. Universally composable sym-
metric encryption. In CSF, 2009.
[41] R. K¨usters, T. Truderung, and J. Graf. A framework for the
cryptographic veriﬁcation of java-like programs. In CSF, pages
198–212, 2012.
[42] A. Langley. Unfortunate current practices for HTTP over
http://www.ietf.org/mail-archive/web/tls/current/
TLS, 2011.
msg07281.html.
[43] N. M. Langley, A. and B. Moeller. Transport Layer Security
(TLS) False Start. Internet Draft, 2010.
[44] J. Lawall, B. Laurie, R. R. Hansen, N. Palix, and G. Muller.
Finding error handling bugs in OpenSSL using coccinelle. In
EDCC’10, 2010.
[45] N. Mavrogiannopoulos and S. Josefsson. GnuTLS documenta-
tion on record padding, 2011. http://www.gnutls.org/manual.
[46] N. Mavrogiannopoulos, F. Vercauteren, V. Velichkov, and
In
B. Preneel. A cross-protocol attack on the tls protocol.
CCS, pages 62–72, 2012.
[47] B. Moeller. Security of CBC ciphersuites in SSL/TLS: Problems
and countermeasures. http://www.openssl.org/∼bodo/tls-cbc.txt,
2004.
[48] P. Morrissey, N. Smart, and B. Warinschi. A modular security
In ASIACRYPT’08,
analysis of the TLS handshake protocol.
pages 55–73, 2008.
[49] K. Ogata and K. Futatsugi. Equational approach to formal
analysis of TLS. In ICSCS, pages 795–804, 2005.
[50] K. G. Paterson, T. Ristenpart, and T. Shrimpton. Tag size does
In
matter: Attacks and proofs for the TLS record protocol.
ASIACRYPT 2011, pages 372–389, 2011.
[51] L. C. Paulson. Inductive analysis of the Internet protocol TLS.
ACM TISSEC, 2(3):332–351, 1999.
[52] M. Ray. Authentication gap in TLS renegotiation.
//extendedsubset.com/Renegotiating TLS.pdf, 2009.
http:
[53] E. Rescorla, M. Ray, S. Dispensa, and N. Oskov. TLS renego-
tiation indication extension. RFC 5746, 2010.
[54] N. Swamy, J. Chen, C. Fournet, P.-Y. Strub, K. Bhargavan, and
J. Yang. Secure distributed programming with value-dependent
types. In ICFP, pages 266–278, 2011.
[55] S. Turner and T. Polk. Prohibiting secure sockets layer (SSL)
version 2.0. RFC 6176, 2011.
[56] S. Vaudenay.
Security ﬂaws induced by CBC padding -
applications to SSL, IPSEC, WTLS ... In L. R. Knudsen, editor,
EUROCRYPT, pages 534–546, 2002.
[57] A. K. L. Yau, K. G. Paterson, and C. J. Mitchell. Padding oracle
attacks on CBC-mode encryption with secret and random IVs.
In FSE, pages 299–319, 2005.
459
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:52:05 UTC from IEEE Xplore.  Restrictions apply.