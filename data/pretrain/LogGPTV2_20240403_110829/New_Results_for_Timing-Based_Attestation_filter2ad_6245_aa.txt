title:New Results for Timing-Based Attestation
author:Xeno Kovah and
Corey Kallenberg and
Chris Weathers and
Amy Herzog and
Matthew Albin and
John Butterworth
2012 IEEE Symposium on Security and Privacy
New Results for Timing-Based Attestation
Xeno Kovah, Corey Kallenberg, Chris Weathers, Amy Herzog, Matthew Albin, John Butterworth
The MITRE Corporation
{xkovah,ckallenberg,cweathers,aherzog,malbin,butterworth}@mitre.org
Bedford, MA, USA
Abstract—In this paper we present a comprehensive timing-
based attestation system suitable for typical enterprise use, and
evidence of that system’s performance. This system, similar to
Pioneer [20] but built with relaxed assumptions, successfully
detects attacks on code integrity over 10 links of an enterprise
network, despite an average of just 1.7% time overhead for
the attacker. We also present the ﬁrst implementation and
evaluation of a Trusted Platform Module (TPM) hardware
timing-based attestation protocol. We describe the design and
results of a set of experiments showing the effectiveness of our
timing-based system, thereby providing further evidence of the
practicality of timing-based attestation in real-world settings.
While system measurement itself is a worthwhile goal, and
timing-based attestation systems can provide measurements
that are equally as trustworthy as hardware-based attestation
systems, we feel that Time Of Check, Time Of Use (TOCTOU)
attacks have not received appropriate attention in the liter-
ature. To address this topic, we present the three conditions
required to execute such an attack, and how past attacks and
defenses relate to these conditions.
Keywords-remote attestation;
software-based attestation;
timing-based attestation; trusted platform module; TOCTOU
attack
I. INTRODUCTION
While a plethora of commercial security products are
available today, the vast majority do not make use of existing
academic work in the area of remote attestation. Over-
whelmingly, security tools protect themselves with access
control mechanisms such as ﬁle permissions, sandboxes,
user-kernel separation, or OS-hypervisor separation. The
ineffectiveness of this approach can be seen in the decades-
long history of successful techniques for bypassing access
control mechanisms.
Mechanisms are needed that can ensure security software
continues to behave correctly even in the presence of an
equally-privileged attacker. Previous work on timing-based
attestation [20] [17] [16] attempted to address this need,
but failed to provide experimental data for typical enterprise
systems. In this paper, we present a comprehensive view
of a timing-based attestation system designed for typical
enterprise use and experimental evidence of its performance.
implemented within our Checkmate tool
suite, offers a number of contributions to the state of
the art. First, we have produced a timing-based attesta-
tion implementation that functions within typical enterprise
environments. Second, we have shown its performance is
The system,
similar to previous research [20] despite a number of relaxed
assumptions and additional checks: Our implementation
does not rely on open-source network drivers; it functions
in the presence of Address Space Layout Randomization
(ASLR)-like kernel module loading within Windows XP, and
real ASLR in Windows 7; it functions well even when the
timing messages are sent over 10 network links (6 switches,
3 routers); it includes an implementation of a self-check
timing measurement based on the TPM’s tickstamp counter.
This system is described in Section III.
While preparing this capability for deployment, we per-
formed numerous experiments on 31 homogenous enterprise
hosts to which we had temporary access; in Section IV
we discuss the experimental set-up and results. The data
show the effectiveness of timing-based attestation for code
integrity within an enterprise setting.
Throughout
the paper, we discuss possible attacks on
timing-based attestation and how we addressed these attacks
within our system. We also discuss the often misunderstood
problem of Time Of Check, Time Of Use (TOCTOU)
attacks against code integrity in Section V and how remote
attestation systems must adapt their designs to defend against
them.
Based on our experimental data and our early deployment
experience, we believe that timing-based attestation systems
like Checkmate can provide strong code integrity guarantees
today, and strong control ﬂow integrity guarantees with more
work.
II. RELATED WORK
This work was undertaken speciﬁcally to determine
whether timing-based attestation systems built for general
purpose PCs, like Pioneer [20] and PioneerNG [17], behaved
as described when adapted to a different environment. Pio-
neer runs on x86-64 Linux and is implemented by inserting
the attestation code into an open source network driver ker-
nel module. PioneerNG runs in System Management Mode
(SMM), is implemented as 16 bit x86 assembly, and attests
to a veriﬁer via USB rather than via the network. In contrast
our code is implemented in 32 bit Windows XP making use
of the existing network driver abstraction layer. We did not
implement DMA protection as PioneerNG did because we
consider that to be one of many TOCTOU attacks requiring
more generic countermeasures, as described in Section V.
© 2012, Xeno Kovah. Under license to IEEE.
DOI 10.1109/SP.2012.45
239
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:48:23 UTC from IEEE Xplore.  Restrictions apply. 
Software designed to provide timing-based attestation has
also been applied to embedded systems beginning with
SWATT [21] and then expanding into areas such as verifying
peripherals [10] [9], wireless sensors [18] [23] [4] and
SCADA systems [22].
An interesting recent result which straddles the boundary
of general purpose PCs and embedded systems is Jakobsson
& Johansson’s work [7] which shows the practicality of
software-based attestation on mobile phones. However, we
believe that their core technique of memory printing, when
applied to the increased RAM on desktops, would lead to
computation times of tens of seconds. We do not consider it
acceptable to lock a user’s system for this amount of time,
and we strive to keep attestation runtime in the 100ms range,
so that it is not noticeable to users.
For attacks on timing-based attestation systems, Castelluc-
cia et al. [3] provide an example control ﬂow based attack
against a software-based attestation system using return
oriented programming. They also outlined a compression
attack which is not applicable to this work, because they
admitted it is detectable by a change in timing. Wurster et
al. [27] & Shankar et al. [24] have also suggested a type of
attack which exhibits TOCTOU characteristics in the way
that it changes virtual to physical mappings for the duration
of measurement. Only during measurement
the attacker
points a virtual memory address to clean physical memory,
and when not measured the virtual address points to attacker-
modiﬁed physical memory. Yan et al. [28] also recently
proposed an attack which exploits pipeline parallelism, and
suggested a countermeasure of introducing backwards data
dependency within checksum loops. This is an easy condi-
tion to achieve, and will be added to our implementation.
They also proposed a TOCTOU attack predicated on control
ﬂow integrity violation. They use an idle CPU to change a
function pointer (such as the return address) just in time
after the self-check function has run, but before secondary
measured code has run.
Figure 1. NDIS Architecture diagram from [12]
A. Networking
CMA is implemented as a kernel module for 32 bit Win-
dows XP/7 (with a 64 bit Windows 7 port underway). This
paper describes primarily the Windows XP implementation.
It is built as a Network Driver Interface Speciﬁcation (NDIS)
version 5.1 Intermediate Driver (IM), sometimes called a
network ﬁlter driver. In Figure 1, “NDIS miniport” drivers
are the device-speciﬁc drivers written by NIC manufacturers.
The box labeled “Lan Protocols” are “NDIS protocol”
drivers implementing generic higher level drivers such as
tcpip.sys (which implements TCP/IP) or npf.sys (which
implements WinPcap.) Normally a miniport driver talks to
a protocol driver through the NDIS abstraction layer. How-
ever, an NDIS intermediate driver exposes a protocol driver
interface to miniports, and a miniport interface to protocol
drivers. In this way it can receive incoming and outbound
network trafﬁc while residing at the lowest possible layer
that is not hardware-speciﬁc. Showing that the system works
while not being NIC-speciﬁc like past work is an important
improvement to the system’s practicality.
III. SELF-CHECKING IMPLEMENTATION
B. Self-check assembly
Our attestation system is part of a project called Check-
mate, which performs both attestation and Windows kernel
integrity measurement. To distinguish the two components,
we will refer to the attestation system as CMA and the
measurement system as CMM. The primary purpose of this
paper is to focus on CMA, as CMM is described in a sep-
arate paper under submission. Our current implementation
does not deal with attackers residing in system management
mode or utilizing hardware support for virtualization. That
is ongoing research, but some existing work [17] already
indicates that virtualization-based malware will cause timing
anomalies that will be detected ”for free” by timing-based
attestation.
Because of limited space, we can only give an abbreviated
background description and readers must have familiarity
with [20] [17]. As with past work in timing-based attestation,
our system is composed of two parts. A server/veriﬁer that
requests attestations that are a function of a server-supplied
nonce, and a client that responds to requests by computing
a self-checksum and sending it back to the server. The
server/client use the existing Pioneer Protocol [20]. The
veriﬁer must be capable of re-computing the checksum as it
believes the client would have. If a naive attacker modiﬁes
any of the memory checked by CMA, this will cause the
checksum to be incorrect, and the veriﬁer will know that
the system is untrustworthy. A sophisticated attacker can
alter the checksum computation to yield a correct checksum
240
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:48:23 UTC from IEEE Xplore.  Restrictions apply. 
even in the presence of modiﬁed CMA memory, however
the construction of the self-checksum function is designed
speciﬁcally so that a forged checksum takes more time
to compute than a genuine one. This is because the self-
checksum is composed of millions of reads over its own
code. If an attacker is forced to put
in even one extra
instruction to create the forgery, this will lead to millions of
instructions of overhead to compute the forged checksum.
The client code and the number of loops are tuned so that the
veriﬁer can detect over the network the delay in responding
to the attestation request.
Like past work our self-check function incorporates multi-
ple pieces of system state in order to attest to code integrity.
ENT RET, or the return address that would return to
the grandparent, GRANDPARENT RET. Whichever
value is selected is mixed with the PRN, so that the
attacker cannot hardcode the expected value.
The incorporation of the parent and grandparent saved re-
turn instructions is in part in response to the ROP TOCTOU
attack presented in [3]. But it is also in response to having
had an external group attempt to attack our self-check, and
having one person independently come up with a simpler
form of this attack. It is because this independent assess-
ment leveraged multiple TOCTOU attacks that we realized
the real-world importance of taking them into account in
designing measurement systems.
1) EIP DST - The inclusion of the instruction pointer
helps to indicate that the memory being executed ex-
ists in the expected memory range. This is the address
of the start of the next block that will be pseudo-
randomly called to. This cannot be used alone because
an attacker could hardcode, rather than calculate, the
value. It is therefore included only because it is readily
available and costs only a single add or xor instruction.
2) EIP SRC - This is like EIP DST, but instead indicates
the location where the calling block resides. Unlike
EIP DST, an attacker cannot precompute or hardcode
this value, since it will differ according to the pseudo-
random jump order.
3) DP - The data pointer helps to indicate that
the
memory being read exists in the expected memory
range.
4) *DP - This is the 4 bytes of data read from memory by
dereferencing DP. It is included so that the checksum
is reading its own memory, so that the ﬁnal checksum
will change if there are any code integrity attacks on
its own memory.
5) PRN - We include the pseudo-random number which
is derived from the nonce sent by the server in the
Pioneer Protocol, and updated in each block. We use
the same PRNG as Pioneer.
6) EFLAGS - Included so that any changes to ﬂags
such as the trap ﬂag, interrupt ﬂag, or the various
conditional code ﬂags, will have to be ﬁxed by the
attacker.
7) DR7 - We place the lower 16 bits of the nonce into the
upper 16 bits of the DR7 hardware debug breakpoint
control register. The lower 16 bits of DR7 are set to
0, which disables all hardware breakpoints. This is
read in each block to help ensure hardware breakpoints
are still disabled, or makes the attacker incur ﬁxing
overhead in each block if he is still using hardware
breakpoints.
8) PARENT RET & GRANDPARENT RET - We
pseudo-randomly include either the return address
on the stack that would return to the parent, PAR-
Table I
HIGH LEVEL: SELF-CHECK FUNCTION
Prolog
Block Variant 0
Block Variant 1
Block Variant 2
Block Variant 3
Block Variant 4
Small Block Variant 0
Minichecksum Fragment 0
Small Block Variant 1
Minichecksum Fragment 1
Small Block Variant 2
Minichecksum Fragment 2
epilog
As shown in Table I our code has eight blocks variants.
The ﬁgure is not to scale, as the ﬁrst ﬁve “large” blocks
have nine sub-blocks, and the last
three “small” blocks
have seven sub-blocks. The two extra sub-blocks in the
large blocks were only added to the increase the block
size. This allowed the size of a small block plus the size
of a minichecksum fragment to equal the size of a large
block, for easier block start address calculation. The use
of a minichecksum is borrowed from PioneerNG. It allows
the primary checksum, as implemented by the blocks, to
read memory only in the memory range of the self-check
function itself, which includes the minichecksum fragments.
This inter-mixed construction optimizes cache behavior. The
minichecksum fragments together implement code that can
read from arbitrary memory ranges outside of the veriﬁcation
function and incorporate data into the checksum. In this
way the blocks check the minichecksum, the minichecksum
checks the CMM Windows memory integrity measurement
code, and the CMM code checks elsewhere on the system
for evidence of compromise. An attacker wishing to hide
from the CMM code must modify the earlier stages of the
dynamic chain of trust, ﬁnally modifying the calculation
of the blocks, which leads to a time overhead in their
241
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:48:23 UTC from IEEE Xplore.  Restrictions apply. 
calculation.
Our checksum is treated as an array of six 4-byte values
and is stored on the stack below all local variables. Like
Pioneer, we store part of the checksum below esp so that
any interrupts that occur while computing the result will
destroy part of the checksum. The checksum is organized so
that checksum[0] is at [esp-8], a gap for storing temporary
values on the stack is located at [esp-4], and checksum[1]-[5]
are stored at [esp] through [esp+16] respectively. Although
we only use a 32 bit nonce/PRN, there is still value in
having the checksum be 192 bits. An attacker wanting to
precompute all possible responses to all possible nonces
would require 232 * 6 * 4 (96G) bytes of memory for this
table. While this could reasonably be stored on a single
server system, or across multiple client systems, it would not
ﬁt on a single typical client system. Additionally, because
Windows loads our module at different addresses across
reboots, as described in Section III-C, the attacker would
have to recompute this table every time the system was
rebooted. Given that TOCTOU and proxy attacks are more
effective currently, as described in Sections IV-H and V, we
believe this is a reasonable design optimization for the time
being, as updating a larger PRN requires more instructions.
The overall structure of a block is shown in Table II, with
the details of one variant of each of the sub-blocks being
shown in Table III. Typically the only difference between
*VAR0 and *VAR1 versions of code is a reordering of add
and xor instructions in order to maintain the strongly ordered
checksum property. As described in Pioneer, this construct