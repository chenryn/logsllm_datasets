ours but they showed how to support conjunction of statements
cheaper.
noted as
be denoted uniquely as w =
2 PRELIMINARIES
2.1 Notation
We use κ and ρ to denote the computational and statistical security
parameters, respectively. We use x ← S to denote that sampling x
uniformly at random from a finite set S. For n ∈ N, we denote by [n]
a set {1, . . . , n}. For a, b ∈ Z with a ≤ b, we write [a, b] = {a, . . . , b}.
We use bold lower-case letters like x for column vectors, and denote
by xi the i-th component of vector x where x1 is the first entry.
For an extension field Fpr of a finite field Fp, where p ≥ 2 is
a prime or a power of a prime and r ≥ 1 is an integer, we fix
some monic, irreducible polynomial f (X) of degree r and write
Fpr (cid:27) Fp[X]/f (X). Therefore, every field element w ∈ Fpr can
h∈[r] wh · X h−1 with wh ∈ Fp for
all h ∈ [r]. We could view the elements over Fpr equivalently as the
vectors in (Fp)r . When we write arithmetic expressions involving
both elements of Fp and elements of Fpr , it is understood that field
elements in Fp are viewed as the polynomials lying in Fpr that
have only constant terms.
A circuit C over Fp is defined by a set of input wires Iin, along
with a list of gates of the form (α, β, γ ,T), where α, β are the indices
of the input wires of the gate, γ is the index of the output wire of
the gate, and T ∈ {Add, Mult} is the type of the gate. If p = 2, C is
a Boolean circuit with Add = ⊕ and Mult = ∧. If p > 2 is a prime
or a power of a prime, C is an arithmetic circuit where Add/Mult
corresponds to addition/multiplication in Fp. We let t denote the
number of multiplication gates in the circuit, and also let n = |Iin|.
A set of t multivariable polynomials over Fp is denoted as { f1, . . . ,
ft}, where each polynomial has degree at most d and takes the same
n variables (x1, . . . , xn) as input. Every polynomial fi can be de-
h∈[0,d] fi ,h, where all terms in fi ,h have degree exactly h.
For a vector z = (z1, . . . , zn) ∈ Fn
p , we define fi(z) = fi(z1, . . . , zn).
Given a polynomial f over Fp, we could naturally define a poly-
nomial over Fpr by interpreting operations over Fp (i.e., additions
and multiplications) to be operations over Fpr .
2.2 MACs and Functionalities
Information-Theoretic MACs. We use information-theoretic mes-
sage authentication codes (IT-MACs) [9, 40] to authenticate values
over Fp or Fpr . Specifically, let ∆ ∈ Fpr be a global key, which is
sampled uniformly at random and known only by one party V.
A value x ∈ Fp or Fpr known by the other party P can be au-
thenticated by giving V a uniform key k ∈ Fpr and giving P
the corresponding MAC tag m = k − ∆ · x ∈ Fpr . We denote
such an authenticated value by [x]. Note that authenticated val-
ues are additively homomorphic. In particular, given the public
coefficients c1, . . . , cℓ, c ∈ Fp or Fpr , the parties can compute
i =1 ci ·xi +c,
+ c · ∆.
We extend the above notation to vectors of authenticated values
as well. In this case, [x] means that P holds x ∈ Fn
p and m ∈ Fn
pr ,
while V holds k ∈ Fn
Security model and functionalities. All our protocols are proven
in the universal composability (UC) framework [22] in the pres-
ence of a malicious, static adversary. We provide a brief overview
of the UC framework in the Appendix A. Our ZK functionality is
i =1 ci ·[xi] +c locally, where P compute y :=ℓ
, and V computes ky :=ℓ
[y] =ℓ
my :=ℓ
pr with k = m + ∆ · x.
i =1 ci · mxi
i =1 ci · kxi
Session 11B: Zero Knowledge II CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2988shown in Figure 1. As we provide the protocols for both circuits
and polynomial sets, we extend the ZK functionality accordingly.
We use the standard sVOLE functionality [17, 18] shown in
Figure 6 of Appendix A to generate authenticated values, where P
pr , and V obtains ∆ ∈ Fpr and k ∈ Fℓ
obtains x ∈ Fℓ
pr ,
such that m = k − ∆· x. This sVOLE functionality can be efficiently
realized using the recent LPN-based protocols [17, 41, 48, 49]. These
protocols have the communication complexity sublinear to the
number of resulting sVOLE correlations.
p and m ∈ Fℓ
3 TECHNICAL OVERVIEW
In this section, we provide the intuition of our constant-round ZK
protocols, and leave the full protocol description, as well as the
proofs of security, to later sections.
3.1 ZK Proof for Circuits over Any Field
In the previous section, we introduced authenticated values, which
can also be viewed as a way for the prover to commit values to
the verifier. It is a non-interactive commitment with an interactive
preprocessing phase. Given this tool, recent work [3, 25, 48] de-
signed efficient zero-knowledge proofs for circuit satisfiability with
high scalability and communication linear to the circuit size. These
works all follow the same paradigm below.
(1) The prover P first commits to all wire values in the circuit to
the verifier, which takes n + t field elements of communication
and n + t number of (s)VOLE correlations, where n is the input
size and t is the number of multiplication gates. Because the
underlying commitment is additively homomorphic, addition
gates can be processed for free.
(2) Prover P then proves that the committed values on multiplica-
tion gates are correct by executing a checking procedure with
the verifier V. This is where prior works differ. The first ap-
proach uses the (s)VOLE-based commitment as a black box so
they could potentially work with different forms of commit-
ments, while the second approach by LPZK [25] uses the fact
that IT-MACs are linear relationships.
Our ZK protocol in the gate-by-gate paradigm. Our protocol
in the circuit-based setting can be viewed as a hybrid approach
of Wolverine, which uses subfield VOLE to support any field size,
and LPZK, which crucially relies on the fact that the VOLE-based
commitments are linear relationships.
Similar to prior work, we use a linear scan on the circuit to
compute the authenticated values on all the wires in the circuit. In
particular, for each multiplication gate, the prover P has (wα , mα),
(wβ , mβ), (wγ , mγ ) ∈ Fp × Fpr ; the verifier V holds kα , kβ , kγ , ∆ ∈
Fpr such that the following four equations hold:
wγ = wα · wβ
and mi = ki − wi · ∆ for i ∈ {α, β, γ}.
If P is malicious, the first equation could potentially be incorrect
and our task is to check that this relationship holds for all multipli-
cation gates. Although the last three equations are linear equations
from the perspective of the verifier, the first equation is not linear.
The crucial observation is that it is possible to convert the non-
linear checking to a linear checking. Specifically, we observe that
for the i-th multiplication gate with wire values (wα , wβ , wγ ), if it
is computed correctly (i.e., wγ = wα · wβ ), then we have:
known to V
(cid:122)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:125)(cid:124)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:123)
(cid:124)(cid:32)(cid:32)(cid:32)(cid:32)(cid:123)(cid:122)(cid:32)(cid:32)(cid:32)(cid:32)(cid:125)
mα · mβ
known to P
denoted as A0,i
=
Bi = kα · kβ − kγ · ∆
= (mα + wα · ∆) · (mβ + wβ · ∆) − (mγ + wγ · ∆) · ∆
= mα · mβ + (wβ · mα + wα · mβ − mγ ) · ∆ + (wα · wβ − wγ ) · ∆
2
(cid:124)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:123)(cid:122)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:125)
+(wβ · mα + wα · mβ − mγ )
·
∆(cid:124)(cid:123)(cid:122)(cid:125)
known to V
global key
known to P
denoted as A1,i
·
∆(cid:124)(cid:123)(cid:122)(cid:125)
We can see that the above relationship is now linear and very
similar to the IT-MAC relationship. What’s more, we also show in
Section 4 that if the underlying wire values (i.e., wα , wβ , wγ ) are
not computed correctly, then the above relationship can hold only
with probability 2/pr : now it becomes a quadratic equation of ∆,
where there are at most two values of ∆ that satisfy the equation.
Now when we look at a circuit with t multiplication gates, we can
obtain one such relationship for each multiplication gate. Namely,
for each i ∈ [t], P has A0,i , A1,i ∈ Fpr and V has Bi ∈ Fpr such
that Bi = A0,i + A1,i · ∆. We can check all t linear relations in a
batch using a random linear combination. In particular, the verifier
samples a uniform element χ ∈ Fpr after the above values have
been defined, and then checks that the following relationship holds:

(cid:124)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:123)(cid:122)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:125)
Bi · χi
= 
(cid:124)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:123)(cid:122)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:125)
A0,i · χi
+
(cid:16)
A1,i · χi(cid:17)
(cid:124)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:123)(cid:122)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:125)
known to V
global key
i∈[t]
known to P
denoted as A0
i∈[t]
known to P
denoted as A1
i∈[t]
known to V
denoted as B
By the verifier sending just one field element (i.e., χ), we are able
to reduce checking t equations in the circuit to checking the above
single equation, that is B = A0 + A1 · ∆, where V has B and ∆,
while P has A0 and A1. This could be easily checked by using a
random linear relationship B∗ = A∗
1 ∈ Fpr
to mask field elements A0 and A1, and then opening the masked
elements. In particular, P sends U = A0 + A∗
0 and V = A1 + A∗
1 to
V, who checks that B + B∗ = U + V · ∆. Finally, this random linear
relationship over Fpr can be easily obtained by generating subfield
VOLE correlations on Fp and packing them to Fpr .
Note that the online phase of the ZK protocol where the circuit
and witness are known, can be made non-interactive by computing
χ using a random oracle to hash the transcript up to that point. In
Section 4, we provide the detailed description of our ZK protocol
for circuit satisfiability and prove that it is UC-secure. We report
the performance of the protocol in Section 6.
1 · ∆ with B∗, A∗
0 + A∗
0, A∗
3.2 Zero-Knowledge Proof for Polynomial Sets
For Boolean circuits, the above ZK protocol sends only one bit
per AND gate in the sVOLE-hybrid model and supports free-XOR.
We believe that in the gate-by-gate paradigm, the communication
cost is optimal: intuitively, each AND gate has to require some
communication when we process each gate individually.
This reminds us of the successful story of garbling, where a pro-
gression of research reached the half-gates garbling scheme [50]
proven to be optimal in the gate-by-gate paradigm. However, a
Session 11B: Zero Knowledge II CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2989lower bound is merely a way to rule out certain approaches and in
this case, the garbling lower bound implies that a better garbling
scheme either needs to use something beyond random oracle and
linear operations, or needs to go beyond the gate-by-gate para-
digm and look at more gates as a whole. Indeed, the follow-up
works [2, 37, 38] have shown that it is indeed possible to garble a
formula more efficiently. In our second protocol, we apply the same
philosophy to our ZK protocol for circuit satisfiability.
Our ZK protocol: proving inner product with smaller cost.
Recall that in the above idea when we prove a multiplication gate
with wire values (x, y, z), two parties essentially prove f (x, y, z) =
x ·y−z = 0. This could be viewed as a degree-2 polynomial on three
variables. Let’s first generalize it to a degree-2 polynomial with more
than just one multiplication. Suppose f is a degree-2 polynomial
i∈[n/2] ci · xi · xn/2+i. Two parties
hold authenticated values [w1], . . . ,[wn], and the prover wants
to prove f (w1, . . . , wn) = 0. We will follow the similar thinking
process as above. In particular, observe that
ci · ki · kn/2+i
such that f (x1, . . . , xn) = c0 +
f (k1, . . . , kn) = c0 + 
= c0 + 
(cid:16)
c0 + 
(cid:16)
c0 + 
ci · mn/2+i · wi
i∈[n/2]
i∈[n/2]
i∈[n/2]
ci · mi · mn/2+i
ci · mi · mn/2+i
=
=
i∈[n/2]
ci · (mi + wi · ∆) · (mn/2+i + wn/2+i · ∆)
2
2
+
i∈[n/2]
i∈[n/2]
+
(cid:17) · ∆
ci · mi · wn/2+i +
ci · mi · wn/2+i +
i∈[n/2]
ci · wi · wn/2+i
(cid:16) 
(cid:16) 
(cid:17)
(cid:16) 
(cid:17) · ∆ +
(cid:17)
(cid:17) · ∆ − c0 · ∆
(cid:16)
(cid:17)
c0 + 
(cid:124)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:123)(cid:122)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:125)
(cid:16) 
(cid:17)
(cid:124)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:123)(cid:122)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:125)
known to P, denoted as A0
ci · mi · wn/2+i + ci · mn/2+i · wi
i∈[n/2]
known to P, denoted as A1
ci · mn/2+i · wi
.

(cid:124)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:123)(cid:122)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:125)
The last equation is due to the fact that f (w1, . . . , wn) = c0 +
i∈[n/2] ci · wi · wn/2+i = 0. Reorganizing the above equation a bit,
we can obtain the following equation:
f (k1, . . . , kn) + c0 · ∆
known to V, denoted as B
ci · mi · mn/2+i
i∈[n/2]