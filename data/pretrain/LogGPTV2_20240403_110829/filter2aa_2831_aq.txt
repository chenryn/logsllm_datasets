require it.
Adding the UnAdvise Method
Let’s take a look at the UnAdvise() method. It is going to close
the connection made by the previous call to Advise().
// Remove the callback object
STDMETHODIMP CSimpleCallback::UnAdvise(long lCookie)
{
// Compare the cookie. Be sure this is same client
if (lCookie != m_lCookie) return E_NOINTERFACE;
// Release the clients interface
m_ICallBack->Release();
m_ICallBack = NULL;
return S_OK;
} 
 We check the cookie to ensure this is the right client. In this
example there’s not much to do if the cookie is wrong, so we
return a generic COM error. Finally, we Release the interface
pointer we’ve been saving. Remember, we did an AddRef() in
the Advise method. This will allow the client to shut down with
no outstanding connections. 
Calling the Client from the Server
Now we get to the heart of our callback interface - the callback!
All that this function calls is a method on the client (sink) inter-
face. Since we already have the pointer, this method works just
like any COM interface. The Awake method is quite simple, but
there’s nothing to prevent methods that are more complex. In
190    Chapter 12 •
Callback Interfaces 
fact, our Later() method will be used later to demonstrate a
multi-threading example.
// Callback the client immediately
STDMETHODIMP CSimpleCallback::Now( long lCode)
{
  HRESULT hr = E_FAIL;
  if (m_ICallBack != NULL)
  {
    // Call method synchronously. 
    // This will not return until
    // the client presses OK on the MessageBox.
    hr = m_ICallBack->Awake( lCode );
  }
  return hr;
}
 This isn’t a very realistic use for a callback interface. Nor-
mally, the server (source) object would execute the callback with
some important notification for its client. With a little imagina-
tion, you can come up with useful implementations of a call-
back.
Notice that the call to Awake() is synchronous. That means
the client’s call to Now() won’t complete until the server’s
Awake() callback completes. This means the client is waiting for
itself! This doesn’t solve our original problem of  waiting for the
server. Don’t worry, we will provide a usable threading solution
later with the Later() method. For now, the Now() method will
demonstrate basic concepts.
If this discussion seems a little hypothetical, it’s because we
haven’t seen the client application yet.
Note: Build the server, and don’t forget to build the Proxy/Stub DLL. Use the BuildMe.bat file to automate
this task. We’ll add the Now and Later implementation later, but the MIDL code won’t change. The test client
requires these MIDL generated headers.
The Client Application
191
Additonal Information and Updates: http://www.iftech.com/dcom
 The Client Application
With the client application we’re going to do something a little
different. Up to this point, we’ve implemented all our COM
objects using the ATL wizards. For this program we’re going to
write the ATL code ourselves. It’s really quite easy.  
The client is a standard MFC dialog-based application. This
will be a plain-vanilla MFC dialog application, which we will
modify to implement a COM object. Next we’ll write the callback
(sink) COM object. Finally, these two elements will be hooked
together. Here’s the sequence of events.
1. Create an MFC Dialog Based Application. Call it CallbackCli-
ent.
2. Modify the client’s main program to support the Callback
Interface (ICallBack). The definition of the ICallBack object
comes from the MIDL code of the CallbackServer server.
We’ll set everything up in the application InitInstance and
ExitInstance methods.
3. Attach code to the button that tests the callback.
Create the Client Dialog Application
Go to the File/New tab and create a new MFC AppWizard
project. I’ve named the project CallbackClient. Take all the stan-
dard dialog application options.
The 
AppWizard 
will 
create 
a 
dialog 
named
IDD_CALLBACKCLIENT_DIALOG. Edit this dialog and delete the
OK button. Leave the Cancel button. 
Next we’ll add a new button, with the ID as
IDD_BUTTON1. Change the text of the button to read “Now”.
Add IDD_BUTTON2 for the “Later” button. The dialog should
now look similar to Figure 12-3.
Next, edit the STDAFX.H file to include ATL. If you leave
out this line, the compiler won’t recognize ATL templates such as
CComModule. Add the following line near the end of STDAFX.H:
#include 
192    Chapter 12 •
Callback Interfaces 
Our dialog should now compile, but it will just be an empty
shell. In the examples that follow we will be leaving out the part
of the application we haven’t modified. We will only present
enough of the application framework to give a context. For a
holistic look at this application you’ll need to look at the exam-
ple source code on the CD. 
Adding the Callback COM Object
Next we’re going to modify the CallbackClient application to
support our ICallBack interface. To do this, we’ll have to manu-
ally add a COM object to the application. This is the first time
we’re not going to use the ATL wizards, but it’s really easy to do.
Edit the main application source module, CallbackCli-
ent.CPP, and add the following class definition at the top, just
after the #include section.
CComModule _Module;   // Define main COM module.
                      // Required for 
#include    // definition of CcomObjectRoot
Figure 12–3
The sample application is a simple dialog
The Client Application
193
Additonal Information and Updates: http://www.iftech.com/dcom
// Callback interface to be implemented on client
class CCallBack :
    public ICallBack,           // Use this interface
                                // (server.idl)
    public CComObjectRoot       // Use ATL
{
public:
    CCallBack() {}              // Default constructor
    // Define COM object map
    BEGIN_COM_MAP(CCallBack)
    COM_INTERFACE_ENTRY(ICallBack)
    END_COM_MAP()
// Icallback
public:
    // The callback method
    STDMETHOD(Awake)(long lVal);
};
// Create object map for callback interfaces
BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()
There’s a lot going on here so we’ll break it up into smaller
bites.
First, we need to include ATL in the source code. This is
done by including . If you just plop this definition
down anywhere in the code, you’ll get lots of errors. This is
because this ATL header is assuming a main module named
“_Module” is already defined. “_Module” is a magic name, and
you’ll have to declare it in every ATL module. 
The ATL class CComModule handles all the plumbing of
starting, stopping, and registering a COM server. Needless to say,
there’s a lot going on in CComModule. Fortunately, we don’t
have to understand all this behind-the-scenes magic to use it.
CComModule _Module;
194    Chapter 12 •
Callback Interfaces 
Once this symbol is defined, we can proceed with our class
definition. We’re going to inherit from ICallback, and the root of
all ATL objects, CComObjectRoot. This class is required for all
ATL objects, it provides the required implementation of IUn-
known - in other words, QueryInterface, AddRef, and Release. 
// Callback interface to be implemented on client
class CCallBack :
    public ICallBack,           // Use this interface
 // (server.idl)
    public CComObjectRoot       // Use ATL
Linking to the Server Headers
The definition of ICallBack is a bit of a mystery here. Remember,
this Interface is defined in the CallbackServer server. We put a
definition of the interface in the IDL code for the server. When
MIDL was executed, it emitted two very useful files:
CallBackServer_i.c and CallBackServer.h. The “i.c” file includes
GUID definitions, and the “.h” file defines the ICallBack interface
in C++.
To get these definitions, include the following statements in
the header file CallbackClient.h:
#include “..\CallbackServer\CallBackServer_i.c”
#include “..\CallbackServer\CallBackServer.h”
You may need to change the path to these files, depending
on where the client and server project was created. 
COM Maps
Meanwhile, back at the CallbackClient.CPP module, we need to
add some more code. The next part of the class is the interface
map. This interface map sets up an array of interface IID’s . The
COM object will use these IID’s when it calls QueryInterface.
These macros hide a lot of code, and if you mistype any of the
entries you may get some unusual, and apparently unrelated,
error messages. Luckily, our COM object only has one interface.
The Client Application
195
Additonal Information and Updates: http://www.iftech.com/dcom
   BEGIN_COM_MAP(CCallBack)
    COM_INTERFACE_ENTRY(ICallBack)
   END_COM_MAP()
Implementing the Callback Method 
This COM object has only a single method called Awake. All that
our implementation does is display a message box. 
STDMETHODIMP CCallBack::Awake(long lVal)
{
    CString msg;
    msg.Format( “Message %d Received”, lVal );
    AfxMessageBox( msg );
    return S_OK;
}
 In a real-life implementation of a callback, this method
might be considerably more complex. The purpose of this
method is to notify the client application of a server event, such
as report completion. Obviously, there isn’t any code in this
example to do this, so we simulate it with a Message Box.
There are also some significant threading issues here. We
need to be aware that the dialog box and CCallBack objects are
running in the same apartment (i.e. thread). You’ve got to be
careful about the callback blocking execution for the dialog.
At the end of the CallbackClient.CPP file, we have the nor-
mal AppWizard generated MFC application class. In this case, the
application is called CCallbackClientApp, and inherits from CWi-
nApp - a standard dialog based application. We’re going to add a
few lines of code to set-up our server connection.
Adding the Object Map
The object map is located just after the class definition. The pur-
pose of this structure is to maintain an array of ATL objects that
will be supported. We’re not exposing any ATL objects to the
outside world, so we don’t need any entries. Any ATL objects
that are put in this structure will be registered when
_Module.Init() is called.
196    Chapter 12 •
Callback Interfaces 
// Create object map for callback interfaces
BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()
 That points out another difference between our ICallBack
interface and a normal COM interface. We aren’t allowing other
programs to instantiate a CCallBack object and interface by call-
ing CoCreateInstance. It isn’t necessary because we’ll be creating
the object internally, and explicitly passing it to any outside
objects that need it.
Connecting to the Server
In COM, everything starts with the client. By defining our CCall-
Back class first, we’re getting ahead of ourselves. Before any-
thing can happen, we need to initialize COM and connect to the
server. We’re doing this in the application’s InitInstance method. 
InitInstance is a standard method of CWinApp, and gets
called to display the application’s main dialog. 
// Initialize the application
BOOL CCallbackClientApp::InitInstance()
{
AfxEnableControlContainer();
// Initialize COM interfaces
InitCOM();
etc...
We’ve added the InitCOM method, which we’re about to
implement. Add this method to the header and enter the follow-
ing code.
BOOL CCallbackClientApp::InitCOM()
{
HRESULT hr;
CoInitialize(0); // Initialize COM
Connecting to the Server
197
Additonal Information and Updates: http://www.iftech.com/dcom
// Initialize the main ATL object 
_Module.Init( ObjectMap, 0 );
// Create a server object
m_pSimple = NULL;
hr = CoCreateInstance( CLSID_SimpleCallback,
0,CLSCTX_SERVER,IID_ISimpleCallback(void**)&m_pSimpl
e );
if (SUCCEEDED(hr))
{
// Create a callback object
CComObject* pCallBack = NULL;
CComObject::CreateInstance( &pCallBack 
);
pCallBack->AddRef();
// Set up the callback connection 
hr = m_pSimple->Advise( pCallBack, &m_lCookie );
// Done with our ref count. Server did an AddRef
pCallBack->Release();
}
return SUCCEEDED(hr);
}
We must, of course, start by initializing the COM subsystem.
We’re using apartment threading, so the old-fashioned CoInitial-
ize works fine. Next, we initialize the ATL main module. This is
done by calling the Init() method on the _Module object. This
gets ATL going and ready to serve the CCallBack COM object. 
hr = CoCreateInstance( CLSID_SimpleCallback, 
                            0, CLSCTX_SERVER,
                            IID_ISimpleCallback, 
                            (void**)&m_pSimple );
 We connect to the server in the usual way, with CoCre-
ateInstance. This starts up the server and delivers a server-side
COM interface. If you haven’t done all of your server registration
198    Chapter 12 •
Callback Interfaces 
correctly, you’ll probably get an error like “Class Not Registered”
here. If you did everything perfectly on the server, we’re ready to
call Advise and register our callback interface with the server.
CComObject* pCallBack = NULL;
CComObject::CreateInstance( &pCallBack );
pCallBack->AddRef();
This code looks a lot like ATL templates - for good reason.
We use the CComObject template to define a pointer to our cli-
ent-side CCallBack class. We instantiate this class using its Cre-
ateInstance method. 
CreateInstance is a static method that provides an efficient
way to create a local COM object. There’s more going on here
than first meets the eye. Notice that we’re not calling CoCreateIn-
stance, the usual way of getting a COM interface. We’re cheating
a little because CCallBack is implemented locally. 
Normally, COM restricts access to COM objects to their inter-
faces only. That doesn’t make sense here because we’re actually
implementing the object. The object creation process is nor-
mally hidden by CoCreateInstance, but in this case, we can see
it. Because everything’s local, we skip all CLSID’s and registra-
tion entirely. We do an AddRef on the object, to ensure that it
stays around for a while. 
 hr = m_pSimple->Advise( pCallBack, &m_lCookie );
 // Done with our ref count. Server did an AddRef
 pCallBack->Release();
 We created this COM object so we could pass it into the
server. This is done in the Advise method. If you remember the
server side, the interface is copied and AddRef’ed by the server.
This leaves us free to release the object, and let normal COM
lifetime management take its course. In the implementation of
UnAdvise, we’ll see where the CCallBack object is finally
released and can shut itself down
Connecting to the Server
199
Additonal Information and Updates: http://www.iftech.com/dcom
Cleaning Up
Eventually, the user is going to press the cancel button and shut
down the application. At this point, we need to close the server
connection and UnAdvise our callback. We put this code in Exit-
Instance, which is called right before the application shuts down.
ExitInstance is a virtual method of CWinApp. We’ll add ExitIn-
stance to the CCallbackClientApp header, and enter the follow-
ing code.
int CCallbackClientApp::ExitInstance()
{
// If we have a server object, release it
if (m_pSimple != NULL)
{
// Remove server’s callback connection
m_pSimple->UnAdvise(m_lCookie);
// Release the server object
m_pSimple->Release();
}
// Shut down this COM apartment
CoUninitialize();
return 0;
}
This is very straightforward code. We UnAdvise our callback
and release the server. Finally we shut down the COM apartment
with CoUninitialize. 
This concludes the application portion of our server. What’s
left is almost trivial - we add the button methods for Now and
Later.
Adding the OnButton Code
Now that we have wired-in our callback sink into the main
application, it’s time to build a test method. We’re going to hook
this test method up into the “Now” button on the main dialog.
Use the class wizard to add a method to the dialog called
OnButton1. You can also add the method for the “Later” button.
200    Chapter 12 •
Callback Interfaces 
The class wizard will generate all the usual message maps
for the two buttons. We’re creating these methods on the actual
dialog class, not the main application. The end result is two
OnButton methods on the CCallbackClientDlg dialog. These two
OnButton methods will act as our test platform. 
void CCallbackClientDlg::OnButton1() 
{
HRESULT hr;
CCallbackClientApp *pApp = 
(CCallbackClientApp*)AfxGetApp();
hr = pApp->m_m_pSimple->Now(1);
if (!SUCCEEDED(hr)) AfxMessageBox( “Call Failed” );
}
void CCallbackClientDlg::OnButton2() 
{
HRESULT hr;
CCallbackClientApp *pApp = 
(CCallbackClientApp*)AfxGetApp();
hr = pApp->m_pSimple->Later(5);
if (!SUCCEEDED(hr)) AfxMessageBox( “Call Failed” );
}
 Since we already connected to the server in InitCOM, we
don’t have to do much here. We just get a pointer to the main
application and use its COM pointer. We call AfxGetApp() to get
a pointer back to our main application. The COM interface
pointer is called “m_pSimple”, and we use it to call a method.
Note that we haven’t implemented the Later method on the
server. It won’t do anything. At this point, the code is complete.
We have presented a large block of source - it was unavoidable.
This example covers a complex interaction between a client and
server. Build the client and press the “Now” button. 
A Chronology of Events
201
Additonal Information and Updates: http://www.iftech.com/dcom
A Chronology of Events 
The purpose of the following list is to follow the sequence of
events required to make the callback. Since a callback involves
the close interaction of a client and server application, we’ve
included both sequences here. 
CLIENT DIALOG 
COM SERVER 
The client application is started. It 
calls InitInstance() on the application 
class. This will initialize the objects 
required for the application.
The InitCOM() method is called. This 