inter-
pretation process. Intuitively, abstract
interpretation can be
considered as “executing” the program on the abstract domain
instead of the concrete domain. The abstract domain is speciﬁc
to an analysis. In abstract interpretation, it is often the case that
branch outcomes cannot be statically determined. Therefore, it
6
assumes all branches are possible. In the presence of loops,
the interpretation may go through the loop bodies multiple
times until a ﬁx point is reached. If the abstract domain is
well designed, the interpretation procedure is guaranteed to
terminate.
Before the abstract interpretation, constants are propagated
during preprocessing using an existing LLVM pass (e.g.,
x1 ∗ x2 is rewritten to x1 ∗ c if x2 is determined to hold a
constant c). During the analysis, A2C iteratively goes through
program statements following the control ﬂow and updating
the corresponding abstract states (e.g., the decoding set) until
a ﬁx point is reached. Speciﬁcally, A2C taints input buffers
from untrusted sources. The taints are propagated through
controllable operations, which may be conducted through
library functions (e.g., memcpy(), toupper(), and icon
v()), linear operations (e.g., y = x and y = 3∗ x), and so on.
If a tainted value reaches an operation on the decoding frontier
computed in the previous phase, which includes comparative,
uncontrollable, and terminal operations, taint propagation is
terminated and the operation is added to the decoding set.
However, the decoding set may be context-sensitive and path-
sensitive. To handle such cases, statements that load constant
values may need to be considered as sources and hence
encoded. As a result, more statements may be added to the
encoding set and the decoding set.
Deﬁnitions. To facilitate discussion, we introduce a few deﬁ-
nitions in Fig. 8. Our analysis computes four kinds of abstract
information: the points-to set, the taint set, and the encoding
and decoding sets. The points-to set σ is a mapping from
an abstract address a (representing some memory location)
or a variable x, together with the calling context, to a set of
abstract addresses denoting the memory locations that may be
pointed-to by a or x. Abstract address Addr is denoted by some
variable representing an abstract global/stack array/buffer or a
label denoting an abstract heap buffer, followed by a sequence
of ﬁelds. Intuitively, one can consider it as the reference path to
some abstract memory location. The role of abstract addresses
in our static analysis is similar to that of concrete addresses
in dynamic analysis (e.g., to look up taint values). Since our
analysis is context-sensitive and ﬁeld-sensitive, context is part
of the mapping and ﬁelds are explicitly modeled in abstract
addresses.
Source represents the (taint) source of a value. There are
two types of Source: CONST and MARKED, meaning a constant
value and an untrusted input source, respectively. We use the
term MARKED to indicate that a value originates from some
input buffer and has only gone through controllable operations.
Hence it is in the exploitable space (Section II). Such values
shall be in their encoded form at runtime. We track the
MARKED value propagation through our analysis. T aintStore
τ stores the (taint) source information for abstract addresses
and variables. Both σ and τ are ﬂow-sensitive, meaning that
A2C computes separate σ and τ for different program locations
(i.e., labels). For example, we use τ (cid:96) to denote the abstract taint
mapping computed at (cid:96). It is implicit in the rest of the paper
for simplicity in discussion.
If MARKED values reach an operation on the decoding
frontier, the operation is inserted to the DecodeSet DEC.
The EncodeSet EN C contains the set of statements at which
the (input) values ought to be encoded. Context C is denoted
TABLE I.
ABSTRACT INTERPRETATION RULES.
Statement
input(cid:96)(xb, xs)
Interpretation Rule
foreach a ∈ σ(cid:96)(xb, C)
τ (cid:96)(a, C) := MARKED((cid:96), xb);
EN C := EN C ∪ {(cid:104)(cid:96), xb(cid:105)};
x :=(cid:96) x1
(x =(cid:96) x1 op c)
x :=(cid:96) LOAD(xa)
STORE(xa, xv )
x :=(cid:96) x1 op x2
x :=(cid:96) x1 → f
x :=
lib(cid:96)(x1, x2, ..)
x :=(cid:96) c
strcat(cid:96)(xa1, xa2)
F(cid:96)(xa)
ret
x := φ(cid:96)(y, x1, x2)
x := malloc(cid:96)(xs)
∀a∈σ(cid:96) (xa,C)
∀a∈σ(cid:96) (xa ,C)
σ(cid:96)(a, C)
τ (cid:96)(a, C)
σ(cid:96)(x, C) := σ(cid:96)(x1, C);
τ (cid:96)(x, C) := τ (cid:96)(x1, C);
σ(cid:96)(x, C) :=(cid:83)
τ (cid:96)(x, C) :=(cid:83)
∀a ∈ σ(cid:96)(xa, C) : σ(cid:96)(a, C) ∪ := σ(cid:96)(xv , C)
∀a ∈ σ(cid:96)(xa, C) : τ (cid:96)(a, C) ∪ := τ (cid:96)(xv , C)
σ(cid:96)(x, C) := ⊥;
ChkSrc((cid:96), x1); ChkSrc((cid:96), x2);
σ(cid:96)(x, C) := {a · f | ∀a ∈ σ(cid:96)(x1, C)}
for each xi ∈ {x1, x2, ...}
ChkSrc((cid:96), xi);
TaintConst((cid:96), x, c);
ChkStrCat((cid:96), xa1, xa2);
C0 := C; C := C · (cid:96);
// xf formal arg
σ(cid:96)(xf , C) := σ(cid:96)(xa, C0);
τ (cid:96)(xf , C) := τ (cid:96)(xa, C0);
foreach buffer var y ∈ F :
σ(cid:96)(y, C) = {y};
C := C − last(C);
σ(cid:96)(x, C) := σ(cid:96)(x1, C) ∪ σ(cid:96)(x2, C);
τ (cid:96)(x, C) := τ (cid:96)(x1, C) ∪ τ (cid:96)(x2, C);
σ(cid:96)(x, C) := (cid:96);
Name
INPUT
NON-
DF-OP
LOAD
STORE
DF-OP
FIELD
DF-TERM
CONST
STRCAT
CALL
RET
PHI
HEAP
by a sequence of labels ((cid:96)’s) that models a call stack. Each
element in the DEC set includes a Context, suggesting that
we decode input buffers depending on the calling context. For
example, (cid:104)C, (cid:96), x(cid:105) ∈ DEC suggests that when the statement
denoted by (cid:96) is encountered under context C at runtime, A2C
will decode the variable x.
Fig. 9. An Example of Context Sensitive Code.
Decoding Set is Context-Sensitive and Path-Sensitive. The
membership of a statement in the decoding set may change
with the context. Fig. 9 shows an example in ngircd, an
Internet Relay Chat (IRC) daemon program. In this example,
we treat all network functions as untrusted input sources. Thus,
the input data from these functions are encoded while data
from ﬁles are not. ngt_TrimStr() is a utility function
for trimming a string. It is invoked at different places. For
instance, Read_Config() calls it with a string from the
conﬁguration ﬁle, which is not encoded. On the other hand,
Parse_Request() also calls it, but with a string from the
network. The string is encoded this time. Hence, A2C may
or may not decode the value in *ptr at Line 47, depending
on the context. Therefore, each statement in the DEC set is
7
annotated with a context such that decoding is only performed
when the same context is encountered at runtime.
The decoding set is also path-sensitive. Consider the exam-
ple in Fig. 10 (a), which contains code snippets from unrtf, a
program for converting documents in Rich Text Format (RTF)
to other formats such as HTML and LaTeX. At 2(cid:13) and 3(cid:13),
str may hold a constant value or a tainted value ch. At 4(cid:13)
and 5(cid:13), str is inserted to a hash map. Strings in the hash map
are loaded and used at 6(cid:13). Depending on whether 2(cid:13) or 3(cid:13) is
executed, Line 336 may or may not belong to the decoding set.
In other words, if tmp holds a constant string at 336, it does
not need to be decoded. Note that in this case, the context of
Line 336 cannot be used to distinguish the different behaviors
of the line. We cannot afford to track paths at runtime either.
Hence, our solution is to identify the related constant strings,
such as that at Line 326, and treat them as input sources so
that they will be encoded as well. As a result, the behavior at
Line 336 becomes path insensitive, always requiring decoding.
(cid:50)
Abstract Interpretation Rules. The interpretation procedure
is formulated by the rules in Table I, which specify how
the abstract
information is updated upon each statement.
Speciﬁcally, when the program reads data from untrusted input
sources through input(xb, xs) with xb the buffer address
and xs the size, the TaintStore of all the abstract memory
locations pointed to by xb are set to MARKED (Rule INPUT).
Note that using the context C makes our analysis context
sensitive. The encoding set is also updated. Rule NON-DF-
OP describes the interpretation of an operation that is not on
the decoding frontier, i.e., controllable operation such as copy.
In this case, A2C copies the points-to set and the abstract
taint set. Rule LOAD describes that for a load instruction,
the resulting points-to/taint set is the union of all the points-
to/taint sets of all abstract memory locations pointed-to by the
address xa. Similarly, for a store statement, the points-to/taint
set of the value variable xv is added to the points-to/taint set
of any abstract memory location pointed to by xa. A2C only
propagates taints for controllable operations. Rules DF-OP han-
dles an uncontrollable operation or a comparative operation.
It ﬁrst resets the taint. It then calls function ChkSrc((cid:96), x)
that checks if variable x is tainted as MARKED. If so, the
statement together with the current context and the variable are
inserted to the decoding set DEC. The context and variable
information is needed to indicate which variable should be
decoded and under what context. The function further tests if
the statement is already in DEC and the variable is currently
tainted as CONST, suggesting that the statement sometimes uses
a value from untrusted input and sometimes uses a constant.
This corresponds to the case in which the decoding set is
path sensitive. To eliminate such path sensitivity, A2C adds
the source of the constant to EN C, indicating that the source
should be tainted as MARKED in the next round of abstraction
interpretation.
Rule DF-TERM handles the other kind of operations in the
decoding frontier: the terminal operations.
Rule CONST handles constant assignment, including con-
stant string assignment. It tests if the constant assignment has
been inserted to the EN C set (by Rules DF-OP or DF-TERM),
indicating that the constant should be encoded so that we need
     VOID       ngt_TrimStr(CHAR *String) {       . . .       // String can be either from        // a configuration file or        // a network message40:  start = String;       . . .46:  ptr = strchr( start, '\0' ) ✁ 1;47:  while(((*ptr == ' ') || (*ptr == 9) ||            (*ptr == 10) || (*ptr == 13) ||         . . .tool/tool.c        VOID Read_Config(VOID){          . . .    386:   fd = fopen( NGIRCd_ConfFile, "r" );          . . . 441:   if( !fgets( str, ..., fd )) break;442:   ngt_TrimStr( str );conf.c        Parse_Request(..., CHAR *Request){           . . .        /* Request is a user request                              through network. */140:    ngt_TrimStr( Request ); parse.cFig. 10. An example of the iterative interpretation procedure on unrtf.
to ﬁgure out its decoding places. In this case, it sets the taint
as MARKED, otherwise CONST. Rule STRCAT handles string
concatenations. When a string from an untrusted source is
concatenated with a constant string, we add the constant string
to the EN C set to indicate that the string shall be encoded.
Such concatenation happens frequently when a program uses
string formatting functions such as sprintf(). Rule CALL
updates the current context. It further propagates the points-to
and taint sets from the actual argument to the formal argument.
At the end, it sets the points-to sets of all the local buffer
variables to contain themselves. The RET rule pops the last
entry in the context. The PHI rule speciﬁes that since x takes
the value of either x1 or x2, its abstract sets are the union of
those of x1 and x2. A2C does not model path conditions so
that it essentially considers all paths are feasible and computes
merged results along various paths. Rule HEAP describes that
we use the label of the allocation statement to denote the
abstract heap region allocated. In addition, the σ and τ entries
computed at a location are also propagated to its control ﬂow
successors. The rules are omitted as they are standard. The
abstract interpretation is iterative until a ﬁx point is reached.
It is easy to infer that our analysis must terminate as all the
abstract domains are ﬁnite.
Example. Fig. 10 shows how the analysis works for unrtf
that reads an RTF ﬁle and transforms it to various formats.
Fig. 10 (a) shows some code snippets of the program. The
description of them can be found at the beginning of Sec-
tion IV-C. The program is simpliﬁed and slightly changed from
its original version for illustration.
The abstract
interpretation procedure is equivalent
to
traversing the path in Fig. 10 (b). The real interpretation order
inside A2C is slightly different due to the φ functions that are
omitted for easy explanation, although the outcome is identical.
In the path, the two branches of the switch are traversed in
two sub-paths: 1(cid:13) 2(cid:13) 4(cid:13) 5(cid:13) and 1(cid:13) 3(cid:13) 4(cid:13) 5(cid:13). They insert strings to
the hash table and the strings are later accessed at 6(cid:13).
Fig. 10 (c) shows the abstract states computed by A2C in
multiple rounds. Each round follows the path in (b) during
interpretation and corresponds to a sub-table in (c). The ﬁrst
column shows the block, line and round numbers of each
statement. For instance, 2-3261 means Line 326 inside 2(cid:13)
8
in the ﬁrst round of interpretation. Here, we only show the
statements related to our analysis. The next
two columns
present the abstract address or variable that each statement
accesses and its taint set. C means the CONST type and M
denotes the MARKED type. The next two columns show the
contents of EN C and DEC. The last column presents the
rules applied.
First Round. EN C and DEC sets are empty at the beginning.
At 1− 2461, since ch is loaded from an input source, we add
ch246 to EN C to indicate that we should encode ch at Line
246. Then, ch is used in a comparison at 1 − 2661, thus we
add ch266 to DEC, meaning that we should decode ch at
Line 266. For simplicity, we ignore the contexts in the DEC
set. At 2 − 3261, a constant string is copied to str, and part
of it is printed at 2 − 3271. Since str has a constant taint at
this point, it does not need to be decoded. Later it is stored
into the hash table at 5 − 1081. Then, a character from a ﬁle
is copied to str at 3 − 3321, and is then stored in the hash
table at 5 − 1081. Since A2C cannot distinguish if the hash
table write and the previous write access different (abstract)
memory locations, it unions the two taints so that the hash
table is tainted with both CONST and MARKED, according to
Rule STORE.
Later, at 6− 3351 and 6− 3361, the stored string is loaded
and compared with a constant string “\\f”. According to Rule
DF-OP, since Line 336 is comparative and tmp is tainted with
MARKED, it shall be decoded. An entry is hence inserted to the
DEC set. Also according to the second if statement inside
ChkSrc(), which is invoked by Rule DF-OP, the constant
string at Line 326 is added to EN C, meaning that the constant
string shall be encoded.
Second and Third Rounds. The second round traverses the