its public key,  ensures that the registration server learns
its public key without any need for public key infrastructure.
 (cid:5)(cid:6)(cid:1)(cid:2) is a random number generated by  that is used
as a challenge to the registration server to authenticate itself.
Finally, MAC is used to ensure that the registration server can
verify the integrity of this message.
On receiving this message,
the registration server ﬁrst
decrypts the message and veriﬁes its integrity. If veriﬁed, it
checks the authorization information of . If  is determined
eligible to join the multicast group, the registration server
executes the second step by sending a message to  containing
the following information:  (cid:5)(cid:6)(cid:1)(cid:2)  (cid:1);  (cid:5)(cid:6)(cid:2) (cid:1); and
a MAC computed over the ﬁrst two pieces of information.
This message is encrypted using the public key of  that the
registration server received in the ﬁrst step.  (cid:5)(cid:6)(cid:1)(cid:2)  (cid:1)
is included to authenticate the registration server’s identity as
the one who knows the private key corresponding to the well-
known public key that  used to encrypt its message in the
ﬁrst step.  (cid:5)(cid:6)(cid:2) (cid:1) is a random number generated by the
registration server and used as a challenge to  to authenticate
itself. Finally, MAC is used to ensure that  can verify the
message integrity.
On receiving this message,  ﬁrst decrypts the message
using its private key and veriﬁes its integrity. If veriﬁed, 
authenticates the registration server by checking  (cid:5)(cid:6)(cid:1)(cid:2) 
(cid:1). If the authentication process succeeds,  executes the third
step by sending a message containing  (cid:5)(cid:6)(cid:2) (cid:1)  (cid:1) and
a MAC computed over it. This message is encrypted using
the public key of the registration server. On receiving this
message, the registration server veriﬁes its integrity and then
authenticates the client.
These three steps have accomplished the following: (1)
The client has authenticated the registration server; (2) The
client has communicated the authorization information to the
registration server and the registration server has determined
the eligibility of the client to join the multicast group; (3)
The registration server has authenticated the client. Message
conﬁdentiality is implemented by encrypting all messages us-
ing appropriate public keys. Message integrity is implemented
by including appropriate MACs. Man-in-the-middle attack and
replay attack are prevented by including appropriate nonce and
implementing a challenge-response protocol.
It is important to note here what we mean by authentication
of a client. We require a client  to provide its public key to
the registration server in the ﬁrst step. There is no mechanism
for the registration server to verify that the public key provided
in this step is indeed the public key of . After receiving
the message from  in the third step, the registration server
can verify that  knows the private key corresponding to the
public key it provided in the ﬁrst step. This ensures that an
adversary that knows ’s public key did not initiate the join
protocol, since the adversary will not know the corresponding
private key and hence cannot send the message in the third
step. Although, the registration server has not veriﬁed that the
public key provided in the ﬁrst step indeed belong to , the
proposed veriﬁcation of the client knowing the corresponding
private key is sufﬁcient for the multicast applications intended
here. The registration server grants access to  after the third
step, because it has already veriﬁed the authorization informa-
tion (e.g. credit card number). In general, authenticating that
the public key provided in step one indeed belongs to  will
require third-party authentication infrastructure, e.g. a public
key infrastructure, which is not needed here.
In the fourth step, the registration server ﬁrst chooses an
appropriate area for  and sends a message to the area
controller of that area. The choice of an appropriate area can
be based on factors such as proximity to the client, load bal-
ancing, etc. This message contains the following information:
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 10:05:28 UTC from IEEE Xplore.  Restrictions apply. 
Step 1: Client
Step 2:
RS
Step 3: Client
{[auth−info]; Pub_k; Nonce_CW; MAC}_Pub_rs
{Nonce_CW+1; Nonce_WC; MAC}__Pub_k
{Nonce_WC+1; MAC}_Pub_rs
Step 4:
RS
{Nonce_AC; K_id; ts; Pub_k; MAC}_Pub_ac; Sig_Prv_rs
Step 5:
RS
Step 6: Client
Step 7: AC
{Nonce_AC+1; Pub_AC; MAC}_Pub_k; Sig_prv_rs
{Nonce_AC+2; Nonce_CA; MAC}_Pub_ac
{Nonce_CA+1; ticket; [aux−keys]; MAC}_Pub_k
RS
Client
RS
AC
Client
AC
Client
Fig. 3.
Join Protocol.
 (cid:3)(cid:4)(cid:0)(cid:1); client ’s id; Timestamp; ’s public key; and
a MAC computed over the ﬁrst four pieces of information.
This message is encrypted using the public key of the area
controller and signed using the private key of the registration
server.  (cid:3)(cid:4)(cid:0)(cid:1) is a random number generated by the
registration server that will be used later for authentication
of the client to the area controller. Timestamp is included
here to prevent a replay attack, in which an adversary that
is able to intercept messages exchanged in this step and later
in step 6, and gain access to the multicast group later on
by replaying those messages. Timestamp is used by an area
controller to catch such replayed messages. The signature
generated using the registration server’s private key is used
by the area controller to authenticate that this message indeed
originated from the registration server.
After sending the message in step 4, the registration server
executes step 5 by sending a message to the client . This
message contains  (cid:3)(cid:4)(cid:0)(cid:1)  (cid:1); public key and address of
the area controller; and MAC computed over the two pieces of
information. This message is encrypted using the public key of
, and signed using the private key of the registration server.
Here  (cid:3)(cid:4)(cid:0)(cid:1) is same as the one used in step 4. This will be
used by  to authenticate itself to the area controller in step
6. Once again, the signature generated using the registration
server’s private key is used by  to authenticate that this
message indeed originated from the registration server.
After receiving this message from the registration server in
step 5,  ﬁrst authenticates the sender of the message to be the
registration server by verifying the signature. It then decrypts
the message using its private key and veriﬁes its integrity.
Next, in step 6, it sends a message to the area controller.
This message contains  (cid:3)(cid:4)(cid:0)(cid:1)  (cid:2),  (cid:3)(cid:4)(cid:1)(cid:0), and a MAC
computed over these two numbers. This message is encrypted
using the area controller’s public key.  (cid:3)(cid:4)(cid:1)(cid:0) is a random
number generated by  that is used as a challenge to the area
controller to authenticate itself.
After receiving the message from the registration server
in step 4, the area controller veriﬁes the signature of the
registration server attached to this message. It then decrypts
the message using its private key and veriﬁes its integrity.
Similarly, on receiving the message from client  in step
6, the area controller decrypts it using its private key and
veriﬁes its integrity. If veriﬁed,
it authenticates the client
by comparing  (cid:3)(cid:4)(cid:0)(cid:1)  (cid:2) received in this message with
 (cid:3)(cid:4)(cid:0)(cid:1) received in the message from the registration server
in step 4. If all information in these two messages are veriﬁed
to be correct, the area controller adds client  in its area. It
ﬁnds a position for  in its auxiliary key tree and updates
the auxiliary keys. The details of auxiliary key tree update are
described later in this section.
In step 7, the area controller sends a message to the client 
containing the following information: all auxiliary keys in the
path from  to the root of the auxiliary key tree;  (cid:3)(cid:4)(cid:1)(cid:0) 
(cid:1); a ticket; and a MAC generated over these three pieces of
information. This message is encrypted using the public key
of .  (cid:3)(cid:4)(cid:1)(cid:0)  (cid:1) is used by  to authenticate that this
message indeed originated from the area controller that knows
the private key corresponding to the public key used to encrypt
the message in step 6. Ticket is a cryptographic entity that is
used by  to move from one area to another. Details of ticket
structure and how it is used are described in Section IV-B.
(cid:0)
(cid:0)
(cid:2) and multicasts (cid:6)(cid:0) 
After a client has been authenicated using these seven
steps, the auxiliary key tree maintained by the area controller
of the area that the client joins is updated. First, the area
controller creates a new area key 
(cid:2)
(encryption of 
(cid:2) using the previous area key (cid:2)) to all
current area members. In addition, it determines an appropriate
(empty) leaf position in the auxiliary key tree of its area to
place . Area controllers in Mykil maintain a balanced tree
structure of auxiliary keys such that each node (except leaf)
in this tree has up to four children. This is based on the
observation that a tree structure with each node having four
children provides the best overall performance [21].
(cid:0)
If an empty leaf position is found in the current auxiliary-
key tree,  is placed at that position. However, if no empty
leaf position is present in the current auxiliary-key tree, the
following procedure is followed. First, ﬁnd the shallowest, left-
most leaf node . Let member (cid:4) is currently associated with
(cid:0), (cid:5)
this leaf. Create four new auxiliary-key nodes, (cid:1)
(cid:0), place them as children of , and respectively assign
and (cid:6)
(cid:0). Next
(cid:0), (cid:8)(cid:2)
randomly generated auxiliary keys (cid:8)(cid:1)
(cid:0) and  with node (cid:2)
(cid:0).
associate member (cid:4) with node (cid:1)
Unicast the list of new auxiliary keys appropriately encrypted
to (cid:4). An example of member join is illustrated in Figure 4.
(cid:0) and (cid:8)(cid:6)
(cid:0), (cid:2)
(cid:0), (cid:8)(cid:5)
(cid:0)
Ka
1K
mc
K2
m1
K3
m2
K4
m3
aK’
K2
m1
K3
m2
K4
m3
1K
1K’
mc
2K’
3K’
4K’
m
Fig. 4. A new member  joins an area.
C. Member Leave
The member leave protocol is again similar to that in LKH,
except for one important step. Since the join operation is much
less expensive if an empty leaf is already present in the tree,
Mykil increases the likelihood of this scenario by not pruning
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 10:05:28 UTC from IEEE Xplore.  Restrictions apply. 
the leaf after a member leaves. All keys along the path from
the node corresponding to the leaving member to the root are
changed, and the changed keys are multicast by encrypting
them using appropriate auxiliary keys.
D. Batching
An important technique called batching has been proposed
[4], [22], [8], [19] to reduce the frequency of rekeying oper-
ations. The main idea of batching is to perform a rekeying
operation only after a minimum number of member join/leave
requests have been received, and/or a certain time interval has
elapsed. Mykil employs batching to reduce the overhead of
rekeying operations in three ways: (1) aggregation of join
events, (2) aggregation of leave events, and (3) aggregation
of join and leave events.
(cid:0)
(cid:0)
(cid:0)(cid:0)
Assume that a new member  wishes to join an area (cid:1). To
do this, the area controller (cid:1)(cid:0) has to update the area key to say
(cid:1). Assume right after that another new member (cid:0) wishes

to join the same area. (cid:1)(cid:0) has to now update the area key to
(cid:1) . If no data multicast occurs between these two join events,

there is no need for (cid:1)(cid:0) to multicast area key 
(cid:1) to the current
area members. Aggregation of join events in Mykil prevents
such needless multicast. To do so, when a new join request
from a new member  arrives at (cid:1)(cid:0), (cid:1)(cid:0) simply calculates a
new leaf position for , records the identity of  and other
current members whose path may have changed due to this
join, and sets an update needed ﬂag. When a new multicast
data packet arrives at (cid:1)(cid:0), (cid:1)(cid:0) checks the update needed ﬂag. If
set, it multicasts a new area key to the current area members,