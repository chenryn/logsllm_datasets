8.8 TB
137.4 GB
Bandwidth
8.2 KB
12.3 KB
4.0 MB
102.4 KB
Bandwidth
262.1 KB
20.5 KB
8.6 MB
286.7 KB
Bandwidth
8.4 MB
20.5 KB
15.1 MB
553.0 KB
Bandwidth
268.4 MB
28.7 KB
23.2 MB
901.1 KB
Bandwidth
8.6 GB
36.9 KB
33.3 MB
1.5 MB
Rounds
1
2
968
3
Rounds
1
3
2096
4
Rounds
1
3
3675
5
Rounds
1
4
5668
6
Rounds
1
5
8122
8
Table I: Storage and communication cost comparisons. Total
storage is the amount of space required for the server, and the
bandwidth and rounds are counted per operation. Each stored
item consists of a 4-byte label and 4-byte value.
implementation. It is not until 219 entries that ORAM+AVL
even outperforms the naive O(n) baseline solution.
As described previously, we attribute much of the speed
to decreasing the round complexity. The HIRB tree requires
much smaller height as compared to an AVL tree because each
HIRB node contains β items on average as compared to just a
single item for an AVL tree. Additionally, the HIRB’s height
is ﬁxed and does not require padding to achieve obliviousness.
Each AVL operation entails 3· 1.44 lg N ORAM operations as
compared to just 2 logβ N vORAM operations for the HIRB.
This difference in communication cost is easily observed in
Table I. Overall, we see that the storage and communication
costs for vORAM+HIRB are not too much larger than that for
a secure deletion B-tree, which does not provide any access
pattern hiding as the oblivious alternatives do.
(The values in this table were generated by considering
the worst-case costs in all cases, for our actual implemen-
tations, but considering only a single operation. Note that, for
constructions providing obliviousness, every operation must
actually follow this worst case cost, and so the comparison is
fair.)
Put simply,
the vORAM+HIRB and SD-B-Tree are the
only implementations which can be considered practical for
real data sizes, and the beneﬁt of vORAM+HIRB is its
considerable additional security guarantees of oblivious and
bounded history independence.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:16:59 UTC from IEEE Xplore.  Restrictions apply. 
VII. CONCLUSION
In this paper, we have shown a new secure cloud storage
system combining the previously disjoint security properties
of obliviousness, secure deletion, and history independence.
This was accomplished by developing a new variable block
size ORAM, or vORAM, and a new history independent,
randomized data structure (HIRB) to be stored within the
vORAM.
The theoretical performance of our vORAM+HIRB con-
struction is competitive to existing systems which provide
fewer security properties. Our implemented system is up to
100X faster (w.r.t. access time) than current best oblivious map
data structure (which provides no secure deletion or history
independence) by Wang et al. (CCS 14), bringing our single-
operation time for a reasonable-sized database (> 219) to less
than 1 second per access.
There much potential for future work in this area. For
example, one could consider data structures that support a
richer set of operations, such as range queries, while preserv-
ing obliviousness, secure deletion, and history independence.
Additionally, the vORAM construction in itself may provide
novel and exciting new analytic results for ORAMs generally
by not requiring ﬁxed bucket sizes. There is a potential
to improve the overall utilization and communication cost
compared to existing ORAM models that used ﬁxed size
blocks.
Finally, while we have demonstrated the practicality in
terms of overall per-operation speed, we did not consider some
additional practical performance measures as investigated by
[12], such as performing asynchronous operations and opti-
mizing upload vs download rates. Developing an ODS map
considering these concerns as well would be a useful direction
for future work.
ACKNOWLEDGEMENTS
This work was
through
supported by the Ofﬁce of Naval
Research
and
N0001415WX01532, and by the National Science Foundation
through awards #1406177 and #1319994.
N0001415WX01532
awards
REFERENCES
[1] X. Zhuang, T. Zhang, and S. Pande, “HIDE: an infrastructure for efﬁ-
ciently protecting information leakage on the address bus,” in ASPLOS
2004, 2004, pp. 72–84.
[2] M. S. Islam, M. Kuzu, and M. Kantarcioglu, “Access pattern disclo-
sure on searchable encryption: Ramiﬁcation, attack and mitigation,” in
NDSS 2012. The Internet Society, Feb. 2012.
[3] J. L. Dautrich Jr and C. V. Ravishankar, “Compromising privacy in
precise query protocols,” in Proceedings of
the 16th International
Conference on Extending Database Technology. ACM, 2013, pp. 155–
166.
[4] O. Goldreich and R. Ostrovsky, “Software protection and simulation on
oblivious rams,” J. ACM, vol. 43, no. 3, pp. 431–473, 1996. [Online].
Available: http://doi.acm.org/10.1145/233551.233553
[5] I. Damgård, S. Meldgaard, and J. B. Nielsen, “Perfectly secure oblivious
RAM without random oracles,” in TCC 2011, ser. LNCS, Y. Ishai, Ed.,
vol. 6597. Springer, Mar. 2011, pp. 144–163.
[6] M. T. Goodrich, M. Mitzenmacher, O. Ohrimenko, and R. Tamassia,
“Privacy-preserving group data access via stateless oblivious RAM
simulation,” in 23rd SODA, Y. Rabani, Ed. ACM-SIAM, Jan. 2012,
pp. 157–167.
[7] E. Kushilevitz, S. Lu, and R. Ostrovsky, “On the (in)security of hash-
based oblivious RAM and a new balancing scheme,” in 23rd SODA,
Y. Rabani, Ed. ACM-SIAM, Jan. 2012, pp. 143–156.
[8] E. Stefanov, E. Shi, and D. X. Song, “Towards practical oblivious ram,”
in NDSS, 2012.
[9] E. Stefanov, M. van Dijk, E. Shi, C. W. Fletcher, L. Ren, X. Yu,
and S. Devadas, “Path ORAM: an extremely simple oblivious RAM
protocol,” in ACM CCS 13. ACM Press, Nov. 2013, pp. 299–310.
[10] J. L. D.
Jr., E.
Stefanov,
“Burst ORAM:
for bursty access patterns,”
minimizing ORAM response times
in Proceedings of
the 23rd USENIX Security Symposium, 2014,
pp. 749–764. [Online]. Available: https://www.usenix.org/conference/
usenixsecurity14/technical-sessions/presentation/dautrich
and E.
Shi,
[11] X. S. Wang, K. Nayak, C. Liu, T.-H. H. Chan, E. Shi, E. Stefanov,
and Y. Huang, “Oblivious data structures,” in ACM CCS 14, G.-J. Ahn,
M. Yung, and N. Li, Eds. ACM Press, Nov. 2014, pp. 215–226.
[12] V. Bindschaedler, M. Naveed, X. Pan, X. Wang, and Y. Huang, “Prac-
ticing oblivious access on cloud storage: the gap, the fallacy and the
new way forward,” in ACM CCS 15, 2015, to appear.
[13] M.
Isaac, “Nude photos of
front
in online privacy debate,” New York Times, Sept. 2, 2014,
http://www.nytimes.com/2014/09/03/technology/trove-of-nude-photos-
sparks-debate-over-online-behavior.html.
lawrence are latest
jennifer
[14] “Lastpass security notice,” https://blog.lastpass.com/2015/06/lastpass-
security-notice.html/.
[15] F.
Konkel,
“The
details
about
the
Jul.
CIA’s
17,
deal
2014,
Amazon,”
with
http://www.theatlantic.com/technology/archive/2014/07/the-details-
about-the-cias-deal-with-amazon/374632/.
Atlantic,
The
[16] S. Bajaj and R. Sion, “Ficklebase: Looking into the future to erase
the past,” in 29th IEEE International Conference on Data Engineering,
ICDE 2013, Brisbane, Australia, April 8-12, 2013, 2013, pp. 86–97.
[17] J. Reardon, H. Ritzdorf, D. A. Basin, and S. Capkun, “Secure data
deletion from persistent media,” in ACM CCS 13. ACM Press, Nov.
2013, pp. 271–284.
[18] T. Moataz, T. Mayberry, and E. Blass, “Constant communication ORAM
with small blocksize,” in Proceedings of
the 22nd ACM SIGSAC
Conference on Computer and Communications Security, Denver, CO,
USA, October 12-6, 2015, 2015, pp. 862–873.
[19] L. Ren, C. W. Fletcher, A. Kwon, E. Stefanov, E. Shi, M. van Dijk,
and S. Devadas, “Constants count: Practical improvements to oblivious
RAM,” in 24th USENIX Security Symposium, USENIX Security 15,
Washington, D.C., USA, August 12-14, 2015., 2015, pp. 415–430.
[20] T. Toft, “Brief announcement: Secure data structures based on multi-
party computation,” in 30th ACM PODC, C. Gavoille and P. Fraigniaud,
Eds. ACM, Jun. 2011, pp. 291–292.
[21] J. C. Mitchell and J. Zimmerman, “Data-oblivious data structures,”
in 31st International Symposium on Theoretical Aspects of Computer
Science (STACS 2014), 2014, pp. 554–565.
[Online]. Available:
http://dx.doi.org/10.4230/LIPIcs.STACS.2014.554
[22] M. Blanton, A. Steele, and M. Aliasgari, “Data-oblivious graph algo-
rithms for secure computation and outsourcing,” in ASIACCS 13. ACM
Press, May 2013, pp. 207–218.
[23] D. Micciancio, “Oblivious data structures: Applications to cryptogra-
phy,” in 29th ACM STOC. ACM Press, May 1997, pp. 456–464.
[24] M. Naor and V. Teague, “Anti-presistence: History independent data
structures,” in 33rd ACM STOC. ACM Press, Jul. 2001, pp. 492–501.
[25] J. D. Hartline, E. S. Hong, A. E. Mohr, W. R. Pentney, and E. C.
Rocke, “Characterizing history independent data structures,” Algorith-
mica, vol. 42, no. 1, pp. 57–74, 2005.
[26] N. Buchbinder and E. Petrank, “Lower and upper bounds on obtaining
history independence,” Inf. Comput., vol. 204, no. 2, pp. 291–337,
2006. [Online]. Available: http://dx.doi.org/10.1016/j.ic.2005.11.001
[27] G. E. Blelloch and D. Golovin, “Strongly history-independent hashing
IEEE Computer Society Press, Oct.
with applications,” in 48th FOCS.
2007, pp. 272–282.
[28] M. Naor, G. Segev, and U. Wieder, “History-independent cuckoo hash-
ing,” in ICALP 2008, Part II, ser. LNCS, L. Aceto, I. Damgård, L. A.
Goldberg, M. M. Halldórsson, A. Ingólfsdóttir, and I. Walukiewicz, Eds.,
vol. 5126. Springer, Jul. 2008, pp. 631–642.
[29] D. Golovin, “B-treaps: A uniquely represented alternative to B-trees,”
in ICALP 2009, Part I, ser. LNCS, vol. 5555. Springer, Jul. 2009, pp.
487–499.
192192
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:16:59 UTC from IEEE Xplore.  Restrictions apply. 
[30] ——, “The B-skip-list: A simpler uniquely represented alternative to
B-trees,” CoRR, vol. abs/1005.0662, 2010.
[31] S. Bajaj, A. Chakraborti, and R. Sion, “Practical foundations of history
independence,” CoRR, vol. abs/1501.06508, 2015.
[32] J. Reardon, D. A. Basin, and S. Capkun, “Sok: Secure data deletion,”
in 2013 IEEE Symposium on Security and Privacy, SP 2013, 2013, pp.
301–315. [Online]. Available: http://dx.doi.org/10.1109/SP.2013.28
[33] D.
R.
and
J.
Proceedings
Lipton,
the
of
Boneh
in
system,”
Symposium,
conference/6th-usenix-security-symposium/revocable-backup-system
[Online]. Available:
1996.
“A
revocable
6th USENIX
backup
Security
https://www.usenix.org/
[34] G. D. Crescenzo, N. Ferguson, R. Impagliazzo, and M. Jakobsson, “How
to forget a secret,” in STACS, 1999, pp. 500–509.
[35] Z. N. J. Peterson, R. C. Burns, J. Herring, A. Stubbleﬁeld, and A. D.
Rubin, “Secure deletion for a versioning ﬁle system,” in Proceedings
of the FAST ’05 Conference on File and Storage Technologies, 2005.
[Online]. Available: http://www.usenix.org/events/fast05/tech/peterson.
html
[36] S. Mitra, M. Winslett, and N. Borisov, “Deleting index entries from
compliance storage,” in EDBT 2008, 11th International Conference
on Extending Database Technology, 2008, pp. 109–120. [Online].
Available: http://doi.acm.org/10.1145/1353343.1353361
[37] J. Katz and Y. Lindell, Introduction to Modern Cryptography. Chapman
and Hall/CRC Press, 2007.
[38] J. R. Lorch, B. Parno, J. W. Mickens, M. Raykova, and J. Schiffman,
“Shroud: ensuring private access to large-scale data in the data center.”
in FAST, vol. 2013, 2013, pp. 199–213.
[39] X. Yu, L. Ren, C. W. Fletcher, A. Kwon, M. van Dijk, and S. Devadas,
“Enhancing oblivious ram performance using dynamic prefetching,”
IACR Cryptology ePrint Archive, vol. 2014, p. 234, 2014.
[40] E. Stefanov, M. van Dijk, E. Shi, T.-H. H. Chan, C. F. L. Ren, X. Yu,
and S. Devadas, “Path ORAM: an extremely simple oblivious RAM
protocol,” CoRR, vol. abs/1202.5150v3, 2014.
[Online]. Available:
http://arxiv.org/abs/1202.5150v3
[41] W. Hoeffding, “Probability inequalities for sums of bounded random
variables,” J. Amer. Statist. Assoc., vol. 58, pp. 13–30, 1963. [Online].
Available: http://www.jstor.org/stable/2282952
[42] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein, Introduction
to Algorithms, 2nd ed. The MIT Press, September 2001.
APPENDIX A
VORAM OPERATION DETAILS
We give the pseudocode of vORAM helper functions.
idgen()
1: Choose r ← {0, 1}2T +γ.
2: return 1(cid:4)r.
loc(id, t)
1: return the location of the node at level t along the path from
the root to the leaf node identiﬁed by id. This is is simply the
index indicated by the (t + 1) most signiﬁcant bits of id.
(cid:4) rootkey : enc key for root bucket
evict(id)
1: key ← rootkey
2: B ← empty list
3: for t = 0, 1, . . . T do
4:
remove bucket at loc(id, t) from persistent storage
decrypt it with key
Append all partial blocks in the bucket to the end of B
key ← child key from bucket according to loc(id, t + 1)
5:
6:
7: end for
8: for each partial block (id∗, (cid:3), blk) in B do
if (id∗, (cid:3)0, blk0) is in stash already
9:
then replace with (id∗, (cid:3)0 + (cid:3), blk0 blk)
10:
else Add (id∗, (cid:3), blk) to stash
11:
12: end for
writeback(id)
1: key ← nil
2: for t = T, T − 1, . . . , 0 do
3:
W←{(id∗, (cid:3), blk) ∈ stash : loc(id∗, t) = loc(id, t)}
(cid:4) merge
4:
5:
6:
7:
8: