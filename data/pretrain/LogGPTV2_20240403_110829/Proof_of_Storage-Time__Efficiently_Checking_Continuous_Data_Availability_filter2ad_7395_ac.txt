audit frequency parameter t and the data storage
time T , this randomized algorithm generates a public-
private key pair (pk, sk).
PoSt.Store(sk, D): The ﬁle-storing algorithm takes
as input a secret key sk and the content D ∈ {0, 1}∗,
encodes D into D∗ as the ﬁle to be stored, and
computes a tag tg for further proof and veriﬁcation.
PoSt.V is the veriﬁcation algorithm which has two
subroutines PoSt.Vcha and PoSt.Vvalid for the chal-
lenge generation and the response validation, respec-
tively. PoSt.Vcha(pk, sk, tg) takes as input the public
key pk, the secret key sk and the tag tg, and generates
a challenge c as well as setting a public timer to
be 0. PoSt.Vvalid(pk, sk, tg, c, p, timer) takes as input
the public key pk, the secret key sk, the tag tg, the
challenge c, the corresponding response p and the time
of the timer for receiving the response p, and outputs
a bit b to indicate “reject” or “accept”.
PoSt.P(pk, tg, D∗, c): The randomized proving algo-
rithm takes as input the public key pk, the ﬁle tag tg
output by St, the decoded ﬁle D∗ and the challenge,
outputs a response p after a period of computation
and sends it back to the veriﬁer immediately after the
computation is ﬁnished.4
A PoSt scheme may possess other advanced features.
Compactnesss. A PoSt scheme is compact, if the cost of the
veriﬁcation algorithm PoSt.V = (PoSt.Vcha, PoSt.Vvalid) is
independent of the storage time T and the size of the ﬁle.
Public veriﬁability. Similar to PDP/PoR, if the subroutines
PoSt.Vcha and PoSt.Vvalid of the verify algorithm do not
need the secret key sk as input, we call this scheme publicly
veriﬁable. It implies that continuous data possession can be
veriﬁed by any third party, not only by the data owner.
Public validation. Consider the case where only PoSt.Vvalid
does not require the secret key as input, while PoSt.Vcha still
needs it. In this case, the response p can be publicly validated,
given the challenge c. We call these PoSt schemes publicly val-
idatable. Unlike publicly veriﬁable schemes, PoSt.Vcha may
still take sk as input so that challenges cannot be generated
publicly. Therefore, the timer for veriﬁcation should be initi-
ated by the data owner but can be seen by everyone. Although
4In practice, PoSt.P is supposed to send back the ﬁnal response after the
storage period ends; otherwise it is impossible to detect malicious attempts
such as discarding the stored data at the last moment. Therefore, either the
computation of PoSt.P takes longer time than T , or an intentional delay is
included in the algorithm.
not as ﬂexible as publicly veriﬁable schemes, validatable PoSt
schemes are sufﬁcient for many useful applications, including
those related to decentralized storage markets, as advocated by
Filecoin. 5 In particular, data owners can outsource their data
to any party in the network and publish a privately-generated
challenge together with the parameters of the smart contract
(the public key pk, the tag tg, and the initial time t1). Any
party that stores the data can submit a response p in time t2,
and the contract can publicly evaluate PoSt.Vvalid with pk, tg,
p and t2 − t1 as input. The storage provider earns his reward
if the output bit b equals to 1.
Stateful/Stateless PoSt. A PoSt scheme is stateful, if it sup-
ports a limited number of audits after the setup procedure and a
state must be maintained. The state is updated after a challenge
is used, i.e., PoSt.Vcha(pk, sk, tg, state) → (c, timer, state).
The PoSt.Store algorithm is parameterized by an integer (cid:96),
which indicates the maximum number of interactions. The
variable state records the times that
the server has been
queried. In practice, a new challenge cannot be generated when
the bound is reached unless the data owner retrieves all the data
and relaunches the store procedure. On the contrary, the audit
interaction for a stateless PoSt can be invoked an unbounded
(polynomial) number of times.
Generally, a PoSt scheme should satisfy both properties of
Correctness and Soundness.
A. Correctness
Correctness requires that the veriﬁcation algorithm accepts
the proof when interacting with a valid prover.
Deﬁnition 2: A stateless PoSt scheme is correct if for all
keypairs (pk, sk) output by PoSt.Kg(λ, t, T ), for all ﬁles D ∈
{0, 1}∗, and for all (D∗, tg) output by PoSt.Store(sk, D),
the veriﬁcation algorithm accepts the proof when interact-
ing with a valid prover. Speciﬁcally,
if p is the response
generated by PoSt.P(pk, tg, D∗, c) on the challenge c gen-
erated by PoSt.Vcha(pk, sk, tg) and sent back to the ver-
iﬁer immediately after the proof computation is ﬁnished,
PoSt.Vvalid(pk, sk, tg, c, p, timer) always outputs 1.
For the stateful PoSt, the correctness deﬁnition is the same,
except the state is involved in PoSt.Vcha.
B. Soundness
As illustrated in the introduction, providing a suitable and
rigorous deﬁnition for soundness is a challenging task. A
natural choice is to upgrade the PoR soundness, which requires
an extractor algorithm to extract the data while interacting
with a legitimate prover. This follows the classical deﬁnition
of proof of knowledge. It is not hard to imagine, in an ideal
version of PoSt, to have an extractor that extracts the data
possessed by a legitimate prover at any speciﬁc point within
the time range T . Our strategy is to characterize the prover
algorithm as an Interactive Turing Machine (ITM), which is
executed to generate a proof after receiving a challenge. We
intend to mimic the situation where someone runs a computer
but ends at a speciﬁc time point, “freezes” its memory, and
then checks the data preserved on the machine. Intuitively,
5Ideally, they would also demand the stronger public veriﬁability property
so that PoSt could be integrated into the mining procedure.
6
the data on a computer should be either preserved in the
memory (characterized as conﬁgurations) or hardcoded in the
program (characterized as the transition function). Therefore,
for the notion of soundness, the data should be extracted from
the conﬁguration corresponding to any speciﬁc time and the
transition function. To facilitate the construction, we provide a
more general deﬁnition for the above-idealized version: instead
of selecting a conﬁguration of one step, we allow the extractor
to choose a bunch of conﬁgurations that correspond to a time
slot with length t.
Fig. 2: PoSt soundness model.
In general,
the soundness experiment of PoSt consists
of two procedures as in PDP/PoR, i.e., the setup game and
the extraction algorithm. The setup game lets the adversary
generate a prover algorithm P(cid:48). In the extraction algorithm,
the extractor recovers the data from the generated algorithm
P(cid:48). The setup game of PoSt is similar to that of PDP/PoR,
while the extraction procedure needs to be deﬁned speciﬁcally.
1) Setup Game: The ﬁrst procedure is the following setup
game between an adversary A and an environment, which sim-
ulates the procedure that the adversary generates a malicious
prover P(cid:48) by getting arbitrary storage data from an honest data
owner and then freely interacts with the veriﬁer.
Step 1. The environment generates a keypair (pk, sk) by run-
ning PoSt.Kg, and provides pk to A
Step 2. The adversary now interacts with the environment.
It can make queries to a store oracle, providing, for
each query, some ﬁle D. The environment computes
(D∗, tg) by invoking PoSt.Store(sk, D) and gives
both D∗ and tg back to A. If the PoSt is stateful, the
environment initiates and maintains a veriﬁer’s state
for each storage query.
Step 3. For any D on which it previously made a store
query,
the adversary undertakes executions of the
PoSt challenge-response interaction, by specifying the
corresponding tag tg. In these protocol executions, the
environment plays the part of the veriﬁer, and the
adversary plays the part of the prover. Speciﬁcally,
the environment maintains a timer for each interaction.
When a protocol execution completes, the adversary
is provided with the output of V. These protocol
executions can be arbitrarily interleaved with each
other and with the store queries described in Step 2.
For the stateful PoSt, the environment also updates the
state as a veriﬁer, so the adversary can only interact
with the veriﬁer a limited number of times for a
speciﬁc storage.
Step 4. Finally, the adversary outputs a challenge tag tg re-
turned from some store query, and the description of
a prover P(cid:48), which is an ITM deﬁned before.
Speciﬁcally, the prover P(cid:48) for a ﬁle D and storage time
T is -admissible for a stateless PoSt
if it convincingly
answers an  fraction of challenges, i.e., Pr[(cid:104)PoSt.V(·),P(cid:48)(cid:105) =
1] ≥ . Similarly, for the stateful scheme we require that
Pr[(cid:104)PoSt.V(·, state),P(cid:48)(cid:105) = 1] ≥  for any state from 1 to l.
The probability is over the coins of the veriﬁer and the prover.
2) Extraction: The second procedure is to allow the extrac-
tor to extract the data from the prover P(cid:48). As discussed above,
we provide a generalized notion of “continuous extractability”,
which aims to capture that if one chooses any time period
with length t during the storage time, the data is available
for at least one time point in this period. Intuitively, if the
interval between two data audits is larger than t, the data
may not be available for this interval, and hence cannot be
extracted from the corresponding bunch of conﬁgurations and
the transition function. So t actually characterizes the largest
interval between two data audits, and it represents the checking
frequency parameter.
Speciﬁcally, we design an extract experiment which has
two procedures. To guarantee that the extracted data is indeed
“on the machine” during that chosen time slot, we run two
procedures. The ﬁrst procedure, named Extr1, is to honestly
run the algorithm P(cid:48) as an ITM,
the sequence of
the conﬁgurations, and to cut out a bundle of sequential
ITM conﬁgurations which correspond to a length of time
t. The second procedure, named Extr2, can use this bundle
of sequential ITM conﬁgurations, along with the transition
function of P(cid:48), to extract the data.
to get
In our deﬁnition, the behavior of Extr1 is ﬁxed, but the
strategy of Extr2 is arbitrary. Moreover, the execution time of
P(cid:48) must be longer than the deposit time T . Particularly, when
given the transition function and a bunch of conﬁgurations
corresponding to one time slot, Extr2 may rewind a portion
of the computations of P(cid:48) by himself. The sketch of the
experiment can be seen in Fig. 2.
Deﬁnition 3 (Soundness): A PoSt scheme is -sound if for
every adversary A which plays the setup game and outputs an
-admissible prover P(cid:48) for a ﬁle D as an ITM with k tapes,
there is an extractor Extr which has two subroutine ITMs,
Extr1 and Extr2, that can perform the following tasks.
•
Extr1 is an ITM with k + 1 working tapes. Extr1’s
input is the description of P(cid:48). He devotes k of his
working tapes to simulate all the tapes of P(cid:48). Extr1
ﬁrst writes an arbitrary challenge on the simulated
input tape of P(cid:48), then simulates every step of P(cid:48)
following the instructions of P(cid:48)’s transition function.
After each step of P(cid:48), Extr1 records the current
conﬁgurations of P(cid:48) on his extra tape before starting
to simulate the next step of P(cid:48). After ﬁnishing all
of P(cid:48) steps, Extr1 will randomly pick t successive
7
•
to write on his output
conﬁgurations of P(cid:48)
tape
together with the description of the transition function
of P(cid:48).
The input of Extr2 is directly obtained from the output
tape of Extr1. Extr2 must recover D purely from the
information s returned by Extr1 except a negligible
probability, no matter which t successive conﬁgura-
tions of P(cid:48) is chosen by Extr1. Hence the probability
Pr (D ←$ Extr2(s)|s ←$ Extr1(P(cid:48))) > 1−negl(λ) for
the randomnesses of both Extr1 and Extr2.
V. CONSTRUCTIONS FOR POST
In this section, we provide two PoSt constructions which
are proven secure in the above model. Each of them has its
own advantages.
The ﬁrst construction follows the structure of the ad-hoc
proposal from the Filecoin white paper [40] but can be proven
secure. Intuitively, it uses a VDF and random oracles to force
the prover to generate PoR proofs sequentially. This scheme
is stateless, which means that the prove procedure can be
launched an unlimited number of times after storing. Also,
this scheme is publicly veriﬁable; hence a third party can
verify the continuous availability of data by interacting with
the server. The drawback of this scheme is that the size of the
ﬁnal proof is linear with respect to the storage time. Given
that the veriﬁcation time is also linear, we consider this just a
warm-up construction.
The next construction is our main one which achieves
compact proofs, so its communication size is independent
of the default time. Particularly, its veriﬁcation algorithm is
extremely efﬁcient. Nevertheless, this construction is stateful,
i.e., after a limited number of PoSt interactions, no more proofs
can be generated until rerunning the storing phase. Moreover,
this scheme provides public validation, but it is not publicly
veriﬁable. This means that the veriﬁer needs a secret key for
the generation of the challenge; however, the veriﬁcation of
the PoSt proof does not.
A. Basic PoSt Scheme
Next, we describe our ﬁrst construction called the basic
PoSt. Our main building blocks are a stateless unpredictable
PoR scheme (deﬁned in Subsection II) and a VDF scheme.
The main intuition is to force the PoSt prover to sequentially
generate one PoR proof every once in a while during the entire
storage period. To achieve this goal, we let the challenges
of the next PoR be derived from the output of VDF, whose
input is the previous PoR proof (see the right side of Fig.
1). Therefore, a malicious prover cannot generate all the PoR
proofs at once at the beginning of the storage period, because
each PoR procedure is connected to the next one in series by
a delay function. Also, the prover cannot discard the data ﬁrst
and wait until the last moment to retrieve it and generate all
the PoR proofs at once, otherwise he will risk not sending the
ﬁnal response in time due to the delay function.
Speciﬁcally,
the following primitives will be used in
the construction. A stateless publicly-veriﬁable PoR scheme
with unpredictability consists of a tuple of algorithms
(PoR.Kg, PoR.Store, PoR.P, PoR.V) where PoR.V =
•
•
•
(PoR.Vcha, PoR.Vvalid). PoR.Vcha and PoR.Vvalid denote
the veriﬁer’s
challenge
for generating the
algorithms
respectively. H and G are
and verifying the proof,
hash functions that can be viewed as random oracles.
(VDF.Setup, VDF.Eval, VDF.Verify) are the algorithms for
a veriﬁable delay function with δ-evaluation time for some
constant δ. D denotes the storage ﬁle. The PoSt scheme needs
a global timer which is initiated by the data owner but can be
seen by everyone.
The PoSt
is parameterized by the storage time T and
checking frequency t. Without loss of generality, T and t are
measured by the number of steps of a Turing machine (to
mimic the CPU clock). Note that since the adversary may
evaluate the delay function slightly faster than the honest
prover, we require them to check the data more frequently
than the requested frequency t. Based on T and t, PoSt scheme
will choose the VDF delay time t(cid:48) ≤ t − 2δT . Precisely, we
set the delay parameter of VDF as t(cid:48). Hence, the sequential
steps for evaluating VDF should be larger than t(cid:48) for any
parallel adversary with poly(λ) processors; on the other hand,
the honest server can ﬁnish the VDF evaluation within time
(1+δ)t(cid:48) (see Section VI-B for more detailed discussions about