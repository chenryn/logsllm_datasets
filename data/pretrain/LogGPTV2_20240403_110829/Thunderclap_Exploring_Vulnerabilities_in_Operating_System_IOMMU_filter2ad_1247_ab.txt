bilities occur when the 4KiB page (or superpage) granularity of
translations allows undesired access beyond the intended physical
memory range, or when permissions are set more broadly than
necessary – for example, if only a sub-page-size region of memory
is intended to be exposed by DMA. Temporal vulnerabilities
occur when IOMMU mappings are open longer than necessary,
allowing undesired accesses when memory may have been
reused for other purposes – e.g., if IOTLB invalidations are
performed asynchronously to allow DMA across memory reuse.
Previous work [37], [42], [53] hypothesized the IOMMU suffers
from such vulnerabilities but without describing any exploits.
III. METHODOLOGY
This section describes our threat model, including our aims
and the practical opportunities open to attackers. It describes
the features of our I/O-security research platform and our test
environment. It describes how our platform allows us to fully
explore the breadth of what can be achieved, with different
scenarios where devices are used. In subsequent sections we use
it to survey operating systems and then focus on them in detail.
A. Threat model
We consider malicious peripherals, i.e., hardware devices
that may be attached to a computer system for ill intent, or an
existing peripheral that may be compromised to the same ends
(e.g., via malicious ﬁrmware update).
We focus on peripherals that can read and write system
memory, directly or indirectly, via PCIe, Thunderbolt, or on-chip
interconnect. Message-passing peripherals such as USB or SATA
devices are not covered by our work and have different threat
models (e.g., [49], [57]). However, the host controllers (i.e., the
bridges from these protocols to memory transactions – usually
PCIe) – are in scope. An attack from a USB-only peripheral
(not via Type-C and Thunderbolt) would ﬁrst require a host
controller exploit: it may be feasible, but we do not explore this.
Attacks may be external, via addition of a pluggable device,
or internal, via compromised ﬁrmware of an existing device.
themselves as whatever kind of
devices they wish by selecting their PCIe device ID, allowing
them to select the vulnerable device driver of their choice.
Peripherals may be external or internal; hot-pluggable, modular,
soldered-down, or on-chip. Physical form factor has limited
impact on the exploits a device can undertake, but it has a
substantial bearing on user expectations. The form factor can
be used to mislead users, shaping a device to look like one
object but act like another. Users may not understand how much
access they are granting to a device that they plug in.
Attackers can present
Our platform ﬁts into a number of physical forms to misdirect
user expectations, including a docking station, charger, and
projector. These are items users might borrow or connect to
without considering security implications. Additional scenarios
might be:
Compromised dongle. An existing Thunderbolt Ethernet or Wi-
Fi dongle that contains a standard PCIe chip has its ﬁrmware com-
promised (e.g., via [32] or [11]). The dongle is fully functional,
Fig. 4: Implementation of fully-functional network card using
a QEMU device model running on FPGA
yet with additional trojan functionality to exﬁltrate data. The don-
gle is left in a meeting or hotel room for an unsuspecting visitor.
Supply-chain attack. The ﬁrmware of a PCIe network card
has exﬁltration functionality added in the factory or in the supply
chain, before it is installed in a customer server. Alternatively,
a bad ﬁrmware update is applied in the ﬁeld.
While we consider primarily PCI Express and popular laptop,
desktop, and server operating systems, our work generalizes
to any device where memory is exposed to peripherals. Our
focus is on use of the IOMMU for host protection. Hypervisors
using it to delegate peripherals to virtual machines, and to
protect from breaking out of VMs using IO devices, present
a related but distinct problem. The same IOMMU is used in
a very different way, with divergent threat models. This also
applies to OSs such as Qubes or Bromium that launch a separate
virtual machine for each task, using the IOMMU to delegate
peripherals to one speciﬁc VM.
B. The Thunderclap I/O-security research platform
To investigate deep interactions with peripherals, we required
a more intricate research platform than previously published.
The full peripheral stack is depicted in Figure 3, including
parts that are standardized and those that are device-speciﬁc.
Because the device-speciﬁc layers are those that have most
interaction with software, we needed an implementation that
extends substantially beyond the work of previous researchers,
who implemented only the standardized layers. To do this, we
needed ﬂexibility to probe both hardware and software, and
so we built our research system using a complex software stack
running on an FPGA, as depicted in Figure 4.
For the hardware, we used the Arm Cortex A9 CPU on an
Intel Arria 10 FPGA to run a software-deﬁned device model
extracted from the QEMU full-system emulator. Additionally
FPGA soft-logic allows it to generate arbitrary PCIe packets.
1) Baseline to reproduce the state of the art: The PCIe
transport layer imposes the semantics of memory on top of the
underlying layers that provide reliable end-to-end delivery of
packets. These transport layer packets (TLPs) may be reads
and writes classiﬁed as either memory, conﬁguration, legacy-I/O,
or other messages (such as power control). The replies to
read requests are completion packets, which contain either the
requested data or an error code.
Our PCIe hardware delivers raw PCIe TLPs to programs
on the FPGA CPU through simple queues, which enables our
adversarial application to send and receive arbitrary packets. This
allowed us to build a baseline platform to test vulnerabilities
to generic PCIe devices, similar to prior literature. The baseline
software can perform DMA by generating arbitrary memory
read and write packets and interpreting their results, including
returned data and indications of errors.
4
CPU
Motherboard
Firmware enables IOMMU by default
Connection
Operating systems tested
Intel i7-7700HQ
Intel i5-6360U
Intel i5-4278U
Intel i5-4570
Intel i5-4670
Intel i7-4770
Intel i7-930
Intel Xeon E5-2670 SR0KX
AMD Ryzen 1600X
Dell XPS 15 9560
Macbook Pro late-2016
Mac Mini late-2014
iMac 27” late-2013
Asus Z87 Deluxe Dual
Asus Q87M-E
Intel DX58SE
Intel S2600CP2
MSI X370 Gaming Plus
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
‘Auto’
TABLE I: Victim machines for experiments
Ubuntu, Windows 10 Pro
Thunderbolt 3
Thunderbolt 3 MacOS, Windows 10 Home/Pro
Thunderbolt 2 MacOS
Thunderbolt 2 MacOS
PCIe
PCIe
PCIe
PCIe
PCIe
FreeBSD, Ubuntu
Windows 10 Enterprise
FreeBSD, Ubuntu/RHEL/Fedora
FreeBSD, Ubuntu
Ubuntu
2) Implementing a full device model: To go further, we wished
to emulate a functional device that would cause the driver to be
activated on the victim OS and expose data via the IOMMU. We
used a software model of an Intel 82574L Gigabit Ethernet Con-
troller from the QEMU full system emulator [8]. This device has
drivers for each operating system we investigated. We extracted
the QEMU e1000e device model and ran it on the FPGA CPU.
An extremely cut-down version of QEMU’s main loop has to be
run in order to keep the simulated model operating. Incoming
PCIe packets are translated into QEMU function calls in the
device model. Similarly, QEMU’s simulated ‘DMA’ is translated
into real PCIe DMA transactions. This enabled our emulated
device to generate the same memory reads, writes and interrupts
that a real device would generate. QEMU’s internal network stack
allows our fake network interface card (NIC) to generate plausible
trafﬁc such as DNS and DHCP – we are not only a malicious
device, but one that functions correctly as far as the operating
system is concerned. The complex software dependencies required
by QEMU mandated the full POSIX environment provided by
Linux, in contrast with a real PCIe peripheral that usually runs
a much more minimal embedded software stack.
With a functional emulated device, which worked despite
the latency of software-generated packets, we could then add
a malicious payload. We added an adversarial component which
was made aware of the state of the emulated NIC and generated
additional malicious DMA trafﬁc and additional PCIe state.
3) Platform form factors: Thunderclap runs on FPGA
evaluation boards, including the Arria 10 SoC Development
Kit. Noting that user expectations are molded by the physical
shape a platform takes, we have designed (although not fully
engineered) a number of embodiments of the platform into form
factors users might expect:
• A Thunderbolt docking station, where the Arm drives the
• A USB-C projector, which has an internal FPGA as well
• A USB-C charger, to charge a laptop as well as provide
as a Thunderbolt bridge to extract video
docking station I/O (ethernet, USB, etc)
a malicious Thunderbolt FPGA
C. Test environment
We attached the FPGA to a number of laptop, desktop, and
server systems to test different exploit paths, over a wide range
of operating systems. Full details of the hardware/software
combinations are shown in Table I.
We focus on the Intel and AMD IOMMUs in our study. In the
mobile space, ARM’s System MMU (SMMU) applies broadly
the same concepts, and a natural extension of our work would
consider use of the SMMU. However, we note that our study al-
ready covers the kernels used in Android (Linux) and iOS (XNU,
common with macOS). The most interesting attacks on these plat-
forms (malicious ﬁrmware in radio basebands, cameras or network
devices) would require more reverse engineering to implement,
since their software environment is proprietary. Additionally, these
platforms do not offer PCIe or Thunderbolt to external devices as
laptops do, so we could not reuse our existing research hardware.
D. Vulnerability space
Our aim is to investigate the shared-memory vulnerability
space. In doing so, we examine how it is exploited through
increasingly complex interactions with the operating system
and device drivers.
To illuminate this, we illustrate how kernel and device-driver
vulnerabilities allow us to extract private data (for instance, plain-
text VPN network trafﬁc), change kernel behavior (for example,
change control ﬂow by manipulating code pointers, allowing
construction of malicious programs from snippets of pre-existing
executable code by means of Return Oriented Programming
(ROP) techniques), and circumvent memory protections. We then
review our vendor interactions, the effectiveness of available
mitigations and potential future directions.
IV. OPERATING-SYSTEM SURVEY
To understand how the IOMMU is used in different OSs,
we performed an analysis of documentation, source code, and
(where necessary) IOMMU page tables of running machines.
A summary is given in Table II, which lists the OS versions
we used for subsequent experiments.
We found that many systems did not even turn the IOMMU
on: either it was disabled in the ﬁrmware, or the operating system
required obscure conﬁguration to enable the IOMMU. MacOS
was the only OS to enable the IOMMU by default. It is notable
that even RedHat Enterprise Linux 7.1 (which is Common Criteria
EAL4+ certiﬁed [55]) did not enable the IOMMU by default. On
those systems without default enablement, we set the necessary
conﬁguration to enable the IOMMU for device protection.
When the IOMMU is enabled, there are two broad modes that
are used. Shared mappings have a single IOMMU page table that
is used by all devices. Per-device mappings implement a different
page table for each PCIe device. We discuss the implications
of these design choices in following sections. Subsequently,
Section IX considers why the IOMMU is used the way it is.
V. ATTACKS WITHOUT OS INTERACTION
The most basic vulnerabilities may be explored with our
baseline platform, which is able to generate arbitrary PCIe
packets
from software. Generating independent memory
transactions replicates prior work in that it has no interactions
with the kernel or any device drivers; it na¨ıvely explores what
data it can access at a hardware level. In principle any PCIe
device with DMA capability could perform similar attacks,
though a particular product (as [20]) may have its own limitations.
A simple approach is memory probing, looking for accessible
memory regions. As an FPGA able to make PCIe memory
5
Operating system
Build/
kernel
Can use
IOMMU
Default
enabled
IOMMU page mappings
Shared
Per-device
Data leakage
Vulnerability
Kernel pointer
Shared-allocator
Windows 7
Windows 8.1
Win 10 Home/Pro 1709
Win 10 Enterprise 1607
Win 10 Enterprise 1703
MacOS 10.10-10.13
Linux: Ubuntu 16.04
Linux: Fedora 25
Linux: RHEL 7.1
FreeBSD 11
PC-BSD/TrueOS 10.3
1 Fixed after our disclosure.
9200
16299
14393
15063
4.8/10
4.8
3.10
11
10.3
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)