enhanced this by enforcing object-call pairing for each vcall
in the program, as well as ﬁxing a number of corner cases
that were discovered in the implementation of VTV. Sim-
ilary, SafeDispatch [22] extended LLVM to support a sim-
ilar policy to VTV. Also for LLVM, VTrust [44] proposed
a hash-based technique to verify the integrity of vcalls. For
the MSVC compiler, VT-Guard [27] proposed a defense that
inserted a secret cookie into each vtable and checked if the
cookie is valid before each vcall. While this makes it harder
for an attacker to inject a valid vtable, it falls short against
memory disclosure attacks that can leak the cookie value.
Recently, Bounov et al. [6] proposed an LLVM exten-
sion that reorders vtables such that integrity policies can
test for vtable membership in constant time.
In general,
compiler-based solutions have the maximum visibility into
the source code, allowing them to enforce stronger policies
than ours. Nevertheless, they require access to the source
code and recompilation of all linked modules, which may not
be feasible in practice. Other solutions, such as CETS [28]
and Dangnull [25], attempted to eliminate dangling point-
ers altogether by tracing object pointers and nullifying them
upon deletion. Unfortunately, sound and complete tracing
of pointers is NP-Hard [24], especially with pointer aliasing
and multithreading constructs available in all modern pro-
gramming languages. Additionally, there are various ways
to mount vtable attacks besides using a dangling pointer,
such as buﬀer overﬂow, format string, and type confusion
attacks. That said, eliminating dangling pointers is comple-
mentary to our work and resembles a strong layer of defense
against various memory corruption attacks.
Binary Solutions. Multiple binary solutions were proposed
to defend against vtable attacks. T-VIP [17] used static
analysis to identify and extract vtables and vcall sites. At
runtime, it checked at each vcall site that the referenced
vtable is read-only and the vcall oﬀset is in the vtable. Sim-
ilarly, RECALL [14] identiﬁed unsafe casting in MSVC bina-
ries by matching the layouts of objects that reach vcall sites.
Both solutions worked on an intermediate binary represen-
tation obtained by lifting the x86 assembly to a static single
assignment (SSA) form. However, as the authors explained,
this is not error-free.
VTint [43] relocated vtables to a read-only memory sec-
tion, and checked before every vcall that the referenced vtable
is read-only. VTint incurred low overhead, but at the same
time it suﬀered from poor identiﬁcation accuracy. For in-
stance, VTint identiﬁed only 115 vtables and 200 vcalls for
447.dealII, whereas VCI identiﬁed about 7 times as many.
Similarly, vfGuard [30] used static analysis to reconstruct
the set of all possible targets for each vcall site, given the
vcall oﬀset, and instrumented the binary to check for mem-
bership. Unfortunately, it was assessed that such policies are
not precise enough to stand against COOP attacks [11, 34].
On a diﬀerent defense front, solutions were proposed to
detect memory corruption and access bugs. Valgrind [29],
AddressSanitizer [32], and Undangle [7] are a few examples
of dynamic memory monitoring systems that help detect
memory access errors, including use-after-free. However, the
overhead is prohibitive for practical deployment as a secu-
rity solution (25x runtime overhead). DieHard [5] provided
a probabilistic memory integrity guarantee by randomizing
and expanding the heap. While it incurred much less over-
head than full-blown dynamic memory monitoring, it re-
quired at least double the heap size for each program it pro-
tects, which is not feasible in practice. More recently, VT-
Pin [33] introduced a simple and novel solution by directly
managing deallocations, and preventing reuse of deleted ob-
jects by repointing their vtptr to a safe vtable. For that
purpose, however, it required hooking the free and malloc
calls, the presence of RTTI in the binary, as well as catching
segfaults that may result from probing unmapped memory.
Complementary to our work is C++ reverse engineering
eﬀorts.
In Smartdec [16], the authors proposed a system
to reconstruct C++ class hierarchies from RTTI. Similarly,
Objdigger [23] extracted objects and member functions of
classes from compiled MSVC binaries. While decompilation
is very valuable for many security problems, VCI is more
tuned for vcall integrity as it focuses on only recovering the
C++ semantics that impose restrictions on vcall targets.
8. CONCLUSION
This paper presented VCI, a system to generate and en-
force a strict CFI policy against vtable attacks in COTS
C++ binaries. VCI statically reconstructs various C++ se-
mantics from the binaries, without needing debug symbols
or type information, making it applicable to any C++ ap-
plication. VCI defeats vtable injection attacks and signif-
150icantly reduces the attack surface for vtable reuse attacks.
As demonstrated by our experiments, VCI signiﬁcantly im-
proves upon the state-of-the-art, defeats real-world exploits,
and incurs low overhead.
Acknowledgments
We thank the anonymous reviewers for their valuable com-
ments. This material is based on work supported by the
National Science Foundation (NSF) under grant no. SATC
1421747, and by the National Institute of Standards and
Technology (NIST) under grant no. 60NANB16D285. Opin-
ions, ﬁndings, conclusions, and recommendations expressed
in this material are those of the authors and do not neces-
sarily reﬂect the views of the NSF, NIST, or the US Gov-
ernment.
References
[1] M. Abadi et al. Control-ﬂow integrity.
Communications Security, 2005.
In Computer and
[2] J. Afek and A. Sharabani. Smashing the pointer for fun and
proﬁt. Black Hat USA, 2007.
[3] Aslr. https://pax.grsecurity.net.
[4] G. Balakrishnan and T. Reps. WYSINWYX: What you see
is not what you eXecute. ACM Trans. on Prog. Lang. and
Syst., 32(6), 2010.
[5] E. D. Berger and B. G. Zorn. DieHard: Probabilistic mem-
ory safety for unsafe languages. In Programming Language
Design and Implementation, 2006.
[6] D. Bounov, R. G. Kıcı, and S. Lerner. Protecting C++
dynamic dispatch through vtable interleaving. In Network
and Distributed System Security, 2016.
[7] J. Caballero et al. Undangle: early detection of dangling
pointers in use-after-free and double-free vulnerabilities. In
International Symposium on Software Testing and Analysis,
2012.
[8] N. Carlini et al. Control-ﬂow bending: On the eﬀectiveness
In USENIX Security, pages 161–
of control-ﬂow integrity.
176, 2015.
[9] N. Carlini and D. Wagner. ROP is still dangerous: Breaking
modern defenses. In USENIX Security, 2014.
[10] S. Crane et al. It’s a TRaP: Table randomization and protec-
tion against function-reuse attacks. In Computer and Com-
munications Security, 2015.
[11] S. Crane et al. Readactor: Practical code randomization
resilient to memory disclosure. In Symposium on Security &
Privacy, 2015.
[12] M. Daniel, J. Honoroﬀ, and C. Miller. Engineering heap
overﬂow exploits with javascript. WOOT, 8, 2008.
[13] L. Davi et al. Stitching the gadgets: On the ineﬀectiveness of
coarse-grained control-ﬂow integrity protection. In USENIX
Security, 2014.
[14] D. Dewey and J. T. Giﬃn. Static detection of C++ vtable
escape vulnerabilities in binary code. In Network and Dis-
tributed System Security, 2012.
[15] Dyninst API. http://www.dyninst.org/dyninst.
[16] A. Fokin et al. SmartDec: Approaching C++ decompilation.
In Working Conference on Reverse Engineering, 2011.
[17] R. Gawlik and T. Holz. Towards automated integrity protec-
tion of C++ virtual function tables in binary programs. In
Annual Computer Security Applications Conference, 2014.
[18] E. Goktas et al. Out of control: Overcoming control-ﬂow
integrity. In Symposium on Security & Privacy, 2014.
[19] I. Haller et al. ShrinkWrap: Vtable protection without loose
In Annual Computer Security Applications Confer-
ends.
ence, 2015.
[20] L. C. Harris and B. P. Miller. Practical analysis of stripped
binary code. ACM SIGARCH Computer Architecture News,
33(5):63–68, 2005.
[21] Itanium c++ abi.
http://mentorembedded.github.io/
cxx-abi/abi.html.
[22] D. Jang, Z. Tatlock, and S. Lerner. Safedispatch: Secur-
ing C++ virtual calls from memory corruption attacks. In
Network and Distributed System Security, 2014.
[23] W. Jin et al. Recovering C++ objects from binaries using
inter-procedural data-ﬂow analysis. In Program Protection
and Reverse Engineering Workshop, 2014.
[24] W. Landi and B. G. Ryder. Pointer-induced aliasing: A prob-
lem classiﬁcation. In Principles of programming languages,
1991.
[25] B. Lee et al. Preventing use-after-free with dangling pointers
nulliﬁcation. In Network and Distributed System Security,
2015.
[26] Z. Lin, X. Zhang, and D. Xu. Automatic reverse engineering
of data structures from binary execution. In Annual Infor-
mation Security Symposium. Purdue University, 2010.
[27] M. R. Miller and K. D. Johnson. Using virtual table protec-
tions to prevent the exploitation of object corruption vulner-
abilities.
[28] S. Nagarakatte et al. CETS: Compiler enforced temporal
safety for C. In International Symposium on Memory Man-
agement, 2010.
[29] N. Nethercote and J. Seward. Valgrind: A framework for
heavyweight dynamic binary instrumentation. In Program-
ming Language Design and Implementation, 2007.
[30] A. Prakash, X. Hu, and H. Yin. vfGuard: Strict protection
for virtual function calls in COTS C++ binaries. In Network
and Distributed System Security, 2015.
[31] G. F. Roglia et al. Surgically returning to randomized libc. In
Annual Computer Security Applications Conference, 2009.
[32] Address sanitizer. https://github.com/google/sanitizers.
[33] P. Sarbinowski et al. Vtpin: practical vtable hijacking pro-
In Annual Conference on Computer
tection for binaries.
Security Applications. ACM, 2016.
[34] F. Schuster et al. Counterfeit object-oriented programming:
On the diﬃculty of preventing code reuse attacks in C++
applications. In Symposium on Security & Privacy, 2015.
[35] J. Seibert, H. Okhravi, and E. Soderstrom.
Information
Leaks Without Memory Disclosures: Remote Side Channel
Attacks on Diversiﬁed Code. In Computer and Communica-
tions Security, 2014.
[36] V. Srinivasan and T. Reps. Slicing machine code. Technical
Report TR1824, UW-Madison, 2015.
[37] C. Tice et al. Enforcing forward-edge control-ﬂow integrity
in gcc & llvm. In USENIX Security, 2014.
[38] van der Veen et al. Practical context-sensitive cﬁ. In Com-
puter and Communications Security, pages 927–940. ACM,
2015.
[39] van der Veen et al. A tough call: Mitigating advanced code-
reuse attacks at the binary level. In Symposium on Security
& Privacy, 2016.
[40] W. R. Williams, X. Meng, B. Welton, and B. P. Miller.
Dyninst and MRNet: Foundational infrastructure for par-
allel tools. 9th Parallel Tools Workshop, 2015.
[41] P. R. Wilson. Uniprocessor garbage collection techniques. In
Memory Management. Springer, 1992.
[42] C. Zhang et al. Practical control ﬂow integrity and random-
ization for binary executables. In Symposium on Security &
Privacy, 2013.
[43] C. Zhang et al. VTint: Defending virtual function tables’
integrity. In Network and Distributed System Security, 2015.
[44] C. Zhang et al. VTrust: Regaining trust on virtual calls. In
Network and Distributed System Security, 2016.
[45] M. Zhang and R. Sekar. Control ﬂow integrity for cots bina-
ries. In USENIX Security, 2013.
151APPENDIX
A. MAIN ALGORITHMS USED BY VCI
Algorithms A.1 to A.4 summarize the main algorithms
used by VCI.
Algorithm A.1: Scan and Extract Vtables
input : Rgns: set of memory regions from the binary
Funcs: set of functions from the binary
output: Vtables: set of virtual function tables
1 foreach func ∈ Funcs do
foreach insn ∈ getInstructions(func) do
if writesMemory(insn) then
src ← getSrcExpr(insn)
dst ← getDstExpr(insn)
if isDefined(src) then
rgn ← getRegion(src)
if readonly(rgn) then
vt ← extractVtable(rgn, src)
Vtables ← Vtables ∪ vt
11 return Vtables
12 Procedure extractVtable(Funcs, rgn, oﬀset)
13
vt ← ∅
i ← 0
foreach wd ∈ rgn starting at oﬀset do
if wd ∈ Funcs then
vt ← vt ∪(cid:104)i, wd(cid:105)
i ← i + 1
else
2
3
4
5
6
7
8
9
10
14
15
16
17
18
19
20
21
2
3
4
5
6
7
8
9
10
11
break
return vt
Algorithm A.2: Identify and Extract Constructors
input : Funcs: set of functions from the binary
Vtables: set of virtual function tables
output: Ctors: set of constructors
1 foreach func ∈ Funcs do
foreach insn ∈ getInstructions(func) do
if writesMemory(insn) then
src ← getSrcExpr(insn)
dst ← getDstExpr(insn)
if isDefined(src) and getDisp(dst) = 0 and
firstArg(dst) then
vt ← Vtables[src]
if vt (cid:54)= ∅ then
if getOffset(func) /∈ vt then
// ctor cannot be in vt
Ctors ← Ctors ∪ func
B. EXAMPLE SNIPPET AND POLICY
Figure B.1 shows an example C++ program,
its corre-
sponding assembly dump, and the policy semantics injected
by VCI at the vcall site. The corresponding ﬁltered PDG
generated by VCI is shown in Figure B.2.
Algorithm A.3: Reconstruct Class Layout
input : cls: initial class layout
Ctors: set of constructors
output: cls: populated class layout
1 oﬀset ← 0
2 foreach insn ∈ getInstructions(cls.ctor) do
3
4
5
6
7
8
9
if isCall(insn) then
dst ← getCallTarget(insn)
if dst ∈ Ctors then
mThis ← findThis(dst)
oﬀset ← calcOffset(cls.this, mThis)
deref ← storesThis(cls, mThis)
addToLayout(cls, oﬀset, dst, deref)
10 return cls
Algorithm A.4: Intra-procedural Type-Vcall Pairing
input : Ctors: set of constructors
Funcs: set of functions from the binary
result : Pairing information between classes and vcalls
3
4
2
1 foreach func ∈ Funcs do
foreach call ∈ func do
foreach param ∈ findParams(call) do
slice ← backwardSlice(param)
foreach entryNode ∈ slice do
def, Adjs ← reaches(entryNode, exitNode)
if def (cid:54)= ∅ then
cls ← resolve(def, Adjs, func, Ctors)
pair(cls, param, call, Adjs)
5
9
6
7
8
10
11
else
pair(∅, param, call, Adjs)
C. ABI DEPENDENCY
The C++ Application Binary Interface (ABI) sets the in-
terface between program modules and the execution envi-
ronment at the assembly level. It deﬁnes things such as the
memory layout of objects, details of how virtual functions
are invoked, and the behavior of the linking stage. The most
adopted C++ ABI is the Itanium ABI [21], which is the fo-
cus of this work. The Itanium ABI is used by all Linux
compilers. Alternatively, the MSVC compiler on Windows
uses the MSVC ABI which was internally developed by Mi-
crosoft. The two ABIs mainly diﬀer in their choice of calling
conventions and the layouts of vtables in memory. Never-
theless, the approach discussed in this paper can also be
applied to MSVC C++ binaries by adjusting the algorithms
to accommodate the rules of MSVC.
D. WHY NOT DEPEND ON RTTI?
C++ supports dynamic type reporting, i.e., identifying and
checking the actual type of an object at runtime (as op-
posed to at compile-time). This is enabled by what the
ABI calls “Runtime Type Information” (RTTI). RTTI en-
ables the program to dynamically identify and cast objects
at runtime, via the typeid and the dynamic_cast operators,
respectively. For each polymorphic class, an RTTI record is
added to the class layout in memory, and a pointer to that
152push
movl
cmp
jne
movl
call
mov
movl
mov
call
mov
jmp
77d:
...
79b:
...
; compare x
7a7:
7aa:
; if x == 0:
7ac:
7b3:
7b8: