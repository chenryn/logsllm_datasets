代码，
3)
其实还有-
５5８℃
83 c4 08
b8 00
c7 
co
５
８f５８
8
88
8
88
5
: code for function bar:
ｄｄ3
6
0
3
L
-59
于
3
6868
3
6
.5
：
61
04 24
2%
b)
c1
44
ec
 24 
08
 3);
fc
ff
孖记
8
08
add
mov
mov
sub
00０0
02
0403
04
foo
ff
ff
0
d;
ff
调
00
00
%edx, %eax'
%ebp
这时在gdb中打印函娄
00
00
我们用
mo
push
mov
3.
movl
movl
L
t
ave
gdbi
跟踪禾
$0x8,%esp
$0x8,%esp
$0x0,%eax
$0x3,0x4(%esp)
%ebp
'S
0
%eax
Oxc(%ebp),%eax
数栈帧。
这
esp,%ebp
0x4(%ecx)
CX
程
这样只生成汇编代码main.s，
4(%ecx),%esp
序的执行，
直到bar函数中
295
而
---
## Page 296
分析这些数据在栈空间的布局，根据gdb的输出结果图示如下[29]:
程分配一块栈空间来保存函数栈帧，ésp寄存器总是指向栈顶，
地址增长的
K
前面要加个,
医
用
数
用disassemble命令是反汇编当前函数，
区里又用到几个新的gdb命令。disassemble可以反汇编当前函数或者指定的函数，
条指
图19.1.函数栈帧
以前我
0x00000003
Oxbff1c414:
Oxbff1c3f4:
6
8.8.8.
xea
0x080483a9 :
0x080483a8
0x080483a5
0x080483a2 :
(gdb)
0x00000001
C
0xbff1c424
C
C
0x00000005
(gdb) x/20 $esp
(gdb) info registers
(gdb) si
 (qp6)
End
令地单步调试
(gdb）
off1c404:
d
x
bar
我们知道每次调用一个函数都要分配一个栈帧来保存参
例如p $esp可以打印esp寄存器的值,
bt
讲过
Si
S1
0
183c2
0x7b
0x73
0x80482e0
0x8048410
0xbff1c404
0xbff1c3f
0xbff1c440
0x5
0x080482e0
0xbff1c440
0xbff1c428
0xbff1c414
0x00000000
return e;
3
3
3
 foo
 at
(a=2
一行代码-
12
5
ret
leave
mov
mov
PF IF ID
如果disassemble命令后面跟函数名或地址则反汇编指定的
8
3
3
3
5
一行代码地单步调试，
134313999
0xbff1c6f7
0x80483a8
0xbff1c404
-1208061964
0xbff1c498
Oxbff1c498
0x080483c2
-1074674624
0x080483e9
int 
int e
int 
e
e
.在上例中esp寄存器的值是0xbff1c3f4,
=c+
:=c+d;
=
Ω+
P
d;
在x86平台上这个栈是从高地址向低
0xb7ea3685
0xb7ea3685
0x00000002
0x00000002
0xb7efbdae
参数和局部变量，现在我们详细
而这里用到的si命令可以-
单独
 操作系统为进
所
8
条
---
## Page 297
栈操作随时变化，
新值。在每个函数的栈帧中,
令把这个值传送给ebp寄存器。这两条指令合起来是把原来ebp的值保存在栈上,
现在看foo函数的汇编代码：
在esp指向的内存位置，
要调用函数foo先要把参数准备好，
元的起始地址。我们从main函数的这里开始看起：
是0xbff1c420~0xbff1c423，我把地址写在每个小方格的下边界线上，
图中每个小方格表示4个字节的内存单元,
1．foo函数调用完之后要返回到cal1的下一条指令继续执行，
，例如foo函数的参数a和b分别通过ebp+8和ebp+12来访问。所以下面的指令把参数a和b再次压
bfiC34t
bff1c3f8
bffl1c3fc
bff1c400
bff1c404
bff1c408
bff1c40c
bff1c410
bff1c414
bff1c418
bff1c41c
bff1c420
bff1c424
80483aa:
int foo(int a, int b)
80483ad:
80483ab:
80483e9:
80483e4:
80483d5:
高地址
return 0;
foo(2， 3);
ebp(main)
ebp(foo)
80483c2
80483e9
e:
C: 2
d:3
a:2
m
，可见参数是从右向左依次压栈的。然后执行cal1指令，这个指令有两个作
55
b８０００00000
e8
esp(bar)
ebp(bar)-
esp(foo)
ebp(foo)====
6
esp(main)
ebp指向栈底，
L
ec
e5
c1
04
：08
，函数的参数和局部变量都是通过ebp的值加上一
，第二个参数保存在esp+4指向的内存位置,
同时把esp的值减4。ésp的值现在是0xbff1c414，
例如b：3这个小方格占的内存地址
的栈帖
bar函数
的栈帧
foo函数
main
而esp指向栈顶，
sub
mov
push
mov
movl
$0x8,%esp
%esp,%ebp
%ebp
 所以把cal1的下一条指令的地
$0x0,%eax
$0x3,0x4(%esp)
，是为了强调该地址是内存单
 第一个参数保存
，然后又给ebp赋
一个偏移量来访
下一条指
---
## Page 298
最后是ret指令，它是cal1指令的逆操作:
存器中。然后执行leave指令，
bar函数有一个int型的返回值，
现在看bar函数的返回指令:
的ebp保存在栈上的值,
现在看bar函数的指令：
数的ebp保存在栈上的值，
了：如果我当前在bar函数中，我可以通过ebp找到bar函数的参数和局部变量，
在gdb中可以用bt命令和frame命令查看每层栈帧上的参数和局部变量，
再把eax寄存器存回局部变量e的内存单元。
以后面几条指令的意思是把参数e和a取出来存在寄存器中做加法，
这次又把foo函数的ebp压栈保存,
2.修改了程序计数器eip，因此跳转到返回地址0x80483c2继续执行。
1．现在esp所指向的栈顶保存着返回地址，
2
1．把ebp的值赋给esp，现在esp的值是0xbff1c404。
，为调用bar函数做准备，
成0xbff1c40c。
值变成0xbff1c408。
现在esp所指向的栈顶保存着foo函数栈帧的ebp，
6808,
80483a5:
804839a:
8048395:
int bar(int c, int d)
80483a2:
80483a0:
804839d:
8048397:
8048394:
80483bd:
8
80483b0:
30483ba:
8
80483b7:
30483b3:
8
return e;
int e =
因此各层函数栈帧通过保存在栈上的ebp的值串起来了。
8
8b 45 fc
c3
8
01
8b
89
55
e8
88
8
，然后把返回地址压栈，调用bar函数：
６q
6
，这个返回值是通过eax寄存器传递的，
P
然后给ebp赋了新值,
10
fc
孖亿
48
0
:（g
ff 
04
ff
，把这个值恢复给eip，
 又可以找到它的参数和局部变量，
，把这个值恢复给ebp，同时esp增加4，esp的
leave
ret
mov
指向bar函数栈帧的栈底，
mo
call
mov
1
M
-0x4(%ebp),%eax
0x8(
Oxc(%ebp),%edx
，计算结果保存在eax寄存器中,
 同时esp增加4，esp的值变
(%ebp),%eax
 所以首先把e的值读到eax寄
 现在可以解释它的工作原理
%eax
，也可以找到foo函
也可以找到main函
通
28
数
所
---
## Page 299
们再看一个参数类型不符的例子：
把本节的例子改成这样：
译器不会对函数调用做检查，
1、在第2节“自定义函数"讲过，
习题 请点评
Interface)
Convention,
须这么传，只是操作系统和编译器选择了以这样的方式实现C代码中的函数调用，这称为Calling
这些规则并不是体系结构所强加的，
重复同样的过程，
地址0x80483c2处是foo函数的返回指令:
3．返回值通过eax寄存器传递。
2．ebp总是指向当前栈帧的栈底。
1．参数压栈传递，并且是从右向左依次压栈。
int main(void)
#include 
int bar(int c, int d)
int foo(int a, int b)
int main(void)
:2058108
的一
t far();
，Calling Convention是操作系统二进制接口规范（ABl，Application Binary
一部分。