title:On the TOCTOU Problem in Remote Attestation
author:Ivan De Oliveira Nunes and
Sashidhar Jakkamsetti and
Norrathep Rattanavipanon and
Gene Tsudik
On the TOCTOU Problem in Remote Attestation
Ivan De Oliveira Nunes
Sashidhar Jakkamsetti
UC Irvine
USA
Rochester Institute of Technology
USA
Norrathep Rattanavipanon
Prince of Songkla University
Thailand
ABSTRACT
Much attention has been devoted to verifying software integrity of
remote embedded (IoT) devices. Many techniques, with different
assumptions and security guarantees, have been proposed under
the common umbrella of so-called Remote Attestation (RA). Aside
from executable’s integrity verification, RA serves as a foundation
for many security services, such as proofs of memory erasure, sys-
tem reset, software update, and verification of runtime properties.
Prior RA techniques verify the remote device binary at the time
when RA functionality is executed, thus providing no information
about the device binary before current RA execution or between
consecutive RA executions. This implies that presence of transient
malware (in the form of modified binary) may be undetected. In
other words, if transient malware infects a device (by modifying
its binary), performs its nefarious tasks, and erases itself before the
next attestation, its temporary presence will not be detected. This
important problem, called Time-Of-Check-Time-Of-Use (TOCTOU),
is well-known in the research literature and remains unaddressed
in the context of hybrid RA.
In this work, we propose Remote Attestation with TOCTOU
Avoidance (RAT A): a provably secure approach to address the
RA TOCTOU problem. With RAT A, even malware that erases it-
self before execution of the next RA, can not hide its ephemeral
presence. RAT A targets hybrid RA architectures, which are aimed at
low-end embedded devices. We present two variants – RAT AA and
RAT AB – suitable for devices with and without real-time clocks,
respectively. Each is shown to be secure and accompanied by a
publicly available and formally verified implementation. Our eval-
uation demonstrates low hardware overhead of both techniques.
Compared with current hybrid RA architectures – that offer no TOC-
TOU protection – RAT A incurs no extra runtime overhead. In fact,
it substantially reduces the time complexity of RA computations:
from linear to constant time.
CCS CONCEPTS
• Security and privacy → Embedded systems security; For-
mal security models; Logic and verification; Security protocols.
Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for third-party components of this work must be honored.
For all other uses, contact the owner/author(s).
CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea
© 2021 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-8454-4/21/11.
https://doi.org/10.1145/3460120.3484532
Gene Tsudik
UC Irvine
USA
KEYWORDS
Remote Attestation; TOCTOU attacks; Hardware Security Mon-
itor; Formal Verification; Linear Temporal Logic; Cryptography;
Reduction Proofs
ACM Reference Format:
Ivan De Oliveira Nunes, Sashidhar Jakkamsetti, Norrathep Rattanavipanon,
and Gene Tsudik. 2021. On the TOCTOU Problem in Remote Attestation. In
Proceedings of the 2021 ACM SIGSAC Conference on Computer and Commu-
nications Security (CCS ’21), November 15–19, 2021, Virtual Event, Republic of
Korea. ACM, New York, NY, USA, 16 pages. https://doi.org/10.1145/3460120.
3484532
1 INTRODUCTION
In the last two decades, our society is gradually becoming sur-
rounded by, and dependent upon, a multitude of specialized com-
puting devices that perform a wide range of functions in many
aspects of everyday life. They are often referred to as embedded,
“smart", CPS or IoT devices, and they vary widely in terms of compu-
tational, storage and communication abilities. However, regardless
of their purposes and resources, these devices have become popular
targets for malicious exploits and malware.
At the low-end of the spectrum, Micro-Controller Units (MCUs)
are designed with strict constraints on monetary cost, physical
size, and energy consumption. These MCUs exist on the edge of
more complex systems, typically interfacing digital and physical
domains, and often implementing safety-critical sensing and/or
actuation functions. Two prominent examples of such MCUs are: TI
MSP4301 and Atmel ATMega AVR2. It is unrealistic to expect such
devices, by themselves, to prevent malware infection via sophisti-
cated security mechanisms (similar to those available on laptops,
smartphones, or relatively higher-end/higher-power embedded sys-
tems3). In this landscape, Remote Attestation (RA) emerged as
an inexpensive and effective means to detect unauthorized modifi-
cations to executables of remote low-end devices. Also, RA serves
as a foundation for other important security services, such as soft-
ware updates [1, 2], control-flow integrity verification [3–5], and
proofs of remote software execution [6]. Generally speaking, RA
allows a trusted entity, called a Verifier (Vrf), to ascertain memory
integrity of an untrusted remote device, called Prover (Prv). As
shown in Figure 1, RA is typically realized as a (deceptively) simple
challenge-response protocol:
1http://www.ti.com/microcontrollers/msp430-ultra-low-power-mcus/applications.
html
2https://www.microchip.com/design-centers/8-bit/avr-mcus
3For instance, higher-end devices such as Raspberry Pi, Tessel, and similar, are usually
2-to-3 orders of magnitude more expensive in terms of monetary cost, physical size,
and energy consumption than the MCUs targeted in this work.
 This work is licensed under a Creative Commons Attribution International 4.0 License. CCS '21, November 15–19, 2021, Virtual Event, Republic of Korea. © 2021 Copyright is held by the owner/author(s). ACM ISBN 978-1-4503-8454-4/21/11. https://doi.org/10.1145/3460120.3484532  Session 11A: Attestation and Firmware Security CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2921(1) Vrf sends an attestation request with a challenge (Chal) to
Prv. This request might also contain a token derived from a
secret that allows Prv to authenticate Vrf.
(2) Prv receives the request and computes a Chal-based authen-
ticated integrity check over a pre-defined memory region. In
low-end embedded systems (and in the context of this paper)
this region corresponds to the entire executable memory, i.e.,
program memory. See Section 3.1.
(3) Prv returns the result to Vrf.
(4) Vrf receives the result and checks whether it corresponds
to a valid memory state.
Vrf
Prv
r
e
q
resp
Authenticated integrity check
Figure 1: Timeline of a typical RA protocol
The authenticated integrity check requires some type of integrity-
ensuring function, typically implemented as a Message Authenti-
cation Code (MAC), computed over Prv attested memory region.
Computing a MAC requires Prv to have a unique secret key, de-
noted by K– a symmetric key shared with Vrf, or a private key for
which the corresponding public key is known to Vrf. K must reside
in secure storage, and be inaccessible to any software running on
Prv, except for privileged and immutable attestation code. Since
the usual RA threat model assumes a fully compromised software
state on Prv, secure storage implies some level of hardware support.
Hybrid RA (based on hardware/software co-design) [7–10] is an
approach particularly suitable for low-end embedded devices. In
hybrid RA designs, the integrity-ensuring function is implemented
in software, while hardware controls execution of this software,
detecting any violations that might cause unexpected behavior or
K leakage. In a nutshell, hybrid RA provides the same security
guarantees as (more expensive) hardware-based RA approaches
(e.g., those based on a TPM [11] or other standalone hardware
modules), while minimizing modifications to the underlying hard-
ware platform. We overview a concrete hybrid RA architecture in
Section 3.2.
Despite much progress, current hybrid RA architectures share
a common limitation: they measure the state of Prv executables
at the time when RA is executed by Prv. They provide no infor-
mation about Prv executables before RA measurement or its state
in between two consecutive RA measurements. We refer to this
problem as Time-Of-Check Time-Of-Use or TOCTOU. While vari-
ants of this problem have been discussed before [12–16], it remains
unsolved in the context of hybrid RA.
We emphasize that the RA–TOCTOU problem (as formulated in
this paper) should not be confused or conflated with the problem of
ensuring temporal consistency between attestation and execution
of a binary, which is solved by runtime attestation approaches, e.g.,
[3–6]. Nonetheless, RA of binaries (i.e., static RA) is still relevant
in that context because most runtime attestation techniques for
low-end devices rely on static RA as a building block (one exception
is [17], which, instead, assumes that binaries never change 4). In
4In many settings involving low-end MCUs this assumption is unrealistic. See Section 2
for details.
fact, as we discuss in Section 8, an RA architecture secure against
TOCTOU makes runtime attestation techniques that rely on static
RA substantially more efficient.
In practice, the TOCTOU problem leaves devices vulnerable to
transient malware which erases itself (its executable) after complet-
ing its tasks. This is harmful in settings where numerous MCUs
report measurements collected over extended periods. For example,
consider several MCU-based sensors that measure energy consump-
tion in a smart city, where large scale erroneous measurement may
lead to power outages. If regular RA schemes that are not secure
against TOCTOU are used in this case (e.g., by performing RA once
a day, or once per billing cycle), security can be subverted by: (i)
changing sensor software to spoof measurements during regular
usage, and (ii) reprogramming the sensor back with the expected
executable, with both (i) and (ii) occurring in the period between
consecutive RA instances. In particular, since the RA request must
be received through an untrusted communication channel, malware
may simply erase itself upon detecting an incoming attestation re-
quest, even if the RA schedule is unknown a priori. As noted earlier,
in settings where detection of runtime violations (e.g., code-reuse
and data corruption attacks) is also desirable (e.g., MCU code is
written with memory-unsafe languages), TOCTOU-Security of the
underlying static RA makes the overall runtime attestation more
efficient; see Section 8.
Our approach to mitigating the TOCTOU problem is based on the
observation that current hybrid RA techniques use trusted hard-
ware only to detect security violations that compromise execution
of RA software itself and take action (e.g., by resetting the device)
if such a violation is detected. Whereas, RAT A main new feature
is the use of a minimal (formally verified) hardware component
to additionally provide historical context about the state of Prv
program memory. This is achieved via secure logging of the latest
timing of program memory modifications in a protected memory
region that is also covered by RA integrity-ensuring function. This
enables Vrf to later check authenticity and integrity of Prv mem-
ory modifications. This new feature is integrated seamlessly into
the underlying RA architecture and the composition is shown to
be secure. We believe this results in the following contributions:
– RA TOCTOU-Security Formulation: We motivate and formalize
TOCTOU in the context of RA. We define RA TOCTOU-Security
using a security game (see Definition 4.1) and discuss why current
RA techniques based on consecutive self-measurements do not
satisfy this definition. We believe our work to be the first formal
treatment of this matter. Furthermore, we evaluate practicality of
RA techniques based on consecutive self-measurements and argue
that using them to obtain TOCTOU-Security incurs extremely high
runtime overhead, possibly starving benign applications on Prv.
– Design, Implementation & Verification: We propose two tech-
niques: RAT AA and RAT AB. The former assumes that Prv has a
secure read-only Real-Time Clock (RTC) synchronized with Vrf.
Since this assumption is unrealistic for many low-end Prv-s, RAT AB
trades off the need for a secure RTC for the need to authenticate
incoming attestation requests; in fact, this feature is already part of
several hybrid RA architectures.
We show that both techniques satisfy the formal definition of
TOCTOU-Security, assuming that their implementations adhere to a
set of formal specifications, stated in Linear Temporal Logic (LTL).
Session 11A: Attestation and Firmware Security CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2922Finally, the implementation itself is formally verified to adhere
to these LTL specifications, yielding security at both design and
implementation levels. Our implementation is publicly available
at [18]. It is realized on a real-world low-end MCU (TI MSP430) and
is deployed using commodity FPGAs. Experimental results show
low hardware overhead, affordable even for cost-sensitive low-end
devices.
– Enhancements to RA and Related Services: We discuss the
implications of RAT A on RA and related services beyond TOCTOU-
Security. In particular, we show that RAT A can, in most cases, lower
RA computational complexity from linear (in terms of attested
memory size) to constant time, resulting in significant savings. We
also discuss RAT A benefits for specialized RA applications: (i) real-
time systems; (ii) run-time integrity/control-flow attestation; and
(iii) collective RA, where a multitude of provers need to be attested
simultaneously.
2 SCOPE
This section delineates the scope of this paper in terms of targeted
devices and desired security properties.
Low-End Devices: This work focuses on CPS/IoT sensors and
actuators (or hybrids thereof) with low computing power. These
are some of the smallest and weakest devices based on low-power
single-core MCUs with only a few KBytes of program and data
memory. Two prominent examples are: Atmel AVR ATmega and TI
MSP430: 8- and 16-bit CPUs, typically running at 1-16MHz clock
frequencies, with ≈ 64 KBytes of addressable memory. SRAM is
used as data memory with the size normally ranging between 4 and
16KBytes, while the rest of address space is available for program
memory. Such devices usually run software atop “bare metal” and