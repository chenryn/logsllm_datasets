3.1 Introductiontobitmapindexing
paper takes the bitmap index compression algorithm
The concept of bitmap index was first introduced by
as a starting point for understanding traffic-archiving
Spiegler and Maayan in 1985[29]. The first commercial
systems.
databaseproductwaspublishedtoimplementabitmap
3 Key Technologies of Bitmap Index index in 1987[30–35]. It uses a sequence of bits to
CompressionCoding indicate the the presence or absence of an item
in the indexed data. With bitmap indexing, logical
Efficientindexingofnetworkpacketsorflowiscentral operations, such as AND, OR, NOT, and XOR, can
to traffic archiving systems. Indexing of traffic data be used to answer complex queries. Bitmap index
has the following characteristic: (1) Large volume of once was designed for scientific data and database,
data: The number of index messages is massive, even which is usually generated by scientific instruments
for brief periods. (2) High rates of incoming data: or scientific simulation. Scientific data are extremely
To keep up with the rate of packet influx, systems large and without further modification change. Bitmap
must be highly efficient. (3) Fixed data structure: The index databases solve the problem on how to quickly
index information for each network packet has a fixed identify a small amount of selected data in a mass
format with a fixed length. (4) Appending without of scientific data, while the traditional relational
modification: Network packet index information will databaseisnotsuitableforthiswork.Thetechnologies
increase only. Once the information is generated, it used in bitmap index databases are bitmap indexing,
can’t be changed. (5) High redundancy: Data items of bitmapcompression,andclassification.Inbitmapindex
networkdataarefrequentlyrepeated. database, the data are stored in columnar and a
Due to the characteristics of network flow data, corresponding bitmap index is therein. A bitmap index
relational databases are not appropriate for this exampleisshowninTable4.
Table3 Acomparisonofdifferenttraffic-archivingsystems.
Dataformat Indexing Storage
System
Packet Flowrecord Bitmap Hash Tree Columnbased Rowbased
TelegraphCQ[17] No Yes PostgreSQL(DBS) No No
Gigascope[18] No Yes No No Yes No No
MIND[19] No Yes No Yes No No No
Hyperion[20] Yes No BloomFilter Multi-levelindexing No No No
FastBit[21]+TelegraphCQ No Yes WAH,PostgreSQL(DBS) Yes No
TimeMachine[22] Yes No No Yes No No Yes
NET-FLi No Yes COMPAX No No LZO No
NetStore[23] No Yes No No No Segmentation No
RASTERZip[24] No Yes Yes No No Yes No
PcapIndex[25] Yes No COPMAX No No Yes No
TifaFlow[26–28] Yes No Yes No No No No
ZhenChenetal.: ASurveyofBitmapIndex-CompressionAlgorithmsforBigData 105
Table4 Anexampleofabitmapindexwhichconsistsofsix the various bitmap index compression algorithms in
tuples(rows).Thecolumnasaattributecanhaveoneoffour chronologicalorder.
values,0,1,2,and3.
3.2 Categories of bitmap index compression
Bitmapindex
Row Column algorithms
=1 =2 =3 =4
1 1 1 0 0 0 To summarize the characteristics of bitmap index
2 2 0 1 0 0
compression algorithms, we compare the bitmap index
3 4 0 0 0 1
compressionalgorithmsbasedondifferentdimensions,
4 3 0 0 1 0
i.e., Segmentation, Chunking, Merge Compress, and
5 2 0 1 0 0
NearIdentical(NI),asshowninTable5.
6 4 0 0 0 1
3.3 Bitmapindexcompressionalgorithms
Currently, classical bitmap index compression
3.3.1 BBC
algorithms are Byte-aligned Bitmap Compression
(BBC)[36], Word-Aligned Hybrid (WAH)[37,38], Antoshenkov[36] proposed the byte-aligned bitmap
Position List Word-Aligned Hybrid (PLWAH)[39], compression method in 1995, the bitmap bytes are
Enhanced Word-Aligned Hybrid (EWAH)[40], classified as gaps and maps. Gaps containing only
COmpressed N Composable Integer SEt 0’s or only 1’s and maps containing a mixture of
(CONCISE)[41], Partitioned Word-Aligned Hybrid both.Continuousgapsareencodedbytheirbytelength
(PWAH)[42], COMPressed Adaptive indeX and a fill bit is used to differ 0 and 1 gaps. Map bytes
(COMPAX)[43], UCB[44], VLC[45], VAL-WAH[46], are directly compiled after the control byte without
RoaringBitmap[47],RLH[48],andDFWAH[49].Thereare encoding. A pair (gap, map) is encoded into a single
improved versions of PLWAH (PLWAH with adaptive atomwhichiscomposedas“controlbyte+gaplength+
counter), such as PLWAH+[50] and APLWAH. An map”.Controlbytecanbedividedintofourcategories:
improved version of COMPAX (COMPAX + oLSH (1) The bitmap bytes which contain 0-3 gaps and 0-
and COMPAX2) has also presented. Figure 4 shows 15mapscanbeencodedasfollows:
1[fillbit][filllength(2bits)][taillength(4bits)].
A fill bit is used to represent all 0’s or all 1’s; fill
length is used to represent the length of gap; and tail
lengthisusedtoindicatethelengthofamap.
(2) Bitmap bytes that contain 0-3 gaps, with 1 bit
differentbetweenthegapandthemap,canbeencoded
asfollows:
01 [fill bit] [fill length (2 bits) ] [odd bit position (3
bits)].
“Odd-bit position” is the different 1 bit (dirty bit)
positionbetweenthemapandthegap.
Fig. 4 The advancement of bitmap index compression
algorithm. (3) Bitmap bytes that contain more than 3 gaps and
Table5 Bitmapindexencodingalgorithms.
MergeCompress NearIdentical
Chunking
Methods Segmentation Dirtybits Dirtybytes
(bit) Piggyback LFL/FLF
NI-0 NI-1 NI-0 NI-1
BBC No 8 Yes No Yes Yes No No
WAH No 31 No No No No No No
EWAH No 31 No No No No No No
PWAH No 63 Yes No No No No No
PLWAH No Yes Yes No Yes No No No
CONCISE No Yes Yes No Yes No No No
COMPAX Yes 31 No Yes No No No Yes
SECOMPAX Yes 31 Yes Yes No No Yes Yes
ICX Yes 31 Yes Yes No No Yes Yes
MASC Yes No No Yes No No Yes Yes
PLWAH+ Yes No Yes Yes Yes Yes No No
106 TsinghuaScienceandTechnology,February2015,20(1):100-115
0-15mapscanbeencodedasfollows: indicates which clean word will follow, and 16bits are
001[fillbit][taillength(4bits)]. usedtostorethenumberofcleanwords.Theremaining
Gaplengthsfollowthecontrolbyte. 15bits are used to store the number of dirty words
(4) Bitmap bytes that contain more than 3 gaps with followingthecleanwords.
1 bit different between the gap and the map can be BecauseEWAHusesonly16bitstostorethenumber
encodedasfollows: ofcleanwords,itmaybelessefficientthanWAHwhen
0001[fillbit][oddbitposition(3bits)]. there are many consecutive sequences of clean words.
3.3.2 WAH Three ways are proposed to alleviate this compression
overhead over clean words. First, more than half of
WAH is the default bitmap index compression
the bits can be allocated to encode the runs of clean
algorithminFastbitdatabase.Itmakesthebitsequences
words. Second, when a marker word indicates a run
into31bits(63bitsforWAH64)asagroup.Thereare
of 216 clean words, the next word will be used to
two types of group: original Literal, which contains 0
indicatethenumberofremainingcleanwords.Finally,
and1in31bits;andoriginalFill,whichcontainsall0’s
thiscompressionpenaltyislessrelevantwhenusing64-
or all 1’s in 31bits. Literal group: The type flag is 0;
bitwordsinsteadof32-bitwords.
theremaining31bitsaretheoriginalLiteralgroup.Fill
When there are few dirty words in the bitmaps,
group: Dividedinto1-Filland0-Fill.Thetypeflagis1,
WAH might be preferable. Even considering EWAH
andthesecondbitisthesignofFilltype(0-Fillis0,1-
andWAHindexesofsimilarsizes,eachEWAHmarker
Fill is 1). The remaining 30bits are a counter, which
wordneedstobeaccessedthreetimestodeterminethe
indicates the number of consecutive 0-Fill (or 1-Fill)
running bits and two running lengths, while no word
groups.
needstobeaccessedmorethantwicewithWAH.When
3.3.3 PLWAH
therearelotsoflongrunsofdirtywordsinthebitmaps,
PLWAHgroupsthebitsequenceinto31-bitunits.There
EWAH might be preferable. EWAH will access each
are Literal and Fill groups, but there are some changes
dirty word at most once, while WAH needs to check
in compression. In WAH, there are an extra flag
the first bit of each dirty word to ascertain it is a dirty
to distinct Fill group and Literal group, and each
word.TheEWAHdecodercanskipasequenceofdirty
group codes as 32 bits. For Fill groups, the lower
words,whiletheWAHdecodermustaccessthemall.
25 bits are a counter. By introducing the definitions
3.3.5 CONCISE
of “nearly identical” and “position list”, PLWAH
CONCISE is based on WAH. In a compressed 32-
further enriches the codebook, increasing the encoding
bit segment, when the leftmost bit is 1, the following
types and improving compression efficiency. A slight
31bits are uncompressed; when the leftmost bit is 0,
improvement over PLWAH is achieved by the method
it means Fill, and the second bit indicates the type
of“PLWAH+adaptivecounter”.Whenthereisalarge
of Fill. The following 5bits are the position of a
number of consecutive 0’s or 1’s, so that a word can’t
“flipped”bitwithinthefirst31-bitblockoftheFill.The
fullyaccommodateacounter,thismethodusesthesame
remaining 25bits count the number of 31-blocks that
typeoftwoconsecutiveFill-word,makingtwocounters
composethefillminusone.Whenpositionbitsequal0
into a single large counter. The first Fill-word records
(binary ‘00000’), the word is a “pure” fill. Otherwise,
the 25 least-significant bits, and the second Fill-word
position bits indicate the bit to switch within the first
records the 25 most-significant bits. Meanwhile, the
31-bit block of the sequence represented by the Fill
position list of the first Fill-word is empty, and the
word. Thatmeansthat1(binary‘00001’)indicatesthat
position list of the second Fill-word is calculated as
ithastofliptherightmostbit,while31(binary‘11111’)
usual.
indicatesthatithastofliptheleftmostbit.
3.3.4 EWAH
3.3.6 PWAH
EWAH defines a 32-bit field that contains consecutive
BasedonWAH,PWAHextendswordlengthto64bits,
0’s or 1’s as a “clean” segment and defines a 32-
and makes a word into P pieces, starting with a P-
bit field that contains mixed 0’s and 1’s as a “dirty”
bit header, which is used to indicate the type of Fill or
segment. EWAH algorithm also uses two types of
Literal. The length of Literal can be indicated flexibly
words, where the first type is a 32-bit verbatim word;
tosavespace.
thesecondtypeofwordisamarkerword,whosefirstbit
ZhenChenetal.: ASurveyofBitmapIndex-CompressionAlgorithmsforBigData 107
There are three kinds of PWAH algorithm, PWAH- algorithm can be classified as two types. According
2, PWAH-4, and PWAH-8. PWAH-2 uses WAH to these categories, the state-of-the-art bitmap index
compression coding. In the experiments, PWAH-8 is compressionalgorithmsareshowninFig.5.
used more frequently than the others. Combined with (1) Scope Extended COMPAX (SECOMPAX)
the Nuutila algorithm[51], PWAH-8 can be effective in SECOMPAX[52] is based on COMPAX2, an enhanced
solving the accessibility query problem of large-scale version of COMPAX. The differences are as follows:
graphs. (a) Nearly Identical Literal (NI-L) SECOMPAX
extends the “dirty byte” concept to consist of 0-NI-L
3.3.7 COMPAX
and1-NI-L,i.e.,aLiteralwordcanbenearlyidenticalto
TherearemorecodewordsinCOMPAXcodebook.The
a0-Fillwordora1-Fillword.Thismaintainssymmetry
definitions of Literal and Fill are same as that of
in the codebook. (b) Extended LFL: In addition to the
WAH and PLWAH. Every 31 bits are a chunk, and
0-NI-L+F+0-NI-Ltype,therearethreeothers: 0-NI-
the chunks are divided into four groups according to
L+F+1-NI-L,1-NI-L+F+0-NI-L,and1-NI-L+F+
the following features: (1) Literal-Fill-Literal (LFL);
1-NI-L. Extended FLF: In addition to the 0F + 0-NI-L
(2) Fill-Literal-Fill (FLF); (3) Fill (F); and (4) Literal
+ 0F1F+0-NI-L+1F type, there are six others: 0F + 1-
(L). The COMPAX+oLSH (online-Locality-Sensitive-
NI-L + 0F, 1F + 1-NI-L + 1F; 1F + 1-NI-L + 0F, 0F +
Hashing) compression method is the same as that of
1-NI-L+1F;1F+0-NI-L+0F,and0F+0-NI-L+1F.
COMPAX, but this compression method needs the
By the inclusion of new codewords, some kinds
reordering of input data stream in advance, which
of origin sequences that COMPAX cannot further
improvescompressionrateconsiderably.
compresscanbedealtwithbySECOMPAX:
3.3.8 SECOMPAX/ICXandMASC/PLWAH+
(a) In the form of FLF, if two Fill words are of
3.3.8.1 Newideasinbitmapindexencoding different types, or a Literal word is nearly identical
SECOMPAX/ICX and MASC/PLWAH+ are proposed to Fill word, COMPAX does not try to encode them
based on COMPAX/PLWAH. SECOMPAX/ICX is as FLF. COMPAX encodes them as an F, an L,
based on COMPAX2, introduces the concept of and an F, while SECOMPAX can encode them as