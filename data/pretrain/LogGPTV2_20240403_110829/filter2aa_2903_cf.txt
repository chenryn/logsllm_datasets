1992年，英特尔公司发布了第一个版本的PCI总线标准。很快，PCI
接口的显卡陆续出现。直到今天，大多数显卡和GPU都是以PCI设备的
身份出现在计算机系统中的。
每个PCI设备都有一段配置空间，最初是256字节，在PCIe中有所扩
展。通过GPU设备的PCI配置空间，可以访问一些基本的信息，或者进
行更改，包括调整MMIO空间的位置。
综上所述，设备寄存器有多种，最古老的是I/O端口形式，今天主
要使用的是映射到物理内存空间的MMIO方式，个别时候使用PCI配置
空间。
设备寄存器的宽度不等，一般从1字节到8字节，大多数是4字节
（32位）。在GPU的四大功能中，显示部分最老，也是至今仍主要使用
设备寄存器方式与CPU交互的部分。
8.3.2 批命令缓冲区
通过设备寄存器不适合传递大量信息。因为频繁访问不仅速度慢，
而且会影响GPU的其他用户。以3D渲染任务为例，需要向GPU传递很
多参数和命令，如果游戏A直接把这些命令和参数直接写给GPU，那么
就会影响其他游戏。解决这个问题的方法是批命令缓冲区，先把每个程
序需要执行的命令放入命令缓冲区中，全部命令准备好了之后，再提交
给GPU。今天的GPU普遍支持这种批命令的方式。比如，在图8-5所示
的G965框图中，矩形框代表GPU，顶上从外到内的箭头代表GPU通过
内存接口（MI）从外部接收命令流。箭头下方的CS代表命令流处理器
（Command Streamer）。
图8-5 G965 GPU的逻辑框图
图8-5中，中间的GEN4子系统中包含了通用执行单元（EU），两
侧分别是固定功能的3D流水线和媒体流水线。CS负责把命令分发给不
同的执行流水线。第11章将详细介绍英特尔GPU和GEN架构。
8.3.3 状态模型
上面介绍的批命令缓冲区解决了成批提交的问题，可以让GPU的多
个用户轮番提交自己的命令，但是还有一个问题没有解决。那就是如果
一个任务没有执行完，同时有更高优先级的任务需要执行，或者一个任
务执行中遇到问题，如何把当前的任务状态保存起来，然后切换到另一
个任务。用操作系统的术语来说，就是如何支持抢先式调度。
今天的GPU流水线都灵活多变，参数众多，如果在每次切换任务时
都要重复配置所有参数和寄存器，那么会浪费很多时间。
状态模型是解决上述问题的较好方案。简单来说，在状态模型中使
用一组状态数据作为软硬件之间的接口，相互传递信息。用程序员的话
来说，就是定义一套软件和硬件都认可的数据结构，然后通过这个数据
结构来保存任务状态。当需要执行某个任务时，只要把这个状态的地址
告诉GPU，GPU就会从这个地址加载状态。当GPU需要挂起这个任务
时，GPU可以把这个任务的状态保存到它的状态结构体中。
在现代GPU中，状态模型是一项重要而且应用广泛的技术。在主流
的GPU中都有实现，图8-6来自英特尔公开的编程手册，用于说明GPU
的状态模型。
图8-6 状态模型（图片来自01网站）
在图8-6中，上面是一个基本的数据结构，其起始地址有个专门的
名字，称为状态基地址（State Base Address），当向GPU下达任务时，
要把这个地址告诉GPU。从此，GPU便从这个状态空间来获取状态信
息。图中左侧是绑定表，考虑到准备任务时某些数据在GPU上的地址还
不确定，所以就先用句柄来索引它，在提交任务时，内核态驱动和操作
系统会在修补阶段（Patching）更新绑定表的内容，落实对象引用。
总结一下，本节简要浏览了GPU与CPU之间的编程接口。从早期的
设备寄存器方式到后来的批命令方式，再到状态模型。变革的主要目的
是更好地支持多任务，并且可以快速提交和切换任务。
8.4 GPU驱动模型
由CPU来给GPU喂任务的工作模式由来已久，根深蒂固。长时间的
积累，导致CPU端产生了很多种管理GPU的模块，比如驱动程序、运行
时、操作系统的GPU管理核心等。于是就需要有个模型来协调各个模
块，GPU的驱动模型便是用来解决这个问题的。本节将分别介绍
Windows操作系统和Linux操作系统上的GPU驱动模型。这个话题比较
复杂，本节只能提纲挈领地介绍要点。
8.4.1 WDDM
WDDM是Windows Vista引入的GPU驱动模型，其全称为“Windows
显示驱动模型”（Windows Display Driver Model）。名字中的“显示”显
然是不全面的，因为WDDM所定义的范围并不局限于显示功能，还有
GPU的另三类应用：媒体、2D/3D加速和GPGPU。
可以把Windows的图形系统大体分为三个阶段：第一个阶段是
GDI，第二个阶段是Windows 2000和XP时使用的XPDM，第三阶段便是
Vista引入的WDDM。
WDDM引入了很多项创新，代表着GPU软件模型的一次重大进
步。首先，它梳理不同身份的模块，重新定义分工，确定了图8-7所示
的四分格局。所谓四分格局，就是纵向按特权级别一分为二，把与硬件
密切相关的部分放在内核空间中，把没有必要放在内核空间中的部分放
在用户空间中；横向按开发者一分为二，把公共部分提炼出来由微软来
实现，把差异较大的设备相关的部分交给显卡厂商去实现。
图8-7 WDDM架构框图
图8-7中，左下角是位于内核空间的DirectX Graphics Kernel，简称
DXG内核。它是WDDM的核心模块，从某种程度来说，可以把它看作
Windows操作系统中管理GPU的内核。它的主要任务有两个：显存管理
和任务调度。在WDDM中，普遍使用虚拟内存技术来管理GPU内存，
使用图形页表把GPU的物理内存映射到虚拟内存。当GPU内存不足时，
可以把某些临时不用的页交换出去，需要时再通过页交换（Paging）机
制交换回来。在任务调度方面，WDDM支持抢先式多任务调度，抢先
调度的粒度因WDDM和硬件的版本不同而不同，大趋势是在不断变
小，以提高实时性并保证高优先级任务可以及时得到执行。
右下角是显卡厂商的内核模式驱动程序，一般简称为KMD。可以
认为，KMD是DXG内核的帮手，当DXG内核需要访问硬件时，会调用
KMD。可以认为，KMD拥有硬件，但是不擅长管理，于是委托给DXG
内核来管理。
图8-7中的左上部分代表操作系统的GPU编程接口和运行时。图中
画出了3个版本的DirectX接口，还有用于视频编解码的DXVA，以及
OpenGL。
右上部分是显卡的用户模式驱动程序，一般简称为UMD。UMD的
最主要任务是把应用程序提交的任务翻译为GPU命令，放入专门分配的
命令缓冲区中，并通过运行时接口成批地提交到内核空间。另外，
UMD还负责执行及时编译等不适合在内核空间完成的任务。图中UMD
上方的OpenGL ICD代表用于汇报OpenGL设备的接口模块，ICD是
Installable Client Driver的缩写。
WDDM模型是进程内模型。举例来说，每个调用DX API的应用程
序进程内，都会加载一份运行时和UMD的实例。图8-8所示的栈回溯很
生动地反映了挖地雷程序内四方协作的过程。
# ChildEBP RetAddr
00 aefc9490 90f32e50 igdkmd32!KmSubmitCommand
01 aefc94b8 90f33018 dxgkrnl!DXGADAPTER::DdiSubmitCommand+0x49
02 aefc94c4 8fc810d5 dxgkrnl!DXGADAPTER_DdiSubmitCommand+0x10
03 aefc94d4 8fc8a4ea dxgmms1!DXGADAPTER::DdiSubmitCommand+0x11
...
0a aefc97a0 90f4dd10 dxgmmsl!vidSchSubmitCommand+0x38b
0b aefc9b44 90f4fa2b dxgkrnl!DXGCONTEXT::Render+0x5bd
0c aefc9d28 83c8b44a dxgkrnl!DxgKRender+0x328
0d aefc9d28 77c664f4 nt!KiFastCallEntry+0x12a
0e 001ae1b8 761f5f05 ntdll!KiFastSystemCallRet
0f 001ae1bc 66ef5a95 GDI32!NtGdiDdDDIRender+0xc
10 001ae328 662d370f d3d9!RenderCB+0x174
11 001ae494 66393c68 igdumd32!USERMODE_DEVICE_CONTEXT::FlushCommandBuffer+
0x15f
...
18 001ae664 662d81d4 igdumd32!BltVidToSys+0x149
19 001ae68c 66f4430d igdumd32!Blt+0x1e4
1a 001ae7d4 66f446af d3d9!DdBltLH+0xllfd
...
25 001aed84 00aa386f minesweeper!RenderManager::Render+0x226
26 001aeda4 00aa3b0c minesweeper!RenderManager::SaveBackBuffer+0x79
27 001aedd0 00aa956d minesweeper!RenderManager::PresentBuffer+0x22
...
32 001afb20 00a9df26 minesweeper!WinMain+0xb1
图8-8 WDDM四方协作示例
图8-8中，最下方是WinMain函数，栈帧27～25代表应用程序在执行
呈现（present）动作时要保存后备缓冲区（back buffer），于是调用了
DX的位块传输API（Blt）。栈帧1a中的d3d9是DirectX的运行时模块，
它把调用转给英特尔显卡驱动的UMD模块igdumd32，后者把这个请求
转给内部的BltVidToSys函数（从显存向主存）。BltVidToSys函数继续
调用内部函数把这个操作转化为GPU的命令，放入命令缓冲区中。准备
好命令缓冲区后，UMD调用DX运行时的回掉函数RenderCB，后者发起
系统调用，把命令缓冲区提交给DXG内核。DxgkRender是DXG内核中
的接口函数，负责接收渲染请求。接下来是复杂的命令提交过程，要先
验证命令缓冲区并修补其中的地址引用（Patching），然后把准备好的
命令缓冲区挂到当前进程的GPU执行上下文结构体中，交给DXG内核的
调度器，排队等待执行。排队成功后，调用显卡驱动的KMD模块并提
交给GPU硬件。
8.4.2 DRI和DRM
在UNIX和Linux系统中，X窗口系统（X Window System）历史悠
久，应用广泛。它起源于美国的麻省理工学院，最初版本发布于1984年
6月，其前身是名为W的窗口系统。从1987年开始，X的版本号一直为
11，因此，今天的很多文档中经常使用X11来称呼X。X是典型的“客户
端-服务器”架构，服务器部分一般称为X服务器，客户端称为X客户
端，比如xterm等。
进入20世纪90年代后，随着3D技术的走红，开源系统中也需要一
套与DirectX类似的GPU快速通道。1998年，DRI应运而生。DRI的全称
为直接渲染基础设施（Direct Renderring Infrastructure）。DRI的目标是
让DRI客户程序和X窗口系统都可以高效地使用GPU。
1999年，DRI项目的一部分核心实现开始发布，名叫直接渲染管理
器（Direct Rendering Manager，DRM）。严格来说，DRM是DRI的一部
分，但今天很多时候，这两个术语经常相互替代。
经过十多年的演进变化，今天的DRI架构已经和WDDM很类似，也
可以按前面介绍的四象限切分方法划分为四大角色，如图8-9所示。
图8-9 DRI架构框图
在DRI架构中，内核模式的核心模块称为DRM核心，其角色相当于
WDDM中的DXG内核。DRM核心的目标是实现与GPU厂商无关的公共
逻辑，主要有以下几方面。
管理和调度GPU任务，这部分一般称为“图形执行管理
器”（Graphics Execution Manager，GEM）。
检测和设置显示模式、分辨率等，这部分功能一般称为“内核模式
设置”（Kernel Mode Setting，KMS）。
管理GPU内存，这部分一般称为图形内存管理器（GMM）。
与具体GPU硬件密切关联的部分要分别实现，使用DRM的术语，
这部分称为DRM驱动，套用WDDM的术语就是KMD。
用户空间中的各种API和运行时通过libDRM与内核空间交互，厂商
相关的部分一般称其为libDRM驱动，相当于WDDM中的UMD。
举例来说，Nvidia GPU的KMD名为nvidia-drm，UMD名为libGL-
nvidia-glx。
8.5 编程技术
现代GPU的发展趋势是使用通用的执行单元代替固定功能的硬件流
水线。这个趋势要求现代GPU不仅要有强大的并行执行能力，还必须有
好的指令集和编程模型，这样才能吸引应用程序开发者来为这个GPU编
写软件，发挥硬件的能力。
但问题是编程模型和指令集的开发与推广难度都是很大的，都需要
长时间的积累和巨大的投入。本节按照历史顺序简要介绍三种有代表性
的GPU编程技术，以点带面。
8.5.1 着色器
现代GPU是在图形应用的强大推力下发展起来的。在这个发展过程
中，3D图形应用自20世纪80年代兴起后至今不衰。某种程度上说，是
3D技术成就了GPU，GPU编程是从为3D渲染服务的着色器（shader）开
始的。
1986年著名的皮克斯动画工作室（Pixar Animation Studios）成立，
最大的股东就是乔布斯。皮克斯公司以完全不同的思路来制作动画片，
他们专门开发了一个名叫RenderMan的软件来让计算机生产出高质量的
三维动画。很多著名的动画电影和好莱坞大片中的特效都是使用
RenderMan产生的[6]。
可能是与合作伙伴联合开发的需要，1988年，皮克斯公司发布了
RenderMan接口规约（RenderMan Interface Specification，RISpec）。
RISpec中定义了一种与C语言类似的语言，名叫Renderman Shading
Language（RSL）。在RSL中，着色器一词被赋予了新的内涵。它代表
一段计算机程序，用来产生不同的光照效果、阴影和颜色信息等。换句
话来说，在计算机所描述的3D世界中，每个物体都是使用很多三角形
来表达的，3D渲染的任务就是要把这样的三维世界转化为一帧帧的二
维图像。在这个转换过程中，需要大量的计算，为了提高灵活性，需要
一种编程语言来自由定义计算的过程。着色器和着色器语言应运而生。
2000年11月，微软发布DirectX 8.0（RC10），其中包含了汇编语言
形式的着色器支持。两年后，DirectX 9发布，包含了高层着色器语言