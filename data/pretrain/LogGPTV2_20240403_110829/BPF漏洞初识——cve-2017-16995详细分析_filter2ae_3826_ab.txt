        LDST(H,  u16)
        LDST(W,  u32)
        LDST(DW, u64)
    #undef LDST
        STX_XADD_W: /* lock xadd *(u32 *)(dst_reg + off16) += src_reg */
            atomic_add((u32) SRC, (atomic_t *)(unsigned long)
                   (DST + insn->off));
            CONT;
        STX_XADD_DW: /* lock xadd *(u64 *)(dst_reg + off16) += src_reg */
            atomic64_add((u64) SRC, (atomic64_t *)(unsigned long)
                     (DST + insn->off));
            CONT;
        LD_ABS_W: /* BPF_R0 = ntohl(*(u32 *) (skb->data + imm32)) */
            off = IMM;
    load_word:
            ...
        default_label:
            /* If we ever reach this, we have a bug somewhere. */
            WARN_RATELIMIT(1, "unknown opcode %02x\n", insn->code);
            return 0;
    }
###  eBPF函数介绍
`eBPF`是通过 执行不同的函数，来实现各种功能，[参考手册在这](https://man7.org/linux/man-pages/man2/bpf.2.html)。可以使用的函数如下：
    //创建一个map内存，返回一个执行map的文件指针      
    BPF_MAP_CREATE
                  Create a map and return a file descriptor that refers to
                  the map.  The close-on-exec file descriptor flag (see
                  fcntl(2)) is automatically enabled for the new file
                  descriptor.
    //从map内存中根据传入的key值寻找到对应的value
    BPF_MAP_LOOKUP_ELEM
                  Look up an element by key in a specified map and return
                  its value.
    //创建或更新map内存中一个key值或value值
    BPF_MAP_UPDATE_ELEM
                  Create or update an element (key/value pair) in a
                  specified map.
    //删除map中的key值
    BPF_MAP_DELETE_ELEM
                  Look up and delete an element by key in a specified map.
    //在map中根据key值查找，并返回下一个元素
    BPF_MAP_GET_NEXT_KEY
                  Look up an element by key in a specified map and return
                  the key of the next element.
    //验证和加载eBPF程序，然后一个新的文件描述符
    BPF_PROG_LOAD
                  Verify and load an eBPF program, returning a new file
                  descriptor associated with the program.  The close-on-exec
                  file descriptor flag (see fcntl(2)) is automatically
                  enabled for the new file descriptor.
接下来，我们依次介绍各个函数的用法。
####  BPF_MAP_CREATE
该函数用于创建一个新的 `map`内存，返回一个新的文件描述符，并指向该内存。
    int
    bpf_create_map(enum bpf_map_type map_type,
    unsigned int key_size,
    unsigned int value_size,
    unsigned int max_entries)
    {
        union bpf_attr attr = {
            .map_type    = map_type,
            .key_size    = key_size,
            .value_size  = value_size,
            .max_entries = max_entries
        };
        return bpf(BPF_MAP_CREATE, &attr, sizeof(attr));c
    }
首先将传入的四个参数，分别赋值给 `bpf_attr`数据结构，其原型如下，包含了使用 `BPF`函数时所需要的各个参数。
    union bpf_attr {
        struct {    /* Used by BPF_MAP_CREATE */
            __u32         map_type;
            __u32         key_size;    /* size of key in bytes */
            __u32         value_size;  /* size of value in bytes */
            __u32         max_entries; /* maximum number of entries
                                                     in a map */
        };
        struct {    /* Used by BPF_MAP_*_ELEM and BPF_MAP_GET_NEXT_KEY
                                  commands */
            __u32         map_fd;
            __aligned_u64 key;
            union {
                __aligned_u64 value;
                __aligned_u64 next_key;
            };
            __u64         flags;
        };
        struct {    /* Used by BPF_PROG_LOAD */
            __u32         prog_type;
            __u32         insn_cnt;
            __aligned_u64 insns;      /* 'const struct bpf_insn *' */
            __aligned_u64 license;    /* 'const char *' */
            __u32         log_level;  /* verbosity level of verifier */
            __u32         log_size;   /* size of user buffer */
            __aligned_u64 log_buf;    /* user supplied 'char *'
                                                    buffer */
            __u32         kern_version;
            /* checked when prog_type=kprobe
                                                    (since Linux 4.1) */
        };
    } __attribute__((aligned(8)));
需要传入的4个参数，含义分别为：
  * `bpf_map_type`，指定 创建的 `map`的类型，所有类型如下，用于指定建立映射的方式
    enum bpf_map_type {
        BPF_MAP_TYPE_UNSPEC,
        BPF_MAP_TYPE_HASH,        //HASH表
        BPF_MAP_TYPE_ARRAY,        //数组
        BPF_MAP_TYPE_PROG_ARRAY,
        BPF_MAP_TYPE_PERF_EVENT_ARRAY,
        BPF_MAP_TYPE_PERCPU_HASH,
        BPF_MAP_TYPE_PERCPU_ARRAY,
        BPF_MAP_TYPE_STACK_TRACE,
        BPF_MAP_TYPE_CGROUP_ARRAY,
        BPF_MAP_TYPE_LRU_HASH,
        BPF_MAP_TYPE_LRU_PERCPU_HASH,
    };
  * `key_size`指定了 `key`的数据大小，用于在后续验证 `bpf`程序时使用，防止越界访问。例如当 一个 `map`创建的 `key_size`为8，那么此时如下函数将会被阻止。因为对于内核，其希望从源地址读取 8字节的数据，但是此时源地址为 `fp-4`，如果读取8字节，就会超出当前栈的边界，所以会被阻止
    bpf_map_lookup_elem(map_fd, fp - 4)
  * 同理，`value_size`指定了 `value`的数据大小。例如，当使用 `value_size=1`创建了 `map`之后，使用 如下代码则会被阻止。因为，这里的 `value`大小为 1 字节，而却想要将其赋值为 4字节，超出了 `value_size`。
    value = bpf_map_lookup_elem(...);
    *(u32 *) value = 1;
  * `max_entries`指定了 `map`的大小
####  BPF_MAP_LOOKUP_ELEM
`BPF_MAP_LOOKUP_ELEM`函数根据传入的 `key`执行寻找其对应的 元素。
    int bpf_lookup_elem(int fd, const void *key, void *value)
    {
        union bpf_attr attr = {
            .map_fd = fd,
            .key    = ptr_to_u64(key),
            .value  = ptr_to_u64(value),
        };
        return bpf(BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));
    }
如果一个元素被找到，则返回0，并将该值存入 存入的`value`参数里，其指向了一个 上一步提到的 `value_size`大小的
`buffer`。如果没有被找到，则返回 `-1`，并设置 `errno`。
####  BPF_MAP_UPDATE_ELEM
`BPF_MAP_UPDATE_ELEM`函数使用传入的 `key`或 `value`创建或者更新一个`map`中的元素
    int bpf_update_elem(int fd, const void *key, const void *value,
                        uint64_t flags)
    {
        union bpf_attr attr = {
            .map_fd = fd,
            .key    = ptr_to_u64(key),
            .value  = ptr_to_u64(value),
            .flags  = flags,
        };
        return bpf(BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));
    }
  * `flag`参数必须为如下选项，
    BPF_ANY
        Create a new element or update an existing element.
    BPF_NOEXIST
        Create a new element only if it did not exist.
    BPF_EXIST
        Update an existing element.
如果成功，返回 0。若失败，则返回 -1。
####  BPF_MAP_DELETE_ELEM
`BPF_MAP_DELETE_ELEM`函数用于根据传入的 `key`或 `value`来删除一个元素：
    int bpf_delete_elem(int fd, const void *key)
    {
        union bpf_attr attr = {
            .map_fd = fd,
            .key    = ptr_to_u64(key),
        };
        return bpf(BPF_MAP_DELETE_ELEM, &attr, sizeof(attr));
    }
如果成功，则返回 0。如果元素为被找到找到，则返回 -1。
####  BPF_MAP_GET_NEXT_KEY
该含糊根据传入的 `key`值寻找到对应的元素，然后返回 其下一个元素：
    int bpf_get_next_key(int fd, const void *key, void *next_key)
    {
        union bpf_attr attr = {
            .map_fd   = fd,
            .key      = ptr_to_u64(key),
            .next_key = ptr_to_u64(next_key),
        };
        return bpf(BPF_MAP_GET_NEXT_KEY, &attr, sizeof(attr));
    }
如果 `key`被找到，则返回0，并将 `next_key`指向 `key`值得下一个元素。如果`key`未找到，则返回 0，并将 `next_key`指向
第一个元素。如果 `key`是最后一个元素，则返回 -1，并将 `next_key`设置为 `ENOENT`。
####  BPF_PROG_LOAD
该函数用于加载一个 `eBPF`程序到内核，返回一个新的指向 `eBPF`程序的文件指针。
    char bpf_log_buf[LOG_BUF_SIZE];
    int
        bpf_prog_load(enum bpf_prog_type type,
                      const struct bpf_insn *insns, int insn_cnt,
                      const char *license)
    {
        union bpf_attr attr = {
            .prog_type = type,
            .insns     = ptr_to_u64(insns),
            .insn_cnt  = insn_cnt,
            .license   = ptr_to_u64(license),
            .log_buf   = ptr_to_u64(bpf_log_buf),
            .log_size  = LOG_BUF_SIZE,
            .log_level = 1,
        };
        return bpf(BPF_PROG_LOAD, &attr, sizeof(attr));
    }
`map`内存可以被 `eBPF`程序访问，并且实现从 `eBPF`程序和用户空间程序
交互数据。例如，`eBPF`程序可以获取进程数据（例如`kprobe`、`packets`）并将数据存储到`map`，然后用户空间程序就可以通过访问
`map`来获取数据。反之亦然。
###  BPF的安全校验
这里我们分析一下 `Verifier`机制，主要检测函数为 `bpf_check`：
    int bpf_check(struct bpf_prog **prog, union bpf_attr *attr)
    {
        char __user *log_ubuf = NULL;
        struct verifier_env *env;
        int ret = -EINVAL;
        //指令条数判断
        if ((*prog)->len len > BPF_MAXINSNS)
            return -E2BIG;
        /* 'struct verifier_env' can be global, but since it's not small,
         * allocate/free it every time bpf_check() is called
         */
        //分配 verifier_env空间
        env = kzalloc(sizeof(struct verifier_env), GFP_KERNEL);
        if (!env)
            return -ENOMEM;
        env->prog = *prog;
        /* grab the mutex to protect few globals used by verifier */
        mutex_lock(&bpf_verifier_lock);
        if (attr->log_level || attr->log_buf || attr->log_size) {
            /* user requested verbose verifier output
             * and supplied buffer to store the verification trace
             */
            log_level = attr->log_level;
            log_ubuf = (char __user *) (unsigned long) attr->log_buf;
            log_size = attr->log_size;
            log_len = 0;
            ret = -EINVAL;
            /* log_* values have to be sane */
            if (log_size  UINT_MAX >> 8 ||
                log_level == 0 || log_ubuf == NULL)
                goto free_env;
            ret = -ENOMEM;
            log_buf = vmalloc(log_size);
            if (!log_buf)
                goto free_env;
        } else {
            log_level = 0;
        }
        /* look for pseudo eBPF instructions that access map FDs and
     * replace them with actual map pointers
     */
        //将伪指令中操作map_fd的部分替换成map地址，注意这个地址是8字节的，因此在实现中用本指令的imm和下一条指令的2个4字节中存储了这个地址
        /* store map pointer inside BPF_LD_IMM64 instruction 
                insn[0].imm = (u32) (unsigned long) map;
                insn[1].imm = ((u64) (unsigned long) map) >> 32;
        */
        //这个函数下面细讲
        ret = replace_map_fd_with_map_ptr(env);
        if (ret explored_states = kcalloc(env->prog->len,
                           sizeof(struct verifier_state_list *),
                           GFP_USER);
        ret = -ENOMEM;
        if (!env->explored_states)
            goto skip_full_check;
        //控制流图检查死循环和不可能到达的跳转
        ret = check_cfg(env);
        if (ret allow_ptr_leaks = capable(CAP_SYS_ADMIN);
        //核心检查函数
        ret = do_check(env);
    skip_full_check:
        while (pop_stack(env, NULL) >= 0);
        free_states(env);
        if (ret == 0)
            /* program is valid, convert *(u32*)(ctx + off) accesses */
            ret = convert_ctx_accesses(env);
        if (log_level && log_len >= log_size - 1) {
            BUG_ON(log_len >= log_size);
            /* verifier log exceeded user supplied buffer */
            ret = -ENOSPC;
            /* fall through to return what was recorded */
        }
        /* copy verifier log back to user space including trailing zero */
        if (log_level && copy_to_user(log_ubuf, log_buf, log_len + 1) != 0) {
            ret = -EFAULT;
            goto free_log_buf;
        }
        if (ret == 0 && env->used_map_cnt) {
            /* if program passed verifier, update used_maps in bpf_prog_info */
            env->prog->aux->used_maps = kmalloc_array(env->used_map_cnt,
                                  sizeof(env->used_maps[0]),
                                  GFP_KERNEL);
            if (!env->prog->aux->used_maps) {
                ret = -ENOMEM;
                goto free_log_buf;
            }
            memcpy(env->prog->aux->used_maps, env->used_maps,
                   sizeof(env->used_maps[0]) * env->used_map_cnt);
            env->prog->aux->used_map_cnt = env->used_map_cnt;
            /* program is valid. Convert pseudo bpf_ld_imm64 into generic
             * bpf_ld_imm64 instructions
             */
            convert_pseudo_ld_imm64(env);
        }
    free_log_buf: