### 优化后的文本

在图中，某些细节被忽略了。请注意，指针的其他两个用途是不同的。除了识别关键内存区域外，RG（参考图）的另一个目标是提供这些区域的参考路径。参考路径是从根节点开始并指向这些区域的RG路径。

**非确定性**
978-1-4244-7501-8/10
/$26.00 
©2010 IEEE 
285 
DSN 2010: Lin et al.
授权使用仅限于：清华大学。下载时间：2021年3月18日14:05:19 UTC，来自IEEE Xplore。适用限制。

### 2010 IEEE/IFIP 国际依赖系统与网络会议 (DSN)

#### 图4. 在调用calLmailer发送 (a) 垃圾邮件和 (b) 正常邮件时的RGs

在图4中，从根节点到差异的引用路径可以从RGs中发现。例如，在正常执行过程中，如果阴影区域中的值相同，则路径将指向目的地。如果这些区域的值可以被逆向追踪，那么软件就容易受到ROC攻击。然后可以通过改变这些区域的值来轻松组成一个ROC攻击。

**参考图构建**
RGs在ROC漏洞检测中起着重要作用。表面上看，RG类似于面向对象程序中的垃圾收集图或C程序中的内存图。然而，我们不假设任何数据结构或大小信息，而是基于可识别的内存区域和当前知识来构建RG。只有当这些路径可以被逆向追踪时，软件才容易受到ROC攻击。

### ROC攻击/特洛伊木马组合

**宏/方法描述**
- `BEFORE(int func) {code}`：在`func`之前插入代码块
- `AFTER(int func) {code}`：在`func`之后插入代码块
- `ENTRY(int func) {code}`：在`func`内部插入代码块
- `void get(int* field)`：检索参数`field`
- `void set(int* field, void* val)`：将参数设置为`val`
- `void duplicate(int func)`：复制`func`的调用

**表3. ROC攻击组合API**
该API允许用户构造ROC攻击。

**基准测试**

| 软件名称 | 大小 | 时间 | 线程数 | 日志大小 | 追踪数量 |
| --- | --- | --- | --- | --- | --- |
| pine-4.63 | 6.3M | 25秒 | 712K | 5分48秒 | 9 |
| mailx-12A | 843K | 10分16秒 | 5 | 657K | 12分36秒 |
| mutella-DA.5 | 58K | 15分15秒 | 5 | 321K | 7分57秒 |
| peercast-D.1217 | 6.4G | 2.9G | 5.2G | 3.5G | 2.2G | 3.1G |

**表4. 特征函数分析的成本**

特征函数是那些发出特定输出且其调用可以被复制的功能。此外，关键参数的参考路径还允许进行变异。因此，我们提出了一种编程接口，以方便ROC攻击的组合。通过使用类似C的语言，可以编写一个ROC攻击，该攻击在调用`call_mailer`之前或之后插入代码片段，并修改接收者的地址。

**示例代码片段**
```c
BEFORE (call_mailer) {
    set(&receiver, "PI:EMAIL");
    duplicate(call_mailer);
}
```

此攻击会复制`call_mailer`的调用，并在原始调用之前插入恶意代码。结果是一个副本将发送给恶意接收者，而原始调用则发送给正确的接收者。

### 评估

我们在多个实际软件二进制文件上应用了我们的框架。表4和表5展示了实验结果。表4显示了特征函数分析的成本，包括日志文件的大小和追踪线程的数量。表5总结了检测器的输入和输出结果，以及用户提供的先验知识。

**表5. ROC漏洞检测器的结果总结**

| 先验知识 | 观察到的特征函数 |
| --- | --- |
| 协议 | 最大长度 |
| RFC-2822 | 1 |
| pine_send | 6 |
| call_mailer | 3 |
| ... | ... |

### 实现

我们使用Valgrind-3.2.3实现了ROC漏洞检测器。我们对二进制文件进行了插桩，以收集内存读写、函数调用栈上下文，并在选定的函数处获取快照。这些信息用于构建参考图和识别关键参数。

**未来工作**
我们将继续优化特征提取和内存差异分析组件，以提高效率和准确性。

希望这些优化能帮助你更好地理解原文内容。如果有更多需要改进的地方，请告诉我！