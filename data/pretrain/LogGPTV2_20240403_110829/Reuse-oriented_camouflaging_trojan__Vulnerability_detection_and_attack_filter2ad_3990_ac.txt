are ignored 
in the figure. Note that pointer 
The other two are for different 
The 
Besides identifying 
critical 
memory regions, 
another 
goal of RG is to provide 
A reference 
path is a RG path that starts 
from a root and 
reference 
paths to these regions. 
non-determinism 
978-1-4244-7501-8/10
/$26.00 
©20lO IEEE 
285 
DSN 20lO: Lin et al. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:05:19 UTC from IEEE Xplore.  Restrictions apply. 
2010 IEEE/IFIP International 
Conference 
on Dependable Systems 
& Networks 
(DSN) 
(a) 
(b) 
Figure 4. RGs at the invocation 
of calLmailer for sending (a) a spam and (b) a regular 
email. 
en­
how to ad­
execution 
region. It indicates 
In Fig. 4, the refer­
can be discov­
point. The soft­
only if such paths can be reverse 
Then a ROC attack can be easily composed by 
the values of these regions. 
leads to the destination 
dress the region at the current 
ware is vulnerable 
gineered. 
mutating 
ence paths from the roots to the differences 
ered from the RGs. For example, 
the subject 
*(*(*(*(*(*(ESP+4)+52)+8)  +0)+0)+8), 
tated by the definition 
the corresponding 
subject) 
are identical 
the normal execution 
if the values in the shaded regions 
the regions 
is taken. 
the paths to email 
in the two graphs. We point out that 
can be mutated to the malicious 
one 
in (a) are copied over to 
point where the snapshot 
paths to 
and 
Dic­
the paths to 
are *(*(*(ESP+0)+0)+28) 
of memory alignment, 
in (b) at the execution 
respectively. 
memory regions 
and the content 
the reference 
(e.g., 
Reference Graph Construction. 
role in ROC vulnerability 
detection. 
On the surface, 
an RG 
RGs play an important 
Given a grammar specification, 
our ROC vulnerability 
and critical 
arguments 
functions 
feature 
identifies 
detector 
with their reference 
software 
ROC vulnerability, 
we further 
is highly susceptible 
the 
To confirm a 
to ROC attacks. 
develop an attack composer 
paths. If both can be identified, 
is in our context 
to the object reference 
in object-oriented 
programs 
graph for garbage 
[8] or the memory 
is very similar 
collection 
The difference 
graph [31] in C programs. 
as we do not assume any data structure 
and size infor­
based on the identifiable 
memory regions 
mation, e.g., global variable 
region and size, stack frame 
address and size, heap chunk address and size, we build 
the corresponding 
RG rooted from the global variables 
stack variables 
to build RGs are elided and can be found in our technical 
report [22]. 
frame. The details 
and 
on how 
on the current 
knowledge. 
Only 
4 ROC Attackffrojan Composition 
978-1-4244-7501-8/101$26.00 
©2010 IEEE 
286 
DSN 2010: Lin et al. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:05:19 UTC from IEEE Xplore.  Restrictions apply. 
2010 IEEEIIFIP International 
Conference 
on Dependable Systems 
& Networks 
(DSN) 
Macro/Method 
BEFORE(int func) {code} 
AFfER(int func) {code} 
ENTRY(int func) {code} 
void get(int* field) 
void set(int' 
void duplicate(int 
func) 
Description 
insert the code block before func 
insert the code block after func 
insert right inside func 
retrieve 
the argument field 
field, void* val) set the argument with val 
duplicate 
the invocation 
of f unc 
Table 3. ROC attack composition 
API. 
that allows user to construct 
ROC attacks. 
Benchmark 
I 
I Software Name  I Size  Time  Threads Log Size 
#Traced 
6.3M  Sm25s 
712K  5m48s 
pine-4.63 
I 
mailx-12A 
I 
mutella-DA.5  843K  IOml6s  9 
peercast-D.1217  58K  15mlSs  5 
I 
657K  12m36s  I 
gift-D.I1.S.1 321K  7m57s 
libGnutella.so.D.11 
6.4G 
2.9G 
S.2G 
3.5G 
2.2G 
3.1G 
extrac­
Table 4. Cost of profiling 
tion. 
for feature 
Recall that feature 
functions 
are those that emit the spec­
of these functions 
the arguments. 
if needed as they do not have irreversible 
interface 
can be duplicated 
for sub­
side ef­
critical 
arguments 
paths also allow mutating 
we propose a programming 
easy ROC attack composition. 
ified output and their invocations 
version 
fects. Furthermore, 
and their reference 
Therefore, 
itates 
the interface 
fore or after a function  invocation, 
ning of the invoked function. 
gument manipulation 
attack can be written 
The following 
directs 
BEFORE (call_mailer) 
and function 
using a C-like language 
an email message. 
illustrates 
code snippet 
provides 
macros that allow inserting 
code be­
As shown in Table 3, 
ar­
A ROC 
a ROC attack that re­
call duplication. 
with the APIs. 
or right at the begin­
that facil­
{ 
It also supports  simple 
set( &receiver, "PI:EMAIL"); 
duplicate(call_mailer);
} 
The attack duplicates 
the calLmailer invocation 
and 
before the du­
to calLmailer. 
for the given calLmailer function 
before the original 
Note that our tool identifies 
The result 
address 
and the 
is that a copy of 
before it is sent 
will be translated 
to a piece of independent 
into as­
path for receiver. 
The binary will then be patched 
the receiver of the email address 
call. The attack code is inserted 
mutates 
plicated 
invocation 
the address 
reference 
the email is sent to the malicious 
to the right receiver. 
The snippet 
sembly code and then compiled 
binary. 
ware. The patch contains 
precedes 
before the original 
implements 
that reverses 
accessing 
and changing 
the field name receiver 
field represents 
parsed by the non-terminal 
ing the receiver's 
the original 
address. 
Details 
and intercepts 
benign invocation; 
the main body of the attack; 
the side effects. 
Receiver 
The patch is further 
can be found in [22]. 
The malicious 
argument 
the duplicate 
the critical 
the argument 
that decides 
binary. 
to the original 
soft­
three parts: an entry patch that 
flow right 
logic that 
and an exit patch 
the control 
a malicious 
the output value 
in grammar g, denot­
weaved into 
and making a duplicated 
denoted by 
call. The 
logic includes 
are conducted 
off-line 
side effect anal­
points. 
Feature 
extraction, 
memory diff-ing 
tion invocation 
ysis, and RG-based 
based on the trace file. The ROC attack composer 
mented independently. 
number of real-world 
the results 
composer. 
5.1 Overall Result 
In our experiments, 
from our ROC vulnerability 
We have applied 
binaries. 
detector 
In the following, 
is imple­
our framework 
to a 
we assume some high-level 
knowl­
we present 
and attack 
in various 
semantics 
implementations 
mainly 
(RFC-2822) 
protocol 
two protocols, 
used. In particular, 
an email protocol 
such as the commu­
our evaluation 
and 
We aim to detect ROC vul­
edge about a target binary's 
nication 
involves 
a P2P protocol  (Gnutella-O.6). 
nerabilities 
We take 5 widely used software 
as 
shown in Tables 4 and 5. The "Size" column in Table 4 is 
(pine and 
the binary size. In the email implementations 
mailx), we aim to find the feature 
responsible 
sending 
In the P2P programs (mutella, 
we aim to implant 
for email 
email or send spam. 
so that we can use it 
peercast, 
to redirect 
malicious 
programs 
as benchmarks 
and gift), 
logic such as a C&C channel. 
of these protocols. 
ex­
in­
Table 4 shows the cost of profiling 
in the feature 
The 
consists 
large log files. 
and produces 
containing 
level profiling 
The instruction 
function 
memory 
of one expensive 
level 
phase. The profiling 
level profiling 
and 10 featherweight 
collects 
function 
is to identify 
to the feature, 
identification. 
containing 
functions 
func­
i.e., containing 
in runs that do not produce the specified 
out­
cost 
The overall 
traction 
struction 
profiling. 
reads, writes and dependencies 
It is to facilitate 
function 
level profiling 
that are not dedicated 
tions executed 
put (or do not accept the specified 
is presented 
in Table 4. The overall 
imal number of traced threads 
log size are shown in the 3rd, 4th, and 5th columns, 
in gift. 
spectively. 
They are treated 
are interested 
dex management 
ture in libGnutella. 
ing is the dominant 
traces for the entire execution 
will work on optimizing 
in gift and the file transfer 
level profil­
The first instruction 
factor in the cost. Currently, 
We 
namely, the file in­
fea­
input). 
profiling 
which is sub-optimal. 
Note that libGnutella 
for one run, and the total 
in their different 
as two different 
this component 
benchmarks 
in the future. 
features, 
it collects 
is a plug-in 
time, the max­
because we 
feature 
re­
Table 5 summarizes 
the input and outcome of the detec­
tor. The columns in Pr ior Knowledge presents 
the in­
by user: Protocol is the feature 
rep-
formation 
provided 
5 Evaluation 
We have implemented 
the ROC vulnerability 
detector 
us­
[24]. We instrument 
a binary to (1) col­
ing Valgrind-3.2.3 
lect memory reads, writes, 
tions, 
(2) keep track offunction 
and (3) take snapshots 
ters for reference 
and de-allocations, 
along with the call stack contexts; 
live ranges, 
relations; 
of memory along with regular 
caller-callee 
regis­
at the selected 
func-
graph construction 
data dependencies, 
heap alloca­
978-1-4244-7501-8/10
/$26.00 
©201O IEEE 
287 
DSN 2010: Lin et al. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:05:19 UTC from IEEE Xplore.  Restrictions apply. 
2010 JEEEIIFIP International 
Conference 
on Dependable Systems 
& Networks 
(DSN) 
Prior Knowledge I I   Observed Feature Function 
Protocol #Var II Func Addr 
RFC-2822 
II Max Length 
II of Ref Path 
I I  Ox081 d5b6f 
II Ox081c613c 
Ox081cbf67 
FuncName 
composeJllail  II  1 
II  3 
pine_send 
II  6 
callJllailer 
3 
talb,mtp 
Ox0809Of59 
3 
smtpJllta 
Ox08092306 
3 
startJllta 
Ox0808e864 
3 
transfer 
Ox0808e6a2 
3 
maill 
Ox0808ee02 
Ox08Od0cc2 MGnuNode: :SendPacket  5 
Ox08Od2eb8 MGnuNode::Send-.Ping  4 
Ox08Od64e2  MGnuNode: : HandlePacket  5 
Ox08Odlblc MGnuNode::Receive-.Ping 4 
1 
Oxb7eee13e  GnuStream::ping 
Oxb7eedfSa GnuStream:: sendPacket 
3 
Oxb7eef3b6 GnuStream::processPacket 6 
Benchmark 
pine-4.63 
mailx-12A 
Email 
Sending 
4 
RFC-2822 
Email 
Sending 
4 
mutella-OA.5 
Ping Send 
1 
Ping Recv 
1 
peercast-0.1217 
gift-0.ll.8.1 
Ping Send 
Ping Recv 
Index 
Management 
1 
1 
0 
libGnutella.so.O.ll 
Query Recv  1 
Ping Recv 
1 
#Identified #Containing Side Effect Write 
Functions #G I #H  #F 
183 I 9 
1 
181 I 37  1 
0 
18 I 9 
2 
3 
9 
1 
18  1 
18  1 
70  1 
1 
1 
0 
0 
2 
1 
1 
0 
0 
0 
0 
Var 
1  I  7 
0  I  8 
4  I  9 
10 
3 
9 
3 
8 
3 
7 
3 
3 
6 
15 
1 
14 
1 
8 
1 
9 
1 
9 
1 
1 
8 
8 
1 
0 
0 
0 
0 
-
-
6 
6 
-
-
-
-
-
-
Ox08054923  share_update..index 5 
5 
Ox080548ge 
3 
Oxb7dc522a 
3 
Oxb7d027fe 
Oxb7d01659 
4 
update..index 
recv _packet 
gtJIIsg-,!uery 
gtJIIsg_ping 
0 
0 
2 
1 
1 
16 
17 
21 
22 
22 
Table 5. Summary of results 
from ROC vulnerability 
detector. 
func­
arguments, 
and we present 
by the provided 
do not require 
function 
in the grammar. The columns in Observed 
grammar; #Var shows the num­
which correspond 
to some non­
any symbolic 
names mainly for read­
The next three columns show the maximal length of 
resented 
ber of critical 
terminals 
Feature Functions show the extracted feature 
tions. Note our techniques 
formation, 
ability. 
the reference 
critical 
functions. 
writes to global variables 
at the end of the function 
if the patch is not a function 
the side effect data. 
(#G) , heap variables 
(#H) , and external 
and the number of containing 
The side effect columns present 
paths of the critical 
we do not collect 
duplication, 
arguments; 
identified; 
files (#F). Note 
variables 
that are live 
the number of 
the number of 
in­
After the ROC vulnerabilities 
ROC trojans 
are identified, 
we use our 
thus confirming 
Note that doing so is completely 
legal according 
"PING" packet in sequences 
botnet commands by 
of vari­
the identical 
imum hops. We can encode various 
sending 
ous length. 
to the protocol 
to a node trying to find its neighbors). 
would work normally 
would understand 
specification 
such encoding 
whereas only the infected 
The un-infected 
peers 
peers (bots) 
among themselves. 
(as such behavior 
corresponds 
function identification: 
We provide 
the PING 
to the ROC vulnerability 
of a 
in both PING mes­
being GUm (the identification 
Note that we are interested 
detector  with 
Reuse-able 
message grammar 
the critical argument 
message). 
sage sending and receiving 
separate 
of functions. 
two feature 
tified, indicating 
Send_Ping 
Part of the attack code is presented 
For the PING 
functions 
features 
features. 
They are considered 
as they are implemented 
by different 
sets 
send and PING receive 
and the critical 
argument 
features, 
are iden­
We select 
that mutella is vulnerable. 
and Receive_Ping to compose the attack. 
as follows. 
Except that mailx has an irreversible 
have been successfully 
exploited. 
we next present 
one representative 
of other case studies 
the mutella binary, 
and we 
report 
in our technical 
BEFORE (Send_Ping) { 
for(i=O;i<2;i++){//Command A 
duplicate(Send_Ping); 
other binaries 
attack composer 
to construct 
the vulnerabilities. 
side effect, 
Due to space limitation, 