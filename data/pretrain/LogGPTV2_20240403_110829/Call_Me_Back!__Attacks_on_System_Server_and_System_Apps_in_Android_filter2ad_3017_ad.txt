tener is android.os.storage.IMountServiceListener.
It
deﬁnes two synchronous callback methods. As shown in
Fragment 3 of Appendix A, the tainted callback handle prop-
agates into the global variable named mListeners (line 1557).
MS also registers a broadcast receiver to listen on the inten-
t, which is broadcasted when the state of USB storage is
changed (line 1498). When MS receives the intent, it will
make callbacks based on every element in mListeners (line
1247, 1249). During this period, it is necessary to ensure the
mutual exclusiveness of mListeners. Therefore, the related
code is in a synchronized block. When this vulnerability is
exploited, the system would get into hazard situation A1.
This vulnerability exists in Android 5.1.0 and no longer
exists in Android 6.0.1, because Android has changed the
type of the callback from synchronous to asynchronous. The
vulnerable service interface has no permission requirement
on the client app.
4.2.4 Vulnerability in Package Manager Service
PMS (Package Manager Service) keeps track of all those
.apks everywhere. The vulnerable service interface in PMS
is freeStorage().
It is in charge of clearing the cache of
given volume Universally Unique Identiﬁer (UUID). The re-
lated code is shown in Fragment 4 of Appendix A. Cache
clearing is a time-consuming work. PMS carries out this
work in an assistant thread leveraging the Handler mecha-
nism (line 2196). Code from the assistant thread is imple-
mented inside the freeStorage() method. Hence, it can
operate the IPC call parameter named pi. The class of pi is
android.content.IntentSender. Similar to PendingInent,
this class also contains a member variable, which is a call-
back handle. The member variable is named as mTarget.
The class of mTarget is also IIntentSender. This class on-
ly deﬁnes one synchronous callback method named send().
After the cleaning work ﬁnishes, the assistant thread will
invoke the pi.sendIntent() method (line 2207). Actually,
it is invoking the callback method of pi.mTarget.send().
In line 2206, PMS tries to check on the validity of pi. How-
ever, it could not validate the identity of the service repre-
sented by pi.mTarget. What’s more, PMS can only handle
one type of exception, namely SendIntentException in line
2212. Hence, we could not expect it to survive any other
types of exception that may be replied from the callback
method. When this vulnerability is exploited, the system
would get into hazard situation A2.
The vulnerable service interface is protected with permis-
sion clear_app_cache. This permission is acquirable for
third party apps before Android 5.1.0, but not in Android
6.0.1. Therefore, although the vulnerability still exists in
Android 6.0.1, it is only exploitable in v2.3.7-v5.1.0.
4.2.5 Vulnerability in SystemUI App
US (USB Service) manages all USB-related state, includ-
ing both host and device support. The requestAccesso-
ryPermission() interface in US can be invoked by a client
app to request the permission of USB accessories. When it is
invoked, US will start an activity in the SystemUI app to let
the device user decide whether or not the permission should
be granted. This interface receives a callback handle as an
IPC call parameter. The parameter is named as pi, whose
class is android.os.PendingIntent. It will be passed to the
activity component in SystemUI. SystemUI uses it to inform
the client app of the decision of the device user. As described
in Section 4.2.2, when pi.send() is invoked by the activity
component in SystemUI, a synchronous callback method is
actually invoked.
The related code is shown in Fragments 5.1, 5.2 and 5.3
of Appendix A. We can see that US starts the activity com-
ponent in SystemUI and passes the callback handle to it by
the intent object (line 1045 in 5.2). The target activity
component acquires the callback handle in the onCreate()
method (line 68 in 5.3) and invokes it when the activity is to
be destroyed (line 146 in 5.3). Malicious services can block
the code of the activity component by preventing the call-
back method from returning until it is too late. When this
vulnerability is exploited, the system would get into hazard
situation B1.
This vulnerability exists in Android 4.1.1-6.0.1. The vul-
nerable service interface is not protected with any permis-
sion. Another interface of US named requestDevicePer-
mission() also has this vulnerability.
4.2.6 Vulnerability in Phone App
The imms system service bridges the public SMS/MMS
APIs with the service interfaces of the MmsService compo-
nent in the Phone app. This kind of design can protect the
integrity of the SS. However, it leaves the Phone app at risk
of attack.
The vulnerable service interfaces in imms are download-
Message(), sendMessage() and sendStoredMessage(). They
all receive an IPC call parameter whose class is Pending-
Intent. As described in Section 4.2.2, the object of the
PendingIntent class contains a callback handle as its mem-
ber variable.
We take the downloadMessage() interface as an example.
The related code is shown in Fragments 6.1, 6.2 and 6.3
of Appendix A. Line 253 in Fragment 6.1 shows that imms
calls the corresponding service interface of the MmsService
component. The received callback handle is also passed to
MmsService. This callback handle is used to inform the
client app about the result of sending/downloading MMS
(line 230 in Fragment 6.3). The invocation of this callback
is located in an assistant thread of MmsService (line 427 in
98Figure 3: One Attack on ActivityManagerService
Fragment 6.2). The invocation statement is not protected
by any try-catch block to handle exceptions. When this
vulnerability is exploited, the system would get into hazard
situation B2.
This vulnerability exists in Android 5.0.0-6.0.1. The ex-
ploit code needs the permission of receive(send)_mms, which
is acquirable for a malicious app.
5. PROOF-OF-CONCEPT ATTACKS
5.1 Basic Attacks and Hazards
We present the basic exploitation of the new vulnerabili-
ties here. The attacks are implemented by directly invoking
the vulnerable service interfaces of the SS instead of some
APIs [17]. Therefore, they are more direct and ﬂexible.
5.1.1 System Service Freeze
In order to freeze a system service, the malicious app needs
to implement a callback method which prevents the return-
ing of callback for a long period of time.
Taking V ul#1 as example, the logical relationship of the
attack is shown in Figure 3. The instance of MyMaliciousSer-
vice’s proxy class is forged as an IPC call parameter. It is
passed to the service interface startInstrumentation() of
AMS. Then AMS starts thread X to handle the request.
When thread X invokes the callback method, the onTrans-
act() method in the MyMaliciousService component will
be in charge of the handling. The attack code in MyMali-
ciousService is very simple in that it sleeps for ten minutes.
Therefore, thread X becomes blocked. Thread Y is another
thread which is started by another service request. It also
wants to acquire the AMS.this lock, but it has to wait until
thread X releases it. After a period of time, the watchdog
thread in AMS will kill the process which provides AMS,
namely the SS. The crash of the SS will result in the soft-
reboot of the system.
V ul#2 is similar to V ul#1, except that it requires speciﬁc
permission. V ul#3 is a little diﬀerent, because it is not
triggered immediately after the callback handle is injected.
Hence, the attacks on V ul#3 are more latent than others.
5.1.2 System Soft-Reboot
To soft-reboot the system in a timely manner, a malicious
app must ﬁnd a way to make the SS throw an exception.
The attacks are varied because there are two possible attack
measures.
(a) Leverage a Malicious Service Component to Attack
(b) Induce PackageManagerService to Attack Itself
Figure 4: Two Attacks on PackageManagerService
as an example. In Figure 4(a), a malicious service is used
to conduct the attack. When the callback method is in-
voked, the malicious service selects one exception, namely
NullPointerException, and throws it back. In Figure 4(b),
PMS is attacked by the exception thrown by itself. First-
ly, the instance of PMS’s proxy class is forged as a callback
handle. It is injected to the freeStorage() interface of PM-
S as an IPC call parameter. PMS invokes this callback in
one of its assistant threads. It believes the callee is a service
whose interfaces are deﬁned by the IIntentSender class.
However, the real callee is itself, whose interfaces are de-
ﬁned by the android.content.pm.IPackageManager class.
As the callee, PMS starts a new thread. Code in this new
thread ﬁnds that the interface descriptors do not match.
Then a java.lang.SecurityException is thrown from the
new thread back to the assistant thread in PMS. It is able to
cause the crash of the process which provides PMS, namely
the SS.
System Application Freeze and Crash
5.1.3
Even if the victim of an attack is a system app, the at-
tack hazard also will seriously threaten some critical system
functionalities.
When V ul#5 is exploited, SystemUI will raise an activity
component on the screen. No matter how the device user
interacts with the activity, the callback method in the mali-
cious app will be invoked. The attacker can block the code
in this activity to make SystemUI unresponsive. V ul#6 ex-
ists in the Phone app. The Phone app is in charge of the
cellular networks. Attacks on this app can cause it to crash
and disable all the functionalities of the cellular networks.
We take the logical relationship of the attacks on V ul#4
The logical relationships of the attacks on V ul#5 and
inject(callback, targetService, ssi);attacker.MyMaliciousService.onTransact()(cid:658)  InjectMA Thread Battacker.Component.doAttack()MA Thread AAMS.finishActivity(...)SS Thread YAMS.startInstrumentation(...) synchronized(this){injectedCallback.rpc();}SS Thread XThread.sleep(10*60*1000);Watchdog.Run()SS Thread Zsynchronized(this){/* Codes */;}(cid:659) CallbackHoldMonitorAMS.this(cid:661)(cid:660)inject(callback,targetService,ssi);attacker.MyMalicousService.onTransact()writeExceptionIntoReply(new NullPointerException())MA Thread Battacker.Component.doAttack()MA Thread APMS.freeStorage(...)mHandler.post(new Runnable() {(cid:540)});SSI Primary ThreadPMS.(new Runnable()).run()SSI Secondary ThreadinjectedCallback.rpc();SSI Assistant Thread(cid:658)Inject(cid:659) Start Thread(cid:660):Invoke Callback.(cid:661):Reply Exceptioninject(callback, targetService, ssi);PMS.onTransact()//Throw exception if interfaces descriptor do not match.data.enforceInterface(DESCRIPTOR);attacker.Component.doAttack()MA Thread APMS.freeStorage(...)mHandler.post(new Runnable() {(cid:258)});SSI Primary ThreadPMS.(new Runnable()).run()New ThreadinjectedCallback.rpc();SSI Assistant Thread(cid:659)(cid:658)  Inject(cid:660)(cid:661) Reply Exception(cid:659): Start Thread.  (cid:660): Invoke Callback.99V ul#6 are similar to Figure 3 and 4. The only diﬀerence
is that the callback handle is passed from a system service
to a vulnerable app. Therefore, we do not provide detailed
ﬁgures here. Although the victim apps can be restarted
quickly, the malicious app can continuously trigger the vul-
nerabilities to conduct repetitive attacks.
5.2 Representative Attack Scenarios
Indiscriminate attacks are meaningless.
If an attacker
wants to maximize the attack eﬀect, it should choose the
best time to exploit the vulnerabilities. Previous work [14]
has shown that it is possible to peek into the apps through
a UI state inference attack. Therefore, attackers can trig-
ger the vulnerabilities when the system is conducting critical
tasks. For example:
V ul#2 can block the location updates of map apps, which
will disable the navigation functions;
V ul#3 can make the SDcard unusable, which may contain
installed apps and app data;
V ul#5 can repetitively block the SystemUI to prevent the
user from pressing speciﬁc buttons;
V ul#6 can disable the cellular networks.
V ul#1 and V ul#4 are the two most signiﬁcant among the
new vulnerabilities. We have leveraged some side channels
to monitor the system and designed four attack scenarios
exploiting these two vulnerabilities. A video of the attacks
has been uploaded onto https://youtu.be/w9BMZdvZZec.
5.2.1 Anti Process Killer
Scenario. In order to conduct a timely attack, the pro-
cess of a malicious app needs to stay alive in the background.
However, a background process is unwelcome and may be
killed irregularly.
Design. Android supports an app to run its services in
diﬀerent processes.
If an app is forced to stop, all of its
processes will be killed successively. In our design, the mali-
cious app registers N services in N diﬀerent processes. Each
service listens to the death of the other N-1 services by im-
plementing the ServiceConnection.onServiceDisconnected()
method. Code in this method will exploit the V ul#4, which
can immediately cause the soft-reboot of the system. The
malicious app can register a broadcast receiver component
to listen to the boot_completed intent. Then it can start
its services again to stay alive.
Result. We installed the PoC app on Android 5.1.0,
Nexus 6. This app registers 10 services in 10 processes. We
tried killing the processes of the app using the third par-
ty app 360 Mobile Safe and the system app Settings. The
test result proves that the PoC app can function as an anti
process killer.
5.2.2 Anti Anti-Virus
Scenario. When a device user encounters too many in-
stances of system crash and functional failure, he/she may
suspect that the device is infected by malicious apps. Most
user will choose an anti-virus app to make a security inspec-
tion. The malicious apps need to hinder this to ensure their
survival.
Design. A malicious app can utilize many characteristics
to detect whether an anti-virus app is scanning the apps. For
example, the scanning signiﬁcantly increases the memory
usages of the anti-virus app. Some anti-virus apps start
new processes to do the scanning. The malicious app only
needs a list of the process names of the anti-virus apps. It
can carry out a real-time monitor on the listed processes to
detect the virus scanning.
Result. We installed the PoC app on Android 5.1.0,
Nexus 6. 360 Mobile Safe was selected as the attack tar-
get. According to our study, it starts two processes, namely
scan and engine when scanning the installed apps. The PoC
app checks whether these processes are alive every one sec-
ond. The vulnerability V ul#1 was selected to conduct the
attack. Exploiting V ul#1 can make the device unresponsive