我也要感谢我的编辑—AndyOram，对我始终如一的支持和热诚。
应该感谢CimarronSoftware为我提供一个环境，让我得以开始此计划。还应该感谢
RealmSystems为我提供一个环境，让我得以完成此计划。尤其要感谢DougAdamson、
CathyAnderson和PeterBookman等人。
---
## Page 18
8
前言
谢谢本书的评阅者们，SimonGerraty、JohnMacdonald和PaulSmith，提供了许多见
解深刻的意见，并且修正了许多令我难为情的错误。
应该感谢的人还有为本书付出贡献的：SteveBayer、RichardBogart、BethCobb、Julie
Daily、David Johnson、AndrewMorton、Richard Pimentel、Brian Stevens及Linus
Torvaldse
还要感谢为我在暴风之海提供安全避风港的如下集体：ChristineDelaney、TonyDiSera、
JohnMajor和DanielReading。
最后，感谢我的妻子MaggieKasten以及我的两个孩子William与James，在最后这16
个月期间对我的支持、鼓励以及爱。
---
## Page 19
第一部分
基本概念
在第一个部分里，我们会将重点放在make的功能上：它们能够做什么以及如何正确地
使用它们。我们首先会做个简介，并且告诉你如何创建你的第一个makefile。这部分的
内容涵盖了make的规则、变量、函数以及脚本。
看完第一部分之后，你将会获得相当完整的GNUmake操作知识，并且掌握许多高级
的用法。
---
## Page 21
第一章
如何编写一个
简单的makefile
程序设计的技术通常遵循着一个极为简单的惯例：编辑源代码文件、将源代码编译成可
执行的形式以及对成果进行调试。尽管将源代码转换成可执行文件被视为惯例，但如果
程序员的做法有误也可能会浪费大量的时间在问题的调试上。大多数开发者都经历过这
样的挫败：修改好一个函数之后，运行新的程序代码时却发现缺陷并未被修正，接着发
现再也无法执行这个经过修改过的函数，因为其中某个程序有误，像无法重新编译源代
码、重新链接可执行文件或是重新建造jar文件。此外，当程序变得越来越复杂时，这
些例行工作可能会因为需要（针对其他平台或程序库的其他版本等）为程序开发不同的
版本而变得越来越容易发生错误。
make程序可让“将源代码转换成可执行文件”之类的例行工作自动化。相较于脚本，
make的优点是：你可以把程序中各元素之间的关系告诉make，然后make会根据这些
关系和时间戳（timestamp）（译注1）判断应该重新进行哪些步骤，以产生你所需要的
程序。有了这个信息，make还可以优化编译过程，跳过非必要的步骤。
GNUmake（以及make的其他变体）可以准确完成此事。make定义了一种语言，可
用来描述源文件、中间文件以及可执行文件之间的关系。它还提供了一些功能，可用来
管理各种候选配置、实现可重用程序库的细节以及让用户以自定义宏将过程参数化。简
言之，make常被视为开发过程的核心，因为它为应用程序的组件以及这些组件的搭配
方式提供了一个可依循的准则。
make一般会将工作细节存放在一个名为makefile的文件中。下面是一个可用来编译传
统“Hello，World”程序的makefile：
译注1：Unix文件具有三种时间属性：atime（最近被读取的时间）、ctime（模式被改变的时间）
以及mtime（最近被写入的时间）。文件的时间数（timestamp）就是指mtime。
11
---
## Page 22
12
第一章
hello:hello.c
gcche1lo.c-ohe11c
要编译此程序，你可以在命令行提示符之后键人：
S make
以便执行make。这将会使得make程序读人makefile文件，并且编译它在该处所找到
的第一个工作目标：
S make
gcchello.C-o he1io
会特别针对该工作目标进行更新的动作；如果命令行上未指定任何工作目标，make就
会采用makefile文件中的第一个工作目标，称为默认目标（defaultgoal）。
在大多数makefile文件中，默认的目标一般就是编译程序，这通常涉及许多步骤。程序
的源代码经常是不完整的，而且必须使用flex或bison之类的工具来产生源代码。接
着，源代码必须被编译成二进制目标文件（binaryobjectfile）一一.o文件用于C/C++、
.class文件用于Java等。然后，对C/C++而言，链接器（通常调用自gcc编译器）会将
这些目标文件链接在一起形成一个可执行文件。
修改源文件中的任何内容并重新调用make，将会使得这些步骤中的某些（通常不是全
部）被重复进行，因此源代码中的变更会被适当地并人可执行文件。这个规范说明书文
件（specificationfile）或makefile文件中，描述了源代码文件、中间文件以及可执行文
件之间的关系，使得make能够以最少的工作量来完成更新可执行文件的工作。
所以，make的主要价值在于它有能力完成编译应用程序时所需要的一系列复杂步骤，
优化的动作。此外，make极具灵活性，你可以在任何具有文件依存关系的地方使用它，
范围从C/C++到Java、TEX、数据库管理等。
工作目标与必要条件
基本上，makefile文件中包含了一组用来编译应用程序的规则。make所看到的第一项规
则，会被作为默认规则（defaultrule）使用。一项规则可分成三个部分：工作目标
（target）、它的必要条件（prerequisite）以及所要执行的命令（command）：
target:prereqlprereq2
s
---
## Page 23
如何编写一个简单的makefile
13
工作目标（target）是一个必须建造的文件或进行的事情：必要条件（prerequisite）或
依存对象（dependent）是工作目标得以被成功创建之前，必须事先存在的那些文件：而
所要执行的命令（command）则是必要条件成立时将会创建工作目标的那些shell命令。
下面这项规则是用来将一个C文件foo.c编译成一个目标文件foo.o：
foo.o:foo.cfoo.h
gcc-cfoo.c
工作目标foo.o出现在冒号之前：必要条件foo.c和foo.h出现在冒号之后；命令脚本
（commandscript）通常出现在后续的文本行上，而且会放在跳格符（tabcharacter）之
后。
当make被要求处理某项规则时，它首先会找出必要条件和工作目标中所指定的文件。
如果必要条件中存在关联到其他规则的文件，则make会先完成相应规则的更新动作，
然后才会考虑到工作目标。如果必要条件中存在时间戳在工作目标的时间戳之后的文件
（译注2），则make会执行命令以便重新建立工作目标。脚本会被传递给shell并在其
subshell中运行。如果其中的任何命令发生错误，则make会终止工作目标的建立动作
并结束执行。
下面这个程序会在它的输人中计算fee、fie、foe和fum等词汇（单词）出现的次数。这
个程序（文件名为count_words.c）并不难，因为它使用了一个flex扫描程序：
#include
extern int fee_count，fie_count,foe_count,fum_count;
extern int yylex(void );
int main(int argc,char **argv)
yylex();
printf（*&d$ded &d\n°，fee_count，fie_count，foe_count，fum_count）;
exit（0）;
这个扫描程序（文件名为lexer.l）相当简单：
int fee_count=0;
int fie_count =0；
int foe_count=0;
int fum_count=0；
fee
fee_count++;
fie
fie_count++:
译注2：也就是说，必要条件中最近有文件遗到修改，但是工作目标尚未进行更新的动作。
---
## Page 24
14
第一章
foefoe_count++;
fumfum_count++;
用来编译这个程序的makefile也很简单：
count_words:count_words.olexer.o-1f1
gcccount_words.olexer.o-1fl-o count_words
count_words.o:count_words.c
gcc-c count_words.c
lexer.o:lexer.c
gcc -c 1exer.c
lexer.c:lexer.1
flex-tlexer.1>lexer.c
当这个makefile首次被执行时，我们会看到：
Smake
gcc-c count_words.c
flex-t 1exer.1>lexer.c
gcc-c lexer.c
gcc count_words.olexer.o-1f1-0 count_words
现在我们已经编译好了一个可执行的程序。当然，此处所举的例子有点简化，因为实际
的程序通常是由多个模块所构成。此外，看过后面的章节你就会知道，这个makefile并
未用到make大部分的特性，所以显得有点长。不过，它仍不失为一个实用的makefile。
举例来说，在这个范例的编写期间，为了测试程序，我执行了这个makefile不少于10次。
当这个makefile范例在执行时，你可能会发现make执行命令的顺序儿乎和它们出现在
手法。一般来说，通用形式的工作目标会先在makefile文件中被指定，而细节则会跟在
后面。make程序对此风格的支持有许多方式，其中以make的两阶段执行模型（two-
phaseexecutionmodel）以及递归变量（recursivevariable）最为重要。我们将会在稍
后的章节中深人探讨相关细节。
检查依存关系
make首先注意到命令行上并未指定任何工作目标，所以会想要建立默认目标
count_words。当make检查其必要条件时看到了三个项目：count_words.o、lexer.o以
及-lf1。现在make会想要编译count_words.o并看到相应的规则。接着，make会再
次检查必要条件并注意到count_words.c并未关联到任何规则，但存在count_words.c这
个文件，所以会执行相应的命令把count_words.c转换成count_words.o：
---
## Page 25
如何编写一个简单的makefile
15
gcc-ccount_words.c
这种“从工作目标到必要条件，从必要条件到工作目标，再从工作自标到必要条件”的
链接（chaining）机制就是make分析makefile决定要执行哪些命令的典型做法。
必要条件的下个项目会让make想要编译lexer.o。规则链会将make导向lexer.c，但
这次lexer.c并不存在。make会从lexer.l找到产生lexer.c的规则，所以make会运行
flex程序。现在lexer.c存在了，make会接着执行gcc命令。
最后，make看到-1f1，其中-1是选项，用来要求gcc必须将其所指定的系统程序库
链接进应用程序。此处指定了fl这个参数，代表实际的程序库名称为libfl.a。GNUmake
对这个语法提供了特别的支持：当-1形式的必要条件被发现时，make会搜索
libNAME.so形式的文件；如果找不到相符的文件，make接着会搜索libNAME.a形式的
文件。在此例中，make会找到/usr/lib/libfl.a，而且会进行最后的动作-链接。
尽量减少重新编译的工作量
运行这个程序时，我们发现它除了会输出fee、fie、foe和fum等单词出现的次数，还会
输出来自输入文件的其他文本。这并非我们想要的结果。问题出在我们忽略了词汇分析
器（lexicalanalyzer）的一些规则，而且flex会将未被认出的文本送往输出。我们只
以解决这个问题：
int fee_count=0;
int fie_count =0;
int foe_count=0;
int fum_count=0;
fee
fee_count++;
fie
fie_count++:
foe
foe_count++;
fum_count++:
\n
编辑这个文件之后，还需要重新编译应用程序以便测试我们所做的修正：
Smake
flex-t lexer.1>lexer.c
gcc -clexer.c
gcc count_words.olexer.o-1f1-ocount_words
请注意，这次count_words.c文件并未被重新编译。分析规则的时候，make发现
count_words.o已存在，而且该文件的时间戳在其必要条件counr_words.c的之后，所以
---
## Page 26
16
第一章
不需要采取任何更新的动作。不过，分析lexer.c的时候，make发现必要条件lexer.l的
时间戳在其工作目标lexer.c的之后，所以make必须更新lexer.c。这会依次引起lexer.o、
count_words的更新。运行这个重新编译的程序，你会看到如下的结果：
Scount_words <lexer.1
3333
调用make
前面的范例做了以下假设：
项目的所有程序代码以及make描述文件全都被放在单一目录中。
make描述文件的文件名为makefile、Makefile或GNUMakefile。
·执行make命令时，makefile就放在用户的当前目录（currentdirectory）中。
当make在上述情况下被调用时，make会自动编译其所找到的第一个工作目标。要更
新另一个不同的工作目标（或多个工作目标），请在命令行上指定工作目标的名称：
$makelexer.c
当make被执行时，它会读取描述文件以及找出所要更新的工作目标。如果工作目标或
其必要条件中的任一文件尚未更新（或不存在），则会（以一次一个命令的方式）执行
相应规则的命令脚本中的shell命令。这些命令被执行之后，make会假设工作目标已完
成更新的动作，于是移往下一个工作目标或是结束执行。
如果你所指定的工作目标已经更新（uptodate），则make除了告诉你此状况并立即结
束运行外，其他什么事也不做：
Smake lexer.c
make:lexer.c'is up to date
如果你所指定的工作目标并未出现在makefile文件中，也不存在与之相应的隐含规则
(implicitrule），则make将会作出如下的响应：
Smake non-existent-target
make:***No rule to make targetnon-existent-target'.Stop.
make提供了许多命令行选项。其中最有用的选项之一是--just-print（或-n），用来
要求make显示它将为特定工作目标执行的命令，但不要实际执行它们。当你编写
makefile时，这个功能特别有用。你甚至还可以在命令行上设定几乎所有的makefile变
量，来改写默认值或makefile文件中所设定的值。
---
## Page 27
如何编写一个简单的makefile
17