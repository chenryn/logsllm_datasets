drops from 1442 to 579 bits, a reduction of around 60%.
Note that, as mentioned in Section 1.2, the ‚Äúbasic‚Äù approach can
be optimized by verifying multiplications with QuickSilver [33] or
the amortized version of Mac‚Äôn‚ÄôCheese [4]. This would bring the
basic costs closer to our optimized protocols, with the downside of
making non-black-box use of information-theoretic MACs, with
QuickSilver, or more rounds of interaction and computation, with
Mac‚Äôn‚ÄôCheese. There are two variants of QuickSilver which prove
satisfiability of circuits (‚ÄúQS-Circuit‚Äù) or of sets of polynomials (‚ÄúQS-
Poly‚Äù) respectively. Since bitADDcarry can be either represented
as a Boolean circuit or as a set of polynomials over F2, we can use
both variants in our conversion protocol.
These results highlight the advantage of our approach com-
pared to using only daBits. We also see that using QuickSilver
or Mac‚Äôn‚ÄôCheese to check multiplications (as also done in the con-
current work Mystique [32]) reduces communication by 1.5‚Äì3x.
This is because verifying a circuit with these protocols is cheaper
than evaluating a circuit in our approach (even using faulty triples).
6.2 Experiments
We have implemented the conversion protocol Œ†Conv using the
faulty-dabit approach of Section 3.4 in the Rust programming lan-
guage using the Swanky library1. The VOLE protocol over the 61-bit
field Fùëù with ùëù = 261 ‚àí 1 is instantiated using [31]. All benchmarks
were run on a MacBook Pro 2018, 2.9 GHz 6-Core Intel Core i9,
32 GB 2400 MHz DDR4, with one thread per party. All experiments
1https://github.com/GaloisInc/swanky
Table 3: Comm. in Mbit when verifying 220 conversion tuples
where ùêµ = ùê∂ = 3 with multiplication check of [31].
ùëö = 8
P
171.8
1488.7
V
19.7
57.8
ùëö = 16
P
V
24.2
174.0
2522.1
111.1
ùëö = 32
P
V
33.1
178.4
4591.1
222.2
Init
Conv
Table 4: Run-time in s for verifying 220 conversion tuples
with ùëö = 32 and ùêµ = ùê∂ = 3 with multiplication check of [31].
Bandwidth
Init
Conv
20 Mbit/s
22.6
399.2
100 Mbit/s
500 Mbit/s
14.0
189.3
12.2
173.5
1 Gbit/s
12.1
169.6
are run in a Docker container running Ubuntu and using tc to arti-
ficially limit the network bandwidth, and simulating 1 ms latency.
Our implementation is currently capable of verifying conversions
for ùëö ‚â§ 60. We therefore run our conversion protocol on bit lengths
ùëö ‚àà {8, 16, 32, 60}. All benchmarks are run ensuring statistical
security of 240, by varying the sizes of ùêµ and ùê∂ according to table
6 (see Appendix F). Lastly, all of these listed benchmarks are run
using Wolverine [31] to verify multiplications as in protocol Œ†Conv
of Section 3.2. We also implemented the variant of our protocol
using QuickSilver [33], which reduces the runtimes by around a
factor of two, thanks to the lower communication and preprocessing
requirements. In Appendix F we list all results when running with
either our optimized protocol, or the variant using [33].
Table 3 shows the communication required between the prover
and verifier when verifying 220 conversion tuples, when varying
the bit lengths.In this table we use Init to define the construction
of the channels used by the two parties as well as the initial setup
of the Wolverine VOLE protocol and the initial commitments to
the provers input. The row Conv covers the time it takes for the
prover and verifier to run Œ†Conv on the input provided by the
prover. This covers generation of the required edaBits, daBits
and multiplication triples. Here, even for the smallest setting of
ùëö = 8 it can already be seen that the conversion costs dominates
both the VOLE setup and the Init phase. In Table 4 we list the time
for the same setup except the bit length is fixed at ùëö = 32. It can
be seen that increasing the network bandwidth beyond 100 Mbit/s
does not improve the protocol runtime by much. Therefore, for our
current implementation, computation is the limiting factor.
Acknowledgements
This work is supported by the European Research Council (ERC)
under the European Unions‚Äôs Horizon 2020 research and innova-
tion programme under grant agreement No. 803096 (SPEC), the
Carlsberg Foundation under the Semper Ardens Research Project
CF18-112 (BCM), and the Defense Advanced Research Projects
Agency (DARPA) under Contract No. HR001120C0085. Any opin-
ions, findings and conclusions or recommendations expressed in
this material are those of the author(s) and do not necessarily re-
flect the views of the Defense Advanced Research Projects Agency
(DARPA). Distribution Statement ‚ÄúA‚Äù (Approved for Public Release,
Distribution Unlimited).
Session 1C: Zero Knowledge I CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea204REFERENCES
[1] Benny Applebaum, Ivan Damg√•rd, Yuval Ishai, Michael Nielsen, and Lior Zichron.
2017. Secure Arithmetic Computation with Constant Computational Overhead.
In CRYPTO 2017, Part I (LNCS). Springer, Heidelberg.
[2] Gilad Asharov, Yehuda Lindell, Thomas Schneider, and Michael Zohner. 2013.
More efficient oblivious transfer and extensions for faster secure computation.
In ACM CCS 2013. ACM Press.
[3] Carsten Baum, Lennart Braun, Alexander Munch-Hansen, Benoit Razet, and
Peter Scholl. 2021. Appenzeller to Brie: Efficient Zero-Knowledge Proofs for
Mixed-Mode Arithmetic and Z2ùëò (Full Version). Cryptology ePrint Archive,
Report 2021/750. https://eprint.iacr.org/2021/750.
[4] Carsten Baum, Alex J. Malozemoff, Marc B. Rosen, and Peter Scholl. 2021.
Mac‚Äôn‚ÄôCheese: Zero-Knowledge Proofs for Boolean and Arithmetic Circuits
with Nested Disjunctions. 41st Annual International Cryptology Conference
(CRYPTO 2021).
[5] Donald Beaver. 1992. Efficient Multiparty Protocols Using Circuit Randomization.
In CRYPTO‚Äô91 (LNCS). Springer, Heidelberg.
[6] Rikke Bendlin, Ivan Damg√•rd, Claudio Orlandi, and Sarah Zakarias. 2011. Semi-
homomorphic Encryption and Multiparty Computation. In EUROCRYPT 2011
(LNCS). Springer, Heidelberg.
[7] Elette Boyle, Geoffroy Couteau, Niv Gilboa, and Yuval Ishai. 2018. Compressing
Vector OLE. In ACM CCS 2018. ACM Press.
[8] Elette Boyle, Geoffroy Couteau, Niv Gilboa, Yuval Ishai, Lisa Kohl, Peter Rindal,
and Peter Scholl. 2019. Efficient Two-Round OT Extension and Silent Non-
Interactive Secure Computation. In ACM CCS 2019. ACM Press.
[9] Elette Boyle, Geoffroy Couteau, Niv Gilboa, Yuval Ishai, Lisa Kohl, and Peter
Scholl. 2019. Efficient Pseudorandom Correlation Generators: Silent OT Extension
and More. In CRYPTO 2019, Part III (LNCS). Springer, Heidelberg.
[10] Matteo Campanelli, Dario Fiore, and Ana√Øs Querol. 2019. LegoSNARK: Modular
Design and Composition of Succinct Zero-Knowledge Proofs. In ACM CCS 2019.
ACM Press.
[11] Octavian Catrina and Sebastiaan de Hoogh. 2010. Improved Primitives for Secure
Multiparty Integer Computation. In SCN 10 (LNCS). Springer, Heidelberg.
[12] Ronald Cramer, Ivan Damg√•rd, Daniel Escudero, Peter Scholl, and Chaoping Xing.
2018. SPD Z2ùëò : Efficient MPC mod 2ùëò for Dishonest Majority. In CRYPTO 2018,
Part II (LNCS). Springer, Heidelberg.
[13] Ivan Damg√•rd, Jesper Buus Nielsen, Michael Nielsen, and Samuel Ranellucci. 2017.
The TinyTable Protocol for 2-Party Secure Computation, or: Gate-Scrambling
Revisited. In CRYPTO 2017, Part I (LNCS). Springer, Heidelberg.
[14] Ivan Damg√•rd, Valerio Pastro, Nigel P. Smart, and Sarah Zakarias. 2012. Multi-
party Computation from Somewhat Homomorphic Encryption. In CRYPTO 2012
(LNCS). Springer, Heidelberg.
[15] Samuel Dittmer, Yuval Ishai, and Rafail Ostrovsky. 2021. Line-point zero knowl-
edge and its applications. In 2nd Conference on Information-Theoretic Cryptogra-
phy (ITC 2021). Schloss Dagstuhl-Leibniz-Zentrum f√ºr Informatik.
[16] Daniel Escudero, Satrajit Ghosh, Marcel Keller, Rahul Rachuri, and Peter Scholl.
2020. Improved Primitives for MPC over Mixed Arithmetic-Binary Circuits. In
CRYPTO 2020, Part II (LNCS). Springer, Heidelberg.
[17] Shimon Even, Oded Goldreich, and Abraham Lempel. 1982. A Randomized
Protocol for Signing Contracts. In CRYPTO‚Äô82. Plenum Press, New York, USA.
[18] Tore Kasper Frederiksen, Jesper Buus Nielsen, and Claudio Orlandi. 2015. Privacy-
Free Garbled Circuits with Applications to Efficient Zero-Knowledge. In EURO-
CRYPT 2015, Part II (LNCS). Springer, Heidelberg.
[19] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. 1985. The Knowledge
Complexity of Interactive Proof-Systems (Extended Abstract). In 17th ACM STOC.
ACM Press.
[20] Carmit Hazay, Peter Scholl, and Eduardo Soria-Vazquez. 2017. Low Cost Constant
Round MPC Combining BMR and Oblivious Transfer. In ASIACRYPT 2017, Part I
(LNCS). Springer, Heidelberg.
[21] David Heath and Vladimir Kolesnikov. 2020. Stacked Garbling for Disjunctive
Zero-Knowledge Proofs. In EUROCRYPT 2020, Part III (LNCS). Springer, Heidel-
berg.
[22] Russell Impagliazzo and Steven Rudich. 1989. Limits on the Provable Conse-
[23] Yuval Ishai, Joe Kilian, Kobbi Nissim, and Erez Petrank. 2003. Extending Oblivious
[24] Yuval Ishai, Manoj Prabhakaran, and Amit Sahai. 2009. Secure Arithmetic Com-
quences of One-Way Permutations. In 21st ACM STOC. ACM Press.
Transfers Efficiently. In CRYPTO 2003 (LNCS). Springer, Heidelberg.
putation with No Honest Majority. In TCC 2009 (LNCS). Springer, Heidelberg.
[25] Marek Jawurek, Florian Kerschbaum, and Claudio Orlandi. 2013. Zero-knowledge
using garbled circuits: how to prove non-algebraic statements efficiently. In ACM
CCS 2013. ACM Press.
[26] Eleftheria Makri, Dragos Rotaru, Frederik Vercauteren, and Sameer Wagh. 2021.
Rabbit: Efficient Comparison for Secure Multi-Party Computation. Financial
Crypto 2021.
[27] Moni Naor and Benny Pinkas. 1999. Oblivious Transfer and Polynomial Evalua-
tion. In 31st ACM STOC. ACM Press.
[28] Dragos Rotaru and Tim Wood. 2019. MArBled Circuits: Mixing Arithmetic and
Boolean Circuits with Active Security. In INDOCRYPT 2019 (LNCS). Springer,
Heidelberg.
[29] Peter Scholl. 2018. Extending Oblivious Transfer with Low Communication via
Key-Homomorphic PRFs. In PKC 2018, Part I (LNCS). Springer, Heidelberg.
[30] Phillipp Schoppmann, Adri√† Gasc√≥n, Leonie Reichert, and Mariana Raykova.
2019. Distributed Vector-OLE: Improved Constructions and Implementation. In
ACM CCS 2019. ACM Press.
[31] Chenkai Weng, Kang Yang, Jonathan Katz, and Xiao Wang. 2021. Wolverine: Fast,
Scalable, and Communication-Efficient Zero-Knowledge Proofs for Boolean and
Arithmetic Circuits. 42nd IEEE Symposium on Security and Privacy (Oakland
2021).
[32] Chenkai Weng, Kang Yang, Xiang Xie, Jonathan Katz, and Xiao Wang. 2021.
Mystique: Efficient Conversions for Zero-Knowledge Proofs with Applications
to Machine Learning. In 30th USENIX Security Symposium (USENIX Security 21).
501‚Äì518.
[33] Kang Yang, Pratik Sarkar, Chenkai Weng, and Xiao Wang. 2021. QuickSilver:
Efficient and Affordable Zero-Knowledge Proofs for Circuits and Polynomials
over Any Field. 28th ACM Conference on Computer and Communications
Security (CCS 2021).
[34] Kang Yang, Chenkai Weng, Xiao Lan, Jiang Zhang, and Xiao Wang. 2020. Ferret:
Fast Extension for Correlated OT with Small Communication. In ACM CCS 2020.
ACM Press.
[35] Samee Zahur, Mike Rosulek, and David Evans. 2015. Two Halves Make a Whole -
Reducing Data Transfer in Garbled Circuits Using Half Gates. In EUROCRYPT 2015,
Part II (LNCS). Springer, Heidelberg.
Session 1C: Zero Knowledge I CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea205A COMMITMENT FUNCTIONALITIES
Functionality F 2,ùëÄ
ComZK
ùëñ=1 ùõºùëñ¬∑ùë•idùëñ
(1) Set ùë•idùëú ‚Üê ùõº0+ùëõ
Homomorphic Commitment Functionality F ùëÖ
ComZK
The functionality communicates with two parties P,V as
well as an adversaryS that may corrupt either party.S may
at any point send a message (abort), upon which F ùëÖ
ComZK
sends (abort) to all parties and terminates. F ùëÖ
con-
tains a state st that is initially ‚àÖ.
ComZK
Random On input (Random, id) from P,V and where
(id, ¬∑) ‚àâ st:
(1) If P is corrupted, obtain ùë•id ‚àà ùëÖ from S. Otherwise
sample ùë•id ‚ààùëÖ ùëÖ uniformly at random.
(2) Set st ‚Üê st ‚à™ {(id, ùë•id)} and send ùë•id to P.
We use the shorthand [ùë•] ‚Üê Random().
Affine Combination On input (Affine, idùëú, id1, . . . , idùëõ,
ùõº0, . . . , ùõºùëõ) from P,V where (idùëñ, ùë•idùëñ) ‚àà st for ùëñ = 1, . . . , ùëõ
and (idùëú, ¬∑) ‚àâ st:
and st ‚Üê st‚à™{(idùëú, ùë•idùëú)}.
We use shorthands such as [ùëß] ‚Üê ùëé ¬∑ [ùë•] + [ùë¶] + ùëè.
(CheckZero, id1, . . . , idùëõ)
CheckZero On input
from
P,V and where (idùëñ, ùë•idùëñ) ‚àà st for ùëñ = 1, . . . , ùëõ:
(1) If ùë•id1 = ¬∑ ¬∑ ¬∑ = ùë•idùëõ = 0, then send (success) to V,
otherwise send (abort) to all parties and terminate.
We use the shorthand CheckZero([ùë•1], . . . , [ùë•ùëõ]).
Input On inputs (Input, id, ùë•) from P and (Input, id) from
V and where (id, ¬∑) ‚àâ st:
(1) Set st ‚Üê st ‚à™ {(id, ùë•)}.
We use the shorthand [ùë•] ‚Üê Input(ùë•).
Open On input (Open, id1, . . . , idùëõ) from P,V where
(idùëñ, ùë•idùëñ) ‚àà st for ùëñ = 1, . . . , ùëõ:
, to V.
(1) Send ùë•id1, . . . , ùë•idùëõ
We use the shorthand ùë•1, . . . , ùë•ùëõ ‚Üê Open([ùë•1], . . . , [ùë•ùëõ]).
Moreover, we might use the following macro: ùë• ‚Üê
Open([ùë•], lst) denotes that P sends ùë• to V and they add
[ùë•] ‚àí ùë• to the list lst.
V