the  overall  FSM  relatively  easy.  Since  the  pFSMs  are 
critical to the analysis – it is meaningful to ask – Are there 
a few pFSMs, which allow us to model the bulk if not all of 
the  studied  data?  Our  analysis  shows  that  we  only  require 
three  types  of  pFSMs  to  model  the  full  range  of  studied 
vulnerabilities (i.e., stack buffer overflow, integer overflow, 
heap  overflow,  input  validation  vulnerabilities,  and  format 
string vulnerabilities). 
Object  Type  Check.  This  is  a  predicate  to  verify 
whether the input object is of the type that the operation is 
defined on. In many circumstance, performing an operation 
on  an  object  of  incorrect  type  results  in  fail-secure  states 
[20],  i.e.,  the  operation  fails  without  causing  security  to  be 
compromised.  For  example,  the  object  of  a  ping  operation 
should be an IP address or a hostname. It is meaningless to 
say  “ping  /etc/passwd”,  because  this  will  result  in  an  error 
message “unknown host /etc/passwd”. However, as we have 
seen  in  the  examples,  failure  in  object  type  check  can  be 
exploited by attackers, e.g., rwalld (see Figure 6) does not 
check  whether the file type is a terminal or a non-terminal 
file,  and  Sendmail  (see  Figure  3)  does  not  check  whether 
the input represents an integer or a long integer. 
Content  and  Attribute  Check.    This  is  a  predicate  to 
verify  whether  the  content  and  the  attributes  of  the  object 
meet  the  security  guarantee.  Examples  of  content  and 
attribute  checks  include  (1)  IIS  filename  decoding  (Figure 
7),  where  the  program  should  verify  that  the  request  does 
not  contain  substring  “../”,  (2)  the  system  should  check 
whether format directives are not embedded in the input, in 
order  to  prevent  format  string  vulnerabilities  (#1480),  and 
(3) GHTTPD (#5960) should check whether the length of the 
input string is less than 200 bytes.  
Reference  Consistency  Check.  This  is  a  predicate  to 
verify  whether  the  binding  between  an  object  and  its 
reference  is  preserved  from  the  time  when  the  object  is 
checked  to  the  time  when  the  operation  is  applied  on  the 
object. The examples include the return address referring to 
the  parent  function  code,  the  function  pointer  referring  to  a 
function code, and a filename referring to a file. As shown in 
the  FSM  models,  several  conditions  may  result  in  violating 
the reference consistency, including stack smashing (#5960), 
signed  integer  overflow  (Figure  3),  heap  overflow  (Figure 
4), format string (#1480), and file race condition (Figure 5).  
The pFSMs representing the three generic predicates are 
depicted  in  Figure  8,  which  shows  a  typical  operation  (P)
encompassing the three predicates. While all predicates may 
not be involved in all operations, the three suffice to  model 
all the studied vulnerabilities classes (stack buffer overflow, 
integer  overflow,  heap  overflow,  input  validation,  and 
format string vulnerabilities). Having defined the three types 
of  predicates,  the  following  lemma  is  stated.  The  proof  is 
straightforward and is given in [21]. 
O peration P
p FS M : O B JE C T  T YP E  C H E CK
I M P L _ T Y P E _ R E J ♦ -
! S P E C _ T Y P E _ A C P T ♦ -
object ♦ -
SPE
C_T
YPE_A
CPT ♦
-
p FS M : CO N T E NT /A TTR IB UT E 
C H E CK
-♦ -
! S PE C_CA _ A CP T  ♦ -
S PE C_CA _ A CPT  ♦ -
IM PL_ CA _ A CPT  ♦ -
I
M
P
L
_
C
A
_
R
E
J ♦
-
IM PL_ TY P E_ A CPT  ♦ -
p FS M : R E FE RE NC E 
C O N SIST E NC Y  
C H E CK
P E C _ C O N S T C Y _ A C P T
S
!
♦
-
I M P L _ C O N S T C Y _ R E J
♦
-
IM P L_ C O N ST CY  _A CP T  ♦ -
SPEC_
CO
NSTCY
_A
CPT
-♦ app ly ope ratio n P
o n the object
♦
-
Figure 8: Types of Generic pFSMs 
Lemma:  (1)  To  ensure  the  security  of  an  operation
requires  predicates  (represented  by  pFSMs)  constituting  the 
operation to be correctly implemented. (2) To foil an exploit
consisting  of  a  sequence  of  vulnerable  operations,  it  is 
sufficient  to  ensure  security  of  one  of  the  operations  in  the 
sequence. 
Type of pFSM 
Object Type Check 
Content and Attribute Check 
Reference Consistency Check 
Table 2: Types of pFSMs 
Vulnerabilities 
Sendmail Signed Integer 
Overflow (Figure 3) 
NULL HTTPD Heap Overflow 
(Figure 4)
Rwall File Corruption (Figure 
6)
IIS Filename Decoding 
Vulnerability (Figure 7)
Xterm File Race Condtion 
(Figure 5)
GHTTPD Buffer overflow on 
Stack [21] 
rpc.statd format string 
vulnerability [21] 
pFSM1: Does the input represent a long 
integer? 
pFSM2 : Is the target file a terminal? 
pFSM2: Is the integer in the interval [0 , 100] ? 
pFSM1: contentLen ≥0?  
pFSM2 : length(input) ≤ size(buffer)  
pFSM1: Does the user have a root privilege?  
pFSM1: Does the filename contain “../”? 
pFSM3: Is GOT entry of setuid() 
unchanged? 
pFSM3 : Are free-chunk links unchanged? 
pFSM4: Is GOT entry of free() unchanged? 
pFSM1: Does the user have a write permission 
to the file? 
pFSM1: size(message) ≤ 200 ? 
pFSM2: Does the filename refer to another 
unverified file? 
pFSM2: Is the return address unchanged? 
pFSM1: Does the filename contain format 
directives (e.g., %n, %d)? 
pFSM2: Is the return address unchanged? 
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:06:47 UTC from IEEE Xplore.  Restrictions apply. 
In  Table  2,  the  pFSMs  of  the  vulnerabilities  analyzed 
in the previous sections are classified according to the three 
types of pFSMs identified above. The most common cause 
of  the  analyzed  vulnerabilities  is  an  incomplete  content 
and/or  attribute  check.  This  can  be  explained  by  fact  that 
determining  the  correctness  of  an  attribute  (e.g.,  a  buffer 
size)  or  a  content  (e.g.,  input  contains  a  string  “%n”)  of  a 
given object may require a comprehensive understanding of 
the  application.  Incompleteness  of  a  reference  consistency 
check  is  another  frequent  reason  for  the  vulnerabilities. 
While  techniques  protecting  the  return  address  have  been 
widely  recognized,  very  few  techniques  are  available  to 
protect 
as 
inconsistency  of  function  pointers,  entries  in  GOT  tables, 
and links to free memory chunks on the heap.  
inconsistencies, 
reference 
other 
such 
7.  Conclusions  
This  paper  presents  a  study  of 
the  security 
in  Bugtraq  database.  The 
vulnerabilities  published 
statistical  study  identifies  leading  categories  of  security 
vulnerabilities. An in-depth analysis of vulnerability reports 
and  the  corresponding  source  code  of  the  applications 
reveal  three  characteristics  of  security  vulnerabilities:  (1) 
exploits must pass through a series of elementary activities, 
(2)  exploiting  a  vulnerability  involves  multiple  vulnerable 
operations on several objects, (3) the vulnerability data and 
corresponding  code  inspections  allow  us  to  derive  a 
predicate  for  each  elementary  activity,  and  a  security 
vulnerability  is  the  result  of  violating  the  predicate  in 
implementation.  These  three  observations  motivate  the 
development of the FSM model to depict and reason about 
security  vulnerabilities. Each  vulnerability is  modeled as a 
series of primitive FSMs (pFSMs), which depicts a derived 
predicate.  The  proposed  FSM  methodology  is  exemplified 
by analyzing several types of vulnerabilities, such as buffer 
overflow  and  signed  integer  overflow.  The  pFSMs  are 
classified into three types, indicating three common causes 
of the modeled vulnerability. These causes reflect different 
aspects 
suggest 
opportunities  for  providing  appropriate  checks  to  protect 
the systems.  
considerations, 
security 
and 
of 
A future direction of this work is to study the security 
predicates  specific  to  different  software  (e.g.,  Internet 
services,  administrative  tools  and  TCP/IP  implementation) 
in addition to the generic predicates discussed in this paper 
(e.g.,  buffer  boundary  and  array  index  checks).  We  hope 
that a comprehensive understanding of these predicates will 
enable  us  to  build  an  automatic  tool  for  the  vulnerability 
analysis. 
Acknowledgments 
Inc. 
This  work  is  supported  in  part  by  a  grant  from 
Motorola 
for 
Communications, and in part  by MURI Grant N00014-01-
1-0576. We thank Fran Baker for her careful reading of an 
early draft of this manuscript. 
as  part  of  Motorola  Center 
References 
[1]  D.  E.  Bell  and  L.  J.  LaPadula.  Secure  computer  systems:  A 
mathematical model Technical report MTR-2547 Vol II. Mitre 
Corporation, Bedford, MA, May 1973.  
J.  Rushby.  Security  Requirements  Specifications:  How  and 
What?  Symposium  on  Requirements  Engineering 
for 
Information Security (SREIS), 2001 
[2] 
[3]  John McLean. Specifying and Modeling of Computer Security. 
IEEE Computer 23(1) pp. 9-16. Jan. 1989.  
[4]  John  McLean.  Security  Models.  In  John  Marciniak  edited, 
Encyclopedia of Software Engineering. Wiley Press, 1994. 
[5]  M. Bishop and D. Bailey, A Critical Analysis of Vulnerability 
Taxonomies,  Technical  Report  96-11,  Department  of 
Computer  Science,  University  of  California  at  Davis  (Sep. 
1996). 
[6]  J.  –C.  Laprie.  Dependable  Computing  and  Fault  Tolerance: 
Concepts  and  Terminology.  Proc.  15th  Intl  Symposium  on 
Fault-Tolerant Computing (FTCS-15), pages 2-11, June 1985. 
[7]  T.  Aslam,  I.  Krsul,  E.  Spafford.  Use  of  A  Taxonomy  of 
Security Faults. Proc. 19th NIST-NCSC National Information 
Systems Security Conference 
[8]  C. Landwehr, A. Bull, J. McDermott, W. Choi, A Taxonomy of 
Computer  Program  Security  Flaws,  with  Examples,  ACM 
Computing Surveys 26, no. 3 (Sep 1994). 
[9]  R.  P.  Abbott,  J.  S.  Chin,  J.  E.  Donnelley,  et  al.  Security 
Analysis  and  Enhancement  of  Computer  Operating  Systems.
NBSIR  76-1041,  Institute  for  Computer  Sciences  and 
Technology, National Bureau of Standards, Apr. 1976. 
[10]  B.  Bisbey  II  and  D.  Hollingsworth.  Protection  Analysis 
Project  Final  Report.  ISI/RR-78-13,  DTIC  AD  A056816, 
USC/Information Sciences Institute, May 1978 
[11]  U.  Lindqvist  and  E.  Jonsson.  How  to  Systematically  Classify 
Computer  Security  Intrusions.  In  Proc.  of  the  1997  IEEE 
Symposium on Security and Privacy, pages 154-163, Oakland, 
CA, May 4-7, 1997. 
[12]  M. Howard and D. LeBlanc, Writing Secure Code. Microsoft 
Press. 2001. 
[13]  http://www.securityfocus.com 
[14]  http://www.cert.org 
[15]  StackGuard  Mechanism:  Emsi's  Vulnerability,  http://www. 
immunix.org/StackGuard/emsi_vuln.html 
[16]  J.  Xu,  Z.  Kalbarczyk,  S.  Patel  and  R.  K.  Iyer.  Compiler  and 
Architecture  Support  for  Defense  against  Buffer  Overflow 
Attacks. 2nd Workshop on Evaluating and Architecting System 
Dependability (EASY), San Jose, CA, October, 2002. 
[17]  R. Ortalo, Y. Deswarte and M. Kaaniche, Experimenting with 
Quantitative  Evaluation  Tools  for  Monitoring  Operational 
Security. IEEE Transactions on Software Engineering, vol. 25, 
no. 5, pp.633-650, Sept. 1999 
[18]  O. Sheyner, J. Haines, S. Jha, et al. Automated generation and 
analysis  of  attack  graphs.  Proc.  2002  IEEE  Symposium  on 
Security and Privacy. Page(s): 254 –265 
[19]  C.  Michael,  A.  Ghosh.  Simple,  state-based  approaches  to 
program-based  anomaly  detection.  ACM  Transactions  on 
Information and System Security. Pages: 203-237. Vol.5 No.3. 
Aug. 2002 
[20]  B.  Madam,  K.  Goseva-Popstojanova,  et  al.  Modeling  and 
Quantification  of  Security  Attributes  of  Software  Systems. 
Proc. 2002 IEEE Intl Conference on Dependable Systems and 
Networks. Pages: 505-514. June 2002 
[21]  S.  Chen,  Z.  Kalbarczyk,  J.  Xu,  R.  Iyer.  Finite  State  Machine 
Models  of  Security  Vulnerabilities.  http://ww.crhc.uiuc.edu/ 
~shuochen/data-model-full.pdf
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:06:47 UTC from IEEE Xplore.  Restrictions apply.