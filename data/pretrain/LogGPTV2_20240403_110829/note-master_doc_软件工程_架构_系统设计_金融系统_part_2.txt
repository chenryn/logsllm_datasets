使用事件溯源架构
- 函数式编程：数据都不可以被修改，所有函数也不允许有随机性以保证确定性
- 计算精度问题
#### 基本概念
- 命令：系统收到的外部指令
- 事件：命令检查的结果就是事件，由于事件是正确性检查后的结果，事件的执行一定不会出问题
- 状态：事件执行的结果是改变状态
#### 队列
所有的命令或者事件的处理都要有确定的顺序
![20221226164917](/assets/20221226164917.webp)
#### 执行事件和改变状态
- 自动机执行：将事件队列当作一个有始无终的磁带。你会从头开始依次读取每个事件。读取之后按事件内的指示来改变内存状态，在执行事件的过程中不能有任何随机行为，不要有真随机数、不要有IO，这样才能保证计算可重复以避免不确定性
- 时光机：重置自动机状态，然后把事件一个一个执行，直到运行到指定的时间点，就能得到该时间点的状态
- 系统快照：金融系统里有一个日切的概念。日切指的是在每天晚上 12 点的时候，你需要对当天的所有业务进行清点，确认无误后再开始下一天的工作，即12点打一个快照
#### 查询
- 历史状态查询：先找到距离查询时间最近的快照，然后从这个快照开始执行事件，直到碰到查询时间点
![2022122617358](/assets/2022122617358.webp)
#### 正确性的本质
任何一个时间点的状态等于之前所有事件效果的累积
$$\sum_{i=0}^{n-1}ei$$
- 自动机是没有随机性的，原因是在数学里所有的数学函数都没有随机性
- 记录事件的时候要求事件之间有顺序，这是因为自动机对应的函数一般是不可交换的（Non-commutative）
- 数据之间是线性序列（Linear Order）的关系。这个线性序列关系是选择用 FIFO 队列的存储队列的原因
### 结果正确
验证：选择不同的计算环境，这样才能降低和之前计算结果的相关性
在极其重要的场景，一般会验证 3 次，只有在至少 3 个结果完全一样的情况下才会向外输出结果
- 实时验证：验证通过之后再往外公布计算结果
- 异步验证：公布结果之后再择机进行验证，可能会对外造成不好的影响，因此需要业务有事后补偿的能力
## 数据传输
### 交易数据
既要保证顺序的正确性，也要保证消息处理的一次性
使用限流手段来保护自身的服务器容量不被击穿，一旦上下游之间做了限流，那么整个系统就需要假设数据会丢失
### 非实时市场数据
- 对延时要求不是特别高的使用场景
非实时数据的传输方式分为订阅发布（Pub/Sub）和消息（Messaging）两大类。在订阅发布的情况下，每个消息的消费者是互相独立的，每个人都需要处理所有消息，并且每个人处理消息的顺序必须是一样的。消息则刚好相反。所有人之间共享所有消息
历史数据是有时效性的，如果所有历史数据对你的价值都是一样高，那么一般来说数据需要尽量完整。相反，如果越接近现在的数据对你的价值越高，那么数据则有可能允许丢失
### 实时市场数据
- 对延时要求非常高的数据场景，能支持的用户数有限，所以一般都需要收席位费
由于对延迟要求高，所以不能采用拉消息的模式，像Kafka的消费模式就不行
同时对消息的编解码效率要求也要很高，相比JSON、XML，二进制编解码协议的效率更高，如金融行业使用的FIX通讯协议，只需要传输数据变动的部分
![20221227105457](/assets/20221227105457.webp)
## 数据存储
- 图数据库：一般都出现那些跟数据分析相关的部门，在和客户进行业务往来之前先要对客户进行背景调查（KYC，Know Your Customer），或者查看用户是否存在洗钱行为（AML，Anti-Money Laundering）
- 时序数据库
- KDB：是个列存储的数据库，配套使用编程语言Q和K，适用的数据量范围是 GB～TB 之间
- 双时序数据库：不适合吞吐量特别高的业务，适合交易量稍小一些的场外交易类业务
- 关系型数据库：编程模型与存储模型不同，即[阻抗不匹配](/软件工程/架构/数据系统.md#数据模型)
- 树状数据存储，NewSQL，虽然解决了对象存储的问题，但没有完美解决对象的查询问题
## 系统优化
### 吞吐量优化
互联网里的“快”，指的是服务器集群的处理能力快，能同时处理很多东西，即吞吐量大
使用[高并发](/软件工程/架构/系统设计/高并发.md#高并发)的优化手段
### 延迟优化
吞吐量优化是系统能力的横向扩展，是宏观资源的调配。而延时是系统能力的纵向扩展，是微观资源的调配
- 单机优化：减少进程上下文切换，比如让进程独享单个CPU，提升内存读写速度
- 网络优化：减少内核态与用户态切换开销
### 特殊优化
#### 合并存储
把事件和前后两个状态都保存在一起，历史查询就变得非常简单。由于现在每个事件都有对应的前后状态，我们只需要寻找离查询时间最近的事件就可以了。找到了对应的事件，我们就可以找到对应的状态
![20221227155549](/assets/20221227155549.webp)
#### 对账优化
1. 前一个事件的最终余额等于下一个事件的初始余额
2. 每个事件的最终余额等于这个事件的初始余额加上事件变动金额
这样对于任何一个用户的任何一个状态，我们都可以顺着链条找到所有金额变动的过程，并对这个过程进行校验
## 支付系统设计
聚合支付：
```mermaid
stateDiagram-v2
  订单服务 --> 支付服务
  支付服务 --> 支付宝
  支付服务 --> 微信支付
  支付服务 --> 银联支付
```
### 表设计
![批注 2020-04-06 114716](/assets/批注%202020-04-06%20114716.png)
### 整体流程
```mermaid
sequenceDiagram
  订单Web ->> 订单服务: 下单
  订单服务 ->> 支付服务: 发送订单
  支付服务 ->> 订单服务: 支付令牌
  订单Web ->> 支付Web: userId，orderId，支付令牌
  支付Web ->> 支付服务: 完成支付
```