in § D.5), sanitization leaves us with 720 distinct bytecodes out of
which we can label 100 contracts to be trivially non-reentrant (be-
cause they did not contain any possibly reentering instruction) and
2 were out of the scope of our analysis (because they contain at
least one DELEGATECALL or CALLCODE instruction) and hence
immediately classified to be potentially vulnerable. We make this
sanitized benchmark available to the community, including byte-
code and sources (where available) [6]. For 13 contracts we failed
to reconstruct the control flow graph, leaving us with 605 distinct
contracts to run our experiments on.
We ran three different experiments for evaluating eThor’s perfor-
mance for the single-entrancy property: one without performing
any Horn clause folding and two performing each one of the two
Horn clause folding variants described in § 4. The aim of this ex-
perimental set up is not only to conduct a comparison with ZEUS,
but also to showcase how eThor’s modular structure facilitates its
performance in that eThor can flexibly benefit from different opti-
mization techniques of the HoRSt compiler. In the comparison with
ZEUS, we take into account the combined result of the three dif-
ferent experiments (the contracts solvable using any of the applied
transformations). For the exhaustive folding, we only considered
instances where we could generate the smt-lib output in less than
15 minutes.9 All of the experiments were conducted on a Google
7We chose to compare with [34] as we found it the only (claimed) sound tool to support
a property comparable to single-entrancy. [48] only supports a no-write-after-call
pattern which the authors claim themselves to be different from reentrancy. [37] makes
use of a similar pattern.
8https://github.com/ethereum/tests/
9This timeout was chosen since it yielded a termination rate of > 95%.
Measure
termination
sensitivity
specificity
F-measure
Definition
terminated/total
tp/(tp + f n)
tn/(tn + f p)
2 ∗ (spec ∗ sens/(spec + sens))
eThor
95.4
100
80
88.9
[34]
98.3
11.4
99.8
20.4
Table 1: Performance comparison of eThor and ZEUS [34].
total/terminated denotes the total number of contracts in the data
set/the number of contracts the respective tool terminated on. tp/fp
denotes the number of true/false positives and tn/fn the number of
true/false negatives.
Cloud Server with 24 Cores at 2.8 GHz and 150 GiB of RAM. At most
30 queries were executed at once, each with a 10 minutes timeout.
Combining the different experiments we were able to obtain results
for all but 20 contracts.
In order to assess the precision of our tool, we compared the
results with [34]. Because of the existing unsoundness claims of [34]
in the literature [24, 47] we manually reassessed the ground truth
provided by [34] for all contracts that were labeled insecure by at
least one of the tools. Since this is a challenging and time consuming
task, especially in the case that no Solidity source code is available,
we excluded all contracts with more than 6000 bytecodes for which
we were not able to obtain the source code, which leaves us with
712 contracts for which we assessed the ground truth.
Surprisingly, we found numerous contracts labeled non-reentrant
by [34] which, if analysed in a single contract setting, definitely
were reentrant according to the definition of reentracy given in
Definition 2.1 and also according to the informal definition provided
in [34] itself10. We assume this to be an artefact of [34]’s syntactical
treatment of the call directive on the Solidity level which is, how-
ever, insufficient to catch all possible reentrancies. As the authors
claim to exclude reentrancies introduced by the send directive (even
though this is officially considered potentially insecure [22]), for
the sake of better comparability, we slightly updated our abstract
semantics to account for calls that can be deemed secure follow-
ing the same argument (namely that a small gas budget prevents
reentrancy). In the following we compare eThor against [34] on
our manually established ground truth. The results are summarized
in Table 1.
For achieving a termination rate comparable to [34] (95.4% vs.
98.3%), we needed to run our tool with a substantially higher time-
out (10 min. query timeout vs 1 min. contract time out for ZEUS).
This difference can be explained by the fact that our analysis works
on little structured bytecode in contrast to the simplified high-level
representation used by [34]. Additional overhead needs to be at-
tributed to the usage of sound abstractions on bytecode level as
well as to our different experimental setup that did not allow for
the same amount of parallelization. The soundness claim of [34]
is challenged by the experimentally assessed sensitivity of only
11.4%. One possible explanation for this low value, which deviates
from the numbers reported in [34] on the same data set, is that
the intuition guiding the manual investigation performed by [34]
10[34] gives the following informal definition: ‘A function is reentrant if it can be
interrupted while in the midst of its execution, and safely re-invoked even before its
previous invocations complete execution.’
12
eThor: Practical and Provably Sound Static Analysis
of Ethereum Smart Contracts
Accepted for ACM CCS, 2020
absence of reentrancy bugs, and provides a dynamic detection algo-
rithm for it. Besides that the authors prove that statically showing
a smart contract to be effectively callback free is indeed undecid-
able. This work serves as a motivation why the correct and precise
static analysis of smart contracts with respect to relevant security
properties is challenging and requires the usage of suitable (sound)
abstractions in order to be feasible, or even possible.
As a consequence, most practical static analysis tools so far
focused on the heuristic detection of certain (classes of) bugs. These
works do not strive for any theoretical guarantees nor do they
aim for giving formal (and semantic) characterizations of security
properties that the analysis targets. Important representatives of
such bug-finding tools are the static analyzer Oyente [38] which
was the first static analyzer for Ethereum smart contracts and the
tool Osiris [47] which focuses on the detection of integer bugs.
Since the aim and scope of these tools differ substantially from the
ones of eThor, we omit a more detailed discussion and refer the
interested reader to recent surveys [19, 24, 36] for more details.
In contrast to pure bug-finding, some recent works target a sound
and automated static analysis of smart contract security properties.
In particular the tools Securify [48], ZEUS [34], EtherTrust [24],
and NeuCheck [37] make such soundness claims.
Securify implements a dependency analysis based on the recon-
structed control-flow graph of contract bytecode and expresses
some generic security properties in terms of these dependencies.
The paper claims that the dependency patterns which they provide
are either sufficient for the satisfaction (compliance patterns) or
the violation (violation patterns) of a property. However, no proofs
for the correctness of the control-flow-graph transformation, the
soundness of the dependency analysis itself, or the relationship
between the security patterns and the properties are provided. As a
consequence we could empirically show that Securify’s algorithm
for control-flow reconstruction is unsound and give counterexam-
ples for 13 out of 17 patterns (which partly also indicate a flaw in
the dependency analysis itself). In § D we give a detailed account
of these issues.
NeuCheck is a tool for analysing Solidity smart contracts by
searching for patterns in the contract syntax graph. The soundness
claim of the work is neither substantiated by a soundness statement,
nor proof. Also no semantics of Solidity is given and no (formal)
security properties are formulated. This lack of formalism makes it
hard to validate any soundness claim. Despite the missing formal
connections, the given patterns are clearly of syntactic nature and
can be argued not to match the intuitive properties given through-
out the paper which makes NeuCheck rather a bug-finding and
style-checking tool. For more details we refer to § D.
Similar to NeuCheck, ZEUS analyzes smart contracts written in
Solidity. To this end, it transforms Solidity smart contracts into an
abstract intermediate language and later into LLVM bitcode which
allows for leveraging existing symbolic model checkers. The code
transformations are claimed to be semantics preserving which how-
ever has already been refuted by [24]. Additionally, the analyzed
security properties are neither formally defined nor are they trans-
lated for model checking in a streamlined fashion: while some of
them are compiled to assertions, other properties require additional
code transformations which we show to be flawed in § D. Empirical
Figure 12: Query runtimes in ms for the combined approach
itemized by queries. A red/green/blue dot denotes a query solved
fastest with no/linear/exhaustive folding.
departed from the notion of single-entrancy and the intuitive def-
inition given by the authors. This highlights the importance of
formalizing not only the analysis technique but also the security
properties to be verified. When interpreting the high specificity
of [34] (almost 100%) one should consider that ZEUS labels only
22 contracts vulnerable in total out of which one is a false positive.
Given that the dataset is biased towards safe contracts (517 safe as
opposed to 195 unsafe ones) a high specificity can be the result of a
tool’s tendency to label contracts erroneously secure. Due to the
proven soundness, for eThor such a behavior is excluded by design.
This overall advantage in accuracy of eThor over ZEUS is reflected
by eThor’s F-measure of 88.9% as opposed to 20.4% for ZEUS.
Horn Clause Folding. Our experimental evaluation shows that,
while both forms of Horn clause folding improve the termination
rate, the results of the different foldings are not directly comparable.
This is illustrated by Figure 12 which plots the (lowest) termination
times for those queries that terminated within 200 seconds during
the large-scale experiment. The different colors indicate the kind of
optimization (no/linear/exhaustive folding) that was fastest to solve
the corresponding query. The distribution of the dots shows that
in the range of low query times (indicating more simply structured
contracts) exhaustive folding (depicted in blue) dominates. However,
for longer query times, often the linear folding (depicted in green)
shows a better performance. One possible explanation for this is
that for more complex contracts, the blow-up in rules created by
the exhaustive folding exceeds the benefits of eliminating more
predicates. Interestingly, for few instances, even applying no folding
at all (indicated in red) led to the fastest termination. We can only
explain this behavior by special heuristics used inside z3 that helped
these particular cases. This shows the lacking predictability of z3
and thereby motivates the necessity of high-level tools like HoRSt
that allow users to easily combine different optimizations in order
to obtain results reliably.
6 RELATED WORK & DISCUSSION
In the last years there has been plenty of work on the automatic
analysis of Ethereum smart contracts. These works can be clas-
sified in dynamic and static analysis approaches: An example of
a dynamic approach is the work by Grossmann et al. [26] which
studies effectively callback freedom, a property characterizing the
13
Accepted for ACM CCS, 2020
Clara Schneidewind, Ilya Grishchenko, Markus Scherer, and Matteo Maffei
evidence for the unsoundness of ZEUS has been reported by [47]
and is emphasized by the empirical evaluation in § 5.
The work presented in [24] surveys different approaches to static
analysis and aims at illustrating design choices and challenges in
sound static analysis. The work also discusses EtherTrust, a first
proof of concept for a reachability analysis based on Horn clauses,
which however is still preliminary and exhibits soundness issues
in its abstraction as discussed § D.
For avoiding the pitfalls leading to unsoundness in the presented
works, eThor follows a principled design approach: Starting from
the formal EVM semantics defined in [25], it formulates an abstract
semantics in the specification language HoRSt which is proven
sound with respect to the concrete semantics, hence covering all
particularities of the EVM bytecode language. Based on this abstract
semantic specification, a streamlined compilation process creates an
SMT-encoding which is again systematically tested for soundness
against the official test suite to minimize the effect of implemen-
tation bugs. The challenge of sound control flow reconstruction
is solved by basing a corresponding preanalysis on a proper relax-
ation of the provably sound abstract semantics in the Soufflé format,
ensuring that the original soundness guarantees are inherited. For
a more robust development, it is planned to also streamline this
process in the future by making the HoRSt compiler support Soufflé
as additional output format for a restricted Horn clause fragment.
For providing end-to-end guarantees of the resulting static ana-
lyzer, we do not only ensure the soundness of the core analysis by
proofs and testing, but also give provably sound approximations
for relevant formalized semantic security properties suitable for
encoding in the analysis framework.
7 CONCLUSION
We presented eThor, the first automated tool implementing a sound
static analysis technique for EVM bytecode, showing how to ab-
stract the semantics of EVM bytecode into a set of Horn clauses
and to express security as well as functional properties in terms of
reachability queries, which are solved using z3. In order to ensure
the long-term maintenance of the static analyzer and facilitate fu-
ture refinements, we designed HoRSt, a development framework for
Horn-clause based static analysis tools, which given a high-level
specification of Horn clauses automatically generates an optimized
implementation in the smt-lib format. We successfully evaluated
eThor against the official Ethereum test suite to gain further con-
fidence in our implementation and conducted a large-scale eval-
uation, demonstrating the practicality of our approach. Within a
large-scale experiment we compared eThor to the state-of-the-art
analysis tool ZEUS, demonstrating that eThor surpasses ZEUS in
terms of overall performance (as quantified by the F-measure).
This work opens up several interesting research directions. For
instance, we plan to extend our analysis as well as HoRSt to re-
lational properties, since some interesting security properties for
smart contracts can be defined in terms of 2-safety properties [25].
Furthermore, we intend to further refine the analysis in order to
enhance its precision, e.g., by extending the approach to a multi-
contract setting, introducing abstractions for calls that approximate
the account’s persistent storage and local memory after calling
more accurately. Furthermore, we plan to significantly extend the
14
scope of HoRSt. First, we intend to make the specification of the
static analysis accessible to proof assistants in order to mechanize
soundness proofs. Furthermore, we intend to explore the automated
generation of static analysis patterns from the specification of the
concrete semantics, in order to further reduce the domain knowl-
edge required in the design of static analyzers.
ACKNOWLEDGMENTS
This work has been partially supported by the the European Re-
search Council (ERC) under the European Union’s Horizon 2020
research (grant agreement 771527-BROWSEC); by the Austrian Sci-
ence Fund (FWF) through the projects PROFET (grant agreement
P31621) and the project W1255-N23; by the Austrian Research Pro-
motion Agency (FFG) through the Bridge-1 project PR4DLT (grant
agreement 13808694) and the COMET K1 SBA; and by the Internet
Foundation Austria (IPA) through the netidee project EtherTrust
(Call 12, project 2158).
REFERENCES
[1] 2016. The DAO Smart Contract.
0xbb9bc244d798123fde783fcc1c72d3bb8c189413#code.
Available at http://etherscan.io/address/
[2] 2017. The Parity Wallet Breach, 30 million ether reported stolen. Available
at https://www.coindesk.com/30-million-ether-reported-stolen-parity-wallet-
breach/.
[3] 2017. The Parity Wallet Vulnerability. Available at https://paritytech.io/blog/
[4] 2019. SafeMath library source. https://github.com/OpenZeppelin/openzeppelin-
security-alert.html.
contracts/blob/master/contracts/math/SafeMath.sol.
[5] 2019. Solidity. https://solidity.readthedocs.io/.
build,
[6] 2020.
source
eThor:
code,
https://secpriv.wien/ethor.
and
evaluation
artifacts.
[7] 2020. evm-cfg-builder. https://github.com/crytic/evm_cfg_builder.
[8] 2020. SMT-LIB. Available at http://smtlib.cs.uiowa.edu/language.shtml.
[9] Chandra Adhikari. 2017. Secure Framework for Healthcare Data Management
Using Ethereum-based Blockchain Technology. (2017).
[10] Elvira Albert, Pablo Gordillo, Benjamin Livshits, Albert Rubio, and Ilya Sergey.
2018. Ethir: A framework for high-level analysis of ethereum bytecode. In
International Symposium on Automated Technology for Verification and Analysis.
Springer, 513–520.
[11] Sidney Amani, Myriam Bégel, Maksym Bortin, and Mark Staples. 2018. Towards
Verifying Ethereum Smart Contract Bytecode in Isabelle/HOL. CPP. ACM. To
appear (2018).
[12] Nicola Atzei, Massimo Bartoletti, and Tiziana Cimoli. 2017. A Survey of Attacks
on Ethereum Smart Contracts (SoK). In International Conference on Principles of
Security and Trust. Springer, 164–186.
[13] Asaph Azaria, Ariel Ekblaw, Thiago Vieira, and Andrew Lippman. 2016. Medrec:
Using Blockchain for Medical Data Access and Permission Management. In Open