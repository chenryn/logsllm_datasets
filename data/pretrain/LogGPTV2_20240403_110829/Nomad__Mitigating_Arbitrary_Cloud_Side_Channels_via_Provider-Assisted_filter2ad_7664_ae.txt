migration constraints in the Client API, as the other attacks (i.e.,
launch many VMs or induce churn) are largely disincentivized be-
cause they induce high cost or are detectable. Figure 9 presents the
effectiveness of our system with a strategic adversary that launched
30 non-movable VMs at an epoch 10. The base case (i.e., sim-
ple adversary) refers to an adversary with only 2 VMs, and the
without Nomad system refers to the system that does random ini-
tial placements for all arriving VMs. This result conﬁrms our in-
tuition that Nomad is resilient to strategic adversaries exploiting
“non-migration” constraints of the Client API (§5).
Figure 9: CDF of client-to-adversary InfoLeakage at an epoch
19 for a sliding window of 5 epochs (cluster size: 200, number
of clients: 200)
8For the purpose of illustration, we introduced the concept of be-
nign and adversarial clients. However, the algorithm makes no as-
sumption on which client is adversarial.
9 Discussion
Before we conclude, we discuss four outstanding issues.
 80 90 100 110 120 130 140 150 160Client1Client2Client3Client4Throughput (# requests / 10s)With NomadWithout Nomad 150 200 250 300Client1Client2Client3Client4Job completion time (s)With Nomad - random initial placementWithout Nomad - random initial placementWithout Nomad - optimal initial placement 0.92 0.93 0.94 0.95 0.96 0.97 0.98 0.99 1 0 0.5 1 1.5 2 2.5 3CDFClient-to-Client InfoLeak (epoch)Base Case (Simple Adversary)With Nomad (Strategic Adversary)Without Nomad (Strategic Adversary)Network impact: Overall network impact of Nomad due to migra-
tion could be a concern. However, we note that modern datacenters
have well-provisioned networks (e.g., 10Gbps full bisection band-
width [17]). Furthermore, Nomad’s migrations are predictable and
amenable to trafﬁc engineering [7]. Furthermore, with techniques
like incremental diffs, the transfer size will be much less than the
base VM memory image with 50% reduction (e.g., [18]). Thus,
we expect minimal network impact from Nomad, especially given
that datacenters handle much larger (tens of GB) ﬂows [17].
Fairness across clients: There are two issues with fairness. The
ﬁrst is w.r.t. the leakage guarantees that each client achieves and the
second is w.r.t. the migration costs that each client faces. While our
current algorithm does not explicitly take into account fairness ob-
jectives across clients, our analysis and empirical evaluations show
that the greedy algorithm naturally achieves a reasonably fair out-
come. That said, extending the basic algorithm to support fair-
ness goals is an interesting direction for future work. In particular,
deﬁning suitable fairness objectives in a heterogeneous environ-
ment where different clients have varying number of VMs, degrees
of replication, and sensitivity to migration is an interesting direc-
tion for future work. We posit that some concepts like dominant
resource fairness might be useful here [15].
Handling heterogeneous client workloads: Our current Place-
ment Algorithm utilizes a different algorithm for each deployment
model. An interesting extension is designing the Placement Al-
gorithm using a hybrid approach that enables a cloud provider to
handle heterogeneous client workloads given an adversarial model
(i.e., client specifying to be R or NR under C or NC scenario).
Incentives for adoption: We argue that cloud clients who are
security conscious have a natural incentive to opt-in to the No-
mad service to minimize the impact of side channels. Moreover,
the impact of Nomad migrations on the applications for reason-
able epoch duration will likely be small and thus the cost is quite
low. Providers too have a natural incentive to enable Nomad as a
service as it might introduce new monetization avenues; e.g., No-
mad can be offered as an value-added security service for a slight,
additional fee. Furthermore, we believe that this vision of adding
provider-assisted services is naturally aligned with the real-world
economics of cloud computing.
10 Conclusions
Co-residency side channels in public cloud deployments have been
demonstrated to be a real and growing threat. Unfortunately, ex-
isting solutions require detailed changes to hardware/software and
client applications, and/or sacriﬁcing the multiplexing beneﬁts that
clouds offer. Nomad offers a practical vector-agnostic and robust
defense against arbitrary (and future) side channels. Moreover, it
is effective against strong adversary models where client VMs can
collaborate and where we do not even need to pinpoint who the ad-
versary is. The key insight is in leveraging provider-assisted VM
migration as a way to bound co-residency and hence limit informa-
tion leakage across all client pairs. We demonstrated that Nomad
can scale to large cloud deployments and imposes low overhead
on client applications. While there are open questions (e.g., very
fast side channels, heterogeneous guarantees), we believe that the
core idea of Nomad is quite powerful and can complement attack-
speciﬁc side channel defenses. Seen in a broader context, Nomad
is a proof point demonstrating a novel cloud provider-assisted se-
curity solution and we believe that this paradigm can more broadly
enable novel and robust defenses against other security problems.
11 Acknowledgments
This work was supported in part by NSF awards CNS-1440065
and CNS-1330599. We thank Anupam Gupta, Ravishankar Krish-
naswamy, Kyle Soska, the anonymous reviewers, and our shepherd
Cristiano Giuffrida for their helpful suggestions.
12 References
[1] Amazon EC2 Pricing. http://aws.amazon.com/ec2/pricing/.
[2] Apache Hadoop. http://hadoop.apache.org/.
[3] Conﬁgure migrations - OpenStack Cloud Administrator Guide.
http://docs.openstack.org/admin-guide-cloud/content/
section_configuring-compute-migrations.html.
[4] IBM CPEX Optimizer. http://www-01.ibm.com/software/
commerce/optimization/cplex-optimizer/.
[5] OpenStack OpenSource Cloud Computing Software.
https://www.openstack.org/.
[6] Wikibench. http://www.wikibench.eu/.
[7] M. Al-Fares et al. Hedera: Dynamic ﬂow scheduling for data center networks.
In Proc. USENIX NSDI, 2010.
[8] A. M. Azab et al. Hypersentry: enabling stealthy in-context measurement of
hypervisor integrity. In Proc. ACM CCS, 2010.
[9] Y. Azar et al. Co-location-resistant clouds. In Proc. ACM CCSW, 2014.
[10] V. Chandola et al. Anomaly detection: A survey. ACM computing surveys
(CSUR), 41(3):15, 2009.
[11] C. Clark et al. Live migration of virtual machines. In Proc. USENIX NSDI,
2005.
[12] J. R. Douceur. The sybil attack. In Peer-to-peer Systems, pages 251–260.
Springer, 2002.
[13] D. Evans et al. Effectiveness of moving target defenses. In Moving Target
Defense, pages 29–48. Springer, 2011.
[14] R. C. Fernandez et al. Making state explicit for imperative big data processing.
In Proc. USENIX ATC, 2014.
[15] A. Ghodsi et al. Dominant resource fairness: Fair allocation of multiple
resource types. In Proc. USENIX NSDI, 2011.
[16] S. Ghorbani et al. Transparent, live migration of a software-deﬁned network. In
Proc. ACM SOCC, 2014.
[17] A. Greenberg et al. Vl2: A scalable and ﬂexible data center network. In Proc.
ACM SIGCOMM, 2009.
[18] D. Gupta et al. Difference engine: Harnessing memory redundancy in virtual
machines. In Proc. USENIX OSDI, 2008.
[19] Y. Han et al. Security games for virtual machine allocation in cloud computing.
In Decision and Game Theory for Security. 2013.
[20] G. Irazoqui et al. Wait a minute! a fast, cross-vm attack on aes. In Cryptology
ePrint Archive,Report 2014/435. 2014.
[21] G. Irazoqui et al. S$a: A shared cache attack that works across cores and deﬁes
vm sandboxing-and its application to aes. In Proc. IEEE S&P, 2015.
[22] C. Jo et al. Efﬁcient live migration of virtual machines using shared storage. In
Proc. ACM VEE, 2013.
[23] T. Kim et al. Stealthmem: System-level protection against cache-based side
channel attacks in the cloud. In Proc. USENIX Security, 2012.
[24] A. Krause and D. Golovin. Submodular function maximization. Tractability:
Practical Approaches to Hard Problems, 3:19, 2012.
[25] M. Li et al. Improving cloud survivability through dependency based virtual
machine placement. In SECRYPT, pages 321–326, 2012.
[26] P. Li et al. Stopwatch: A cloud architecture for timing channel mitigation. ACM
TISSEC, 17(2), Nov. 2014.
[27] F. Liu et al. Last-level cache side-channel attacks are practical. In Proc. IEEE
S&P, 2015.
[28] F. Liu and R. B. Lee. Random ﬁll cache architecture. In Proc. Micro, 2014.
[29] R. Owens and W. Wang. Non-interactive os ﬁngerprinting through memory
de-duplication technique in virtual machines. In Proc. IPCCC, 2011.
[30] D. Page. Partitioned cache architecture as a side-channel defence mechanism.
In Cryptology ePrint Archive,Report 2005/280. 2005.
[31] E. Pattuk et al. Preventing cryptographic key leakage in cloud virtual machines.
In Proc. USENIX Security, 2014.
[32] H. Raj et al. Resource management for isolation enhanced cloud services. In
Proc. ACM CCSW, 2009.
[33] T. Ristenpart et al. Hey, you, get off of my cloud: Exploring information
leakage in third-party compute clouds. In Proc. ACM CCS, 2009.
[34] J. Shi et al. Limiting cache-based side-channel in multi-tenant cloud using
dynamic page coloring. In Proc. DSN, 2011.
[35] V. Shrivastava et al. Application-aware virtual machine migration in data
centers. In Proc. INFOCOM, 2011.
[36] K. Suzaki et al. Memory deduplication as a threat to the guest os. In Proc.
EUROSEC, 2011.
[37] V. Varadarajan et al. Scheduler-based defenses against cross-vm side-channels.
In Proc. USENIX Security, 2014.
[38] B. C. Vattikonda et al. Eliminating ﬁne grained timers in xen. In Proc. ACM
CCSW, 2011.
[39] J. Wang et al. Hypercheck: A hardware-assisted integrity monitor. In Recent
Advances in Intrusion Detection, 2010.
[40] Z. Wang and R. B. Lee. A novel cache architecture with enhanced performance
and security. In Proc. Micro, 2008.
[41] Y. Yarom and K. Falkner. Flush+reload: A high resolution, low noise, l3 cache
side-channel attack. In Proc. USENIX Security, 2014.
[42] Y. Zhang et al. Cross-vm side channels and their use to extract private keys. In
Proc. ACM CCS, 2012.
[43] Y. Zhang et al. Incentive compatible moving target defense against
vm-colocation attacks in clouds. In Information Security and Privacy Research,
pages 388–399. Springer, 2012.
[44] Y. Zhang et al. Cross-tenant side-channel attacks in paas clouds. In Proc. ACM
CCS, 2014.
[45] Y. Zhang and M. K. Reiter. Duppel: Retroﬁtting commodity operating systems
to mitigate cache side channels in the cloud. In Proc. ACM CCS, 2013.
[46] J. Zheng et al. Workload-aware live storage migration for clouds. In Proc. ACM
VEE, 2011.
APPENDIX
A ILP Formulation
In this section, we describe the ILP formulation for the optimization
problem that the Nomad Placement Algorithm needs to solve every
epoch. As discussed earlier, the algorithm takes as input the VM
placement over the last sliding window of epochs and other param-
eters that determine the information leakage. The objective func-
tion is to minimize the total information leakage across all client
pairs.
We use binary indicator variables, dc,i,k(t), to denote the place-
ment assignment of a speciﬁc VM instance i of a client c at ma-
chine k in the epoch t. These are the key control variables that we
need to set to determine the optimal placements. Then, it naturally
follows that the inputs to the ILP formulation are these control vari-
ables for the past ∆ epochs to be used in summarizing co-residency
over time. The output would be the placement assignments for the
next epoch.
Equation 9 in Figure 10 states that the total number of VMs as-
signed to a machine should not exceed machine’s capacity. Further-
more, each VM should only have one machine assignment (Equa-
tion 10). Equation 11 models a per-epoch binary co-residence re-
lationship that indicates if 2 VMs are co-resident in a machine k at
epoch t. Intuitively, this is like modeling an AND operation; i.e., if
both VMs have the same machine assignment k, this binary indi-
cator is set to 1. If there exists any machine in which two VMs are
co-resident, then we ﬂag that these two VMs (VM c,i and VM c(cid:48),i(cid:48))
are co-resident at an epoch t (Equation 12).
Having determined whether a given pair of VMs are co-resident,
we can summarize the information leakage across the three dimen-
sions, namely over time, over adversary’s VMs, and over client’s
VMs. This models the InfoLeakage between a client pair c and
c’. For brevity, the ﬁgure only shows the model for the (cid:104)R, C(cid:105)
case, the summarization involves summation over adversary’s and
client’s VMs.
Minimize (cid:80)
(cid:88)
(cid:88)
c,c(cid:48)
∀k, t,
c
i
InfoLeak
(cid:104)R,C(cid:105)
c→c(cid:48) (t, ∆) such that
dc,i,k(t) ≤ Capk
(cid:88)
k
dc,i,k(t) = 1
∀c, i, k, t ∈ lifetimec,i,
∀c, i, c(cid:48), i(cid:48), c (cid:54)= c(cid:48), k, t
CoRes c,i,c(cid:48),i(cid:48),k(t) ≥ dc,i,k(t) + dc(cid:48),i(cid:48),k(t) − 1
CoRes c,i,c(cid:48),i(cid:48),k(t) ≤ dc,i,k(t)
CoRes c,i,c(cid:48),i(cid:48),k(t) ≤ dc(cid:48),i(cid:48),k(t)
∀c, i, c(cid:48), i(cid:48), c (cid:54)= c(cid:48), t,
CoRes c,i,c(cid:48),i(cid:48) (t) ≤(cid:88)
CoRes c,i,c(cid:48),i(cid:48),k(t)
k
CoRes c,i,c(cid:48),i(cid:48) (t) ≥ CoRes c,i,c(cid:48),i(cid:48),k(t)
(cid:104)R,C(cid:105)
∀c, c(cid:48), c (cid:54)= c(cid:48), t, InfoLeak
c→c(cid:48) (t, ∆) =
(cid:88)
(cid:88)
(cid:88)
i
i(cid:48)
t(cid:48)∈[t-∆,t]
∀c, i, k, t, mvc,i,m(t) = dc,i,k(t) ⊕ dc,i,k(t − 1)
mvc,i,m(t) ≤ dc,i,k(t) + dc,i,k(t − 1)
mvc,i,m(t) ≥ dc,i,k(t) − dc,i,k(t − 1)
mvc,i,m(t) ≤ 2 − dc,i,k(t) − dc,i,k(t − 1)
∀c, i, t, mvc,i(t) = 0.5
(cid:88)
mvc,i,m(t)
∀c, t, GlobalMigCost(t) =
k
mvc,i(t(cid:48))
∀c, t, GlobalMigCost(t) ≤ PercentBudget
c,i
(cid:88)
(cid:88)
c,i,k
dc,i,k(t)
(9)
(10)
(11)
(12)
CoRes c,i,c(cid:48),i(cid:48) (t(cid:48))
(13)
(14)
(15)
(16)
Figure 10: (cid:104)R, C(cid:105): ILP formulation for Nomad Placement Al-
gorithm
The ILP formulation is also applicable for three other deploy-
ment models; Equation 13 needs to be changed to reﬂect the correct
InfoLeakage model.
Now that we have modeled the co-residency across client pairs,
the only remaining factor is the migration cost. To this end, we
introduce another binary indicator that indicates whether a VM has
migrated from a previous epoch t − 1. mvc,i,m(t) is a binary
variable that indicates whether VM c,i was either in machine k in
the previous epoch and is no longer in machine k or vice versa.
This gives an indicator that tells whether a VM has moved away
or moved into this machine k. Intuitively, this is like modeling a
XOR operation (Equation 14). Summing over this variable for each
VM instance givesi the total number of migrations from the previ-
ous epoch (Equation 15). Lastly, Equation 16 models the migration
budget such that the total number of migrations should not exceed
PercentBudget of the total workloads (i.e., total number of VMs
that currently have place assignments).