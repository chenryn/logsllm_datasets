ptr = fort;
6.假设有下面的声明：
int grid[30][100];
a.用1种写法表示grid[22][56]
b.用2种写法表示grid[22][0]
730
c.用3种写法表示grid[0][0]
7.正确声明以下各变量：
a.digits是一个内含10个int类型值的数组
b.rates是一个内含6个float类型值的数组
c.mat是一个内含3个元素的数组，每个元素都是内含5个整数的数组
d.psa是一个内含20个元素的数组，每个元素都是指向int的指针
e.pstr是一个指向数组的指针，该数组内含20个char类型的值
8.
a.声明一个内含6个int类型值的数组，并初始化各元素为1、2、4、8、
16、32
b.用数组表示法表示a声明的数组的第3个元素（其值为4）
c.假设编译器支持C99/C11标准，声明一个内含100个int类型值的数组，
并初始化最后一个元素为-1，其他元素不考虑
d.假设编译器支持C99/C11标准，声明一个内含100个int类型值的数组，
并初始化下标为5、10、11、12、3的元素为101，其他元素不考虑
9.内含10个元素的数组下标范围是什么？
10.假设有下面的声明：
float rootbeer[10], things[10][5], *pf, value = 2.2;
int i = 3;
判断以下各项是否有效：
731
a.rootbeer[2] = value;
b.scanf("%f", &rootbeer );
c.rootbeer = value;
d.printf("%f", rootbeer);
e.things[4][4] = rootbeer[3];
f.things[5] = rootbeer;
g.pf = value;
h.pf = rootbeer;
11.声明一个800×600的int类型数组。
12.下面声明了3个数组：
double trots[20];
short clops[10][30];
long shots[5][10][15];
a.分别以传统方式和以变长数组为参数的方式编写处理trots数组的void
函数原型和函数调用
b.分别以传统方式和以变长数组为参数的方式编写处理clops数组的void
函数原型和函数调用
c.分别以传统方式和以变长数组为参数的方式编写处理shots数组的void
函数原型和函数调用
13.下面有两个函数原型：
732
void show(const double ar[], int n);     // n是数组元素的个数
void show2(const double ar2[][3], int n);  // n是二维数组的行数
a.编写一个函数调用，把一个内含8、3、9和2的复合字面量传递给
show()函数。
b.编写一个函数调用，把一个2行3列的复合字面量（8、3、9作为第1
行，5、4、1作为第2行）传递给show2()函数。
733
10.13 编程练习
1.修改程序清单10.7的rain.c程序，用指针进行计算（仍然要声明并初始
化数组）。
2.编写一个程序，初始化一个double类型的数组，然后把该数组的内容
拷贝至3个其他数组中（在main()中声明这4个数组）。使用带数组表示法的
函数进行第1份拷贝。使用带指针表示法和指针递增的函数进行第2份拷贝。
把目标数组名、源数组名和待拷贝的元素个数作为前两个函数的参数。第3
个函数以目标数组名、源数组名和指向源数组最后一个元素后面的元素的指
针。也就是说，给定以下声明，则函数调用如下所示：
double source[5] = {1.1, 2.2, 3.3, 4.4, 5.5};
double target1[5];
double target2[5];
double target3[5];
copy_arr(target1, source, 5);
copy_ptr(target2, source, 5);
copy_ptrs(target3, source, source + 5);
3.编写一个函数，返回储存在int类型数组中的最大值，并在一个简单的
程序中测试该函数。
4.编写一个函数，返回储存在double类型数组中最大值的下标，并在一
个简单的程序中测试该函数。
5.编写一个函数，返回储存在double类型数组中最大值和最小值的差
值，并在一个简单的程序中测试该函数。
734
6.编写一个函数，把double类型数组中的数据倒序排列，并在一个简单
的程序中测试该函数。
7.编写一个程序，初始化一个double类型的二维数组，使用编程练习2中
的一个拷贝函数把该数组中的数据拷贝至另一个二维数组中（因为二维数组
是数组的数组，所以可以使用处理一维数组的拷贝函数来处理数组中的每个
子数组）。
8.使用编程练习2中的拷贝函数，把一个内含7个元素的数组中第3～第5
个元素拷贝至内含3个元素的数组中。该函数本身不需要修改，只需要选择
合适的实际参数（实际参数不需要是数组名和数组大小，只需要是数组元素
的地址和待处理元素的个数）。
9.编写一个程序，初始化一个double类型的3×5二维数组，使用一个处理
变长数组的函数将其拷贝至另一个二维数组中。还要编写一个以变长数组为
形参的函数以显示两个数组的内容。这两个函数应该能处理任意N×M数组
（如果编译器不支持变长数组，就使用传统C函数处理N×5的数组）。
10.编写一个函数，把两个数组中相对应的元素相加，然后把结果储存
到第 3 个数组中。也就是说，如果数组1中包含的值是2、4、5、8，数组2中
包含的值是1、0、4、6，那么该函数把3、4、9、14赋给第3个数组。函数接
受3个数组名和一个数组大小。在一个简单的程序中测试该函数。
11.编写一个程序，声明一个int类型的3×5二维数组，并用合适的值初始
化它。该程序打印数组中的值，然后各值翻倍（即是原值的2倍），并显示
出各元素的新值。编写一个函数显示数组的内容，再编写一个函数把各元素
的值翻倍。这两个函数都以函数名和行数作为参数。
12.重写程序清单10.7的rain.c程序，把main()中的主要任务都改成用函数
来完成。
13.编写一个程序，提示用户输入3组数，每组数包含5个double类型的数
（假设用户都正确地响应，不会输入非数值数据）。该程序应完成下列任
735
务。
a.把用户输入的数据储存在3×5的数组中
b.计算每组（5个）数据的平均值
c.计算所有数据的平均值
d.找出这15个数据中的最大值
e.打印结果
每个任务都要用单独的函数来完成（使用传统C处理数组的方式）。完
成任务b，要编写一个计算并返回一维数组平均值的函数，利用循环调用该
函数3次。对于处理其他任务的函数，应该把整个数组作为参数，完成任务c
和d的函数应把结果返回主调函数。
14.以变长数组作为函数形参，完成编程练习13。
[1].在最后一次while循环中执行完start++;后，start的值就是end的值。——译
者注
736
第11章 字符串和字符串函数
本章介绍以下内容：
函数：gets()、gets_s()、fgets()、puts()、fputs()、strcat()、strncat()、
strcmp()、strncmp()、strcpy()、strncpy()、sprintf()、strchr()
创建并使用字符串
使用C库中的字符和字符串函数，并创建自定义的字符串函数
使用命令行参数
字符串是C语言中最有用、最重要的数据类型之一。虽然我们一直在使
用字符串，但是要学的东西还很多。C 库提供大量的函数用于读写字符串、
拷贝字符串、比较字符串、合并字符串、查找字符串等。通过本章的学习，
读者将进一步提高自己的编程水平。
737
11.1 表示字符串和字符串I/O
第4章介绍过，字符串是以空字符（\0）结尾的char类型数组。因此，可
以把上一章学到的数组和指针的知识应用于字符串。不过，由于字符串十分
常用，所以 C提供了许多专门用于处理字符串的函数。本章将讨论字符串的
性质、如何声明并初始化字符串、如何在程序中输入和输出字符串，以及如
何操控字符串。
程序清单11.1演示了在程序中表示字符串的几种方式。
程序清单11.1 strings1.c程序
//  strings1.c
#include 
#define MSG "I am a symbolic string constant."
#define MAXLENGTH 81
int main(void)
{
char words[MAXLENGTH] = "I am a string in an array.";
const char * pt1 = "Something is pointing at me.";
puts("Here are some strings:");
puts(MSG);
puts(words);
puts(pt1);
738
words[8] = 'p';
puts(words);
return 0;
}
和printf()函数一样，puts()函数也属于stdio.h系列的输入/输出函数。但
是，与printf()不同的是，puts()函数只显示字符串，而且自动在显示的字符
串末尾加上换行符。下面是该程序的输出：
Here are some strings:
I am an old-fashioned symbolic string constant.
I am a string in an array.
Something is pointing at me.
I am a spring in an array.
我们先分析一下该程序中定义字符串的几种方法，然后再讲解把字符串
读入程序涉及的一些操作，最后学习如何输出字符串。
11.1.1 在程序中定义字符串
程序清单11.1中使用了多种方法（即字符串常量、char类型数组、指向
char的指针）定义字符串。程序应该确保有足够的空间储存字符串，这一点
我们稍后讨论。
1.字符串字面量（字符串常量）
用双引号括起来的内容称为字符串字面量（string literal），也叫作字符
串常量（string 
constant）。双引号中的字符和编译器自动加入末尾的\0字
符，都作为字符串储存在内存中，所以"I am a symbolic stringconstant."、"I
739
am a string in an array."、"Something is pointed at me."、"Here are some
strings:"都是字符串字面量。
从ANSI 
C标准起，如果字符串字面量之间没有间隔，或者用空白字符
分隔，C会将其视为串联起来的字符串字面量。例如：
char greeting[50] = "Hello, and"" how are" " you"
" today!";
与下面的代码等价：
char greeting[50] = "Hello, and how are you today!";
如果要在字符串内部使用双引号，必须在双引号前面加上一个反斜杠
（\）：
printf("\"Run, Spot, run!\" exclaimed Dick.\n");
输出如下：
"Run, Spot, run!" exclaimed Dick.
字符串常量属于静态存储类别（static storage class），这说明如果在函
数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存
在，即使函数被调用多次。用双引号括起来的内容被视为指向该字符串储存
位置的指针。这类似于把数组名作为指向该数组位置的指针。如果确实如
此，程序清单11.2中的程序会输出什么？
程序清单11.2 strptr.c程序
/* strptr.c -- 把字符串看作指针 */
#include 
int main(void)
740
{
printf("%s, %p, %c\n", "We", "are", *"space farers");
return 0;
}
printf()根据%s 转换说明打印 We，根据%p 转换说明打印一个地址。因
此，如果"are"代表一个地址，printf()将打印该字符串首字符的地址（如果使
用ANSI之前的实现，可能要用%u或%lu代替%p）。最后，*"space farers"表
示该字符串所指向地址上储存的值，应该是字符串*"space 
farers"的首字
符。是否真的是这样？下面是该程序的输出：
We, 0x100000f61, s
2.字符串数组和初始化
定义字符串数组时，必须让编译器知道需要多少空间。一种方法是用足
够空间的数组储存字符串。在下面的声明中，用指定的字符串初始化数组
m1：
const char m1[40] = "Limit yourself to one line's worth.";
const表明不会更改这个字符串。
这种形式的初始化比标准的数组初始化形式简单得多：
const char m1[40] = { 'L','i', 'm', 'i', 't', ' ', 'y', 'o', 'u', 'r', 's', 'e', 'l',
'f', ' ', 't', 'o', ' ', 'o', 'n', 'e', ' ','l', 'i', 'n', 'e',
'\", 's', ' ', 'w', 'o', 'r','t', 'h', '.', '\0'
};
741
注意最后的空字符。没有这个空字符，这就不是一个字符串，而是一个
字符数组。
在指定数组大小时，要确保数组的元素个数至少比字符串长度多1（为
了容纳空字符）。所有未被使用的元素都被自动初始化为0（这里的0指的是
char形式的空字符，不是数字字符0），如图11.1所示。
图11.1 初始化数组
通常，让编译器确定数组的大小很方便。回忆一下，省略数组初始化声
明中的大小，编译器会自动计算数组的大小：
const char m2[] = "If you can't think of anything, fake it.";
让编译器确定初始化字符数组的大小很合理。因为处理字符串的函数通
常都不知道数组的大小，这些函数通过查找字符串末尾的空字符确定字符串
在何处结束。
让编译器计算数组的大小只能用在初始化数组时。如果创建一个稍后再
填充的数组，就必须在声明时指定大小。声明数组时，数组大小必须是可求
值的整数。在C99新增变长数组之前，数组的大小必须是整型常量，包括由
整型常量组成的表达式。
int n = 8;
char cookies[1];    // 有效
char cakes[2 + 5];// 有效，数组大小是整型常量表达式
742
char pies[2*sizeof(long double) + 1]; // 有效
char crumbs[n];     // 在C99标准之前无效，C99标准之后这种数组
是变长数组
字符数组名和其他数组名一样，是该数组首元素的地址。因此，假设有
下面的初始化：
char car[10] = "Tata";
那么，以下表达式都为真：
car == &car[0]、*car == 'T'、*(car+1) == car[1] == 'a'。
还可以使用指针表示法创建字符串。例如，程序清单11.1中使用了下面
的声明：
const char * pt1 = "Something is pointing at me.";
该声明和下面的声明几乎相同：