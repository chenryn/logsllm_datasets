你能发现潜在的问题吗？如果已经有一个名为mpcmdrunk.log.bak的文件存在，会发生什么?
为了回答这个问题，我考虑了以下测试方案:
  * 1.在C: WindowsTemp目录创建一个名为MpCmdRun.log.bak文件。
  * 2.使用任意数据填充C: WindowsTempMpCmdRun.log文件，使其大小接近16MB。
  * 3.触发签名更新
  * 4.使用Procmon观察结果
如果mpcmdrunk.log.bak是一个现有的文件，它只是被覆盖。我们可以假设这是预期行为，因此此测试不是很确定。相反，我想到的第一个测试场景是：如果MpCmdRun.log.bak是目录呢？
如果MpCmdRun.log.bak不是一个简单的文件，我们可以假设它不能简单地被覆盖。所以，我最初的假设是日志轮换将完全失败。与其创建原始日志文件的备份，不如将其覆盖。不过，我用Procmon观察到的行为远比这有趣。Defender实际上删除了该目录，然后继续正常的日志轮换。因此，我决定重做该测试，但是，这次我还在里面创建了C:WindowsTempMpCmdRun.log.bak文件和目录。原来，删除实际上是递归的！
这很有趣!现在的问题是:我们是否可以重定向这个文件操作?
这是这个测试用例的初始设置:
  * 创建一个虚拟的目标目录:C:ZZ_SANDBOXtarget。
  * MpCmdRun.log.bak被创建为一个目录并被设置为此目录的挂载点。
  * 这个MpCmdRun.log日志文件中包含16777002字节的任意数据。
挂载点的目标目录包含一个文件夹和一个文件。
这是我在执行PowerShell命令Update-MpSignature后在Procmon中观察到的内容：
Defender在挂载后，以递归方式删除每个文件和文件夹，最后删除文件夹C:WindowsTempMpCmdRun.log.bak本身。这意味着，作为普通用户，我们可以欺骗该服务删除文件系统上任何文件或文件夹…
## 可利用性
正如我们在前面看到的，利用是非常简单的。我们要做的唯一一件事就是创建目录C:
WindowsTempMpCmdRun.log.bak，并将其设置为文件系统上另一个位置的挂载点。
注意:实际上并没有那么简单，因为如果我们想要执行目标文件或目录删除，需要额外的技巧，但这里我不讨论这个。
不过，我们面临一个实际问题：填充日志文件需要多长时间，直到其大小超过16MB，这对于一个简单的日志文件来说是相当高的值。因此，我做了几个测试，并测量了每个命令所需的时间。然后，我推断了结果，以估计所需的总时间。应当注意，该Update-MpSignature命令不能并行运行多次。
###  测试1
作为第一个测试，我选择了一个幼稚的方法。我运行了Update-MpSignature命令一百次，并测量了整个过程。
下面是第一次测试的结果。使用这种技术，如果我们在循环中运行Update-MpSignature命令，则需要超过22个小时来填充文件并触发漏洞。
DESCRIPTION | TIME | FILE SIZE | # OF CALLS  
---|---|---|---  
Raw data for 100 calls | 650s (10m 50s) | 136,230 bytes | 100  
Estimated time to reach the target file size | 80,050s (22h 14m 10s) |
16,777,216 bytes | 12,316  
至少可以说，这不太实际。
###  测试2
在测试1之后，我检查了Update-MpSignature命令的文档，以查看是否可以对其进行调整以加快整个过程。这个命令的选项非常有限，但有一个引起了我的注意。
此命令接受一个UpdateSource作为参数，实际上是一个枚举，如我们在上面截图所见。使用大多数可用值时，将立即返回错误消息，并且不会向日志文件中写入任何内容，因此它们对于这种利用场景毫无用处。
但是，在使用InternalDefinitionUpdateServer值时，我观察到了一个有趣的结果。
因为我的VM是在Windows中独立安装的，所以它没有配置使用“内部服务器”进行更新。相反，它们直接从MS服务器接收，因此出现错误消息。
此方法的主要优点是几乎立即返回错误消息，但事件仍会写入日志文件，这使得它非常适合在这种特定情况下进行利用。
因此，我也运行了该命令一百次，并观察了结果。
这一次，100次调用用了不到4秒的时间完成。这还不足以计算相关的统计数据，所以这次我用10,000次调用运行相同的测试。
DESCRIPTION | TIME | FILE SIZE | # OF CALLS  
---|---|---|---  
Raw data for 10,000 calls | 363s (6m 2s) | 2,441,120 bytes | 10,000  
Estimated time to reach the target file size | 2,495s (41m 35s) | 16,777,216
bytes | 68,728  
稍作调整，整个操作将需要大约40分钟，而不是前一个命令的22个多小时。因此，这将大大减少填充日志文件所需的时间。还应该注意的是，这些值对应于最坏情况，即日志文件最初为空。我认为这个值是可以接受的，所以我在Poc中实现了这一方法，下面截图显示了结果。
从一个空的日志文件开始，PoC用了大约38分钟完成，这与我之前所做的估算非常接近。
顺便说一下，如果您注意到最后一个屏幕截图，您可能会注意到我指定了C:
ProgramDataMicrosoftWindowsWER作为要删除的目录。我不是随机选择这个的。我选择这个是因为，一旦这个文件夹被删除，你就可以像[@jonaslyk](https://github.com/jonaslyk
"@jonaslyk")在这篇文章中解释的那样，以NT AUTHORITYSYSTEM的形式执行代码:  
[From directory deletion to SYSTEM
shell](https://secret.club/2020/04/23/directory-deletion-shell.html)。
## 结论
这可能是我写的关于这种特权文件操作滥用的最后一篇文章。在发给所有漏洞研究人员的电子邮件中，微软宣布他们改变了奖金的范围。因此，这种利用不再符合条件。这个决定是合理的，因为一个通用补丁正在开发中，它将解决这类bug。
我不得不说，这个决定听起来有点过早。如果这个补丁已经在最新的Windows
10预览版中实现了，这是可以理解的，但事实并非如此。我认为这更多的是一个经济决定，而不是纯粹的技术问题，因为这样的赏金计划可能意味着每月几十万美元的成本。
## Links & Resources
  * CVE-2020-1170 | Microsoft Windows Defender Elevation of Privilege Vulnerability  
  * SECRET CLUB – From directory deletion to SYSTEM shell  