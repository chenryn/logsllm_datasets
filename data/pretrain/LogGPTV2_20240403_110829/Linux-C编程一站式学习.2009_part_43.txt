mov
push
mov
movzbl 
mov
mov
P
，在编译时要加-fPIc选项，例如:
%ebp
0x0,%edx
$0x1,%eax
0x0,%eax
%eax, 0x0
,%eax
，所以用-g选项加调试信息。注
---
## Page 343
现在看用-fPIc编译生成的目标文件有什么不同:
定死了，
标出了指令中有四处需要在重定位时修改。
的.rel.text段的信息：
指令中凡是用到stack和top的地址都用0x0表示，
原来指令中的0x0被修改成了0x804a010和0x804a040，这样做了重定位之后，各段的加载地址就
extern int top;
0000oooo :
Disassembly of section 
push.o:
S
S
因为在指令中使用了绝对地址。
void push(char c)
extern 
extern char stack[512];
S
0000001b
Offset
Relocation section 
￥
80483eb:
80483ea:
80483e9:
80483d9:
80483d4:
80483d1:
80483cc:
80483c9:
80483c6:
80483c3:
80483c0:
00000025
0
2a
29:
 push.c
2
,-C -g -fPIC stack/stack.c stack/push.c stack/pop.c
 int top;
.-g main.c stack.o push.o pop.o is_empty.o -Istack -o main
char stack[512];
stack[++top]
86
00001101
00001001
file format elf32-i386
0001001
Info
686
80.88
83
8b
83
8
5
6
5
co
10
R
Type
..-.....
386
.rel.text'
a0
8
ao
01
c;
04
.text:
04
04
04
108
08
下面编译链接成可执行文件之后再做反汇编分析：
08
08
 at offset 0x848 contains 4 entries:
ret
leave
，准备在重定位时修改。再看readelf输出
00000000
00000000
00000000
nop
leave
00
add
push
t
ovzbl
V
$0xl,%eax
0x804a010,%eax
%ebp
 Sym.
0x804a010,%edx
oeax,
0x4(
esp,%ebp
stack
top
top
top
Name
0x804a010
---
## Page 344
共享库再做反汇编分析：
top和stack对应的记录类型不再是R_386_32了，
做进-
指令中用到的stack和top的地址不再以Ox0表示,
一步修改。再看readelf输出的.rel.text段:
void
extern 
00000035
0000002
000000e
80000000
void push(char c)
￥
7
7
6
3
：
：
 push(char c)
：
：
：
：
：
：
：
58388
d
&
8b
&
80
8888
8 
8
8
8
18
38
8
5
00001503
00001403
00001202
*
1c 24
%
pc 
C4
0
99
8
8
45
45
&
e5
Info
i686.get_pc_thunk.bx>:
0
3
4
04
08
42
thunk.bx
5
0
00
.
0000
0000
ff
R
ff
R
R
R`
 Type
00
386GOTPC
.rel.text'
386_PC32
00
00
00
0.
00
9
6
GOT32
GOT32
 stack.o push.o pop.o is_empty.o
2
at offset 0x94c contains
ret
i686.get_pc_thunk.bx:
mov
add
mov
mov
push 
mov
而是R_386_GOT32，
t
d
d
公
ovzbl
ish
而是以oxo（ebx)表示，但其中还是留有0x0准备
Sym.
00000000
00000000
00000000
00000000
dqa%
(%esp),%ebx
%ebx
$0x4,%esp
%ebp
!
0x0(%ebx),%edx
0x0(%ebx),
0xl(%eax),%edx
0x0(%ebx),%eax
S
8
S
Value
0x8(%ebp),%eax
0x0（
60x2,%ebx
6
bx
,%ecx
 Sym. Name
stack
top
top
do
,%eax
,%eax
有什么区别呢？我们先编译生成
GLOBAL_OFFSET_TABLE_
 6 entries:
---
## Page 345
把top的值加1存到edx中，
可以发现，
和先前的指令对比一下：
址
址。
和先前的结果不同,
因此称为位置无关代码。另外，注意这几条指令：
所以共享库各段的加载地址并没有定死，
ebx-8
ebx-12
图 20.3.间接寻址
494:
488:
，-0xc(%ebx)这个地址并不是变量top的地址，
94:
stack[0]的值
top的值
stack的地址
top的地址
stack[1]的值
一个地址才是变量top的地址，
888
855899
8088
8
8
68
8
8
8b
88
指令中的ox0（%ebx)被修改成-0xc(%ebx)和-0x8（%ebx)，
c4
0969
00
5.5
09
8
83
88
--................
01
04
f4
88
如下图所示：
18
8开
：ff ff
ff ff
：1b0000
ff
出
出
ff
，所以mov-0xc（%ebx），%eax是把变量top的地址传
，可以加载到任意位置，
6.6
mov
lea
mov
add
mov
movzbl
mov
mov
AOu
mov
mov
add
Pp
0xl(%eax),%edx
$0x4,%esp
%al,(%edx,%ecx,1)
-0xc(%ebx),%eax
%edx,(%eax)
-0xc(%ebx),%eax
-0xc(%ebx),%eax
0x8(%ebp),%eax
$0x1b6c,%ebx
，这个地址的内存单元中又保存了另外-
%eax),
(%eax),%eax 
(%eax),%edx
oeax
$0x1,%eax
0x804a010,%eax
因为指令中没有使用绝对地
而不是修改成绝对地
个
---
## Page 346
行idconfig:
再试试第二种方法，这是最常用的方法。把libstack.so所在目录的绝对路径（比
环境变量，
这种方法只适合在开发中临时用一下,
路径：
统中，
时搜索到的,
dynamic-linker指定动态链接器的路径，它也像其它共享库一样加载到进程的地址空间
每个共享库都在什么路径下，
ldd模拟运行一遍main,
用idd命令查看可执行文件依赖于哪些共享库：
到libstack.so,
结果出乎意料，
现在把main.c和共享库编译链接在一起，然后运行:
址写死在指令中，这也是一种避免硬编码的策略。
top和stack的绝对地址保存在一个地址表中，
bad(http://www.visi.com/~barr/ldpath.html)
3．如果上述步骤都找不到，则到默认的系统路径中查找，先是/usr/ib然后是/ib 。
2
1．首先在环境变量LD_LIBRARY_PATH所记录的路径中查找。
，它的路径是在编译链接时指定的，
然后从缓存文件/etc/ld.so.cache中查找。这个缓存文件由1dconfig命令读取配置文
它是
$ ldd main 
S
是由内核虚拟出来的共享库，所以它没有对应的路径，
open：
/main:
SS
 LD_LIBRARY_PATH=. ./main
理由可以参考Why LD_LIBRARY_PATH is 
 gcc main.c -g -L. -lstack -Istack -o main
/main
，编译的时候没问题，
-..-..-..-..-...
linux-gate.so.1 => 
在运行过程中做动态链接,
..-...............
not
，由于指定了-L.选项，
 通常LD_LIBRARY_PATH是不推荐使用的，尽量不要设置这个
......
，我们在第 2 节“main函数和启动例程"讲过gcc在做链接时用
(0xb7f42000)
 found
（0xb7f5c000)
而指令通过地址表做间接寻址，因此避免了将绝对地
从而得知这个可执行文件依赖于哪些共享库,
，编译器可以在当前目录下找 
它负责处理系统调用。总之,
346
共享
系
---
## Page 347
项。可以看到readelf的结果多了-
-Wl，-rpath,/home/akaedu/somedir表示-rpath /home/akaedu/somedir是由gcc传递给链接器的选
中：
其实还有第四种方法，