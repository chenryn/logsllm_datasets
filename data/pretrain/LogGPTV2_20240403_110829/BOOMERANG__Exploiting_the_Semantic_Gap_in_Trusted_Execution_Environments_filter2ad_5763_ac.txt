making it an exceptionally high-impact implementation, as any
vulnerabilities could potentially lead to a complete compro-
mise of these devices [25].
1) Untrusted Application and Untrusted OS: QSEE ex-
poses a kernel driver /dev/qseecom to untrusted applica-
tions ( 1b and 1c
in Figure 2). Interactions with this device
are carried out using the ioctl system call with various
commands, which untrusted applications can use to interact
with the secure world. Qualcomm also provides a user-space li-
brary libQSEEComAPI.so, which conveniently exposes the
different ioctl commands as functions. Data is exchanged
between untrusted and trusted applications using a specialized
data structure (Figure 3). This data structure is then passed
through a PTRSAN function to resolve any pointers to non-
secure world memory regions. In QSEE, physical memory
addresses are used as the common entity between worlds,
and the pointer translation from virtual to physical occurs
directly in the provided kernel driver ( 1b and 1c in Figure 2).
Sending commands to a TA happens in multiple steps, which
are described hereinafter.
First, the untrusted application requests the allocation of a
shared memory region using a separate shared memory driver
/dev/ion [1]. This region will be used for both requests
and responses. The shared memory driver returns a shared
memory identiﬁer (i.e., shmid), an opaque identiﬁer that is
used to refer to this memory region, independent of its location.
This identiﬁer can then be used to map (i.e., using mmap)
the allocated memory into the untrusted application’s memory
space. The shared memory region is then split into two buffers,
one for sending data into the trusted world (i.e., send_buf)
and one for the response (i.e., resp_buf).
Second, the application prepares the command to be ex-
ecuted, and stores it in send_buf (see Figure 3). Pointers
stored directly in the driver interface structure will always be
validated and translated by the pointer translation function.
However,
the untrusted application can also pass pointers
within the body of the request
itself that was previously
allocated using /dev/ion (i.e., within the send_buf data).
Since the request body is application-speciﬁc, these point-
ers cannot automatically be located or translated. To en-
able this, the application can supply a replacement vector
(i.e., QSEECom_io_fd_info), which is a list of offsets in
send_buf that should contain the pointers together with the
corresponding shmids that should be translated and placed
there. The ﬁnal command sent will contain the physical ad-
dresses for each shared memory region in the desired locations.
an ioctl
the
directly
command,
QSEECOM_IOCTL_SEND_MODFD_CMD_REQ
or uses the QSEECom_send_modified_cmd command
provided by the libQSEEComAPI.so library to trigger the
execution of the command. This causes QSEECOM to copy
the request buffer into a temporary buffer, and optionally
perform pointer translation.
application either performs
/dev/qseecom
device with
Third,
the
on
the
2) Untrusted OS and Trusted OS: The untrusted OS and
trusted OS interact using Qualcomm’s secure channel manger
(SCM), which deﬁnes a set of functions that prepare and
execute SMC calls with the provided data. All SMC calls are
made with four parameters (i.e., send buf, sbuf len, resp buf,
rbuf len), where send_buf and resp_buf are the buffers
passed by the application. All of these parameters are packed
into an scm_command structure, and the physical address of
the packed structure is passed as an argument [36].
5
to craft an arbitrary physical memory read exploit.
both
While
are
QSEECom_send_cmd
QSEECom_send_modified_cmd
and
the
libQSEECom.so library, where additional checks could
be implemented, it would still be possible to perform the
same un-sanitized operations on the kernel driver directly.
Therefore, any fool-proof solution will require at least some
coordination with the secure world to ensure that it cannot be
easily bypassed, such as the ones we examine in Section VII.
provided
in
B. Trustonic
Trustonic [53] is another very popular vendor of TrustZone-
based TEE technology. Their TEE implementation is widely
deployed across consumer hardware (over 400 million de-
vices [7]), with Samsung leveraging it as part of its Knox [41]
platform. Trustonic encrypts and signs all of their trusted
applications and their trusted OS kernel, which makes it more
challenging to audit their functionality, although recent efforts
have made headway in recovering the decrypted code [14].
1) Untrusted Application and Untrusted OS: Trustonic
employs a kernel driver /dev/mobicore, similar to QSEE,
and a service mcDaemon, which user applications must use to
communicate with the secure world. Due to its permissions,
unprivileged user applications cannot communicate with the
driver /dev/mobicore directly, as was possible in the case
of QSEE. In Trustonic’s implementation, communication with
the secure world must go through the mcDaemon service
using a write-and-notify mechanism known as world-shared
memory (WSM). This communication is initiated when an
untrusted application registers a buffer, called a session buffer,
with a TA to open a new session. Commands intended for
the TA are then sent by writing data into the session buffer,
and issuing a notify command through mcDaemon. Once the
data is passed to the secure world, the trusted OS will then
notify the TA that the contents are ready. Similarly, to receive
responses, untrusted applications wait for a notiﬁcation from
the TA (through mcDaemon).
In the Trustonic implementation, opaque identiﬁers are
used instead of memory locations (i.e., physical memory
pointers). By examining the source of mcDaemon [56], we
conﬁrmed that the opaque id is actually a virtual address that
has been mapped into the memory space of the TA, within
the secure world. If an untrusted application wants to share
some memory with a TA, it must register the buffer using the
processMapBulkBuf function in the mcDaemon service,
which maps the corresponding physical memory region into
the TA’s memory space and returns an opaque identiﬁer back
to the untrusted application. processMapBulkBuf also
veriﬁes that the pointer being converted is indeed owned by
the requesting application, which thwarts the trivial instance
of BOOMERANG. From this point on, the only method for
the untrusted application to interact with that shared memory
region is using this opaque identiﬁer and the mcDaemon
service (i.e., the untrusted application has no direct control
over the pointers that the TA will receive and operate on).
2) Untrusted OS and Trusted OS: The interaction between
the untrusted OS and the trusted OS is performed using the
standard SMC TrustZone instruction. Unlike QSEE, where the
physical address of a packed structure is passed to the trusted
6
Fig. 3: The data structure used to communicate with the TEE
in QSEE [15].
3) Trusted OS and Trusted Application: TAs are executed
as user mode applications within the trusted world, with no
access to any other secure world memory (e.g., other TAs or
the trusted OS). Consequently, TAs must issue system calls to
the trusted OS kernel for any privileged tasks that they need
to perform. For example, to access non-secure memory (i.e., a
physical address passed from the untrusted world), they must
utilize the qsee_register_shared_buffer() syscall.
In this call, the trusted OS validates that the request mem-
ory region is not inside the secure world (e.g., within the
trusted OS),
itself from the untrusted world. If
the physical memory address is indeed within the non-secure
world’s memory, the kernel will map the requested physi-
cal memory region into the TA’s memory space. Note that
qsee_register_shared_buffer() only veriﬁes that
the memory is not in the secure world; it cannot verify that
this physical address indeed belongs to the untrusted world
application that initiated this request [25].
to protect
As
of
the
use
QSEE:
untrusted
this puts
4) BOOMERANG
on
application makes
discussed
above,
the
function, which
QSEECom_send_modified_buffer
updates
the send_buf with physical addresses before
sending it to the TA using the provided replacement vector
(i.e., QSEECom_io_fd_info). However,
the
onus on the untrusted application to supply the necessary
information for the appropriate pointer translation to occur.
to pass arbitrary
A malicious application that wishes
physical memory addresses could simply insert
them into
send_buf in the proper locations for the victim TA, and
exclude them from the replacement vector. Alternatively, the
malicious application could simply utilize the un-sanitized
QSEECom_send_cmd command, which will send commands
to the TA without any pointer translation (see Figure 3). The
trusted OS only checks to conﬁrm that these physical pointers
are not mapped into the secure world. Thus, any malicious
physical address placed within the send_buf buffer, and
kept hidden from PTRSAN, will be blindly acted upon by
the TA (e.g., decrypted, copied, encoded), resulting in a
BOOMERANG vulnerability. We show in Section VI-B how
we were able to leverage actual BOOMERANG vulnerabilities
TEE Driver Interface struct QSEECom_handle *handlevoid *send_bufuint32_t sbuf_lenvoid *resp_bufuint32_t rbuf_lenstruct QSEECom_ion_fd_info  *ifd_dataunsigned char *ion_sbuffervoid *pointerTA Input???void *pointer???void *pointer???void *pointer???TA Output int32_t fdPTRSANuint32_t cmd_buf_offset;int32_t fduint32_t cmd_buf_offset;int32_t fduint32_t cmd_buf_offset;int32_t fduint32_t cmd_buf_offset;TA-specific SemanticsQSEECom_send_cmdQSEECom_send_modified_cmdv o i d processMapBulkBuf ( C o n n e c t i o n ∗ c o n n e c t i o n ) {
. . .
/ / T r u s t o n i c ’ s PTRSAN f u n c t i o n
uint64 t pAddrL2 = d e v i c e−>findWsmL2 ( cmd . handle ,
c o n n e c t i o n−>s o c k e t D e s c r i p t o r ) ;
. . .
/ / Map b u l k memory t o s e c u r e world
/ / BOOMERANG i f
mcResult t mcResult = d e v i c e−>mapBulk ( c o n n e c t i o n ,
t h e a t t a c k e r can c o n t r o l pAddrL2
cmd . s e s s i o n I d , cmd . handle , pAddrL2 ,
cmd . o f f s e t P a y l o a d , cmd . lenBulkMem ,
&s e c u r e V i r t u a l A d r ) ;
( mcResult
. . .
i f
w r i t e R e s u l t ( c o n n e c t i o n , mcResult ) ;
r e t u r n ;
!= MC DRV OK) {
}
mcDrvRspMapBulkMem t
r s p . h e a d e r . r e s p o n s e I d = MC DRV OK;
r s p . p a y l o a d . s e s s i o n I d = cmd . s e s s i o n I d ;
r s p . p a y l o a d . s e c u r e V i r t u a l A d r = s e c u r e V i r t u a l A d r ;
c o n n e c t i o n−>w r i t e D a t a (& rsp ,
r s p ;
s i z e o f ( mcDrvRspMapBulkMem t ) ) ;
}
Fig. 4: Code snippet from Trustonic’s MobiCore daemon that
exhibits a potential BOOMERANG ﬂaw [55].
OS, Trustonic’s implementation explicitly passes parameters
using values stored in registers (current implementations only
support up to four unique parameters [54]).
3) Trusted OS and Trusted Application: Given that the
secure world binaries are encrypted, we were not able to
completely reverse-engineer the interaction between TAs and
the trusted OS. However, based on our experience with other
implementations, we assume that it follows a similar structure,
where TAs in the trusted world run as normal user-space
applications, with no access to the trusted OS’s memory.
Similarly, all privileged tasks from TAs are likely handled
by system calls to the trusted OS. We hypothesize that they
also implement some checks on the pointers (i.e., opaque
ids, virtual addresses) passed by the untrusted applications to
validate that they indeed belong to the non-secure world, but
currently we have no way to conﬁrm this.
4) BOOMERANG on Trustonic: Although there is no ex-
plicit PTRSAN mechanism in Trustonic’s implementation, the
use of opaque identiﬁers by mcDaemon for shared memory
inherently ensures that an untrusted user application does not
have control over the resulting pointers. Figure 4 shows the
exact code that is enforcing this within the mcDaemon service.
Note that this construction inherently makes the assumption
that all shared memory requests come from mcDaemon, and
that this daemon is not compromised. However, if an attacker
were able to gain access to /dev/mobicore, or compromise
mcDaemon, pAddrL2 (in Listing 4) could be replaced with
an arbitrary non-secure world physical memory (just as in
QSEE) resulting in a BOOMERANG vulnerability. We have
conﬁrmed this issue with Trustonic, and are working with them
toward an improved design for future releases.
C. Open Source Trusted Execution Environment (OP-TEE)
OP-TEE [33] is an open source TEE implementation,
which can run on a selection of hardware development plat-
forms. OP-TEE adheres to the GlobalPlatform [13] speciﬁ-
cation and provides libraries that ease the development of
7
Fig. 5: Outline of interactions with the TEE in OP-TEE’s
implementation using common-memory. [27], [35]
TAs. While OP-TEE has not yet been deployed on consumer
hardware, it was valuable for our research, as it provided us
with an implementation into which we had complete visibility
and a platform for evaluating our defenses.
1) Untrusted Application and Untrusted OS: Similar to
other implementations,
the untrusted OS exposes a driver
/dev/tee0 [47], which can be used by applications to
interact with the TAs. A client library libteec.so [49] is
also provided to make it easier for applications to communicate
with this driver. All parameters that are passed to the TA are
strongly typed. There are two broad types: a pointer type and
a value type (either of which can be input to a TA, output from
a TA, or both). Every call to the secure world can only support
up to four parameters, which must conform to the strict typing.
Untrusted applications again use opaque pointers (i.e.,
shmids) to refer to memory that is intended to be shared with
a TA. To pass a pointer argument, the untrusted application
communicates with /dev/tee0 to request memory of a
speciﬁc length. The kernel driver then allocates this memory in
a dedicated shared memory region (i.e., common-memory),
pairs it with a shmid, and returns it to the client. Untrusted
applications can use this shmid to map the memory into their
address space, where they can then write commands to and
read responses from the TA. This shared memory region is
accessible by both the non-secure and secure worlds. However,
because it is a dedicated memory region, it greatly reduces the
risk of BOOMERANG vulnerabilities.
2) Untrusted OS and Trusted OS: Upon receiving a com-
mand from the untrusted application, the untrusted OS will
ﬁrst perform the required pointer translations (i.e., PTRSAN).
Next, it packs all of the parameters into an optee_msg_arg
structure and copies it into a free region in common-memory.
Lastly,
it performs a world-switch using the SMC instruc-
tion [48], with the physical address of this region as its
argument.
3) Trusted OS and Trusted Application: TAs in OP-TEE
run as unprivileged applications within the secure world, each
running in its own thread, which are only spawned when a
request is issued from the non-secure world. All privileged
operations must, again, be performed through system calls into
optee_to_msg_paramNon-secure Memorycommon-memorySecure Memorystruct tee_param *paramssize_t num_paramsconst struct optee_msg_param *msg_paramsNon-secure WorldSecure WorldUser ModeSupervisor ModeSupervisor ModeUser Modetee_ta_verify_paramstruct tee_ta_session *sessstruct tee_ta_param *paramUntrusted ApplicationTrusted ApplicationPhysical Memorythe trusted OS (i.e., supervisor call (SVC) instructions). For
each memory parameter passed to a TA from the non-secure
world, the physical address is ﬁrst checked to ensure that is
contained within the common-memory region, and that this
memory region is mapped to the thread that is handling the
request. More precisely, the trusted OS will take the physical
address that was passed as a parameter and update it with