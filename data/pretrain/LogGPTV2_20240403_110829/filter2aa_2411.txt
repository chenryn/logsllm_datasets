Reverse Engineering by Crayon: 
Reverse Engineering by Crayon: 
Game Changing Hypervisor and
Game Changing Hypervisor and
Game Changing Hypervisor and 
Game Changing Hypervisor and 
Visualization Analysis
Visualization Analysis
Fine-grained covert debugging using 
hypervisors and analysis via visualization
Daniel A. Quist
Lorie M. Liebrock
Offensive Computing, LLC
New Mexico Tech
Defcon 17
Las Vegas, NV
Introduction
Introduction
Introduction
Introduction
 Reverse Engineering is Hard!
g
g
 Hypervisor based executable 
monitoring
monitoring
 Modifications for improved performance
 Visualization tool for rapid analysis
 Visualization tool for rapid analysis
 Modifying the reverse engineering 
process
Difficulties of RE
Difficulties of RE
Difficulties of RE
Difficulties of RE
 Time consuming process
g p
 Difficult set of skills to acquire
 Tools are advanced but still don’t
 Tools are advanced, but still don t 
provide adequate views.
 Focused on static analysis
 Focused on static analysis
 Software armoring makes process 
diffi
lt
even more difficult
Process for Reverse Engineering
Process for Reverse Engineering
Process for Reverse Engineering
Process for Reverse Engineering
 Setup an isolated run-time 
p
environment
 Execution and initial analysis
Execution and initial analysis
 Deobfuscate compressed or packed 
code
code
 Disassembly / Code-level Analysis
Id
tif
d
l
l
t
d
 Identify and analyze relevant and 
interesting portions of the program
Isolated Analysis Environment
Isolated Analysis Environment
Isolated Analysis Environment
Isolated Analysis Environment
 Setup an Isolated Runtime 
p
Environment
◦ Virtual machines: VMWare, Xen, KVM, …
f f
◦ Need to protect yourself from malicious code
◦ Create a known-good baseline environment
Create a known good baseline environment
◦ Quickly allows backtracking if something bad 
happens
Execution and Initial Analysis
Execution and Initial Analysis
Execution and Initial Analysis
Execution and Initial Analysis
 Goal: Quickly figure out what the 
program is doing without looking at 
assembly
 Look for:
Ch
t
th
fil
t
◦ Changes to the file system
◦ Changes to the behavior of the system
 Network traffic
 Network traffic
 Overall performance
 Ads or changed browser settings
g
g
Remove Software Armoring
Remove Software Armoring
Remove Software Armoring
Remove Software Armoring
 Program protections to prevent 
g
p
p
reverse engineering
 Done via packers – Small
Done via packers 
Small 
encoder/decoder
 Self-modifying code
 Self modifying code
 Lots of research about this
OllyBonE Saffron Polyunpack Renovo
◦ OllyBonE, Saffron, Polyunpack, Renovo, 
Ether, Azure
◦ My research uses Ether
◦ My research uses Ether
Packing and Encryption
Packing and Encryption
Packing and Encryption
Packing and Encryption
 Self-modifying code
◦ Small decoder stub
◦ Decompress the main executable
◦ Restore imports
 Play “tricks” with the executable
◦ OS Loader is inherently lazy (efficient)
◦ Hide the imports
Ob
l
ti
◦ Obscure relocations
◦ Use bogus values for various unimportant 
fields
fields
Software Armoring
Software Armoring
Software Armoring
Software Armoring
◦ Compressed, obfuscated, hidden code
◦ Virtual machine detection
◦ Debugger detection
◦ Shifting decode frames
Normal PE File
Normal PE File
Normal PE File
Normal PE File
Packed PE File
Packed PE File
Packed PE File
Packed PE File
Troublesome Protections
Troublesome Protections
Troublesome Protections
Troublesome Protections
 Virtual Machine Detection
◦ Redpill, ocvmdetect, Paul Ferrie’s paper
 Debugger Detection
Debugger Detection
◦ IsDebuggerPresent()
◦ EFLAGS bitmask
EFLAGS bitmask
 Timing Attacks
◦ Analyze value of RDTSC before and after
◦ Analyze value of RDTSC before and after
◦ Really effective
Thwarting Protections
Thwarting Protections
Thwarting Protections
Thwarting Protections
Two methods for circumvention
1. Know about all the protections before 
p
hand and disable them
2. Make yourself invisible
Virtual Machine Monitoring
Virtual Machine Monitoring
Virtual Machine Monitoring
Virtual Machine Monitoring
 Soft VM Based systems
◦ Renovo
◦ Polyunpack
◦ Zynamics Bochs unpacker
Problems
 Problems
◦ Detection of virtual machines is easy
◦ Intel CPU never traditionally designed for
◦ Intel CPU never traditionally designed for 
virtualization
◦ Do not emulate x86 bug-for-bug
Do not emulate x86 bug for bug
OS Integrated Monitoring
OS Integrated Monitoring
OS Integrated Monitoring
OS Integrated Monitoring
 Saffron, OllyBonE
y
◦ Page-fault handler based debugger
◦ Abuses the supervisor bit on memory 
p
y
pages
◦ High-level executions per page
 Problems
◦ Destabilizes the system
Destabilizes the system
◦ Need dedicated hardware
◦ Fine-grain monitoring not possible
Fine grain monitoring not possible
Fully Hardware Virtualizations
Fully Hardware Virtualizations
Fully Hardware Virtualizations
Fully Hardware Virtualizations
 Ether: A. Dinaburg, P. Royal
◦ Xen based hypervisor system
◦ Base functions for monitoring
S
t
ll
 System calls
 Instruction traces
 Memory Writes
Memory Writes
◦ All interactions done by memory page mapping
 Problems
◦ Unpacking code primitive
◦ Dumps mangled and not possible to 
dissassemble
◦ Old version of Xen hypervisor
Disassembly and Code Analysis
Disassembly and Code Analysis
Disassembly and Code Analysis
Disassembly and Code Analysis
 Most nebulous portion of the process
 Largely depends on intuition
◦ Example: When we reversed the MP3 
Cutter and MIRC programs
◦ Takes time and experience
L
ki
t
bl i t di
 Looking at assembly is tedious
 Suffers from “not seeing the forest 
f
th
t
”
d
from the trees” syndrome
 Analyst fatigue – Level of attention 
required yields few results
required yields few results
Find Interesting and Relevant 
Find Interesting and Relevant 
P
i
f h
E
bl
P
i
f h
E
bl
Portions of the Executable
Portions of the Executable
 Like disassembly, this relies on a lot of 
y
intuition and experience
 Typical starting points:
Typical starting points:
◦ Look for interesting strings
◦ Look for API calls
Look for API calls
◦ Examine the interaction with the OS
 This portion is fundamentally
 This portion is fundamentally 
imprecise, tedious, and often 
frustrating for beginners and experts
frustrating for beginners and experts
Contributions
Contributions
Contributions
Contributions
 Modifications to Ether
◦ Improve malware unpacking
◦ Enable advanced tracing mechanisms
◦ Automate much of the tedious portions
 Visualizing Execution for Reversing 
d A
l
i (VERA)
and Analysis (VERA)
◦ Speed up disassembly and finding 
interesting portions of an executable
interesting portions of an executable
◦ Faster identification of the Original Entry 
Point
o t
Ether System Architecture
Ether System Architecture
Ether System Architecture
Ether System Architecture
Extensions to Ether
Extensions to Ether
Extensions to Ether
Extensions to Ether
 Removed unpacking code from 
h
i
i
hypervisor into userspace
B
d
l
i
 Better user mode analysis
PE R
i
t
All
f
 PE Repair system – Allows for 
disassembly of executables
 Added enhanced monitoring system for 
executables
executables
Results
Results
Results
Results
 Close to a truly covert analysis system
y
y
y
◦ Ether is nearly invisible
◦ Still subject to bluepill detections
j
p
 Fine-grain resolution of program 
execution
execution
 Application memory monitoring and 
full analysis capabilities
full analysis capabilities
 Dumps from Ether can now be loaded 
in IDA Pro without modification
in IDA Pro without modification
Open Problems
Open Problems
Open Problems
Open Problems
 Unpacking process produces lots of 
candidate dump files
f
O
 Need to figure out what the OEP is
I
t
b ildi
i
till
i
 Import rebuilding is still an issue
N
th t th
i
i
t
l f
t
i
 Now that there is a nice tool for tracing 
programs covertly, we need to do 
analysis
analysis
Visualization of Trace Data
Visualization of Trace Data
Visualization of Trace Data
Visualization of Trace Data
 Goals:
◦ Quickly visually subvert software armoring
◦ Identify modules of the program
 Initialization
 Main loops
 End of unpacking code
 End of unpacking code
◦ Figure out where the self-modifying code 
ends (OEP detection)
e ds (O
detect o )
◦ Discover dynamic runtime program behavior
◦ Integrate with existing tools
g
g
Visualizing the OEP Problem
Visualizing the OEP Problem
Visualizing the OEP Problem
Visualizing the OEP Problem
 Each block (vertex) represents a basic 
block executed in the user mode code
 Each line represents a transition
Th
thi k
th
li
th
it
 The thicker the line, the more it was 
executed
 Colors represent areas of memory 
execution
execution
VERA
VERA
VERA
VERA
 Visualization of Executables for 
Reversing and Analysis
 Windows MFC Application
 Integrates with IDA Pro
 Fast, small memory footprint
VERA Architecture
VERA Architecture
VERA Architecture
VERA Architecture
Visualizing Packers
Visualizing Packers
Visualizing Packers
Visualizing Packers
 Memory regions marked for PE 
y
g
heuristics
Demo!
Demo!
Demo!
Demo!
Netbull
Netbull Virus (Not Packed)
Netbull Virus (Not Packed)
Netbull Virus (Not Packed)
Virus (Not Packed)
Netbull
Netbull Zoomed View
Netbull Zoomed View
Netbull Zoomed View
Zoomed View
Visualizing Packers
Visualizing Packers
Visualizing Packers
Visualizing Packers
 Memory regions marked for PE 
y
g
heuristics
UPX
UPX
UPX
UPX
UPX
UPX - OEP
UPX OEP
UPX OEP
OEP
ASPack
ASPack
ASPack
ASPack
FSG
FSG
FSG
FSG
MEW
MEW
MEW
MEW
TeLock
TeLock
TeLock
TeLock
Future Work
Future Work
Future Work
Future Work
 General GUI / bug fixes
g
 Integration with IDA Pro
 Memory access visualization
 Memory access visualization
 System call integration
F
ti
b
d
i
 Function boundaries
 Interactivity with unpacking process
 Modify hypervisor to work with 
WinDBG, OllyDbg, IDA Debugger
Conclusions
Conclusions
Conclusions
Conclusions
 Visualizations make it easy to identify 
y
y
the OEP
 No statistical analysis of data needed
No statistical analysis of data needed
 Program phases readily identified
 Graphs are relatively simple
 Graphs are relatively simple
 Preliminary user study shows tool 
h ld
i
f
di
holds promise for speeding up reverse 
engineering
Questions?
Questions?
Questions?
Questions?
These slides are out of date! Find the latest ones at:
These slides are out of date! Find the latest ones at:
http://www.offensivecomputing.net/