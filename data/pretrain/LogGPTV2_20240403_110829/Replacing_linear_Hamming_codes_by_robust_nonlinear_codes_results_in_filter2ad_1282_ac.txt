**授权使用说明：**
本内容仅限于清华大学授权使用。下载时间：2021年3月20日UTC 09:58:41，来源于IEEE Xplore。使用时需遵守相关限制。

---

### 线性SEC-DED码与多比特错误

线性SEC-DED（单错误纠正-双错误检测）码在处理多比特错误方面表现不佳，因为它们具有较小数量的不可检测多比特错误，并且更适合应用于MBU（多比特翻转）率较高的场景。此外，通过调整参数，可以在代码的鲁棒性和硬件开销之间找到平衡点。通常来说，较小的`a`值会提高代码的鲁棒性，但同时也会增加编码器所需的硬件资源。通过仔细选择`a`和`m`，我们可以根据不同的鲁棒性和硬件开销需求构建合适的代码。

#### 示例 4.2 (扩展Vasil’ev码)
1. **设定 `a = 16` 和 V 为 (21,16,3) Hamming 码**：选择与示例 4.1 中相同的非重复二次函数。根据定理 4.4 描述的广义 Vasil’ev 构造方法，在此基础上添加一个整体奇偶校验位，可以构造出一个 (39,32,4) 部分鲁棒码，其中 |Kd| = 2^16，d = 4，且 max Q(e) 对于 e 不属于 Kd 的情况等于 0.5。
   
2. **替代方案 `a = 6` 和 V 为 (31,26,3) 完美 Hamming 码**：同样可以构造一个 (39,32,4) 部分鲁棒码，此时 |Kd| = 2^6，尽管编码器的硬件开销较大。

3. **当硬件开销更为关键时**：可以选择 `a = 18` 并设 V 为 (19,14,3) Hamming 码。这样得到的部分鲁棒码将拥有最大的 |Kd| 值（即 2^18），然而其编码器实现的硬件开销却是最小的。

其他一些具有小检测核的完美非线性码的构造可以在参考文献 [27][28][32][1][9] 中找到。表 1 比较了这些非线性码与完美线性 Hamming 码之间的 |Kd|、max Q(e) 以及编码/解码复杂度。如预期那样，线性 Hamming 码虽然具有最低的编码/解码复杂度，但其不可检测错误的数量最多，这使得它不适合那些需要保护免受多比特错误影响的应用场景。

Phelps-Solov’eva 码 [27] 的 |Kd| 略大于 Vasil’ev 码，但由于至少需要执行两次 GF(2) 上的矩阵乘法来计算码字两部分的综合症，因此其编码和解码复杂度较高。利用切换构造 [9] 可以生成维度为一的检测核，但是这类码的最大 Q(e) 接近于 1，并且其编码和解码复杂度远高于 Vasil’ev 码，从而极大地限制了它们的应用范围。鉴于此，我们建议采用 Vasil’ev 码及其扩展版本作为传统线性单错误纠正及 SEC-DED 码的替代方案，特别是在多比特错误不容忽视的应用场合下。

我们注意到，本节描述的最小距离鲁棒和部分鲁棒码的构造方法很容易推广到非二进制情形。

### 5. 架构设计
为了展示利用最小距离部分鲁棒码保护内存免受软错误的优势，我们将比较一个 (39,32,4) 扩展 Vasil’ev 码与经典线性 (39,32,4) 扩展 Hamming 码 [34] 在误检/纠错性能以及硬件开销方面的差异。后者被用于保护 Virtex-II Pro 设备中的双倍数据速率 DIMM 内存。

图 1 显示了一种基于系统误差校正码的通用内存架构。在写入操作期间，编码器生成冗余位并将其保存在冗余内存块中；而在读取过程中，ECC 模块计算所检索数据的综合症并执行错误校正算法。如果发生无法纠正的错误，则 ERR 标志会被触发并且不会尝试进行任何更正。

![General Memory Architecture with ECC Functions](figure1.png)

**图 1：带有 ECC 功能的一般内存架构**

#### 5.1 基于扩展 Hamming 码的内存保护架构
对于传统的线性 SEC-DED 码，编码器通过对 k 位数据与选定线性码的编码矩阵 P 进行 GF(2) 上的矩阵乘法来生成冗余位。[34] 中使用的 (39,32) 奇偶校验矩阵 H 形式为 H=(P|I)，其中 I 是单位矩阵，而 P 的具体形式如下所示：
```
01010110101010101010101011010101101110011011001100110011011001101101111000111100001111000111100011100000001111111100000001111111000000000011111111001111100000000000111111000000000000000000000000011111111111111111111111111111111.
```

[34] 中的设计仅覆盖了信息部分的最后一个奇偶校验位，因此 C 不是一个完全的 SEC-DED 码，只能检测发生在信息部分的双比特错误。如果双比特错误中至少有一个位于 C 的冗余部分，则该码可能会将其误纠正为单比特错误。为了让 C 成为一个完全的 SEC-DED 码，我们需要基于整个码字的所有位来计算最后一个奇偶校验位，而不是仅仅基于信息位。冗余位与相关的 32 位数据一同生成并写入内存。在读取阶段，数据和冗余位同时被读取，然后按照类似检查位生成的方式计算综合症，用于查找错误类型和位置。创建一个 32 位校正掩码以纠正发生在信息部分的单比特错误。当检测到单比特错误时，原始数据与掩码进行异或运算，从而反转受影响的位。如果没有错误或多比特错误发生，则所有掩码位均为零，数据将直接通过 ECC 模块而不做任何修改。

基于传统线性 SEC-DED 码的内存保护方案的主要缺点是其对多比特错误的不可检测/误纠正概率较高。对于任何线性系统码，Kd=C，|Kd|=|C|=2^k。因此，对于 (39,32,4) 扩展 Hamming 码而言，不可检测错误的数量为 2^32。容易证明，任意 (n,k,d) 线性系统纠错码 C 能够纠正最多 2^(n-k)-1 个错误。若纠正了 N 个错误（0≤N≤2^(n-k)-1），则误纠正错误数为 N·(2^k-1)。例如，在 [34] 中描述的方法中，只有信息部分发生的单比特错误才会被纠正（N=32），因此多比特误纠正错误数为 32*(2^32-1)。

#### 5.2 基于扩展 Vasil’ev 码的内存保护架构
(a+m+2,a+kV,4) 扩展 Vasil’ev 码的码字格式为 (x, (x,0)+v, p(x)+f(y), p(x)+p(v)+f(y))，其中 x 属于 GF(2^a)，0 属于 GF(2^(m-a))，0kV 表示当错误出现在 V 的冗余位上且不需要纠正时，ERR 将被触发且不进行任何更正。类似的流程也可以应用于 a>kV 的情况。

**示例 5.1**
在此示例中，我们将展示如何为 a=6 时的 (39,32,4) 扩展 Vasil’ev 码 C 编码和解码消息 (11111001011011000110010111001111)。根据公式 (9)，当 a=6 时，x=(111110)，y 可以通过 XOR(x,0) 计算得出，其中 0 属于 GF(2^(|a-kV|))，其余 kV=26 位消息组成 y=(10100011000110010111001111)。假设 V 的奇偶校验矩阵 H 为给定的形式，那么 v∈V 的冗余位为 (00101)。设 f 为示例 4.1 中描述的非重复二次函数，则 p(x)=1，p(v)=0，f(y)=0。最后两个非线性冗余位为 11，整个码字为 (111110010110110001100101110011110010111)。

假设第 9 位发生了单比特错误，接收到扭曲后的码字后，根据公式 (11)、(12)、(13) 计算 S1、S2 和 S3。结果得到 S1=h3=(11101)，S2=0，S3=1。翻转 x 的第 3 位并重新计算 S2，新的 S2 值为 1，表明错误位于第二部分的第 3 位，即整个码字的第 9 位。

![Error Correction Algorithm for the Extended Vasil’ev Code (a≤kV)](figure2.png)

**图 2：扩展 Vasil’ev 码 (a≤kV) 的错误校正算法**

---

以上是对原文档内容的专业化改写，旨在使表述更加清晰、连贯，并突出技术细节。