# 10 \| 第1～9讲课后思考题答案及常见问题答疑你好，我是蒋德钧。 咱们的课程已经更新 9讲了，这段时间，我收到了很多留言。很多同学都认真地回答了课后思考题，有些回答甚至可以说是标准答案。另外，还有很多同学针对Redis的基本原理和关键机制，提出了非常好的问题，值得好好讨论一下。 今天，我就和你聊一聊课后题答案，并且挑选一些典型问题，集中进行一次讲解，希望可以解决你的困惑。 课后思考题答案第 1 讲]  **问题：和跟 Redis 相比，SimpleKV还缺少什么？** \@曾轼麟、@Kaito同学给出的答案都非常棒。他们从数据结构到功能扩展，从内存效率到事务性，从高可用集群再到高可扩展集群，对SimpleKV 和 Redis进行了详细的对比。而且，他们还从运维使用的角度进行了分析。我先分享一下两位同学的答案。 \@曾轼麟同学： >  > 1.   >>>>     数据结构：缺乏广泛的数据结构支持，比如支持范围查询的 SkipList>     和 Stream 等数据结构。>     >     >>> 2.   >>>>     高可用：缺乏哨兵或者 master-slave>     模式的高可用设计；>     >     >>> 3.   >>>>     横向扩展：缺乏集群和分片功能；>     >     >>> 4.   >>>>     内存安全性：缺乏内存过载时的 key>     淘汰算法的支持；>     >     >>> 5.   >>>>     内存利用率：没有充分对数据结构进行优化，提高内存利用率，例如使用压缩性的数据结构；>     >     >>> 6.   >>>>     功能扩展：需要具备后续功能的拓展；>     >     >>> 7.   >>>>     不具备事务性：无法保证多个操作的原子性。>     >     >>\@Kaito 同学： >  > SimpleKV> 所缺少的有：丰富的数据类型、支持数据压缩、过期机制、数据淘汰策略、主从复制、集群化、高可用集群等，另外，还可以增加统计模块、通知模块、调试模块、元数据查询等辅助功能。> > >我也给个答案总结。还记得我在开篇词slate-object="inline"讲过的"两大维度""三大主线"吗？这里我们也可以借助这个框架进行分析，如下表所示。此外，在表格最后，我还从键值数据库开发和运维的辅助工具上，对SimpleKV 和 Redis 做了对比。 ![](Images/6fb4a6d39e4126b09cd9f1606ddeca61.png)savepage-src="https://static001.geekbang.org/resource/image/67/36/67e77bea2568a4f0997c1853d9c60036.jpg"}第 2 讲]  **问题：整数数组和压缩列表作为底层数据结构的优势是什么？** 整数数组和压缩列表的设计，充分体现了Redis"又快又省"特点中的"省"，也就是节省内存空间。整数数组和压缩列表都是在内存中分配一块地址连续的空间，然后把集合中的元素一个接一个地放在这块空间内，非常紧凑。因为元素是挨个连续放置的，我们不用再通过额外的指针把元素串接起来，这就避免了额外指针带来的空间开销。 我画一张图，展示下这两个结构的内存布局。整数数组和压缩列表中的 entry都是实际的集合元素，它们一个挨一个保存，非常节省内存空间。 ![](Images/775316a73982f59dc3f74dbf7e80eca7.png)savepage-src="https://static001.geekbang.org/resource/image/2c/2a/2c57cc1c548a0733bd1bf09f397f342a.jpg"}Redis之所以采用不同的数据结构，其实是在性能和内存使用效率之间进行的平衡。 第 3 讲]  **问题：Redis 基本 IO模型中还有哪些潜在的性能瓶颈？** 这个问题是希望你能进一步理解阻塞操作对 Redis 单线程性能的影响。在Redis 基本 IO 模型中，主要是主线程在执行操作，任何耗时的操作，例如bigkey、全量返回等操作，都是潜在的性能瓶颈。 第 4 讲]  **问题 1：AOF重写过程中有没有其他潜在的阻塞风险？** 这里有两个风险。 风险一：Redis 主线程 fork 创建 bgrewriteaof子进程时，内核需要创建用于管理子进程的相关数据结构，这些数据结构在操作系统中通常叫作进程控制块（ProcessControl Block，简称为 PCB）。内核要把主线程的 PCB内容拷贝给子进程。这个创建和拷贝过程由内核执行，是会阻塞主线程的。而且，在拷贝过程中，子进程要拷贝父进程的页表，这个过程的耗时和Redis 实例的内存大小有关。如果 Redis 实例内存大，页表就会大，fork执行时间就会长，这就会给主线程带来阻塞风险。 风险二：bgrewriteaof子进程会和主线程共享内存。当主线程收到新写或修改的操作时，主线程会申请新的内存空间，用来保存新写或修改的数据，如果操作的是bigkey，也就是数据量大的集合类型数据，那么，主线程会因为申请大空间而面临阻塞风险。因为操作系统在分配内存空间时，有查找和锁的开销，这就会导致阻塞。 **问题 2：AOF 重写为什么不共享使用 AOF本身的日志？** 如果都用 AOF 日志的话，主线程要写，bgrewriteaof子进程也要写，这两者会竞争文件系统的锁，这就会对 Redis主线程的性能造成影响。 第 5 讲]  问题：使用一个 2 核 CPU、4GB 内存、500GB 磁盘的云主机运行Redis，Redis 数据库的数据量大小差不多是 2GB。当时 Redis主要以修改操作为主，写读比例差不多在 8:2 左右，也就是说，如果有 100个请求，80 个请求执行的是修改操作。在这个场景下，用 RDB做持久化有什么风险吗？ \@Kaito 同学的回答从内存资源和 CPU资源两方面分析了风险，非常棒。我稍微做了些完善和精简，你可以参考一下。 **内存不足的风险**：Redis fork 一个 bgsave 子进程进行 RDB写入，如果主线程再接收到写操作，就会采用写时复制。写时复制需要给写操作的数据分配新的内存空间。本问题中写的比例为80%，那么，在持久化过程中，为了保存 80%写操作涉及的数据，写时复制机制会在实例内存中，为这些数据再分配新内存空间，分配的内存量相当于整个实例数据量的80%，大约是1.6GB，这样一来，整个系统内存的使用量就接近饱和了。此时，如果实例还有大量的新key 写入或 key 修改，云主机内存很快就会被吃光。如果云主机开启了 Swap机制，就会有一部分数据被换到磁盘上，当访问磁盘上的这部分数据时，性能会急剧下降。如果云主机没有开启Swap，会直接触发 OOM，整个 Redis 实例会面临被系统 kill掉的风险。 **主线程和子进程竞争使用 CPU的风险** ：生成 RDB的子进程需要 CPU 核运行，主线程本身也需要 CPU 核运行，而且，如果 Redis还启用了后台线程，此时，主线程、子进程和后台线程都会竞争 CPU资源。由于云主机只有 2 核CPU，这就会影响到主线程处理请求的速度。 第 6 讲]  **问题：为什么主从库间的复制不使用AOF？** 答案：有两个原因。 1.       RDB 文件是二进制文件，无论是要把 RDB 写入磁盘，还是要通过网络传输    RDB，IO 效率都比记录和传输 AOF    的高。    2.       在从库端进行恢复时，用 RDB 的恢复效率要高于用    AOF。    第 7 讲]  **问题1：在主从切换过程中，客户端能否正常地进行请求操作呢？** 主从集群一般是采用读写分离模式，当主库故障后，客户端仍然可以把读请求发送给从库，让从库服务。但是，对于写请求操作，客户端就无法执行了。 **问题2：如果想要应用程序不感知服务的中断，还需要哨兵或客户端再做些什么吗？** 一方面，客户端需要能缓存应用发送的写请求。只要不是同步写操作（Redis应用场景一般也没有同步写），写请求通常不会在应用程序的关键路径上，所以，客户端缓存写请求后，给应用程序返回一个确认就行。 另一方面，主从切换完成后，客户端要能和新主库重新建立连接，哨兵需要提供订阅频道，让客户端能够订阅到新主库的信息。同时，客户端也需要能主动和哨兵通信，询问新主库的信息。 第 8 讲]  **问题 1：5 个哨兵实例的集群，quorum 值设为 2。在运行过程中，如果有 3个哨兵实例都发生故障了，此时，Redis主库如果有故障，还能正确地判断主库"客观下线"吗？如果可以的话，还能进行主从库自动切换吗？** 因为判定主库"客观下线"的依据是，认为主库"主观下线"的哨兵个数要大于等于quorum 值，现在还剩 2 个哨兵实例，个数正好等于 quorum值，所以还能正常判断主库是否处于"客观下线"状态。如果一个哨兵想要执行主从切换，就要获到半数以上的哨兵投票赞成，也就是至少需要3 个哨兵投票赞成。但是，现在只有 2个哨兵了，所以就无法进行主从切换了。 **问题 2：哨兵实例是不是越多越好呢？如果同时调大down-after-milliseconds值，对减少误判是不是也有好处？** 哨兵实例越多，误判率会越低，但是在判定主库下线和选举 Leader时，实例需要拿到的赞成票数也越多，等待所有哨兵投完票的时间可能也会相应增加，主从库切换的时间也会变长，客户端容易堆积较多的请求操作，可能会导致客户端请求溢出，从而造成请求丢失。如果业务层对Redis的操作有响应时间要求，就可能会因为新主库一直没有选定，新操作无法执行而发生超时报警。 调大 down-after-milliseconds后，可能会导致这样的情况：主库实际已经发生故障了，但是哨兵过了很长时间才判断出来，这就会影响到Redis 对业务的可用性。 第 9 讲]  问题：为什么 Redis不直接用一个表，把键值对和实例的对应关系记录下来？ 如果使用表记录键值对和实例的对应关系，一旦键值对和实例的对应关系发生了变化（例如实例有增减或者数据重新分布），就要修改表。如果是单线程操作表，那么所有操作都要串行执行，性能慢；如果是多线程操作表，就涉及到加锁开销。此外，如果数据量非常大，使用表记录键值对和实例的对应关系，需要的额外存储空间也会增加。 基于哈希槽计算时，虽然也要记录哈希槽和实例的对应关系，但是哈希槽的个数要比键值对的个数少很多，无论是修改哈希槽和实例的对应关系，还是使用额外空间存储哈希槽和实例的对应关系，都比直接记录键值对和实例的关系的开销小得多。 好了，这些问题你都回答上来了吗？如果你还有其他想法，也欢迎多多留言，跟我和其他同学进行交流讨论。 典型问题讲解接下来，我再讲一些代表性问题，包括 Redis rehash的时机和执行机制，主线程、子进程和后台线程的联系和区别，写时复制的底层实现原理，以及replication buffer 和 repl_backlog_buffer的区别。 问题 1：rehash 的触发时机和渐进式执行机制我发现，很多同学对 Redis 的哈希表数据结构都很感兴趣，尤其是哈希表的rehash操作，所以，我再集中回答两个问题。 **1.Redis 什么时候做rehash？** Redis 会使用装载因子（load factor）来判断是否需要做rehash。装载因子的计算方式是，哈希表中所有 entry的个数除以哈希表的哈希桶个数。Redis 会根据装载因子的两种情况，来触发rehash 操作： 1.  装载因子≥1，同时，哈希表被允许进行    rehash；    2.  装载因子≥5。        在第一种情况下，如果装载因子等于1，同时我们假设，所有键值对是平均分布在哈希表的各个桶中的，那么，此时，哈希表可以不用链式哈希，因为一个哈希桶正好保存了一个键值对。 但是，如果此时再有新的数据写入，哈希表就要使用链式哈希了，这会对查询性能产生影响。在进行RDB 生成和 AOF 重写时，哈希表的 rehash 是被禁止的，这是为了避免对 RDB 和AOF 重写造成影响。如果此时，Redis 没有在生成 RDB 和重写AOF，那么，就可以进行rehash。否则的话，再有数据写入时，哈希表就要开始使用查询较慢的链式哈希了。 在第二种情况下，也就是装载因子大于等于 5时，就表明当前保存的数据量已经远远大于哈希桶的个数，哈希桶里会有大量的链式哈希存在，性能会受到严重影响，此时，就立马开始做rehash。 刚刚说的是触发 rehash 的情况，如果装载因子小于 1，或者装载因子大于 1但是小于 5，同时哈希表暂时不被允许进行 rehash（例如，实例正在生成 RDB或者重写 AOF），此时，哈希表是不会进行 rehash操作的。 **2. 采用渐进式 hash 时，如果实例暂时没有收到新请求，是不是就不做rehash 了？** 其实不是的。Redis 会执行定时任务，定时任务中就包含了 rehash操作。所谓的定时任务，就是按照一定频率（例如每 100ms/次）执行的任务。 在 rehash 被触发后，即使没有收到新请求，Redis 也会定时执行一次 rehash操作，而且，每次执行时长不会超过1ms，以免对其他任务造成影响。 问题 2：主线程、子进程和后台线程的联系与区别我在课程中提到了主线程、主进程、子进程、子线程和后台线程这几个词，有些同学可能会有疑惑，我再帮你总结下它们的区别。 首先，我来解释一下进程和线程的区别。 从操作系统的角度来看，进程一般是指资源分配单元，例如一个进程拥有自己的堆、栈、虚存空间（页表）、文件描述符等；而线程一般是指CPU 进行调度和执行的实体。 了解了进程和线程的区别后，我们再来看下什么是主进程和主线程。 如果一个进程启动后，没有再创建额外的线程，那么，这样的进程一般称为主进程或主线程。 举个例子，下面是我写的一个 C 程序片段，main 函数会直接调用一个 worker函数，函数 worker 就是执行一个 for循环计算。下面这个程序运行后，它自己就是一个主进程，同时也是个主线程。     int counter = 0;    void *worker() {         for (int i=0;i info memory    
# Memory    used_memory:1039120    127.0.0.1:6379> hset 1101000 060 3302000080    (integer) 1    127.0.0.1:6379> info memory    