### Optimized Text

#### Soot and Constraint Checking
Soot was found to perform overly strict constraint checking, which led to translation issues. After patching Soot, the number of translation problems significantly decreased. We anticipate that these conversion failures can be effectively resolved over time.

#### Alternative Implementation Option
Another implementation option is to develop a Dalvik bytecode analysis and instrumentation framework. This approach would allow operations to be directly applied to Dalvik bytecode, thereby minimizing conflicts and failures associated with conversions between different tools.

#### Fully Automatic Defense
For most vulnerable samples in our experiment, we were able to manually verify component hijacking vulnerabilities. However, due to the object-oriented nature of Android programs, computed taint slices can sometimes become very large and complex. As a result, we were unable to confirm exploitable paths for some vulnerable apps through manual effort, and thus could not reproduce the expected attacks. Developers face similar, if not greater, challenges, making it difficult to find timely solutions. Therefore, devising a fully automated mechanism is essential to defend against this specific, complicated vulnerability.

In principle, our automatic patching approach can still protect these unconfirmed cases without needing to know the real presence of potential vulnerabilities. If a vulnerability does exist, AppSealer will disable the actual exploitation on the fly. Otherwise, AppSealer does not interrupt program execution, ensuring that usability is not affected. With automated patching, users do not have to wait for developers to fix the problem.

### Related Work

#### Automatic Patch & Signature Generation
Efforts to automatically generate patches for vulnerable programs or signatures to filter out malicious input are closely related to our work. For example:
- **AutoPaG** [11] automatically analyzes source code, identifies root causes of out-of-bound exploits, and generates fine-grained source code patches.
- **IntPatch** [12] uses classic type theory and dataflow analysis to identify potential integer-overflow-to-buffer-overflow vulnerabilities and instruments programs with runtime checks.
- **Sidiroglou and Keromytis** [13] rely on source code transformations to apply automatically created patches to vulnerable segments of applications.
- **Newsome et al.** [14] propose an execution-based filter that filters out attacks based on the execution trace of the vulnerable program.
- **ShieldGen** [6] generates data patches or vulnerability signatures for unknown vulnerabilities given a zero-day attack instance.
- **Razmov and Simon** [22] automate the filter generation process based on a simple formal description of assumptions about application inputs.

#### Analysis & Mitigation on Smartphone Privacy Issues, Vulnerabilities, and Malware
Significant efforts have been made to discover and address emerging threats in smartphones. Privacy leakage has been studied across various platforms, including iOS, Android, and Windows Phone [18], [21], [23], [24]. Mitigation mechanisms include:
- Rewriting applications to insert mediation code [24]–[26].
- Modifying the Android framework [27], [28] or operating system [29] to enforce privacy policies.
- Preventing attacks on application vulnerabilities such as privilege escalation [30], [31], permission re-delegation [3], capability leaks [2], content leaks and pollution [4], and component hijacking [5].
- Detecting and mitigating malware, which poses a significant threat to smartphone users [32]–[37].

#### Bytecode Rewriting
Our approach involves rewriting existing bytecode programs, which is related to prior work on bytecode rewriting techniques. For instance:
- **Privacy Blocker** [26] performs static analysis of application binaries to identify and selectively replace requests for sensitive data with hard-coded shadow data.
- **I-ARM-Droid** [38] rewrites Dalvik bytecode to interpose on all API invocations and enforce security policies.
- **Aurasium** [25] repackages Android apps to sandbox important native APIs for monitoring security and privacy violations.
- **Livshits and Jung** [24] implement a graph-theoretic algorithm to place mediation prompts into bytecode programs to protect resource access.

In comparison, our work rewrites the bytecode program more extensively. The inserted patch statements monitor and control specific data flows in the rewritten app.

#### Information Flow Control
Our patch statements exercise information flow control (IFC) during runtime. IFC has been studied in various contexts:
- **Chandra and Franz** [39] implement an information flow framework for the Java virtual machine, combining static analysis to capture implicit flows.
- **JFlow** [40] extends the Java language with statically-checked information flow annotations.
- **Jia et al.** [41] propose a component-level runtime enforcement system for Android apps.
- **duPro** [42] is an efficient user-space information flow control framework that isolates protection domains within the same process.
- **Zeng et al.** [43] introduce an IRM-implementation framework at the compiler intermediate-representation (IR) level.

In contrast, we take a static rewriting approach that requires no support from developers and no modification to the runtime. Additionally, we focus on a specific vulnerability and enforce control on solely relevant information flows.

### Conclusion
We developed a technique to automatically generate patches for Android applications with component hijacking vulnerabilities. Given a vulnerable Android app, we first perform static bytecode analysis to identify small but complete program slices leading to the discovered vulnerability. We then devise several shadowing mechanisms to insert new variables and instructions along these slices to track dangerous information at runtime. To improve performance, we apply optimizations to remove redundant instructions, minimizing the footprint of the generated patch. Our evaluation on 16 real-world vulnerable Android applications demonstrates that AppSealer can effectively track and mitigate component hijacking vulnerabilities. After optimization, the patch code represents only a small portion (15.9% on average) of the entire program, and the runtime overhead introduced by AppSealer is minimal, averaging just 2%.

### Acknowledgment
We would like to thank anonymous reviewers for their comments. This research was supported in part by NSF Grants #1018217 and #1054605, and McAfee Inc. Any opinions, findings, and conclusions made in this material are those of the authors and do not necessarily reflect the views of the funding agencies.

### References
[References listed as provided in the original text]

This optimized version aims to enhance clarity, coherence, and professionalism while maintaining the original content's integrity.