# 22 \| 答疑篇：分布式体系架构与分布式计算相关问题你好，我是聂鹏程。今天，我来继续带你打卡分布式核心技术。 到目前为止，"分布式技术原理与算法解析"专栏已经更新 21篇文章了，我已经为你介绍了分布式技术四纵四横知识体系中的三横，即"布式资源管理""分布式计算技术"和"分布式通信"，以及四纵中的"分布式协同"和"分布式调度"。 在这里，我首先要感谢你们坚持学习每一篇文章，以及对每一道思考题的积极思考与讨论，并且还在此基础上对类似问题进行了扩展。 比如，@1024、@每天晒白牙、@游弋云端、@Jackey 和 \@Dale等同学，对双主问题展开了激烈的讨论；再比如，@xj_zh、@mt11912、@小白啊、@随心而至等同学，对Master 如何判断 Slave 是否存活的问题进行了讨论，特别是\@小白啊还专门查询了 Kubernetes的方法，在留言区进行了回复。 这样的同学还有很多，我就不再一一点名了。今天，我就针对前面文章涉及的与思考题有关的留言，做一次进一步地梳理与分析，以帮助你夯实前面所学的知识点。 留言涉及的问题有很多，但我经过进一步地分析和总结后，发现大家特别感兴趣和有疑惑的思考题主要分为两类： 1.  分布式体系架构中，如何判断节点存活的问题；        2.  分布式计算技术中，离线计算、批量计算、实时计算和流式计算的区别。        今天，我主要就对这两类思考题进行一下分析和讲解。 分布式体系架构相关问题在第 9 篇文章"分布式体系结构之集中式结构：一人在上，万人在下slate-object="inline""中，我给你留了一个思考题：**在集中式架构中，Master 如何判断 Slave是否存活呢**？ 首先，我先和你说说 Slave 故障的两类情况：一种是 Slave进程退出，另一种是 Slave所在服务器宕机或重启了。你可能会说，这两种情况的判断方法，难道还不一致吗？别着急，且听我慢慢道来。 如下图所示，假设 Master 节点与 3 个 Slave节点相连。请注意，我在图中，Master 与 Slave 之间画了两条线，实线旁写的是TCP 长连接，虚线旁写的是心跳。因为 Master 与 Slave之间的监控关系是固定的，因此我用了两种机制协同来判断 Slave是否存活。 ![](Images/46eb22c5bcb003ed60fa8df9514ae9c3.png)savepage-src="https://static001.geekbang.org/resource/image/a0/a1/a04e5d8e89239be68a1ed239b66d6ea1.png"}其中， **TCP长连接就是针对 Slave 进程退出，但是 Slave所在服务器未故障的情况。**这种方式是借助 TCP 长连接的工作原理进行判断的。TCP长连接中，TCP 会对对端的 Socket 进行检测，当发现对端 Socket不可用时，比如不能发出探测包或探测包未收到响应，会返回 -1的状态，表示连接断开。所以，这种方式可以快速检测到 Slave进程的退出。 对于 Slave所在服务器故障的情况，由于服务器宕机或重启，那么系统环境等均不工作了，这种情况TCP 长连接也无法进行探测了，也就是说 TCP长连接方法在这种场景下无法判断节点是否故障。 对于这种场景，现有的软件架构中，基本都采用了**心跳方式**。其核心策略是，Master 按照周期性（比如每隔 1s）的方式给Slave 发送心跳包，正常情况下 Slave 收到 Master发送的心跳包后，会立即回复一个心跳包，告知 Master 自己还活着。当某个Slave（比如 Slave1）所在服务器故障后，由于 Slave 无法接收到 Master的心跳包，也就无法回复了。 因此，Master 也无法接收到这个 Slave（比如Slave1）的回复信息。通常情况下，**系统会设置一个阈值（一般设置为与心跳周期一致），若超过这个阈值还未收到Slave 节点的回复，Master 就会标记自己与该 Slave心跳超时。** 其中，设置阈值的目的是，解决 Slave 故障情况下，Master一直收不到心跳信息而阻塞在那里等待心跳回复的问题。一般连续 k 次 Master与 Slave 的心跳超时，Master 就会判断该 Slave 故障了。其中，设置连续 k次的目的是，降低因为系统做垃圾回收或网络延迟导致误判的概率。 这里的 k，主要是根据业务场景进行设置的。如果 k设置得太小，容易导致故障误判率过高，因为系统在做垃圾回收或系统进程正在占用资源时，会阻塞心跳，导致心跳包无法及时回复而超时，从而被误判。如果k 设置得太大，会导致故障发现的时间过长，因为故障发现时间 =k\*心跳发送周期。 接下来，我们继续延展下这个问题吧。 追问 1：非集中式架构中，如何判断节点是否存活？集中式架构中，采用了 TCP连接和心跳协同判断节点是否存活，那么非集中式架构中是否也是这样判断的呢？ 其实，**在非集中式架构与集中式架构中，判断节点是否存活的原理有所不同。**因为，非集中式架构中节点之间是对等的，没有 Master 与 Slave之分。如果每个节点间都建立 TCP 长连接，假设集群中有 n个节点，那么每个节点均需要与其他 n-1个节点建长连接，这将导致每个节点的资源占用都会非常多。因此，非集中式架构是采用心跳的方式进行判断的。 这里你可能会问，如果像集中式架构那样，每个节点与其他 n-1个节点都发送心跳的话，整个集群中同一时间心跳消息为n\*(n-1)，消息量也特别大，甚至会导致网络风暴，应该怎么办。 其实，与集中式架构中的心跳包不同，非集中式架构中采用的心跳方式的核心思想是，**每个节点被b（1≤b\ L2 高级缓存 \> L3 高级缓存 \>内存。其中，L1 高级缓存的访问速度，几乎和 CPU中寄存器的访问速度一样快。 有了这三级缓存，很多数据不需要到内存中读取，而直接读取这三级缓存中的数据即可，缩短了数据访问的时间，使得计算机运行速度变得更快。 **网络访问中的缓存**，通常是指本地的"磁盘"。通过网络访问数据时，需要与远程服务器交互来进行传输，而网络间数据传输以及远程服务器对请求的响应，会耗费很多时间。如果本机器的磁盘可以对你经常访问的远程内容进行存储，这样就不用每次都与远程服务器交互，从而减少网络数据传输与服务器响应的延迟，极大地提高性能。 可以看出，**缓存的概念是相对的，基于不同的背景或应用场景，缓存所映射的存储设备是不一样的。** 总结今天，我主要与你分享了分布式数据的缓存技术。 首先，我以水缸的例子带你直观了解了什么是缓存，并引出了什么是分布式数据缓存。分布式数据缓存是以内存作为磁盘的缓存，存储一些用户经常需要用的数据，以提高访问速度。 其次，我以主流的 Redis 和 Memcached为例，与你介绍了分布式缓存技术中的关键技术，包括支持的数据存储结构（比如k/v、Set、List等）、持久化技术（包括快照方式等）和数据同步技术（具体技术原理，可参见第 26 篇文章slate-object="inline"）。 最后，我再通过一张思维导图来归纳一下今天的核心知识点吧。 ![](Images/8b5826ecdd598e88cffe09835cbe4bb4.png)savepage-src="https://static001.geekbang.org/resource/image/1e/45/1e625c22f729a87ea551f6bbc343f045.png"}相信通过本讲的学习，你已不再觉得分布式缓存有多么神秘了，不管是使用Redis 还是看 Redis等系统的源码，一定会更容易理解和上手。加油，行动起来吧！ 思考题本讲我主要介绍了 Redis 和 Memcached分布式数据缓存系统，你还知道哪些主流的分布式数据缓存系统呢？它们的缓存核心技术是什么呢？ 我是聂鹏程，感谢你的收听，欢迎你在评论区给我留言分享你的观点，也欢迎你把这篇文章分享给更多的朋友一起阅读。我们下期再会！ ![](Images/c191f391e2aab7575517a886bbd7a681.png)savepage-src="https://static001.geekbang.org/resource/image/a4/8c/a42a16601611a1a72599ecfca434508c.jpg"}
# 特别放送 \| 徐志强：学习这件事儿，不到长城非好汉>  > 你好，我是聂鹏程。今天，我要和你分享的是，一名专栏订阅用户"徐志强"的学习经历与方法，主题是"学习这件事儿，不到长城非好汉"。> > >>  > 你在学习专栏的过程中，有没有什么独特的学习方法和心路历程呢？欢迎你写在留言区，我很期待能跟你在这里交流、讨论，一起学习进步。> > >>  > 话不多说，现在就请你返回文稿看看徐志强的故事吧。> > >大家好，我是徐志强，一名 Java开发者，从事互联网金融工作三年了。从 2016年毕业到现在，我从一枚"小白"变成了"熟练工"。但，我一直不甘心从"小熟练工"变成"老熟练工"，所以我来了"极客时间"。回过头来看，自学的这三年，我收获很多，也走了不少弯路。所以，我想把自己的学习经历分享出来，希望能帮你避开些弯路。我是如何学习的？我自学的三年，可以分为以下三个阶段。**第一阶段**：啥都不懂，啥都想学。我买了非常多的书，数据库、操作系统、分布式等每个知识领域都买了一两本，但只是停留在"看了"的阶段。工作中遇到问题时，我不能融会贯通地用到所学知识，或者说我自学的知识基本用不到工作中。这就像大脑里装了很多武器，但我只记得它们的说明书，无法根据它们的特性做出选择。其实在这个阶段，我们都很容易有个误解：觉得只要看了足够多的书、学了足够多的框架，能力自然就会得到提高，但其实蜻蜓点水般的学习收效甚微。所以，在我看来，广度学习虽然容易，但其实只算是到了长城脚下，只是起点。**第二阶段**：调整思路，有选择地精读某些内容。觉察到不对后，我把之前那些书重新找了出来，并调整学习思路：挑选关键知识点采取精读的方式复习，并开始啃一些框架和库的源码。"如果不了解核心原理，我始终都是一枚小白或者熟练工"，这是我经常暗示自己的话。为此，我曾经通宵 Debug就是为了搞明白一段很复杂的源码。每次我在源码中发现了书中描述的知识点后，都非常有成就感，原来就是这样呀！这也让我持续有动力去啃源码。但我发现，学习源码并没有提升程序设计能力，我又进入了新的困惑期：怎样才能更好地消化和理解知识、怎样才能做到举一反三，养成解决问题的能力。为了爬上长城，我继续寻找答案。**第三阶段**：学习一些架构方面的知识，形成知识点和问题的映射。当精读某一领域的知识内容后发现，我在系统设计上短板暴露了出来。因为做系统设计需要有全局思维，需要对整个系统架构的技术栈有清楚的认识，能对比分析不同技术的差异和特性，而不能局限于一个分支。于是，我开始学习架构方面的知识，学习知识点和问题间的映射关系。每遇到一个问题我都会多思考几套解决方案并进行对比分析，每学到一个新知识点就思考它可以用在哪些场景，以及各个知识点有什么共性和联系。说到这里，我再分享一段我的面试经历吧。去年年初我去参加面试，因为平时看了不少书、也阅读了不少源码，可以很轻松地通过一面、二面，但最后一面我就有点招架不住了。后来，我请教面试官，自己还欠缺哪方面的知识和能力。他告诉我，单论某一个知识点我掌握得还不错，但我不能将所有知识由点串成线，由线串成面，最终形成网，建议我平时多思考、多总结。他的这番话对我影响非常大，一下就点醒了我，帮我找到了困惑许久的问题答案。正处于第三阶段学习的我，或许后面我还会有新的困惑，但方法总比问题多。现在，虽然我不知道自己爬到了长城的第几级台阶，但我坚信自己终将站上最高的烽火台！**总结我的学习经历，我觉得有下面几个点值得注意：**1.       一定要坚持学习充电，否则很快就会被淘汰。        2.       不要惧怕学习新技术，新技术不管怎么变化，原理和本质都是不变的。        3.       一定不要只漂在技术的表面，一定要学原理，否则漂的时间久了你自己都不知道漂到哪了。        4.       师傅领进门很关键。学一门新技术，最好是找一本经典的书，或者一门经典的课程系统地学习。        5.       多思考，才能构建自己的知识体系和思维模式，才能将知识化作解决问题的方案。在学习时，我们要思考各个知识点的共性和内在联系，思考这个知识点能解决什么问题，以及遇到的问题能用什么知识点去解决。这样，脑中储存的知识，才能真正为我们所用。        为什么要学习分布式技术和原理？分布式是当前技术领域的趋势之一，它扩展了计算机的计算边界，是区块链、人工智能、机器学习、大数据等众多前沿技术的基石。所以，如果你不想永远当一枚小白或者熟练工，也不想被行业淘汰的话，就必须学习分布式技术，且一定要把原理学明白，不能局限于皮毛。我们不能一直随着浪花漂荡，要尝试将自己沉入海底，这样才能经受得住惊涛骇浪的洗礼，最终到彼岸。我学习的第一个中间件是Kafka，刚开始学的时候就被它的分区、选主、备份等概念搞得晕头转向，后来又学习了Redis 和Elasticsearch。这时，我发现这些中间件有一些共同特点：都会考虑分区来提高吞吐量，都会考虑备份来保证容错和可用性，多个备份之间都会选举一个主来提供服务。慢慢地，对这些概念越来越熟悉后，我发现它们在分布式场景下都会遇到些类似的问题，只是各自的解决方案不同而已。因此，我心中萌生了系统学习分布式技术和原理的想法，因为只有弄清楚了分布式技术的本质和原理，才能在各种眼花缭乱的技术框架中游刃有余。于是，我开始在网上搜集各种学习资料，又来到了极客时间，来到了"分布式技术原理与算法解析"这个专栏。我是怎么学习这个专栏的？说到我是怎么学习这个专栏的，因为之前已经自学过些分布式技术原理，所以可能会和其他人的方法不太一样。首先，我不是利用碎片时间单篇文章地去学习，而是会找一个比较长的空闲时间，一气呵成地学习完一个模块的内容。这样我可以联系上下文，一下搞定相关知识点。其次，学完每篇文章，我都会梳理、总结自己对这篇文章的理解，并尝试回答课后思考题，在评论区留言。同时，我也会关注其他同学的留言问题，并尝试做解答。在这个过程中，针对文章中的疑惑点，我会先去搜索相关资料学习，然后将具体的疑惑点留言给老师，等他的解答。最后，关于知识点的思考和联想很重要。老师讲的很多分布式技术知识点都是通用的，在很多的中间件和框架中都有体现，根据这些理论去思考具体的组件是如何实现的，可以帮助我理解得更深刻。学习到现在，我最大的收获和体会到现在为止，整个专栏已经更新了 18篇文章，可以说帮助我建立了对分布式技术和原理比较全面、系统的认知，越往后的体会越深。其实，在学习这个专栏前，我就对分布式的一些概念，比如分布式事务、BASE理论、CAP理论、分布式锁等有些了解，但这些知识点在我脑中是独立没有关联起来的。所以，这个专栏对我最大的帮助是，帮我打通了这些知识点，有了一个系统化的认知。此外，这个专栏给了我极大的信心。因为，聂老师的讲述是由浅入深的，并且还有大量形象的比喻和深刻的类比。比如，用事务模型来解释共享状态的分布式调度，在我看来就很形象、很有深度。因此，这个专栏给我的感觉是"分布式技术和原理原来就是这么回事呀"，完全消除了我之前的畏难情绪。虽然学完这个课程不代表能透彻掌握分布式的技术原理和算法，但这肯定是一个非常棒的开始。留给朋友们的建议如果你之前没有接触过分布式的技术和中间件的话，我建议你先花点时间去补些基础，但这也不妨碍你将这个专栏作为你的"分布式技术和原理导论"来学习。如果你之前了解过一些分布式技术和分布式组件，但是学得不深入的话，我觉得这个专栏可以帮你建立全面的分布式知识体系，直接带你练习上乘内功。非常值得拥有，我现在也正处于这个阶段。如果你已经对分布式技术和常用组件都很熟悉了的话，我觉得这个专栏可以带你到更高的层次，去思考分布式的核心本质，帮助你更好地造轮子。每个人都有自己的一座长城，有些人爬了一年数个月，有些人爬了十年，而有些人爬了一辈子，他们在长城上看到风景肯定大有不同。技术学习件事，我希望自己当一回好汉，爬上自己的长城，也祝愿各位小伙伴能爬上自己的长城！![](Images/c191f391e2aab7575517a886bbd7a681.png)savepage-src="https://static001.geekbang.org/resource/image/a4/8c/a42a16601611a1a72599ecfca434508c.jpg"}