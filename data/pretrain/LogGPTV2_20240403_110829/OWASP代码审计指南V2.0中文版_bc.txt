start() 
⚫ 
stop() 
267 
⚫ 
destroy() 
⚫ 
init() 
⚫ 
synchronized  
⚫ 
wait() 
⚫ 
notify() 
⚫ 
notifyAll() 
对于经典的 ASP，多线程不是一个直接支持的特性，所以这种竞争条件只能在使用
COM 对象时出现。 
静态方法和变量(每个类一个，而不是每个对象一个)是一个问题，尤其是在多线程之间
存在共享状态的情况下。例如，在 Apache 中，struts 静态成员不应用于存储与特定请求相
关的信息。一个类的同一个实例可以被多个线程使用，并且静态成员的值不能得到保证。 
类的实例不需要线程安全，因为每个操作/请求都有一个实例。静态必须线程安全。 
⚫ 
对静态变量的参考，这些必须是线程锁定的。 
⚫ 
在 fnally{}以外的地方释放锁可能会导致问题。 
⚫ 
改变静态的静态方法。 
4.7.3   参考 
• http://msdn2.microsoft.com/en-us/library/f857xew0(vs.71).aspx 
268 
4.8 缓冲区溢出 
缓冲区是为存储信息而留出的连续内存量。例如，如果一个程序必须记住某些东西，比
如你的购物车包含什么，或者在当前操作之前输入了什么数据，该信息就会存储在缓冲区的
内存中。像 C，C++(许多操作系统是用 C++写的)，Objective-C（非常高效），它们允许
代码直接访问进程内存(通过内存分配和指针)，并混合数据和控制信息(例如，在进程堆栈中)。
如果程序员使用缓冲区出错，并允许用户输入超出分配的内存，则用户输入可以覆盖程序控
制信息，并允许用户修改代码的执行。 
注意 Java，C#.NET、Python 和 Ruby 不容易受到缓冲区溢出的影响，因为它们使用
了将字符串存储在 char 数组中的方式，这些数组的边界由框架自动审计，并且它们不允许
程序员直接访问内存(虚拟机层处理内存)。因此，本节不适用于这些语言。但是请注意，在
这些语言中调用的本机代码(例如，汇编，C，C++)通过接口，如 JNI 或“不安全”的 C#
部分可能容易受到缓冲区溢出的影响。 
4.8.1 24.1 描述 
为了分配缓冲区，代码声明了一个特定大小的变量: 
char MyBuffer[100]；//足以容纳 100 个字符变量 
int MyintBuf[5]；//足以容纳 5 个整数 
Widget MyWidgetraray[17]；//足以容纳 17 个小部件对象 
由于没有自动边界审计，代码可以尝试在数组位置 23(不存在)添加一个小部件。当代
269 
码这样做时，编译器将计算第 23 个小部件应该放在内存中的什么位置(通过乘以 23×
Sizeof(小部件)，并将其添加到“myWidgetArray”指针的位置)。存在于该位置的任何其
他对象或程序控制变量/寄存器将被覆盖。 
数组、向量等，都是从 0 开始索引，这意味着容器中的第一个元素在“myBuffer[0]”
处，因此容器中的最后一个元素不在数组索引 100 处，而是在数组索引 99 处。当循环或编
程逻辑假设对象可以写入最后一个索引而不损坏内存时，这通常会导致错误和“逐个关闭”
错误。 
在 C 语言中，在 C++ STL 变得流行之前，字符串被保存为字符数组: 
char nameString[10]； 
这意味着“nameString”字符数组容易受到上述数组索引问题的影响，并且当使用许
多字符串操作函数(如 strcpy、strcat，稍后描述)时，写入超过第 10 个元素会导致缓冲区
溢出，从而导致内存损坏。 
 例如，一个程序可能想要记录一周中的几天。程序员告诉计算机为 7 个数字存储一个
空间。这是一个缓冲区的例子。但是如果试图添加执行第 8 个数字会如何？像 C 和 C++这
样的语言不执行边界审计，因此，如果程序是用这种语言编写的，第 8 条数据将覆盖内存
中下一个程序的程序空间，并导致数据损坏。这可能导致程序崩溃，更有甚者精心制作的溢
出可能导致恶意代码被执行，因为溢出覆盖的是实际代码。 
4.8.2  审计什么:缓冲区溢出 
示例： 
void copyData(char *userId) { 
270 
char smallBuffer[10]; // size of 10 
strcpy (smallBuffer, userId); 
} 
int main(int argc, char *argv[]) { 
char *userId = “01234567890”; // Payload of 12 when you include the ‘\n’ string termination 
// automatically added by the “01234567890” literal 
copyData (userId); // this shall cause a buffer overload 
} 
c 库函数，如 strcpy()，strcat()，sprintf()和 vsprintf()对空终止的字符串进行操作，
并执行无边界审计。get()是另一个函数，它从标准输入中读取输入(到缓冲区中)，直到找到
一个终止的换行符或文件结束符。scanf()函数家族也可能导致缓冲区溢出。 
使用 strncpy()，strncat()和 snprintf()函数允许传递第三个“长度”参数，该参数确定
将被复制的数据的最大长度进入目标缓冲区。如果这被正确设置为要写入的缓冲区的大小，
它将防止目标缓冲区溢出。还要注意 fgets()是 get()的替代。在将数组写入缓冲区之前，请
务必审计数组的边界。微软 C 运行库还提供了许多带有' _s '后缀的函数的附加版本(strcpy_s，
strcat_s，sprintf_s)。这些函数执行额外的错误条件审计，并在失败时调用错误处理程序。 
下面的 C 代码不容易出现缓冲区溢出，因为复制功能是由“strncpy”执行的，它指定
了要复制的字符数组长度的第三个参数 10。 
 示例： 
void copyData(char *userId) { 
char smallBuffer[10]; // size of 10 
strncpy(smallBuffer, userId, sizeof(smallBuffer)); // only copy first 10 elements 
smallBuffer[10] = 0; // Make sure it is terminated. 
} 
271 
int main(int argc, char *argv[]) { 
char *userId = “01234567890”; // Payload of 11 
copyData (userId); 
} 
现代的 C++ (C++11)程序可以访问许多 STL 对象和模板，这有助于防止安全漏洞。
std::string 对象不要求调用代码具有对基础指针的任何访问权限，而是自动扩展基础字符串
表示形式(堆上的字符缓冲区)，以适应正在执行的操作。因此，代码不能导致 std::string 对
象上的缓冲区溢出。 
关于指针(可以用其他方式导致溢出)，C++11 有智能指针，它再次消除了调用代码使
用底层指针的任何必要，当变量超出范围时，这些类型的指针会自动分配和销毁。这有助于
防止内存泄漏和双重删除错误。还有 STL 容器，比如 std::vector、std::list 等。所有的动态
分配他们的内存意味着正常使用不会导致缓冲区溢出。请注意，仍然可以访问原始指针下的
这些容器，或者重新解释_cast 对象，因此缓冲区溢出是可能的，但是它们更难引起。 
编译器也有助于解决内存问题，在现代编译器中有“stack canaries”，这是放在编译
代码中的微妙元素，用于审计越界内存访问。这些可以在编译代码时启用，也可以自动启用。
有许多这种 stack canaries 的例子，对于某些系统，stack canaries 的许多选择取决于组织
对安全性和性能的偏好。苹果也有针对 iOS 代码的 stack canaries，因为 Objective 也容
易出现缓冲区溢出。 
一般来说，有明显的代码示例，手动代码审计者可以发现潜在的溢出和逐个错误，但是
其他内存泄漏(或问题)可能更难发现。因此，手动代码审计应该由市场上可用的内存审计程
序来支持。 
272 
4.8.3 审计什么:格式化函数溢出 
格式函数是 ANSI C 规范中的一个函数，可用于将原始 C 数据类型定制为人类可读的形
式。几乎所有的 C 程序都使用它们来输出信息、打印错误信息或处理字符串。 
表:格式函数溢出 
字符串形式 
相关输入 
%x 
Hexadecimal values (unsigned int) 
%s 
Strings ((const) (unsigned) char*) 
%n 
Integer 
%d 
Decimal 
%u 
Unsigned decimal (unsigned int) 
这种情况下的%s 确保由参数“abc”指向的值被打印为一个字符数组。例如: 
char * myString = " abcprintf ("Hello: %s\n "，ABC)； 
通过向格式函数提供格式字符串，我们能够控制它的行为。因此，以格式字符串的形式
提供输入会让我们的应用程序做一些不该做的事情。我们到底能让应用程序做什么？ 
如果我们提供%x(十六进制无符号整数)作为输入，“printf”函数将期望找到一个与该
格式字符串相关的整数，但是没有参数存在。这在编译时无法检测到。这个问题在运行时会
浮出水面。 
273 
printf 函数发现参数中的每一个%都假定堆栈上有一个关联的值。这样，函数向下遍历
堆栈，从堆栈中读取相应的值，并将其打印给用户。 
使用格式字符串，我们可以通过使用格式字符串来执行一些无效的指针访问，例如: 
printf(" % s % s % s % s % s % s % s % s % s % s % s % s % s ")； 
更糟糕的是在“printf()”中使用了“%n”指令。该指令接受一个' int* '并将到目前为
止的字节数'写入'到该位置。 
在哪里可以找到这个潜在的漏洞。“printf()”函数家族、“printf()、fprintf()、sprintf()、
snprintf()普遍存在此问题。另外还有“syslog()”(写入系统日志信息)和 setprocetitle(const 
char * fmt，...)(设置用于显示过程标识符信息的字符串)。 
4.8.4 审计什么:整数溢出 
整数的数据表示将具有有限的空间，例如，许多语言中的缩写是 16 位二进制补码数，
这意味着它可以容纳最大值 32，767 和最小值-32，768。二进制补码代表(16 的)第一位是
正数还是负数的表示。如果第一位是“1”，那么它是一个负数。 
表 24 给出了一些边界数的表示。 
示例： 
数字 
展示 
32766 
0111111111111110 
274 
32767 
0111111111111111 
-32768 
1000000000000000 
-1 
1111111111111111 
号码  代表 
32,766                                                      
0111111111111110 
32,767                                                          
0111111111111111 
-32,768                                                         
1000000000000000 
-1                                                                  
1111111111111111 
如果你把 1 加到 32，766 上，它就把 1 加到表示上，给出上面显示的 32，767 的表示。
但是，如果您再次添加一个，它会设置第一个位(也称为，最高有效位)，然后被系统解释为
-32，768。 
275 
如果您有一个循环(或其他逻辑)在短时间内增加或计算值，那么应用程序可能会遇到这
种溢出。还要注意，减法里面低于-32，768 的值也意味着该数字将绕到高正值，这称为下
溢。 
示例： 
0x7fffffff 的二进制表示为 111111111111111111111111111111111111111；该整
数用有符号长整数可以容纳的最高正值初始化。 
这里，当我们将 1 加到十六进制值 0x7fffffff 上时，整数的值溢出并变成负数(0x 7 
fffff+1 = 80000000)。在十进制中，这是(-2147483648)。想想这可能造成的问题。编译
器不会检测到这一点，应用程序也不会注意到这个问题。 
当我们在比较或算术中使用有符号整数时，以及在比较有符号整数和无符号整数时，我
们会遇到这些问题。 
 示例： 
 int myArray[100]; 
int fillArray(int v1, int v2){ 
if(v2 > sizeof(myArray) / sizeof(int) -1 ){ 
return -1; /* Too Big */ 
} 
myArray [v2] = v1; 
return 0; 
} 
这里，这个条件审计 v2 是否大于数组大小，如果 v2 是一个巨大的负数，“如果”条
件将通过。 
276 
如果未执行边界审计，则“myArray[v2] = v1”行可能会将值 v1 赋给数组边界之外的
位置，从而导致意外结果。 
4.8.5 参考 
参见 OWASP 关于缓冲区溢出攻击的文章。 
关于如何测试缓冲区溢出漏洞，请参见《OWASP 测试指南》。 
参见阴极射线管中的安全增强:http://msdn 2 . Microsoft . com/en-us/library/8ef 
0s 5kh(vs . 80)。 