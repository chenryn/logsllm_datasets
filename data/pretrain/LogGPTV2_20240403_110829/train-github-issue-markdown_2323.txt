by **daniel.crettol** :
    package main
    import "fmt"
    type A struct {
        i int
    }
    func new1() *A {
        return &A{10}
    }
    func new2() *A {
        p := A{}
        p.i = 11
        return &p
    }
    func dummy(p *A) {
    }
    func new3() *A {
        p := A{}
        p.i = 12
        dummy(&p)
        return &p
    }
    func main() {
        a1 := new1()
        fmt.Printf("a1=%p %+v\n", a1, a1)
        a2 := new2()
        fmt.Printf("a2=%p %+v\n", a2, a2)
        a3 := new3()
        fmt.Printf("a3=%p %+v\n", a3, a3)
    }
    $ go build -gcflags '-N' bugtst.go && ./bugtst
    a1=0xc208000150 &{i:10}
    a2=0x7f31b606ddc0 &{i:11}
    a3=0xc2080001e0 &{i:12}
    $ go build -gcflags '' bugtst.go && ./bugtst
    a1=0xc208000150 &{i:10}
    a2=0xc2080001a8 &{i:11}
    a3=0xc2080001e8 &{i:12}
    $ go version
    go version go1.3.1 linux/amd64
    I had this pattern in a program and the struct generated by the new2 function was
    corrupted after returned.
    It seems to me that the compiler does not generate a copy of the structure when using
    the new2 function but does it when we call the new1 and new2 function.
    As the -N -L flags seems to be required to debug with gcc, it's really annoying.
    Happy debugging :)