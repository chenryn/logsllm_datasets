——————————
① 原意是“全球性的”。在计算机行业中指全局性的（变量，函数等）。其反义词是LOCAL（局部的）。
图灵社区会员 metorm 专享 尊重版权
10 实现HLT（harib00j） …… 63
“函数的处理到此结束，返回吧”，简洁明了。 1
在C语言里使用这个函数的方法非常简单。我们来看看bootpack.c。
2
本次的bootpack.c
/*告诉C编译器，有一个函数在别的文件里*/
3
void io_hlt(void);
/*是函数声明却不用{ }，而用;，这表示的意思是：函数是在别的文件中，你自己找一下吧！*/
3
void HariMain(void)
{
fin:
5
io_hlt(); /*执行naskfunc.nas里的_io_hlt*/
goto fin;
} 6
源程序里的注释写得很到位，请仔细阅读一下。
7
好了，源程序增加了，Makefile也进行了添加，那么赶紧运行“make run”看看吧。结果虽
然还是黑屏，但程序运行肯定是正常的。太好了，这就放心了。大家明天见！
8
9
10
11
12
13
14
15
16
图灵社区会员 metorm 专享 尊重版权
第 4 天
C语言与画面显示的练习
 用C语言实现内存写入（harib01a）
 条纹图案（harib01b）
 挑战指针（harib01c）
 指针应用（1）（harib01d）
 指针应用（2）（harib01e）
 色号设定（harib01f）
 绘制矩形（harib01g）
 今天的成果（harib01h）
11 用 C 语言实现内存写入（harib01a）
昨天我们成功地让画面显示黑屏了，但只做到这一步没什么意思，还是往画面上画点儿什么
东西比较有趣。想要画东西的话，只要往VRAM里写点什么就可以了。但是在C语言中又没有直
接写入指定内存地址的语句①。嗯，真是不方便。所以，我们干脆就创建一个有这种功能的函数。
下面就来修改一下naskfunc.nas。
naskfunc.nas里添加的部分
_write_mem8: ; void write_mem8(int addr, int data);
MOV ECX,[ESP+4] ; [ESP + 4]中存放的是地址，将其读入ECX
MOV AL,[ESP+8] ; [ESP + 8]中存放的是数据，将其读入AL
MOV [ECX],AL
RET
这个函数类似于C语言中的“write_mem8（0x1234,0x56）;”语句，动作上相当于“MOV
BYTE[0x1234],0x56”。顺便说一下，addr是address的缩写，在这里用它来表示地址。
■■■■■
在C语言中如果用到了write_mem8函数，就会跳转到_write_mem8。此时参数指定的数字就
——————————
① “怎么会？分明有啊！”如果你有这样的疑问，那么作为本书的读者，你已经知道得相当多了。
图灵社区会员 metorm 专享 尊重版权
1 用C语言实现内存写入（harib01a） …… 65
存放在内存里，分别是： 1
第一个数字的存放地址：[ESP + 4]
第二个数字的存放地址：[ESP + 8] 2
第三个数字的存放地址：[ESP + 12]
第四个数字的存放地址：[ESP + 16]
3
(以下略）
我们想取得用参数指定的数字0x1234或0x56的内容，就用MOV指令读入寄存器。因为CPU
4
已经是32位模式，所以我们积极使用32位寄存器。16位寄存器也不是不能用，但如果用了的话，
不只机器语言的字节数会增加，而且执行速度也会变慢，没什么好处。
4
在指定内存地址的地方，如果使用16位寄存器指定[CX]或[SP]之类的就会出错，但使用32位
寄存器，连[ECX]、[ESP]等都OK，基本上没有不能使用的寄存器。真方便。另外，在指定地址
6
时，不光可以指定寄存器，还可以使用往寄存器加一个常数，或者减一个常数的方式。另外说一
下，在16位模式下，也能使用这种方式指定，但那时候没有什么地方用得上，所以没有使用。
7
如果与C语言联合使用的话，有的寄存器能自由使用，有的寄存器不能自由使用，能自由使用
的只有EAX、ECX、EDX这3个。至于其他寄存器，只能使用其值，而不能改变其值。因为这些寄
存器在C语言编译后生成的机器语言中，用于记忆非常重要的值。因此这次我们只用EAX和ECX。 8
■■■■■
9
这次还给naskfunc.nas增加了一行，那就是INSTRSET指令。它是用来告诉nask“这个程序是
给486用的哦”，nask见了这一行之后就知道“哦，那见了EAX这个词，就解释成寄存器名”。如
10
果什么都不指定，它就会认为那是为8086这种非常古老的、而且只有16位寄存器的CPU而写的程
序，见了EAX这个词，会误解成标签（Label），或是常数。8086那时候写的程序中，曾偶尔使用
11
EAX来做标签，当时也没想到这个单词后来会成为寄存器名而不能再随便使用。
上面虽然写着486用，但并不是说会出现仅能在486中执行的机器语言，这只是单纯的词语解
12
释的问题。所以486用的模式下，如果只使用16位寄存器，也能成为在8086中亦可执行的机器语言。
“纸娃娃操作系统”也支持386，所以虽然这里指定的是486，但并不是386中就不能用。可能会有
人问，这里的386，486都是什么意思啊？我们来简单介绍一下电脑的CPU（英特尔系列）家谱。 13
8086→80186→286→386→486→Pentium→PentiumPro→PentiumII→PentiumIII→Pentium4→…
14
从上面的家谱来看，386已经是非常古老的CPU了。到286为止CPU是16位，而386以后CPU
是32位。
15
■■■■■
现在，汇编这部分已经准备好了，下面来修改C语言吧。这次我们导入了变量。
16
图灵社区会员 metorm 专享 尊重版权
66 …… 第4天：C语言与画面显示的练习
本次的bootpack.c内容
void io_hlt(void);
void write_mem8(int addr, int data);
void HariMain(void)
{
int i; /*变量声明：i是一个32位整数*/
for (i = 0xa0000; i <= 0xaffff; i++) {
write_mem8(i, 15); /* MOV BYTE [i],15 */
}
for (;;) {
io_hlt();
}
}
for 语句是初次登场它是循环语句，会循环执行花括号（{}）括起来的部分。圆括号（()）中
写的是循环执行的条件。共有3个条件，各个条件之间以分号（;）隔开，最初一个条件是初始值。
所以上文第一个for语句中，把0xa0000赋值给i。任何for语句的初始值设定语句总是要执行，这是
C语言的规定。
下一个部分“i <= 0xaffff”是循环条件。for语句会判断是否满足这个条件，如果不满足，就
跳出“{}”括起来的循环体部分。另外，这个部分在第一次执行时就要判断，所以，有时候循环
体部分有可能一次都得不到执行。不过这次的for语句中，最初的i值是0xa0000，满足条件，所以
循环体部分能够被执行。
最后一个部分是“i++”，这是“i = i+1; ”的省略形式，也就是i的值增加1。这个语句在循
环体执行完以后肯定要执行一次，然后判断循环条件。
只看文字说明不易于理解，我们写成代码形式来辅助说明。
for (A ; B ; C){D; } 与以下程序等价
A;
label:
if (B) {
D;
C;
goto label;
}
for语句的3个条件，全都可以省略。这种情况下，不做任何初值设定，循环条件永远成立，
“{}”内的循环体部分执行完以后，不做任何处理。也就是单纯的无限循环。我们在“io_hlt(); ”
处使用了这种循环。
■■■■■
图灵社区会员 metorm 专享 尊重版权
2 条纹图案（harib01b） …… 67
下一步是运行“make run ”还是“make install”呢？两个都可以，但不管执行哪个，画面都
1
不是黑屏，而是白屏。哦?这是怎么回事呢？因为VRAM全部都写入了15，意思是全部像素的颜
色都是第15种颜色，而第15种颜色碰巧是纯白，所以画面就成了白色。还是画面上有点什么变化
2
才好。
3
4
4
6
太好了，成功了！但看不出来……
最初做成的时候，还挺高兴的，但在写这本书的时候，才发觉这是一次失败。纯白的截图放
7
到书里还是一片白，什么都看不出来。
8
22 条纹图案（harib01b）
所以，为了在印成书后能看出效果，我们就显示成有条纹的图案吧。修改也很简单，只要稍 9
微改动一下bootpack.c就可以了。
10
for (i = 0xa0000; i <= 0xaffff; i++) {
write_mem8(i, i & 0x0f);
}
11
哪儿变了呢？是write_mem8那里。地址部分虽然和之前一样，但写入的值由15变成了 i &
0x0f 。
12
在这里&是“与”运算，是数学中没有的一种运算。很久以前，CPU就不仅能处理数值数据，
还能处理图形数据。在处理图形数据的时候，加减乘除这种数学上的计算功能几乎没什么用。因
13
为所处理的数据虽然是二进制数，但它们并不是作为数字来使用的，重点是0和1的排列方式，对
于图形来说，这种排列方式本身更重要。
14
那么对于图形数据应该进行什么样的运算呢？可以将某些特定的位变为1，某些特定的位变
为0，或者是反转①特定的位等，做这样的运算。
15
■■■■■
——————————
16
① 反转指让0变为1、1变为0的操作，形象地来说就好比照片的底片一样。
图灵社区会员 metorm 专享 尊重版权
68 …… 第4天：C语言与画面显示的练习
先来看看让特定位变成1的功能。这可以通过“或”（OR）运算来实现。
0100 OR 0010 → 0110
1010 OR 0010 → 1010
计算“A OR B”的时候，每一位分别计算，对于某一位，A和B的该位只要有一个是1，“或”
运算的结果，该位就是1。否则（A和B的该位都是0）结果就是0。也就是说，如果某个图像数据
放在变量i里，让i与0010进行或运算，1所在的那一位（从右往左第2位）就一定会变为1。对于其
他的位则没有任何影响。如果i的该位（从右往左第2位）原本就是1，则i不变。
下面说说让特定位变成0的功能。这可以通过“与”（AND）运算来实现。
0100 AND 1101 → 0100
1010 AND 1101 → 1000
计算“A AND B”的时候，也是每一位分别计算，对于某一位，A和B的该位都是1的时候，
“与”运算的结果，该位才是1，否则结果就是0。也就是说，如果某个图像数据放在变量i里，让
i与1101进行“与”运算，则0所在的那一位（从右往左第2位）就一定会变为0。如果i的该位（从
右往左第2位）原本就是0，则i不变。跟“或”运算不同，“与”运算中不想改变的部分要设为1，
想改为0的部分要设为0（也就是说，一个是i与0010进行“或”运算，一个是i与1101进行“与”
运算）。这一点需要我们注意。
最后我们来看让特定位反转的功能。这可以通过“异或”（XOR）运算来实现。
0100 XOR 0010 → 0110
1010 AND 0010 → 1000
计算“A XOR B”的时候，同样也是每一位分别计算，对于某一位，A和B该位的值如果不
相同，“异或”运算的结果，该位是1，否则就是0。也就是说，如果某个图像数据放在变量i里，
让i与0010进行“异或”运算，就可以对该位进行反转，而别的位不受影响。如果i与所有位都是1
（即0xffffffff）的数进行“异或”，则全部位都反转。
■■■■■
这次我们用的是“与”（AND）运算。将地址值与0x0f进行“与”运算会怎么样呢？低4位
原封保留，而高4位全部都变成0。所以，写入的值是：
00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00 01 02 03 04 05 06 …
就像这样，每隔16个像素，色号就反复一次。会出现什么效果呢？运行一下“make run”就
知道了。
出现了下面这种条纹图案。
印成书之后也能看得很清楚，成功啦！
图灵社区会员 metorm 专享 尊重版权
3 挑战指针（harib01c） …… 69
1
2
3
4
33 挑战指针（harib01c）
4
前面说过“C语言中没有直接写入指定内存地址的语句”，实际上这不是C语言的缺陷，因
为有替代这种命令的语句。一般大多数程序员主要使用那种替代语句，像这次这样，做一个函数 6
write_mem8的，也就只有笔者了。如果有替代方案的话，大家肯定想用一下，笔者也想试试看。
write_mem3(i, i & 0x0f）； 7
替代以上语句的是：
8
*i = i & 0x0f;
两个语句有点像，但又不尽相同。不管那么多了，先换成后面一种写法看看吧。好了，改完
9
了，用“make run”命令运行一下。唉？奇怪，怎么会出错呢？
invalid type argument of ｀unary *'
10
类型错误？
■■■■■ 11
没错，就是类型错误。这种写法，从本质上讲没问题，但这样就是无法顺利运行。我们从编
译器的角度稍微想想就能明白为什么会出错了。回想一下，如果写以下汇编语句，会发生什么情 12
况呢？
MOV [ 0x1234], 0x56 13
是的，会出错。这是因为指定内存时，不知道到底是BYTE，还是WORD，还是DWORD。
只有在另一方也是寄存器的时候才能省略，其他情况都不能省略。 14
其实C编译器也面临着同样的问题。这次，我们费劲写了一条C语句，它的编译结果相当于
下面的汇编语句所生成的机器语言， 15