System call invocations
Taint propagations
(cid:258)
Logs
Multi-layer
Monitoring
Information-
Flow
Tracking
Path
Exploration
Malton
Cross-layer execution paths
Cross-layer data flows
Implementation features
Comprehensive 
Behaviors
Figure 1: The scenario of Malton.
3.1 Overview
Malton helps security analysts obtain a complete view
of malware samples under examination. To achieve this
goal, Malton supports three major functionalities. First,
due to the multi-layer nature of Android system, Malton
can capture malware behaviors at different layers. For
instance, malware may conduct malicious activities by
USENIX Association
26th USENIX Security Symposium    291
invoking native code from Java methods, and such be-
haviors involve method invocations and data transmis-
sion at multiple layers. The challenging issue is how to
effectively bridge the semantic gap when monitoring the
ARM instructions.
Second, malware could leak private information by
passing the data across multiple layers back and forth.
Note that many framework APIs are JNI methods (e.g.,
String.concat(), String.toCharArray(), etc.), whose real
implementations are in native code. Malton can detect
such privacy leakage because it supports cross-layer in-
formation ﬂow tracking (Section 3.5).
Third, since malware may conduct diverse malicious
activities according to different commands and contexts,
Malton can trigger these activities by exploring the paths
automatically (Section 3.6). It is non-trivial to achieve
this goal because dynamic analysis systems usually have
limited code coverage.
Figure 1 illustrates a use scenario of Malton. Malton
runs in real Android devices and conducts multi-layer
monitoring, information ﬂow tracking, and path explor-
ing. After running a malware sample, Malton generates
logs containing the information of method invocations
and taint propagations at different layers and the result
of concolic executions. Based on the logs, we can recon-
struct the execution paths and the information ﬂows for
characterizing malware behaviors.
Though Malton performs the analysis in multiple lay-
ers as shown in Figure 2, the implementation of Malton
in each layer is not independent. Instead, different layers
share the information with each other. For example, the
taint propagation module in the instruction layer needs
the information about the Java methods that are parsed
and processed in the framework layer.
Malton is built upon Valgrind [53] (V3.11.0) with
around 25k lines of C/C++ codes calculated by CLOC [1].
Next, we will detail the implementation at each layer.
3.2 Android Framework Layer
To monitor the invocations of privacy-concerned Java
methods of the Android framework and the app itself,
Malton instruments the native code of the framework and
the app. Since the Dalvik code has been compiled into
native instructions, we leverage Valgrind for the instru-
mentation. The challenge here is how to recover and un-
derstand the semantic information of Java methods from
the ARM instructions, including the method name, pa-
rameters, call stacks, etc. For instance, if a malware sam-
ple uses the Android framework API to retrieve user con-
tacts, Malton should capture this behavior from the ARM
instructions and recover the context of the API invoca-
tion. To address this challenge, we propose an efﬁcient
way to bridge the semantic gaps between the low level
Android Application (APK)
Android Framework Layer
Oat file parser
Java method tracker
Java object parser
Android Runtime (ART) Layer
JNI reflection
Java reflection
JNI invocation
Dynamic native code loading
Dynamic Java code loading 
System Layer
Network operation monitor
File operation monitor
Memory operation monitor
Process operation monitor
M
a
l
t
o
n
Instruction Layer
In-memory concolic execution
Taint propagation
Direct execution
Smartphone
Figure 2: The overview of Malton.
native instructions and upper layer Java methods.
Java Method Tracker To track the Java method invoca-
tions, we need to identify the entry point and exit points
of each Java method from the ARM instructions dynam-
ically. Note that the ARM instructions resulted from the
Dalvik bytecode are further translated into multiple IR
blocks by Malton. An IR block is a collection of IR state-
ments with one entry point and multiple exit points. One
exit point of an IR block could be either the condition-
al exit statement (i.e., Ist Exit) or the next statement
(i.e., Ist Next). We leverage the APIs from Valgrind
to add instrumentation at the beginning, before any IR
instruction, after any IR instruction, or at the end of the
selected IR block. The instrumentation statements will
invoke our helper functions.
To obtain the entry point of a Java method, we use
the method information in the OAT ﬁle. Speciﬁcally, the
OAT ﬁle contains the information of each compiled Java
method (ArtMethod), including the method name, off-
set of the ARM instructions, access ﬂags, etc. Malton
parses the OAT ﬁles of both the Android framework and
the app itself to retrieve such information, and keeps it
in a hash table. When the native code is translated into
the IR blocks, Malton looks up the beginning address of
each IR block in the hash table to decide whether it is the
entry of a Java method. If so, Malton inserts the helper
function (i.e., callTrack()) at the beginning of the block to
record the method invocation and parse arguments when
it is executed.
To identify the exit point of a Java method, Malton
leverages the method calling convention of the ARM ar-
chitecture2. Speciﬁcally, the return address of a method
is stored in the link register (i.e., the lr register) when the
method is invoked. Hence, in callTrack(), Malton pushes
2Comments in ﬁle /art/compiler/dex/quick/arm/arm lir.h
292    26th USENIX Security Symposium
USENIX Association
Register r0
StringObject
object_.klass_
object_.monitor_
count_
hash_code_
value_: 
"6534900622308366"
Instance of Java class 
java.lang.String
ClassObject
(of java.lang.String)
object_.klass_
object_.monitor_
.....
name_("java.lang.String")
.....
Class object representing type
java.lang.String
Figure 3: The example of parsing the Java object of the
result of TelephonyManager.getDeviceId()
the value of lr into the method call stack since lr could
be changed during the execution of the method. Malton
also inserts the helper function (i.e., retTrack()) before
each exit point (i.e., Ist Exit and Ist Next) of the
IR block. In retTrack(), Malton compares the jump target
of the IR block with the method’s return address stored
at the top of the method call stack. If they are equal, an
exit point of the method is found, and this return address
is popped from the method call stack.
the
instance
of
is
invoked,
ArtMethod
the method after
Malton parses the arguments and the return val-
ue of
the entry point and the
exits point of the method are identiﬁed, respective-
ly.
According to the method calling convention,
the register r0 points to the ArtMethod object of
current method, and registers r1 − r3 contain the
three arguments. Other arguments beyond the
ﬁrst
three words are pushed into the stack by the
ﬁrst
caller.
For example, when the framework method
sendMessageAtTime(Message msg, long uptimeMillis)
of class android/os/Handler
r0 points
the method
to
sendMessageAtTime(),
r1 stores the this object and
r2 represents the argument msg.
For the argument
uptimeMillis, the high 32 bits are stored in the register
r3 and the low 32 bits are pushed into the stack. When
the method returns, the return value is stored in the
register r0 if the return value is 32 bits, and in registers
r0 and r1 if the return value is 64 bits.
Java Object Parser After getting the method arguments
and the return value, we need to further parse the value
if it is not the primitive data. There are two major data
types [42] in Java, including primitive data types and ref-
erence/object data types (objects). For the primitive type-
s, which include byte, char, short, int, long, ﬂoat, double
and boolean, we can directly get the value from registers
and the stack. For the object, the value that we obtain
from the register or the stack is a pointer that points to a
data structure containing the detailed information of this
object. Following this pointer, we get the class informa-
tion of this object, and then parse the memory of this
object to determine the concrete value.
Figure 3 illustrates the process of parsing the Java ob-
ject of the result of TelephonyManager.getDeviceId(). Ac-
cording to its method shorty, we know that the return val-
ue of this API is a Java object represented by an Object
instance, of which the memory address is stored in the
register r0. Then, we can decide that the concrete type
of this object is java.lang.String. By parsing the results
according to the memory layout of String object, which
is represented by the StringObject data structure, we can
obtain the concrete string “6534900622308366”. Current-
ly, Malton can parse the Java objects related to String and
Array. To handle new objects, users just need to imple-
ment the corresponding parsers for Malton.
3.3 Android Runtime Layer
To capture stealthy behaviors that cannot be monitored
by the Java method tracker in the Android framework
layer, Malton further instruments the ART runtime (i.e.,
libart.so). For example, the packed malware may use
the internal functions of the ART runtime to load and
execute the decrypted bytecode directly from the memo-
ry [85,88]. Malicious payloads could also be implement-
ed in native code, and then invoke the privacy-concerned
Java methods from native code through the JNI reﬂection
mechanism. While the invoked Java method could be
tracked by the Java method tracker in the Android frame-
work layer, Malton tracks the JNI reﬂection to provide
a comprehensive view of malicious behaviors, such as,
the context when privacy-concerned Java methods are in-
voked from the native code. This is one advantage of
Malton over other tools.
Table 1: Runtime behaviors related functions.
Behavior
Native code loading
Java code loading
JNI invocation
JNI reﬂection
Java reﬂection
Functions
JavaVMExt::LoadNativeLibrary()
DexFile::DexFile()
DexFile::OpenMemory()
ClassLinker::DeﬁneClass()
artFindNativeMethod()
ArtMehod::invoke()
InvokeWithVarArgs()
InvokeWithJValues()
InvokeVirtualOrInterfaceWithJValues()
InvokeVirtualOrInterfaceWithVarArgs()
InvokeMethod()
Table 1 enumerates the runtime behaviors and the cor-
responding functions in the ART runtime that Malton in-
struments. Native code loading means that malicious
code could be implemented in native code and loaded in-
to memory, where Java code loading refers to loading the
Dalvik bytecode. Note that Android packers usually ex-
ploit these APIs to directly load the decrypted bytecode
from memory. JNI invocation refers to all the function
calls from Java methods to native methods. This includes
USENIX Association
26th USENIX Security Symposium    293
the JNI calls in the app and the Android framework. JNI
reﬂection, on the other hand, refers to calling Java meth-
ods from native code. For instance, malicious payload-
s implemented in native code could invoke framework
APIs using JNI reﬂection. Java reﬂection is commonly
used by malware to modify the runtime behavior for e-
vading the static analysis [61]. For example, framework
APIs could be invoked by decrypting the method names
and class names at runtime using Java reﬂection.
3.4 System Layer
Malton tracks system calls and system library functions
at the system layer. To track system calls, Malton reg-
isters callback handlers before and after the system cal-
l invocation through Valgrind APIs. For system library
functions, Malton wraps them using the function wrapper
mechanism of Valgrind. In the current prototype, Malton
focuses on four types of behaviors at the system lever.
• Network operations. Since malware usually receives
the control commands and sends private data through
network, Malton inspects these behaviors by wrapping
network related system calls, such as, sys connect(),
sys sendto(), recvfrom(), etc.
• File operations. As malware often accesses sensitive
information in ﬁles and/or dynamically loads mali-
cious payloads from the ﬁle system, Malton records
ﬁle operations to identify such behaviors.
• Memory operations. Since packed malware usually
dynamically modiﬁes its own codes through memory
operations, like sys mmap(), sys protect(), etc., Malton
monitors such memory operations.
• Process operations. As malware often needs to fork
new process, or exits when the emulator or the debug
environment is detected, Malton captures such behav-
iors by monitoring system calls relevant to the process
operations, including sys execve(), sys exit(), etc.
Moreover, Malton may need to modify the arguments
and/or the return values of system calls to explore code
paths. For example, the C&C server may have been shut
down when malware samples are being analyzed.
In
this case, Malton replaces the results of the system call
sys connect() to success, or replaces the address of C&C
with a bogus one controlled by the analyst to trigger ma-
licious payloads. We will discuss the techniques used to
explore code paths in Section 3.6.
3.5
Instruction Layer: Taint Propagation
At the instruction layer, Malton performs two major
tasks, namely, taint propagation and path exploration.
Note that accomplishing these tasks needs the semantic
Table 2: The taint propagation related IR Statements.
IR Statement
Ist WrTmp
Ist LoadG
Ist CAS
Ist LLSC
Ist Put
Ist PutI
Representation
Assign a value (i.e., IR Expression) to a temporary.
Load a value to a temporary with guard.
Do an atomic compare-and-swap operation.
Do an either load-linked or store-conditional operation.
Write a value to a guest register.
Write a value to a guest register at a non-ﬁxed
offset in the guest state.