# Run in NodeJS    > eval(`{      1;      2;      ; // empty      x:break x; // empty    }`)    2在这个例子中的后面两行语句都返回`empty`，因此不覆盖既有的值，所以整个语句块的执行结果是`2`。又例如：    
# Run in NodeJS    > eval(`{      ; // empty      1;      ; // empty    }`)    1在这个例子中第 1行代码执行结果返回`empty`，于是第 2行的结果值`1`覆盖了它；而第 3行的结果值仍然是`empty`所以不导致覆盖，因此整个语句的返回值将是1。 >  > NOTE: 参见 13.2.13 Block -\> RS:> Evaluation> > , 以及 15.2.1.23 Module -\> RS: Evaluation 中，对> >> **UpdateEmpty**> > (s, sl)> 的使用。> >而上述的规则 2，就比较复杂一些了。这出现在if、do...while、while、for/for...in/for...of、with、switch 和 try语句块中。在 ECMAScript 6 之后，这些语句约定不会返回empty，因此它的执行结果"至少会返回一个 undefined值"，而在此之前，它们的执行结果是不确定的，既可能返回 undefined值，也可能返回empty，并导致上一行语句值不覆盖。举例来说：    
# Run in NodeJS 5.10+ (or NodeJS 4)    > eval(`{      2;      if (true);    }`)    undefined由于 ES6 约定`if`语句不返回`empty`，所以第 1行返回的值`2`将被覆盖，最终显示为`undefined`。而在此之前（例如 NodeJS4），它将返回值`2`;>  > NOTE: 参考阅读> > [《前端要给力之：语句在 JavaScript> 中的值》> >  slate-object="inline"> 。> > >由此一来，ECMAScript 规范约定了 JavaScript中所有语句的执行结果值的可能范围：`empty`，或一个既有的执行结果值（包括undefined）。引用的值现在还存在最后一个问题：所谓"引用"，算是什么值？回顾第一讲的内容：表达式的本质是求值运算，而引用是不能直接作为最终求值的操作数的。因此引用实际上不能作为语句结果来返回，并且它在表达式计算中也仅是作为中间操作数（而非表达最终值的操作数）。所以在语句返回值的处理中，总是存在一个"执行表达式并'取值'"的操作，以便确保不会有"引用"类型的数据作为语句的最终结果。而这，也就是在ECMAScript 规中的`throw 1`语句的第二行代码的由来：>  > 2.>> **Let**> >  exprValue be ?> GetValue(exprRef).> > >事实上在这里的符号"?opName()"语法也是一个简写，在 ECMAScript 中它表示一个ReturnIfAbrupt(x)的语义：如果设一个"处理（opName()）"的结果是x，那么， >  > 如果 x 是特殊的（非 normal 类型的）完成记录，则返回> x；否则返回一个以 x.\[\[value\]\] 为值的、normal> 类型的完成记录。> > >简而言之，就是在 GetValue()这个操作外面再封装一次异常处理。这往往是很有效的，例如：    throw 1/0;那么 exprRef作为表达式的计算结果，其本身就将是一个异常，于是`? GetValue(exprRef)`就可以返回这个异常对象（而不是异常的值）本身了。类似的，所谓"表达式语句"（这是排在"最简单语句榜"的第二名的语句）就直接返回这个值：>  > ExpressionStatement> > :> > Expression> > ;> > >>>  > 1.>> **Let**> >  exprRef be the result of evaluating> Expression.> > >>>  > 2.>> **Return**> >  ?> GetValue(exprRef).> > >还有一行代码现在还有一行代码，也就是第一行的"**let**... result of evaluating... "。其中的"resultof evaluating..."基本上算是 ECMAScript中一个约定俗成的写法。不管是执行语句还是表达式，都是如此。这意味着引擎需要按之前我讲述过的那些执行逻辑来处理对应的代码块、表达式或值（操作数），然后将结果作为Result 返回。ECMAScript所描述的引擎，能够理解"执行一行语句"与"执行一个表达式"的不同，并且由此决定它们返回的是一个"引用记录"还是"完成记录"（规范类型）。当外层的处理逻辑发现是一个引用时，会再根据当前逻辑的需要将"引用"理解为左操作数（取引用）或右操作数（取值）；否则当它是一个完成记录时，就尝试检测它的类型，也就是语句的完成状态（throw、return、normal或其他）。 所以，throw 语句也好，return语句也罢，所有的语句与它"外部的代码块（或`Parse Tree`中的父级结点）"间其实都是通过这个**完成状态**来通讯的。而外部代码块是否处理这个状态，则是由外部代码自己来决定的。而几乎所有的外部代码块在执行一个语句（或表达式）时，都会采用上述的ReturnIfAbrupt(x) 逻辑来封装，也就是说，如果是normal，则继续处理；否则将该完成状态原样返回，交由外部的、其他的代码来处理。所以，就有了下面这样一些语法设计：1.       循环语句用于处理非标签化的 continue 与 break，并处理为    normal；否则，        2.       标签语句用于拦截那些"向外层返回"的 continue 和    break；且，如果能处理（例如是目标标签），则替换成    normal。        3.       函数的内部过程        `[[Call]]`，将检查"函数体执行"（将作为一个块语句执行）所返回状态是否是    return 类型，如果是，则替换成    normal。        于是，显而易见的，所有语句行执行结果状态要么是normal，要么就是还未被拦截的 throw类型的语句完成状态。try 语句用于处理那些漏网之鱼（throw 状态）：在 catch 块中替换成normal，以表示 try 语句正常完成；或在 finally中不做任何处理，以继续维持既有的完成状态，也就是throw。 值 1最后，本小节标题中的代码中只剩下了一个值`1`，在实际使用中，它既可以是一个其他表达式的执行结果，也可以是一个用户定义或创建的对象。无论如何，只要它是一个JavaScript 可以处理的结果Result（引用或值），那么它就可以通过内部运算`GetValue()`来得到一个真实数据，并放在一个 throw类型的完成记录中，通过一层一层的`Parse Tree/Nodes`中的`ReturnIfAbrupt(x)`向上传递，直到有一个 try块捕获它。例如：    try {      throw 1;    catch(e) {      console.log(e);  // 1    }或者，它也可能溢出到代码的最顶层，成为根级`Parse Node`，也就是`Script`或`Module`类型的全局块的返回值。这时，引擎或 Shell程序就会得到它，于是......你的程序挂了。知识回顾在最近几讲，我讲的内容从语句执行到函数执行，从引用类型到完成类型，从循环到迭代，基本上已经完成了关于JavaScript 执行过程的全部介绍。当然，这些都是在串行环境中发生的事情，至于并行环境下的执行过程，在专栏的后续文章中我还会再讲给你。作为一个概述，建议你回顾一下本专栏之前所讲的内容。包括（但不限于）：1.       引用类型与值类型在 ECMAScript 和 JavaScript    中的不同含义；        2.       基本逻辑（顺序、分支与循环）在语句执行和函数执行中的不同实现；        3.       流程控制逻辑（中断、跳转和异步等）的实现方法，以及它们的要素，例如循环控制变量；        4.       JavaScript    执行语句和函数的过程，引擎层面从装载到执行完整流程；        5.       理解语法解析让物理代码到标记（Token）、标识符、语句、表达式等抽象元素的过程；        6.       明确上述抽象元素的静态含义与动态含义之间的不同，明确语法元素与语义组件的实例化。        综合来看，JavaScript 语言是面向程序员开发来使用的，是面子上的活儿，而ECMAScript 既是规范也是实现，是藏在引擎底下的事情。ECMAScript约定了一整套的框架、类型与体系化的术语，根本上就是为了严谨地叙述JavaScript的实现。并且，它提供了大量的语法或语义组件，用以规范和实现将来的JavaScript。直到现在，我向你的讲述的内容，在 ECMAScript中大概也是十不过一。这些内容主要还是在刻画 ECMAScript规范的梗概，以及它的核心逻辑。从下一讲开始，我将向你正式地介绍 JavaScript最重要的语言特性，也就是它的面向对象系统。当然，一如本专栏之前的风格，我不会向你介绍类型 x.toString()这样的、可以在手册上查阅的内容，我的本意，在于与你一起学习和分析：JavaScript是怎样的一门语言，以及它为什么是这样的一种语言。
# 12 \| 1 in 1..constructor：这行代码的结果值，既可能是true，也可能是false你好，我是周爱民。欢迎你回到我的专栏。 如果你听过上一讲，那么你应该知道，接下来我要与你聊的是 JavaScript的**面向对象系统**。 最早期的 JavaScript 只有一个非常非常弱的对象系统。我用过 JavaScript1.0，甚至可能还是最早尝试用它在浏览器中写代码的一批程序员，我也寻找和收集过早期的CEniv 和 ScriptEase，只为了探究它最早的语言特性与 JavaScript之间的相似之处。 然而，不得不说的是，曾经的 JavaScript在**面向对象**特性方面，在语法上更像Java，而在实现上却是谁也不像。 JavaScript 1.0\~1.3 中的对象在 JavaScript 1.0 的时候，对象是不支持继承的。那时的 JavaScript使用的是称为"**类抄写**"的技术来创建对象，例如：     function Car() {      this.name = "Car";      this.color = "Red";    }    var x = new Car();关于类抄写以及与此相关的性质，我会在后续的内容中详细讲述。现在，你在这里需要留意的是：在"Car()"这个函数中，事实上该函数是以"类"的身份来声明了一系列的属性（Property）。正是因此，使用`new Car()`来创建的"类的实例"（也就是对象`this`）也就具有了这些属性。 这样的"类 -\> 对象"的模型其实是很简单和粗糙的。但 JavaScript 1.0时代的**对象**就是如此，并且，重要的是，事实上直到现在 JavaScript的对象仍然如此。ECMAScript规范明确定义了这样的一个概念： 对象是零到多个的属性的集合。 >  > In ECMAScript, an> > object> > is a collection of zero or> more>> properties> > .> > >你可能还注意到了，JavaScript 1.0的对象系统是有类的，并且在语义上也是"对象创建自类"。这使得它在表面上"看起来"还是有一些继承性的。例如，一个对象必然继承了它的类所声明的那些性质，也就是"属性"。但是因为这个1.0 版存在的时间很短，所以后来大多数人都不记得JavaScript"**有类，而又不支持类的继承**"这件事情，从而将从 JavaScript 1.1才开始具有的**原型继承**作为它最主要的面向对象特征。 在这个阶段，JavaScript中有关全局环境和全局变量的设计也已经成熟了，简单地来说，就是： 1.       向没有声明的变量名赋值，会隐式地创建一个全局变量；        2.       全局变量会被绑定为全局对象（global）的属性    。    这样一来，JavaScript的变量环境（或者全局环境）与对象系统就关联了起来。而接下来，由于JavaScript也实现了带有闭包性质的函数，因此"闭包"也成了环境的管理组件。也就是说，闭包与对象都具有实现变量环境的能力。 因此，在这个阶段，JavaScript提出了"**对象闭包**"与"**函数闭包**"两个概念，并把它们用来实现的环境称为"**域**（Scope）"。这些概念和语言特性，一直支持 JavaScript 走到1.3 版本，并随着 ECMAScript ed3确定了下来。 在这个时代，JavaScript语言的设计与发展还基本是以它的发明者布兰登·艾奇（BrendanEich）为主导的，JavaScript的语言特性也处于一个较小的集合中，并且它的应用也主要是以浏览器客户端为主。这时代的JavaScript深得早期设计与语言定义的精髓。这些东西，你可以从后来布兰登·艾奇的一个开源项目中读到。这个项目称为Narcissus，是用 JavaScript 来实现的一个完整的 JavaScript1.3。在这个项目中，对象和函数所创建的闭包都统一由一个简单的对象表示，称为scope。例如：     scope = {      object: ,      parent:     }因此，所谓"**使用 with语句创建一个对象闭包**"就简单地被实现为：     // code from $(narcissus)/src/jsexec.js    ...    // 向 x 所代表的 scope-chain 表尾加入一个新的 scope    x.scope = {object: t, parent: x.scope};    try {      // n.body 是 with 语句中执行的语句块      execute(n.body, x); // 指在该闭包（链）`x`中执行上述语句    }    finally {      x.scope = x.scope.parent;  // 移除链尾的一个 scope    }可见 JavaScript 1.3时代的执行环境，其实就是一个闭包链的管理。而且这种闭包既可以是对象的，也可以是函数的。尽管在静态语法说明或描述时，它们被称为**作用域**或**域**（Scope），或者在动态环境中它们被称为**上下文**（Context），但在本质上，它们是同样的一堆东西。 综合来看，JavaScript中的对象本质上是**属性集**，这可以视为一个**键值列表**，而对象继承是由这样的列表构成的、称为原型的链。另一方面，执行的上下文就是函数或全局的变量表，这同样可以表达为一个键值列表，而执行环境也可以视为一个由该键值列表构成的链。 于是，在 JavaScript 1.3，以及 ECMAScript ed3的整个时代，这门语言仅仅依赖**键值列表**和**基于它们的链**实现并完善了它最初的设计。 属性访问与可见性但是从一开始，JavaScript就有一个东西没有说清楚，那就是属性名的可见性。 这种可见性在 OOP（面向对象编程）中有专门的、明确的说法，但在早期的JavaScript中，它可以简单地理解为"**一个属性是否能用 for...in语句列举出来**"。如果它可以被列举，那么就是可见的，否则就称为隐藏的。 你知道，任何对象都有"constructor"这个属性，缺省指向创建它的构造器函数，并且它应当是隐藏的属性。但是在早期的JavaScript 中，这个属性如何隐藏，却是没有规范来约定的。例如在 JScript中，它就是一个特殊名字，只要是这个名字，就隐藏；而在 SpiderMonkey中，当用户重写这个属性后，它就变成了可见的。 后来 ECMAScript就约定了所谓的"**属性的性质**（attributes）"这样的东西，也就是我们现在知道的**可写性**、**可列举性**（可见性）和**可配置性**。ECMAScript约定： 1.  "constructor"缺省是一个不可列举的属性；        2.  使用赋值表达式添加属性时，属性的可列举性缺省为        `true`。        这样一来，"constructor"在可见性（这里是指可列举性）上的行为就变得可预期了。类似于此的，ECMAScript约定了读写属性的方法，以及在属性中访问、操作性质的全部规则，并统一使用所谓"属性描述符"来管理这些规则。于是，这使得ECMAScript 规范进入了 5.x 时代。相较于早期的 3.x，这个版本的 ECMAScript规范并没有太多的改变，只是从语言概念层面上实现了"大一统"，所有浏览器厂商，以及引擎的开发者都遵循了这些规则，为后续的JavaScript 大爆发------ECMAScript 6的发布铺平了道路。到目前为止，JavaScript 中的对象仍然是简单的、原始的、使用 JavaScript1.x时代的基础设计的原型继承。而每一个对象，仍然都只是简简单单的一个所谓的"**属性包**"。从原型中继承来的属性对于绝大多数对象来说，"constructor"是从它的原型继承来的一个属性，这有别于它"自有的（Own）"属性。在原型继承中，在子类实例重写属性时，实际发生的行为是"**在子类实例的自有属性表中添加一个新项**"。这并不改变原型中相同属性名的值，但子类实例中的**属性性质**以及**值**覆盖了原型中的。这是原型继承------几乎是公开的------所有的秘密所在。在使用原型继承来的属性时，有两种可能的行为，这取决于属性的具体性质------属性描述符的类型。1.       如果是        **数据描述符**        （d），那么        `d.value`总是指向这个数据的值本身；        2.       如果是        **存取描述符**        ，那么        `d.get()`和        `d.set()`将分别指向属性的存取方法。        并且，如果是存取描述符，那么存取方法（get/setter）并不一定关联到数据，也并不一定是数据的置值或取值。某些情况下，存取方法可能会用作特殊的用途，例如模拟在VBScript中常常出现的"无括号的方法调用"。例如：    excel = Object.defineProperty(new Object, 'Exit', {      get() {        process.exit();      }    });    // 类似 JScript/VBScript 中的 ActiveObject 组件的调用方法    excel.Exit;当用户不使用属性赋值或`defineProperty()`等方法来添加自有的属性时，属性访问会（默认地）上溯原型链直到找到指定属性。这一定程度上成就了"包装类"这一特殊的语言特性。所谓"**包装类**"是 JavaScript 从 Java借鉴来的特性之一，它使得用户代码可以用标准的面向对象方法来访问普通的值类型数据。于是，所谓"一切都是对象"就在眨眼间变成了现实。例如，下面这个示例中使用的字符串常量x：     x = "abc";    console.log(x.toString());当在使用 x.toString() 时，JavaScript会自动将"值类型的字符串（"abc"）"通过包装类变成一个字符串对象。这类似于执行下面的代码：    console.log(Object(x).toString());这个包装的过程发生于**函数调用运算"()"**的处理过程中，或者将"x.toString"作为整体来处理的过程中。也就是说，仅仅是"对象属性存取"这个行为本身，并不会触发一个普通"值类型数据"向它的包装类型转换。除了`Undefined`，基本类型中的所有值类型数据都有自己的包装类，包括符号，又或者布尔值。这使得这些值类型的数据也可以具有与之对应的包装类的原型属性或方法。这些属性与方法自己引用自原型，而不是自有数据。很显然的，值类型数据本身并不是对象，因此也不可能拥有自有的属性表。字面量与标识符通常情况下，开发人员会将标识符直接称为**名字**（在 ECMAScript规范中，它的全称是"标识符名字（IdentifierName）"），而**字面量**是一个数据的文本表示。显然，通常标识符就用作后者的名字标识。对于这两种东西，在ECMAScript中的处理机制并不太一样，并且在文本解析阶段就会把二者区分开来。例如：    // var x = 1;    1;    x;其中"1"是字面量值，JavaScript 会直接处理它；而 x是一个标识符，就需要建立一个"引用"来处理了。但是接下来，如果是代码（假设下面的代码是成立的）：    1.toString那么它作为"整体"就需要被创建为一个引用，以作为后续计算的操作数（取成员值，或仅是引用该成员）。是的，就它们同是"引用"这一事实而言，"1.toString"与"x"在引擎级别有些类似。然而在数字字面量中，"1.xxxxx"这样的语法是有含义的。它是浮点数的表示法。所以"1.toString"这样的语法在JavaScript中会报错，这个错误来自于浮点数的字面量解析过程，而不是"`.`作为存取运算符"的处理过程。在 JavaScript中，浮点数的小位数是可以为空的，因此"1."和"1.0"将作为相同的浮点数被解析出来。既然"1."表示的是浮点数，那么"1...constructor"表示的就是该浮点数字面量的".constructor"属性。现在我想你已经看出来了，标题中的：    1 in 1..constructor其实是一个表达式。在语义上，它与如下的表达式是等义的：    