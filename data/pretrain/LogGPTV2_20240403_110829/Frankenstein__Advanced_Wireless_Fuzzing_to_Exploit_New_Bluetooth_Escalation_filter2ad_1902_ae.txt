In Bluetooth 4.2 the maximum PDU length was extended
from 20 B to 255 B. A PDU is stored in a special purpose
BLOC pool with a buffer size of 264 B, as shown in Figure 9.
Besides the PDU payload, the buffer also contains 12 B for
headers. Therefore, the buffer is 3 B too small to hold the
maximum total PDU length of 255 B. These 3 B are part of
the pointer to the next free BLOC buffer, as previously depicted
in Figure 6.
However, the fourth overﬂowing byte is determined by the
Cyclic Redundancy Check (CRC) and also copied. It is stored
in the receive buffer, despite previously being validated in
hardware. An attacker has to adapt the payload, including the
Device
Chip
< Bluetooth 4.2 —
BCM4345C0
BCM4347B0
CYW20719B1
CYW20735B1
BCM4375B1
CYW20819A1
Raspberry Pi 3+/4
Samsung Galaxy S8
Evaluation Board
Evaluation Board
Samsung Galaxy S10e/S10/S10+
Evaluation Board
BLOC
Packet
264 B
Buffer
Packet Data Unit (PDU)
12 B
252 B
Build Date
< 2014
Aug 19 2014
Jun 3 2016
Jan 17 2017
Jan 18 2018
Apr 13 2018
May 22 2018
Vuln
No
Yes
Yes
Yes
Yes
Crash
Yes
4 B
Pointer
3 B
CRC
2 B
1
Figure 9: BLE PDU violating a BLOC buffer.
CRC, to take control over the heap. The initial CRC state is
randomized for each connection. Malicious packets with a
chosen CRC need to be produced within the tight Bluetooth
clock to prevent connection termination. The attacker can
pre-calculate the header and ﬁrst 248 B payload. The payload
can be static for this attack. The next 4 B payload are used
to adjust the CRC. After this, 3 B of the BLOC buffer header
are inserted. These are followed by the chosen CRC, which
manipulates the remaining 1 B of the header.
Our current PoC works over-the-air, but only allocates two
BLOC buffers at once by sending a fragmented GATT notiﬁca-
tion within one BLE event. One additional buffer allocation
is needed to gain RCE with a write-what-where gadget. Since
the affected BLOC buffer is one of the largest, we assume that
there is a standard-compliant way to execute this attack, i.e.,
using the 1M or 2M PHY modes. Table 5 shows a list of
tested devices, which was validated with the partial PoC and
local buffer debugging on the device using InternalBlue.
Interestingly, the Samsung Galaxy S10e is differently af-
fected by exactly the same heap corruption. Bluetooth crashes
over-the-air with our PoC because a new heap check was
introduced. It checks for overﬂows by saving the Link Regis-
ter (LR) and a static 1 B canary at the end of each BLOC buffer
element. If the check fails, it crashes gracefully. When this
happens, only one heap element is allocated, and we could
not deploy a write-what-where gadget. The heap check pro-
tects from RCE with CVE-2019-13916 despite the bug still
being present. We were able to produce correct data for the
heap check, which already requires all 4 B of our overﬂow.
To control the next element header, an 8 B overﬂow would be
required. Such a new RCE might be found by either patching
CVE-2019-13916 manually on the CYW20735 ﬁrmware and
continue fuzzing with Frankenstein or by porting it to the
non-vulnerable Samsung Galaxy S10e ﬁrmware.
As we did not provide a full PoC and Patchram is limited,
CVE-2019-13916 has not been ﬁxed on any RCE exploitable
device to the best of our knowledge, despite reporting it in
July 2019.
30    29th USENIX Security Symposium
USENIX Association
Figure 10: LMP fuzzing results on Ubuntu with BlueZ.
6.4 Any ACL Packet (CVE-2019-18614)
Within classic Bluetooth, Asynchronous Connection-Less
(ACL) mode is used for data transfer, such as tethering or
music streaming. Similar to HCI, it is sent to the host using
UART, but with a different data preﬁx.
Upon driver initialization by the operating system, the Blue-
tooth chip signals the maximum packet and buffer size using
the HCI_Read_Buffer_Size command [12, p. 795]. Broad-
com chips are conﬁgured for an ACL length of 1021 B and 8
packets. If this buffer is exceeded, this causes a heap overﬂow.
It is important to note that this overﬂow cannot be exploited
without bypassing the driver and operating system Bluetooth
stack, which requires privileged access either way.
Yet, on the CYW20735 chip only, there is a buffer mis-
conﬁguration that makes ACL exploitable. The global vari-
ables BT_ACL_HOST_TO_DEVICE_DEFAULT_SIZE and BT_
ACL_DEVICE_TO_HOST_DEFAULT_SIZE are set
to 384 B,
while the chip still signals a size of 1021 B to the host. Thus,
just setting up a regular headset for audio streaming as a user
immediately results in a heap overﬂow. As the misconﬁgu-
ration affects both directions, the heap overﬂow can also be
triggered over-the-air by sending a few L2Ping packets ex-
ceeding 384 B. When reconﬁguring the buffer size in WICED
Studio 6.2, this bricks the board’s capability of ﬂashing new
ﬁrmware.
This vulnerability stopped us from further ACL fuzzing
with the emulated CYW20735 ﬁrmware. It is impossible to
take a snapshot during music streaming or tethering before
the ﬁrmware crashes. However, the CYW20819 ﬁrmware does
not have this issue—and Frankenstein is almost completely
ported to this newer ﬁrmware as of June 2020.
Mutator
BlueZ
LMP
Coverage
HCI
./lmp_fuzz
HCI/TCP
HCI Cache
./hci_oracle
HCI/TCP
Cache Miss
Figure 11: Testing of emulated LMP fuzzing against the Linux
BlueZ Bluetooth stack.
6.5 BlueFrag (CVE-2020-0022)
Nonetheless, we tried to create a PoC for CVE-2019-18614
based on the assumption that a chip might cache ACL packets
if sent using Logical Link Control and Adaptation Protocol
(L2CAP) fragments. Instead of crashing the chip, it crashed
within bluetoothd of an up-to-date Samsung Galaxy S10e as
of November 2019. After the report, which contained a PoC
including a Control Flow Integrity (CFI) bypass to create a
reverse shell using Bluetooth within 2 min, this was ﬁxed in
the Android February 2020 patches as CVE-2020-0022. The
details of this are covered in our blog post [40].
6.6 Link Management Protocol State Failures
The Link Management Protocol (LMP) in classic Bluetooth
is managing connection and encryption setup. The protocol
itself is rather simple. However, the most recent attacks af-
fecting a large fraction of Bluetooth devices were located in
the LM logic [2, 8]. Each packet type has a ﬁxed length, with
the maximum length being 17 B [12, p. 679].
We attach the emulated ﬁrmware to a Linux host to sys-
tematically test LMP with Frankenstein, as depicted in Fig-
ure 11. The ﬁrmware processes LMP packets generated by
coverage-guided fuzzing, which in turn causes valid HCI
events. A cache answers known event sequences, and un-
USENIX Association
29th USENIX Security Symposium    31
known sequences are forwarded to the Linux BlueZ host im-
plementation. This differs from code coverage based tools
like syzkaller [31], because only valid management-related
events are passed to the host. Moreover, we aim at increasing
coverage within the ﬁrmware and not within the host.
This interplay with a real system generates various interest-
ing outputs, as depicted in Figure 10. The user interface shows
a lot of weird pairing requests. We even observed faults that
produced dmesg error outputs and one system freeze. How-
ever, they were hard to debug in practice, and we were not
able to ﬁle speciﬁc bug reports.
7 Discussion
This section discusses Frankenstein and patching of discov-
ered vulnerabilities on a broader scope. Section 7.1 pro-
vides an overview of other ﬁrmwares that could be fuzzed
with Frankenstein. We show the current state of Broadcom
ﬁrmware patches on multiple generations of devices in Sec-
tion 7.2. Mitigation techniques against our attacks are dis-
cussed in Section 7.3 and Section 7.4.
7.1 Applicability to Other Systems
The general idea of emulating ﬁrmware to facilitate wireless
fuzzing can also be applied to other chips. An emulator similar
to QEMU and a basic understanding of the ﬁrmware binary
are required, though.
Our emulation framework is tailored to ARM chips and
ThreadX. ThreadX is the number one RTOS, which runs on
over 6.2 billion devices and provides multiple ARM imple-
mentations [22]. Wireless ﬁrmware designed for this combi-
nation is wide-spread. The other ﬁrmware that we internally
ported for Frankenstein is ARM-based and does not use any
operating system at all.
In the following, we provide an overview of wireless
ﬁrmware based on similar technologies. We assume that more
similar wireless platforms exist, however, conﬁrming this re-
quires an extensive analysis of the respective ﬁrmware bina-
ries. Due to the popularity of ARM and ThreadX, we assume
that there are further Frankenstein targets.
A platform that uses ARM and ThreadX and implements
a wireless standard is Marvell Avastar Wi-Fi [43]. More-
over, the Huawei baseband, as well as the Shannon base-
band in Samsung smartphones, are ARM-based [14]. Broad-
com’s Wi-Fi chips are ARM-based, but the operating sys-
tem is HNDRTE [6]. We took a deeper look into the Rasp-
berry Pi 3+/4 and Samsung Galaxy S9 Wi-Fi ﬁrmware and
compared them to the Bluetooth ﬁrmware with known sym-
bols. We found that the main function in Wi-Fi and Blue-
tooth calls _tx_initialize_kernel_enter. Thus, both
Broadcom wireless stacks use ThreadX for threading, timers,
and events. Yet, Wi-Fi uses HNDRTE functions instead of
ThreadX functions for memory management.
7.2 Patching Bluetooth Vulnerabilities
Broadcom Bluetooth chips are released with a ﬁxed ROM
image. Patches are applied using a special Patchram mech-
anism [35]. Each Patchram slot is temporarily stored in a
remapped RAM section and consists of 4 B. This is sufﬁcient
to insert a branch instruction to code stored in a regular RAM
section. The operating system applies device-speciﬁc patches
during driver initialization.
Depending on the chip, there can be 128 or 256 Patchram
slots. This increasing number shows the need to be able to
apply more patches. Analysis of operating system patches
reveals that 256 Patchram slots are by far not sufﬁcient. An
overview is shown in Table 6. Moreover, the RAM area con-
taining the code each patch jumps into is limited. Overall,
even recently released devices only allow for a few more
patches. Manufacturers like Apple, who support devices for
multiple years, cannot include all patches. For example, CVE-
2019-11516 was ﬁxed in iOS 12.4 on all devices except the
iPhone 6, which already uses all Patchram slots.
Broadcom claimed CVE-2019-13916 would not be an is-
sue despite producing a heap overﬂow. Thus, we assume
that Broadcom only ships security updates for issues that
are publicly known and that they consider exploitable. The
limited Patchram slots force them into this decision. To this
end, expanding the Frankenstein fuzz cases beyond zero-click
attacks would likely result in further issues that Broadcom
would decide not to patch.
When initially ﬁnding CVE-2019-11516, it was exploitable
on any Broadcom chip we tested. Surprisingly, during respon-
sible disclosure, Broadcom stated that they knew about the
issue since February 2018. We could conﬁrm this because the
Samsung Galaxy S10e ROM contains a ﬁx and has a com-
pile date of April 2018. Interestingly, the most recent Cypress
evaluation board CYW20819 with ﬁrmware from May 2018
does not contain a ﬁx.
Device manufacturers need to trust Broadcom to include
proper patches. One of the device manufacturers claimed
that Broadcom assured them the devices had been patched,
despite being vulnerable in our tests. Dissecting and conﬁrm-
ing patches at large scale is very hard for anyone besides
Broadcom. Binary difﬁng tools perform poorly on raw ARM
binaries, as correct function identiﬁcation due to duplicate
meanings in Thumb mode at 2 B offsets is challenging [23].
Advanced graph analysis methods fail on this ﬁrmware be-
cause state-of-the-art disassemblers miss a signiﬁcant amount
of functions, thus, corrupting call graphs. Despite only dif-
fering in ARM Cortex M3 versus M4, having comparable
compiler options, and similar hardware register locations, less
than 6 % of the functions could be identiﬁed in practice be-
tween the Nexus 5 ﬁrmware and the CYW20735 evaluation
board ﬁrmware using BinDiff [35].
32    29th USENIX Security Symposium
USENIX Association
Table 6: Patchram slots used on various Broadcom devices.
8 Related Work
Chip
BCM4345B0
BCM4345C0
BCM4345C1
BCM4347B0
BCM4347B1
BCM4375B1
Device
iPhone 6
Raspberry Pi 3+/4
iPhone SE
Samsung Galaxy S8
iPhone 8/X/XR
Samsung Galaxy S10/S10+
OS
iOS 12.4
Raspbian Buster
iOS 12.4
Android 9
iOS 13.4.1
Android 9
Slots
128/128
128/128
127/128
254/256
240/256
212/256
7.3 Memory Protection in Broadcom Chips
Broadcom announced the introduction of critical area access
memory protection to prevent attacks like CVE-2019-15063.
The idea is that special purpose registers, such as those for co-
existence, can only be conﬁgured during device initialization
and are locked afterward. Despite reporting CVE-2019-15063
in August 2019, we did not see critical area access as a patch
in any ﬁrmware as of February 2020. We assume that this
feature is infeasible because the underlying ARM chip is a
Cortex M3 on chips prior to 2016 and a Cortex M4 on newer
chips [23], neither of which support such a feature.
After further questions to the Broadcom security team about
how and when critical area access will be applied, we ﬁnally
saw something potentially related to this feature in iOS 13.4.1
and the March 2020 Samsung Android release. Instead of pro-
tecting memory at the chip-level, the HCI commands to read
and write memory are restricted, including the undocumented
super duper peek poke command. After driver initialization,
these commands are blocked. While this helps against misus-
ing bluetoothd to block the Wi-Fi chip causing Denial of
Service (DoS), it does not protect from over-the-air RCE on
the Bluetooth chip and further escalation into the Wi-Fi chip.
7.4 Heap Management in ThreadX
CVE-2019-11516, CVE-2019-13916, and CVE-2019-18614
exploit the heap structure in the underlying operating sys-
tem. Patching this would secure 6.2 billion systems running
ThreadX. We proposed Express Logic to integrate a heap
sanitizer. As the BLOC structure contains ﬁxed sizes, these
checks run in constant time and could have fully mitigated
our exploit technique and helped developers to detect vulnera-
bilities. They responded that we are not the ﬁrst to exploit the
ThreadX heap—a similar attack was published a few months
before against Marvell Avastar Wi-Fi chips [43]. Nonethe-
less, they do not plan to integrate any mitigation, stating that
applications are responsible for secure heap access.
Despite this statement, the Samsung Galaxy S10e performs
a very basic heap check. We do not know whether Broadcom
or Express Logic introduced it. Crafting valid payloads is pos-
sible with the new check, but the payload needs to be adapted
for each ﬁrmware version. This is already a requirement for
all attacks that rely on calling functions and do not only write
to special hardware registers.
In the following, we summarize existing work on wireless
chip exploitation as well as Bluetooth fuzzing.
To the best of our knowledge, publicly available work
on Bluetooth fuzzing only covers host implementations.
Firmware has not been extensively fuzzed or systematically
tested. Vendors might have non-public testing mechanisms.
Yet, the previously listed ﬁndings in wireless ﬁrmware show
that vendors do not have sufﬁcient techniques to prevent heap
and buffer overﬂows.
So far, Bluetooth ﬁrmware research has been limited to
extend chip functionality. btlejack builds on the documented
Nordic Semiconductor BLE ﬁrmware [15]. It supports pas-
sive and active MITM attacks including BLE 5 hopping. In
contrast, InternalBlue is based on reverse-engineered Broad-
com chips [35]. While it does not support MITM attacks, it