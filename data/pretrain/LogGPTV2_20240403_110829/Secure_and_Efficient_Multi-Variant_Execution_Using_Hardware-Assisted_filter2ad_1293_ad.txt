### 优化后的文本

#### 服务器性能评估

我们对以下服务器应用进行了性能评估：
- Nginx
- Lighttpd
- Bind
- Beanstalkd

为了充分饱和所有服务器程序，我们通过回环接口重新运行了基准测试。需要注意的是，这种策略虽然合理，但可能会导致更悲观的性能结果。例如，Dune 原论文报告在轻量级网络配置下，lighttpd 的开销约为 1% [28]。然而，在我们的设置中（使用回环接口），同样的实验结果显示开销显著增加（约 12%）。这是由于减少了网络开销，使得系统的影响更加明显。

我们评估了 MvArmor 在所有支持的安全策略下的性能。图 4 显示了代码执行安全策略下，随着变体数量增加（从 1 到 4）的结果。由于服务器应用程序通常不会执行任何属于代码执行策略的系统调用，因此结果与没有任何敏感系统调用的策略相同。当禁用我们的变体生成策略（仅考虑 MVX 同步开销）时，两种策略的结果没有差异。这表明，尽管使用了效率较低的安全分配器，跟随者仍然能够跟上领导者，因此我们的变体生成策略几乎没有影响。需要注意的是，对于只有一个变体的情况，安全策略没有影响，因为此时不存在同步问题。

图 6 报告了稍微保守一些的信息披露安全策略的结果。由于我们的服务器应用程序大量使用写入系统调用，这些调用现在以锁步方式运行（迫使跟随者在空闲时间等待领导者而不是执行额外操作），因此较慢的跟随者（以及我们的变体生成策略）的开销无法完全掩盖。为进行比较，图 7 报告了同一策略下，但禁用了变体生成策略的结果。最后，图 5 报告了最保守的安全策略（综合策略）的结果。在这种配置下，变体生成策略（以及跟随者中的自定义分配器）的影响更为明显，因为所有系统调用都以锁步方式运行（例如，两个变体的情况下，几何平均值为 55.2% 对比 49.1%）。

如图所示，像 Nginx 和 Lighttpd 这样具有较少“重复制”系统调用的程序，随着变体数量的增加，其扩展效率较低，并且更容易受到更保守的安全策略（例如，综合策略下的全锁步）的影响。另一方面，Beanstalkd 发出的系统调用相对较少，报告的开销主要是由于 Beanstalkd 的大缓冲区复制成本。这导致 Beanstalkd 的性能受到我们的系统调用插入策略的显著影响，但在变体数量增加和更保守的安全策略下表现良好。我们观察到类似的行为对于 Bind，它每个请求只发出两个非常“重复制”的系统调用（即 recvmsg 和 sendmsg）。

总体而言，我们的结果表明 MvArmor 在变体数量增加时表现出良好的可扩展性。例如，从 2 变体到 3 变体的配置，平均开销（几何平均值）仅增加了约 3%（不同安全策略下）。只有在耗尽核心数量时（例如，在 4 核设置中的 4 变体配置，其中一个核心专用于基准测试程序），才会出现显著的性能下降。我们还注意到，更大规模的可扩展性分析虽然可能有趣，但在实际中并不重要。MvArmor 默认配置使用 2 个变体，足以提供强大的安全保障，并且最小化了核心利用率，鼓励在实际环境中部署。

接下来，我们将我们的结果与 Varan [22] 进行比较。为了公平比较，我们重点关注代码执行安全策略，该策略与 Varan 的 MVX 策略最为接近。对于 Nginx，MvArmor 的性能与 Varan 非常相似（分别为 41% 和 37%，2 个变体）。但对于 Beanstalkd 和 Lighttpd，我们观察到了不同的结果。特别是对于 Beanstalkd，MvArmor 的开销相对较低且稳定（约 41%），而 Varan 的开销逐渐增加（分别为 52% 和 57%，2 个和 3 个变体）。相反，对于 Lighttpd，Varan 报告的开销较低且几乎恒定（约 14%），而 MvArmor 的开销从 2 个变体开始就达到了 70%。

总体而言，MvArmor 的开销结果与 Varan 相当，尽管我们的实验表明，这两个系统的实际性能取决于所考虑的程序。我们认为这些结果非常令人鼓舞，因为 (i) Varan 是目前最快的 MVX 实现，(ii) 相比 Varan，即使在最不保守的（代码执行）安全策略下，MvArmor 也提供了更强的安全保障，(iii) 我们的基于回环接口的性能结果较为悲观，并且可以通过进一步启用由我们的设计支持的 libOS 风格优化来改进。

#### SPEC 性能

为了进一步将我们的结果与现有解决方案进行比较，我们评估了 MvArmor 对 SPEC CINT2006 基准测试的影响。尽管 SPEC 基准测试是 CPU 密集型的，并且发出的系统调用数量相对较少（从而为 MVX 系统提供了乐观的性能结果），但该实验仍提供了有用的比较数据点。图 8 展示了我们的发现。

如图所示，MvArmor 在 2 个变体配置下平均开销为 9.1%（几何平均值），在 4 个变体配置下平均开销为 20.4%。进一步检查显示，大多数情况下，报告的开销主要来源于系统内存带宽的影响。例如，mcf 和 libquantum 等基准测试特别依赖于内存，并且在多核架构上的同时运行效果不佳 [57]。

尽管 Dune 中使用 EPTs 在内存密集型基准测试中导致了更大的 TLB 缺失影响 [28]，但我们的结果仍然令人鼓舞，并且实际上比文献中最好的 MVX 表现者 Varan 更好。Varan 在相同的基准测试集上，使用 2 个变体的平均开销为 14.2%（几何平均值）[22]。

#### 微基准测试性能

为了仔细确定 MvArmor 引入的开销来源，我们使用多个微基准测试对其进行了评估。具体来说，我们测量了各种系统调用在用户程序视角下的周期数，分别在 Dune [28] 和我们的完整 MvArmor 解决方案（使用 1 个或 2 个变体，即 MV1 和 MV2）下进行。图 9 展示了我们的发现。

getpid 和 close(-1) 系统调用的持续时间非常短，内核几乎立即返回到用户空间。对于这些简单的系统调用，Dune 单独增加了大约 1,300 个周期，主要用于系统调用插入和（主要是）syscall 返回路径。

希望这些优化能使您的文档更加清晰、连贯和专业。如果有更多需要修改的内容，请告诉我！