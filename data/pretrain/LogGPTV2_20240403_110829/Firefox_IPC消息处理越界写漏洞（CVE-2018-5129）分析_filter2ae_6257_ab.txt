    }
上述代码片段是CopyPlane函数的“慢速路径”。如前所述，它使用“Slow”嵌套for循环，对aSrc和aDst缓冲区进行循环，并逐字节复制图像数据。然而，内层循环中的宽度（Width）存在漏洞，内层循环使用width属性来计算x轴。这就是漏洞的第二部分。
这里的问题在于，CopyData中mBuffer变量的大小计算和后续分配，都不会再使用width变量。它会根据高度和跨度计算目标缓冲区的大小，与宽度无关。然后，我们的CopyPlane函数会迭代aSrc和aDst的高度和宽度。
所以回顾一下，我们有以下两个条件：
1、基于高度*跨度计算尺寸；
2、嵌套的for循环，其中内层for循环遍历缓冲区的宽度，而这个宽度是在第一步中未考虑过的变量。
因此，我迅速编写了一个触发器，用了大概几小时的时间。之后，我便可以通过越界访问写入漏洞，成功使得52版本的Firefox崩溃。
## 五、制作触发器
目前，我们已经掌握了漏洞，接下来需要证明该漏洞确实影响浏览器。在本章中，我将确定受漏洞影响代码的最简单路径，并通过JavaScript触发器来实现每一个步骤。  
在探索了许多潜在的代码路径之后，我们发现针对52版本的Firefox，最简单的方法就是通过公开的CreateImageBitmap()函数。我们要想成功运行calc.exe，大概需要如下几个步骤：
1、createImageBitmap()
2、ImageBitmap::Create
3、ImageBitmap::CreateImageFromBufferSourceRawData
4、CopyData
5、CopyPlane
###  5.1入口点
createImageBitmap函数是一个可以从Web Worker或主线程调用的工厂方法，它有很多重载，但我们感兴趣的是这一个：
    createImageBitmap(buffer, offset, length, 'FORMAT', [layout1, layout2, layout3]);
这就是我们的入口点。从这里开始，我们可以研究引擎的更深层次。
###  5.2 ImageBitmap构造函数
ImageBitmap对象的构造函数与JavaScript的入口点非常相似。它使用缓冲区、偏移量、长度、格式和布局，负责初始化和创建ImageBitmap对象。
    /*static*/ already_AddRefed
    ImageBitmap::Create(nsIGlobalObject* aGlobal, 
                        const ImageBitmapSource& aBuffer, /* 1 */
                        int32_t aOffset, /* 2 */
                        int32_t aLength, /* 3 */
                        mozilla::dom::ImageBitmapFormat aFormat, /* 4 */
                        const Sequence& aLayout, /* 5 */
                        ErrorResult& aRv)
aBuffer：表示我们将从中创建ImageBitmap的ArrayBuffer或ArrayBufferView。
aOffset：一个有符号32位整数，表示aBuffer中的偏移量，用于从中提取ImageBitmap数据。
aLength：一个有符号32位整数，表示对象的长度。
aFormat：表示创建ImageBitmap时aBuffer的格式。
aLayout：ImageBitmap的布局对象数组。
下面是构造函数相关的代码：
    ... 
      uint8_t* bufferData = nullptr;
      uint32_t bufferLength = 0;
      /* 1 */
      if (aBuffer.IsArrayBuffer()) {
        const ArrayBuffer& buffer = aBuffer.GetAsArrayBuffer();
        buffer.ComputeLengthAndData();
        bufferData = buffer.Data();
        bufferLength = buffer.Length();
      } else if (aBuffer.IsArrayBufferView()) {
        const ArrayBufferView& bufferView = aBuffer.GetAsArrayBufferView();
        bufferView.ComputeLengthAndData();
        bufferData = bufferView.Data();
        bufferLength = bufferView.Length();
      } else {
        aRv.Throw(NS_ERROR_NOT_IMPLEMENTED);
        return promise.forget();
      }
      ...
      /* 2 */
      // Check the buffer.
      if (((uint32_t)(aOffset + aLength) > bufferLength)) {
        aRv.Throw(NS_ERROR_DOM_INDEX_SIZE_ERR);
        return promise.forget();
      }
      // Create and Crop the raw data into a layers::Image
      RefPtr data;
      /* 3 */
      if (NS_IsMainThread()) {
        data = CreateImageFromBufferSourceRawData(bufferData + aOffset, bufferLength,
                                                  aFormat, aLayout);
      } else {
        ...
      }
     ...
    }
在构造函数中，我们需要理解3个重要的地方：
1、确保aBuffer或我们的aSrc是ArrayBuffer或ArrayBufferView。
2、该检查确保我们提供的aOffset和aLength小于第一部分中计算的bufferLength。
3、最后，需进行检查，以确保在主线程上执行。如果我们决定从Web-worker创建ImageBitmap对象，那么这一if语句的值将为False，而else语句中将负责求值。因此，if(NS_IsMainThread())的计算结果必须要为True，因为我们下一阶段必须要用到CreateImageFromBufferSourceRawData函数。
此时，我们构造的触发器可能如下所示：
    try{
      var aBuffer = new Uint8Array(0x100000);
      var aOffset = 0;
      var aLength = 0x1000;
      bitmap = createImageBitmap(aBuffer, aOffset, aLength, 'FORMAT', [...]);
    } catch (ex) {
      console.log(ex);
    }
###  5.3 CreateImageFromBufferSourceRawData
由于涉及到包含了许多不同图像格式的大型switch语句，因此这个函数需要花费一定时间来进行研究。最终我们发现，该函数接受aBufferData、aBufferLength、aFormat和aLayout参数。通过对这些参数进行操纵，就可以调用存在漏洞的CopyData函数。
        CreateImageFromBufferSourceRawData(const uint8_t *aBufferData, /* 1 */
                                       uint32_t aBufferLength, /* 2 */
                                       mozilla::dom::ImageBitmapFormat aFormat, /* 3 */
                                       const Sequence& aLayout)/* 4 */
const uint8_t *aBufferData：如ImageBitmap :: Create方法中的bufferData +
aOffset所描述，指向我们的aBufferData的指针。
uint32_t aBufferLength – 已经过验证并传入的无符号32位整数。
mozilla::dom::ImageBitmapFormat
aFormat：直接从ImageBitmap::Create方法传递的ImageBitmapFormat对象。
const Sequence&
aLayout：直接从ImageBitmap::Create方法传递的布局对象的地址。
CreateImageFromBufferSourceRawData方法用于从缓冲区创建图像。生成的ImageBitmap所采用的格式，取决于aFormat参数。这一aFormat参数会传递给switch语句，然后用于选择生成的ImageBitmap格式。这个对象可以采用许多不同的格式，但在Firefox
52.0发布时，只有两个条件（Case）可以实现：case ImageBitmapFormat::DEPTH:和case
ImageBitmapFormat::YUV420SP_NV21:。
我们感兴趣的是后者这种条件。
      case ImageBitmapFormat::RGBA32:
      case ImageBitmapFormat::BGRA32:
      case ImageBitmapFormat::RGB24:
      case ImageBitmapFormat::BGR24:
      case ImageBitmapFormat::GRAY8:
      case ImageBitmapFormat::HSV:
      case ImageBitmapFormat::Lab:
      case ImageBitmapFormat::DEPTH:
      {
        ...
      }
      case ImageBitmapFormat::YUV444P:
      case ImageBitmapFormat::YUV422P:
      case ImageBitmapFormat::YUV420P:
      case ImageBitmapFormat::YUV420SP_NV12:
      case ImageBitmapFormat::YUV420SP_NV21:
      {
          TARGET
      }
我们的目标格式YUV420SP_NV21，是一种特定的颜色编码格式，被称为YUV。该格式通常作为彩色图像通道的一部分。我们在调用createImageBitmap时，只需要让aFormat参数的值为字符串“YUV420P”即可进入到这种条件（Case）。
YUV420SP_NV21条件体的内容如下所示：
    ...
        // Prepare the PlanarYCbCrData.
        /* 1 */
        const ChannelPixelLayout& yLayout = aLayout[0];
        const ChannelPixelLayout& uLayout = aFormat != ImageBitmapFormat::YUV420SP_NV21 ? aLayout[1] : aLayout[2];
        const ChannelPixelLayout& vLayout = aFormat != ImageBitmapFormat::YUV420SP_NV21 ? aLayout[2] : aLayout[1];
        layers::PlanarYCbCrData data;
        // Luminance buffer
        data.mYChannel = const_cast(aBufferData + yLayout.mOffset);
        data.mYStride = yLayout.mStride;
        data.mYSize = gfx::IntSize(yLayout.mWidth, yLayout.mHeight);
        data.mYSkip = yLayout.mSkip;
        // Chroma buffers
        data.mCbChannel = const_cast(aBufferData + uLayout.mOffset);
        data.mCrChannel = const_cast(aBufferData + vLayout.mOffset);
        data.mCbCrStride = uLayout.mStride;