[root@shifm1tmp]# cp abc.txt code/abc.txt
图22
 包号1和2（见图23）：
图23
客户端：“我可以进入0x2cc9be18（即/code目录）吗？”服务器：“你的请求被接受了，进来吧。”
包号4和5（见图24）：
图24
客户端：“请问这里有叫abc.txt的文件么？”
服务器：“没有。”
(10)
包号6和7（见图25）：
图25
客户端：“那我想创建一个叫abc.txt的文件。”
服务器：“没问题，这个文件的file handle是0x531352e1。”
包号64、104、130、190（见图26）：
图26
 客户端：“从0x531352e1的偏移量为0处（即abc.txt的文件开头）写131072字节。”
服务器：“第一个131072字节写好了。”
客户端：“从0x531352e1的偏移量为131072处（即接着上一个写完的位置）再写131072字节。”
客户端：“从0x531352e1的偏移量为262144处（即接着上一个写完的位置）再写131072字节。”
（继续写，直到写完整个文件。）
包号306和307（见图27）：
图27
客户端：“我刚才往0x531352e1（也就是abc.txt）写的数据都存盘了吗？”
服务器：“都存好了。”
(11)
包号308和309（见图28）：
图28
客户端：“那我看看0x531352e1（也就是abc.txt）的文件属性。”
服务器：“文件的权限、uid、gid、文件大小等信息都给你。”
 这个例子的写操作也是多个WRITE Call连续发出去的，这是因为我们在挂载时没有指定任何参数，所以使用了默认的async写方式。和async相对应的是sync方式。假如mount时使用了sync参数（见图29），客户端会先发送一个WRITE Call，等收到Reply后再发下一个Call，也就是说WRITE Call和WRITE Reply是交替出现的。除此之外，还有什么办法在包里看出一个写操作是async还是sync呢？答案就是每个WRITE Call上的“UNSTABLE”和“FILE_SYNC”标志，前者表示async，后者表示sync。图30显示了用sync参数后的网络包。
图29
图30
从图30中不仅可以看到FILE_SYNC标志，还可以看到WRITE Call和WRITE Reply是交替出现的（也就是说没有连续的Call）。不难想象，每个WRITE Call写多少数据也是影响写性能的重要因素，我们可以在mount时用wsize参数来指定每次应该写多少。不过在有些客户端上启用sync 参数之后，无论wsize定义成多少都会被强制为4KB，从而导致写性能非常差。那为什么还有人用sync方式呢？答案是有些特殊的应用要求服务器收到sync的写请求之后，一定要等到存盘才能回复WRITE Reply，sync操作正符合了这个需求。由此我们也可以推出COMMIT对于sync写操作是没有必要的。
非常值得一提的是，经常有人在mount时使用noac参数，然后发现读写性能都有问题。而根据RFC的说明，noac只是让客户端不缓存文件属性而已，为什么会影响性能呢？光看文档也许永远发现不了原因。抓个包吧，Wireshark会告诉我们答案。
 先看写文件的情况（见图31）：
图31
在图32中，从Write Call里的FILE_SYNC可以知道，虽然在mount时并没有指定sync参数，但是noac把写操作强制变成sync方式了，性能自然也会下降。
图32
再看读文件时的情况（见图33）：
[root@shifm1 tmp]# mount -o noac 10.32.106.62:/code /tmp/code
[root@shifm1 tmp]# cat /tmp/code/abc.txt
图33
 从图33中可以看到，在读文件过程中，客户端频繁地通过GETATTR查询文件属性，所以读性能也受到了影响，在高延迟的网络中影响尤为明显。
纵观全文，我们分析了挂载过程的每个步骤，理清了NFS的安全机制，还研究了读写过程的各种细节，几乎把NFS协议的方方面面都覆盖了。如果你认真读完本文，可以说对NFS的理解已经达到很高的境界，以后碰到类似noac这般隐蔽的问题也难不倒你。假如真能遇到棘手的难题，我建议用Wireshark分析。一旦用它解决了第一个问题，恭喜你，很快就会中毒上瘾的。中毒之后会有什么症状呢？你可能碰到什么问题都想抓个包分析，就像小时候刚学会骑车一样，到小区门口打个酱油都要骑车去。
从Wireshark看网络分层
对于刚上网络课的学生来说，最难理解的莫过于网络分层了。
“只不过是传输一些数据，为什么要分那么多层次呢？”这是大学里一直困扰我的问题。虽然课本在此处花费了不少笔墨，但还是过于抽象，我始终无法想像一个网络包里的层次究竟是什么样子。这对一名网络工程师来说是不可接受的，就像连器官都分不清楚的医生，谁能放心让他做手术呢？幸好后来遇到Wireshark，才算解开了这个疑问。
前文已经介绍过NFS协议，我们便以它为例来学习网络分层。图1是客户端10.32.106.159往服务器10.32.106.62上写文件时抓的网络包。
图1
这5个包大概做了下面这些事。
客户端：“我想创建test.txt。”
服务器：“创建成功啦（该文件的file handle是0xf87a7de0，点开包才能看到）。”
 客户端：“我想写28个字节到该文件里（这些字节显示在图1的右下角）。”
服务器：“收到啦。”
服务器：“写好啦。”
其中第3个包（编号为15）的详情如图2所示。Wireshark已经形象地把这个包的内容用分层的结构显示出来。
图2
• 应用层：由于NFS是基于RPC的协议，所以Wireshark把它分成NFS和RPC两行来显示。仔细检查这一层的详细信息，会发现它只专注于文件操作，比如读或者写，而对于数据传输一无所知。点开“+”号便能看到这个写操作的详情，比如用户的UID、文件的file handle和要写的字节数等。
• 传输层：这一层用到了TCP 协议。应用层所产生的数据就是由TCP来控制传输的。点开TCP层前的“+”号，我们可以看到Seq号和Ack号等一系列信息，它们用于网络包的排序、重传、流量控制等。虽然名曰“传输层”，但它并不是把网络包从一个设备传到另一个，而只是对传输行为进行控制。真正负责设备间传输的是下面两层。TCP是非常有用的协议，也是本书的重点。
• 网络互连层（网络层）：在这个包中，本层的主要任务是把TCP层传下来的数据加上目标地址和源地址。有了目标地址，数据才可能送达接收方；而有了源地址，接收方才知道发送方是谁。
• 网络接口层（数据链路层）：从中可以看到相邻两个设备的MAC地址，因此该网络包才能以接力的方式送达目标地址。
从这个例子中，我们可以看到网络分层就像是有序的分工。每一层都有自己
 的责任范围，上层协议完成工作后就交给下一层，最终形成一个完整的网络包。这个过程可以用图3表示。
图3
现在回想起来，如果当时老师能打开Wireshark，让我们看到这些实实在在的分层，我也不会困惑那么久了（假如那天我没有逃课的话）。不过教科书上有一个例子，倒的确是很有助于理解分层的，这么多年之后我还记得它—有位经理想给另一个城市的经理寄个文件，过程大概如图4所示。
图4
这个场景中的4个角色可以对应网络的4个层次，每个角色都有自己的分工，最终完成文件的送达。分工会带来很多好处，因为每个人都可以专注自己擅长的领域，更好地服务他人。经理不一定要学会开车，就像写NFS代码的程序员可以