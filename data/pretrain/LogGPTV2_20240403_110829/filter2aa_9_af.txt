### 优化后的文本

---

#### 文件操作示例
在命令行中，使用以下命令将 `abc.txt` 复制到 `/code` 目录下：
```bash
[root@shifm1 tmp]# cp abc.txt code/abc.txt
```

#### 网络包分析
**图22**  
- **包号1和2（见图23）：**
  - 客户端：“我可以进入0x2cc9be18（即/code目录）吗？”
  - 服务器：“你的请求被接受了，进来吧。”

**图23**  
- **包号4和5（见图24）：**
  - 客户端：“请问这里有叫 `abc.txt` 的文件吗？”
  - 服务器：“没有。”

**图24**  
- **包号6和7（见图25）：**
  - 客户端：“那我想创建一个叫 `abc.txt` 的文件。”
  - 服务器：“没问题，这个文件的 file handle 是 0x531352e1。”

**图25**  
- **包号64、104、130、190（见图26）：**
  - 客户端：“从 0x531352e1 的偏移量为 0 处（即 `abc.txt` 的文件开头）写 131072 字节。”
  - 服务器：“第一个 131072 字节写好了。”
  - 客户端：“从 0x531352e1 的偏移量为 131072 处（即接着上一个写完的位置）再写 131072 字节。”
  - 客户端：“从 0x531352e1 的偏移量为 262144 处（即接着上一个写完的位置）再写 131072 字节。”
  - （继续写，直到写完整个文件。）

**图26**  
- **包号306和307（见图27）：**
  - 客户端：“我刚才往 0x531352e1（也就是 `abc.txt`）写的数据都存盘了吗？”
  - 服务器：“都存好了。”

**图27**  
- **包号308和309（见图28）：**
  - 客户端：“那我看看 0x531352e1（也就是 `abc.txt`）的文件属性。”
  - 服务器：“文件的权限、UID、GID、文件大小等信息都给你。”

#### 异步与同步写操作
- **异步写操作**：在这个例子中，写操作是多个 WRITE Call 连续发出的，因为我们在挂载时没有指定任何参数，所以使用了默认的异步写方式。
- **同步写操作**：如果在挂载时使用了 `sync` 参数（见图29），客户端会先发送一个 WRITE Call，等待收到 Reply 后再发下一个 Call，也就是说 WRITE Call 和 WRITE Reply 是交替出现的。

**图29**  
- **如何区分异步和同步写操作**：可以通过每个 WRITE Call 上的“UNSTABLE”和“FILE_SYNC”标志来判断，前者表示异步，后者表示同步。图30显示了使用 `sync` 参数后的网络包。

**图30**  
- 从图30中不仅可以看到 FILE_SYNC 标志，还可以看到 WRITE Call 和 WRITE Reply 是交替出现的（也就是说没有连续的 Call）。每个 WRITE Call 写多少数据也是影响写性能的重要因素，我们可以在挂载时用 `wsize` 参数来指定每次应该写多少。不过在有些客户端上启用 `sync` 参数之后，无论 `wsize` 定义成多少都会被强制为 4KB，从而导致写性能非常差。

#### 使用 `noac` 参数的影响
- **写文件的情况**（见图31）：在图32中，从 Write Call 里的 FILE_SYNC 可以知道，虽然在挂载时并没有指定 `sync` 参数，但是 `noac` 把写操作强制变成同步方式了，性能自然也会下降。

**图31**  
- **读文件的情况**（见图33）：
  ```bash
  [root@shifm1 tmp]# mount -o noac 10.32.106.62:/code /tmp/code
  [root@shifm1 tmp]# cat /tmp/code/abc.txt
  ```
  - 从图33中可以看到，在读文件过程中，客户端频繁地通过 GETATTR 查询文件属性，所以读性能也受到了影响，在高延迟的网络中影响尤为明显。

**图33**

#### 总结
本文详细分析了挂载过程的每个步骤，理清了 NFS 的安全机制，并研究了读写过程的各种细节，几乎涵盖了 NFS 协议的方方面面。如果你认真读完本文，可以说对 NFS 的理解已经达到很高的境界，以后碰到类似 `noac` 这般隐蔽的问题也难不倒你。假如真能遇到棘手的难题，建议使用 Wireshark 进行分析。一旦用它解决了第一个问题，很快就会中毒上瘾。中毒之后会有什么症状呢？你可能碰到什么问题都想抓个包分析，就像小时候刚学会骑车一样，到小区门口打个酱油都要骑车去。

#### 从 Wireshark 看网络分层
对于刚上网络课的学生来说，最难理解的莫过于网络分层了。“只不过是传输一些数据，为什么要分那么多层次呢？”这是大学里一直困扰我的问题。虽然课本在此处花费了不少笔墨，但还是过于抽象，我始终无法想象一个网络包里的层次究竟是什么样子。这对一名网络工程师来说是不可接受的，就像连器官都分不清楚的医生，谁能放心让他做手术呢？幸好后来遇到 Wireshark，才算解开了这个疑问。

前文已经介绍过 NFS 协议，我们便以它为例来学习网络分层。图1是客户端 10.32.106.159 往服务器 10.32.106.62 上写文件时抓的网络包。

**图1**  
- 这5个包大概做了下面这些事：
  - 客户端：“我想创建 `test.txt`。”
  - 服务器：“创建成功啦（该文件的 file handle 是 0xf87a7de0，点开包才能看到）。”
  - 客户端：“我想写 28 个字节到该文件里（这些字节显示在图1的右下角）。”
  - 服务器：“收到啦。”
  - 服务器：“写好啦。”

其中第3个包（编号为15）的详情如图2所示。Wireshark 已经形象地把这个包的内容用分层的结构显示出来。

**图2**  
- **应用层**：由于 NFS 是基于 RPC 的协议，所以 Wireshark 把它分成 NFS 和 RPC 两行来显示。仔细检查这一层的详细信息，会发现它只专注于文件操作，比如读或者写，而对于数据传输一无所知。点开“+”号便能看到这个写操作的详情，比如用户的 UID、文件的 file handle 和要写的字节数等。
- **传输层**：这一层用到了 TCP 协议。应用层所产生的数据就是由 TCP 来控制传输的。点开 TCP 层前的“+”号，我们可以看到 Seq 号和 Ack 号等一系列信息，它们用于网络包的排序、重传、流量控制等。虽然名曰“传输层”，但它并不是把网络包从一个设备传到另一个，而只是对传输行为进行控制。真正负责设备间传输的是下面两层。TCP 是非常有用的协议，也是本书的重点。
- **网络互连层（网络层）**：在这个包中，本层的主要任务是把 TCP 层传下来的数据加上目标地址和源地址。有了目标地址，数据才可能送达接收方；而有了源地址，接收方才知道发送方是谁。
- **网络接口层（数据链路层）**：从中可以看到相邻两个设备的 MAC 地址，因此该网络包才能以接力的方式送达目标地址。

从这个例子中，我们可以看到网络分层就像是有序的分工。每一层都有自己明确的责任范围，上层协议完成工作后就交给下一层，最终形成一个完整的网络包。这个过程可以用图3表示。

**图3**  
- 现在回想起来，如果当时老师能打开 Wireshark，让我们看到这些实实在在的分层，我也不会困惑那么久了（假如那天我没有逃课的话）。不过教科书上有一个例子，倒的确是很有助于理解分层的，这么多年之后我还记得它—有位经理想给另一个城市的经理寄个文件，过程大概如图4所示。

**图4**  
- 这个场景中的4个角色可以对应网络的4个层次，每个角色都有自己的分工，最终完成文件的送达。分工会带来很多好处，因为每个人都可以专注自己擅长的领域，更好地服务他人。经理不一定要学会开车，就像写 NFS 代码的程序员可以专注于文件操作而不必了解底层的传输细节。

---