反编译则没有反汇编这么容易了，它只能尽最大可能还原初始高级语言代码。也正是因为各自功能的目标不同，一个是生成汇编代码一个是生成高级语言代码，后者的复杂性可想而知。以C++为例，其中的数据结构、类型声明和代码结构想要从编译后的代码中再重新获得，其复杂性不言而喻。也正因如此，反编译器的数量少之又少，且功能实用的反编译器一般都价格昂贵。
反编译器可以按照他们能够分析的软件类别进行划分，像是C#、VB、Java等语言生成的目标代码只是中间形式，并不能直接被x86这样的处理器执行，而是依赖于对应语言的虚拟机来完成执行（比如.NET
Framework 和JVM），因此这种中间形式的目标代码是一种伪代码（pseudo code，故而有P-Code一词）。
这种中间形式的伪代码将大多数信息以伪指令和伪元数据的形式来存储，并因其远简单于x86和x64代码而使得反编译变得极为容易。这也导致了很多专用反编译器的诞生，它们能够轻易地得到未保护软件的源码。对于这些语言的开发者来说，这种技术的存在无疑是一种噩梦。
以上做了一些简单的介绍，下面就将呈现一些最流行的反汇编器和反编译器以及它们的使用说明。
**IDA和Hex-Rays**
IDA简写于Interactive
DisAssembler，它是逆向领域无可争议的老大哥。IDA是一个拥有内置60多种类型代码分析的反汇编器。它还拥有自己的脚本语言和庞大的主流编程语言签名库，同时也提供插件功能来增强功能（比如Python写的脚本）。
图4：IDA的反汇编和反编译窗口
最广为人知也最有价值的IDA插件非Hex-Rays莫属，它同时支持x86、x64、ARM平台的反编译，可谓是无价之宝。
IDA拥有很多硬件平台的内置调试器，无疑是为这个完美的多功能文件分析工具锦上添花。
**.NET Reflector**
当我们需要分析处理使用.NET Framework的软件时（如C#或VB.net），.NET
Reflector会帮上大忙。我们可以通过它快速高效地一窥软件架构。
.NET
Reflector的最大优势在于它有一个小而精悍的插件库，比如其中就有一个插件，能够通过反编译过的软件代码重建整个VS工程。另外，因其与Microsoft
Visual Studio的集成，它可以同时调试自己的代码和封闭库的代码。
.NET
Framework反编译软件的简单性催生了许多安全工具，当然在这里我们讨论的是从编译过的程序中移除元数据这一类的数据混淆技术，它可以修改中间代码（即IL
code——[Intermediate
Code](https://www.techopedia.com/definition/24290/intermediate-language-il-net)）、可以加密文本字符串，等等。如果我们偶然碰见这样一个程序，我们得首先熟知de4dot
反混淆器的相关技巧，以便令其自动解除施加在其上的花样繁多的混淆保护。
图5：.NET Reflector反编译器窗口
**dnSpy**
它是.NET反编译的真正主力，拥有内置的代码编辑器和调试器。不止如此，直观且现代化的界面以及免费的使用许可非常具有吸引力。
图6：dnSpy反编译和调试窗口
**Java Decompiler/JD-GUI**
顾名思义，Java Decompiler是一款Java的反编译器，它可以查看编译过的.class字节码文件或是全部的.jar包。
它有一个非常有用的搜索引擎，通过规则丰富的过滤器搜索名称、类型、构造器、作用域、方法和文本字符串等。
除了软件本身之外，它还提供了Eclipse 和 IntelliJ IDEA开发环境的插件，这样在IDE中也可以查看编译过的模块了。
如果你曾经用过或是一直在用大名鼎鼎的反编译软件JAD（从2001年后就没有更新过了），那么现在是时候放下你手上的工具转到JD-GUI
上来了。它不仅支持Java的新元素，对于编译过的项目的导航也十分简单且使人乐在其中。
值得一提的是，就像.NET一样，Java代码如果也经过了混淆处理的保护，那么反编译软件的效果将大打折扣，极端情况下甚至会失效。
图7：Java Decompiler（又名JD-GUI）
**JustDecompile**
这款软件是之前提到过的商业软件.NET Reflector的免费替代版本，使用Telerik
的UI组件开发。免费并不意味着劣质，它拥有内置的参考搜索引擎，还可以从反编译的源代码生成工程的能力。支持插件扩展，包括前面提到过的de4dot反混淆插件。
图8：Just Decompile反编译器
**  
**
**ReFox**
ReFox针对的是使用微软的Visual
FoxPro数据库编程环境创建的软件。这是一种在等同环境下比较小众的解决方案，但目前并没有更好的替代方案来解决这个问题，主要原因是曾经存在过的一些类似软件早已不再更新并且无法支持最新的VFP软件。ReFox允许对类进行反编译、查看表和内置数据。
图9：ReFox反编译器
**VB Decompiler**
通过VB 5和VB
6创建的软件已经是过去式了，但是其基于伪代码（P-Code）的内在代码结构却成为了.NET技术的摇篮。最开始这确实导致了一些问题，因为根本没有专门的可以用来分析VB的工具，而VB
Decompiler的诞生略晚于市场需求，但在实际应用中当我们需要将VB应用程序（EXE、DLL、OCX控制）生成伪代码时，它的地位是不可替代的。
图10：VB Decompiler
**IDR**
IDR缩写于Interactive Delphi
Reconstructor，是一款Delphi环境下的反汇编和反编译工具。与IDA相比它更为出众的地方在于它能够分析Dephi代码的内部结构，内置了窗体查看器，从而可以方便快速地找到分配到窗体上的控制事件（比如按钮1的OnClick事件）。IDR拥有庞大的标准Dephi环境签名库，且涵盖所有Delphi版本，所以在最终输出时我们能够看到简单易读的函数名。
图11：Dephi的反汇编和反编译器——IDR
**类别3：调试器**
作为一个程序员，迟早都得接触到他最喜欢的编程语言环境下的调试器的相关功能，多亏了调试器的存在我们可以实时跟踪到应用程序的运行情况，看看其中的指令是如何影响内存和变量或者发现潜在的错误的。当调试我们自己的软件时，我们往往掌握着源码并在高层调试即可，与之相比，在我们并没有源码的情况下想要调试软件就没有那么容易。这时专门的调试软件就派上用场了，它能够对二进制形式的软件做一系列的高级分析，正因为软件是经过编译的，所以这也意味着使用者需要对底层的语言和处理器的工作方式有所了解。
**OllyDbg**
事实上，OD可以说是在逆向工程界Windows平台上的标准调试器（除了IDA内置的调试器）。它不仅能够分析软件代码还能干预到程序运行的几乎每一个方面。
OllyDbg还包括一些强大而有趣的功能，它允许条件化代码追踪，它拥有庞大的插件库，其中就有让反调试技术无所遁形的Phant0m
插件，有控制OD在脚本层运行的ODbgScript插件，而且光是脚本这一项（通常用于未受保护的应用程序解包）就有成百上千个。
OllyDbg的流行的事实无可非议，因为确实找不出第二个像OllyDbg一样拥有如此多的插件的调试器，即使是曾经的传奇SoftICE
系统调试器望尘莫及。还有一个有趣的软件叫做Immunity
Debugger，它是内置了Python脚本支持的OllyDbg特殊版本，主要用途是分析恶意软件和创建exploit。
目前OllyDbg有两个版本，旧版版本号为1.10，新版2.01有了更多的扩展支持，现在正越来越流行。但是以上的版本都只支持32位的，不过有个好消息是因为64位系统的广泛流行一个新的64位版本OllyDbg正在开发中。
图12：OllyDbg v1.10
图13：OllyDbg v2.01
**x64dbg**
x64dbg其实包含两个调试器，一个针对64位软件调试而另一个针对32位软件。它拥有现代化的界面，大量的配置选项，内部引擎基于现代化编程库开发（如TitanEngine,
Capstone Engine, Keystone Engine）。
x64dbg支持的特性数量繁多，让人印象深刻。包括插件、内置脚本语言、Yara签名扫描、内置反编译器等等。它的发展十分积极。考虑到64位的OllyDbg一直都处于开发的状态中，x64dbg已经成为标准的64位软件调试器。
图14：调试器x64dbg
**  
**
**DILE**
.NET Framwork软件的调试器。这是一个非常鲁棒的软件（稳定性不好），但在某些情况下却是无价的。它的界面看起来像是Visual
Studio的内置调试器。这里非要提到它的一个原因是它是为数不多的可以在没有源代码的情况下调试.NET
Framwork软件的工具之一。当然，前面提到的.NET Reflector也可以通过Deblector插件来完成调试功能。
图15：.NET-DILE软件调试器
（未完待续……）
传送门：[【逆向工具综述（下）】](http://bobao.360.cn/learning/detail/3307.html)