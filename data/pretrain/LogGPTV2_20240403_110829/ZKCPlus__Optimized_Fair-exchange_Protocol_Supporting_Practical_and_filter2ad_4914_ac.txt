· 𝜌i,

i∈[2m]
i∈[2m]
i∈[2m]
𝜏 =
r = 
𝜌 = 
k∈[0,log m]
0 u–1
1
· · · u–1
k ) ∈ F2m
p ,
P : ld, rd
$← Fn
p,
s1 = ⟨l, rd ◦ yn⟩ + ⟨ld, r⟩,
(Ld, 𝜄d) ← Commit(pp, ld),
(S1, 𝜎1) ← Commit(pp, s1),
s2 = ⟨ld, rd ◦ yn⟩,
(Rd, 𝜌d) ← Commit(pp, rd),
(S2, 𝜎2) ← Commit(pp, s2).
P → V : Ld, Rd, S1, S2.
V → P : e
$← Fp.
P : l′ = l + e · ld,
𝜄′ = 𝜄 + e · 𝜄d,
P → V : l′, r′, 𝜄′, 𝜌′, 𝜏′.
j∈[m]
i∈[m]
V : L = 
R = 
log 2m
i∈[m]


(cid:16)
j∈[m]
r′ = r + e · rd ◦ yn,
𝜌′ = 𝜌 + e · 𝜌d,
wi ·(cid:0)zi · Aij + zi+m · Cij
(cid:0)zi · Bij
(cid:1) · Vj + 
(cid:17)
i∈[m]
L′ = L0 + e · Ld, Check(pp, L′, l′, 𝜄′) ?= 1,
zi+m · ⟨1, G⟩,
n , 𝜌′) ?= 1,
+ e · S1 + e2 · S2,
R′ = R + e · Rd, Check(pp, R′, r′ ◦ y–1
T′ =
Check(pp, T′, ⟨l, r⟩, 𝜏′) ?= 1.
k · T +
u2
k + u–2
k
· T –
k=0
k
𝜏′ = 𝜏 + e · 𝜎1 + e2 · 𝜎2.
(cid:1) · Vj,
Figure 2: Protocol for data-parallel circuits
Session 11B: Zero Knowledge II CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea3006i∈[m]
(y, y2,· · · , yn) is a vector generated by challenger y
the m equations are combined by another challenger w
wi(cid:16)⟨ai, bi ◦ yn⟩ – ⟨ci, yn⟩(cid:17)

$← Fp. Further,
$← Fp,
= 0.
(13)
as
Note that (13) is about a sum of 2m inner products. For simplicity,
we define {li}i∈[2m] and {ri}i∈[2m] in (7) and (8), and rewrite (13)
i∈[2m]⟨li, ri⟩ = 0. Following a recursive method in [31], the
protocol proceeds in (log m + 1) rounds of interactions (starting
from k = log m and finishing by k = 0). In the k-th round P sends
the commitments to
⟨li, ri+2k⟩,
⟨li+2k, ri⟩,
t–
k =
t+
k =
i=1
(14)
and V responds with a random challenger uk. P then computes
(15)
for the next round. Note how the number of involving vectors is
halved. After the final round, we arrive at two vectors
k · li + uk · ri+m
li ← uk · li + u–1
k · li+m,
ri ← u–1
i=1
2k
l =
zi · li,
r =
z–1
i
· ri,
(16)
2k
2m
i=1
where zi is the i-th element vector z with a binary counting structure
2m
i=1
z =
(cid:169)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:171)
u0u1 . . . ulog m
u–1
0 u1 . . . ulog m
...
u–1
0 u–1
1 . . . u–1
log m
(cid:170)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:172) ,
(17)
(18)
whereas (13) holds iff the following equation
k · t–
k · t+
u2
k + u–2
⟨l, r⟩ =
k
log m
k=0
holds. More details about the reduction is in Appendix B.4.
Theorem 3.1. The protocol in Figure 2 for relation (11) has per-
fect completeness, computational witness-extended emulation and
perfect special honest-verifier zero-knowledge under the discrete
logarithm relation assumption.
Proof for Theorem 3.1 is in Appendix D. By the Fiat-shamir
heuristic, we can convert it into an NIZK argument of knowledge,
which has perfect completeness, computational knowledge soundness
and perfect zero-knowledge in the random oracle model.
3.2 Proof composition
Observe that the construction in Figure 2 starts with P committing
private vj as Vj for j ∈ priv. We may include a subset of Vj for
j ∈ cms where cms ⊂ priv as part of the public input (statement),
and convert the relation of (11) into the form
,
p
(A, B, C) ∈ Fm×m
{vj ∈ Fn
p}j∈pub,
{Vj ∈ G}j∈cms;
{vj ∈ Fn
p}j∈priv,
{𝜈j ∈ Fp}j∈cms

ai =
bi =
ci =

j∈[m] Aijvj,
j∈[m] Bijvj,
j∈[m] Cijvj,
i∈[m] ai ◦ bi = ci ∧
j∈cms Check(pp, Vj, vj, 𝜈j) = 1
.
(19)
It is straightforward to see that relation (19) fits the notion of RCom
for CP-NIZK arguments.
The composable nature of CP-NIZK arguments allows modu-
larly building of arguments for very complex relations by linking
arguments for relatively simpler subroutines. Moreover, in our con-
struction vector vj ∈ Fn
p is arranged to include the assignments
to the same j-th entry for each of the n sub-circuits, which makes
reusing its commitment Vj across different subroutines almost free
of cost. For example, consider the typical MapReduce model for
large-scale data processing, where a map function is applied in
parallel to each chunk of data, and the outputs are aggregated and
fed into a reduce function. The map function itself may contain
many identical subroutines running on shared inputs, or on outputs
of the previous subroutines. Argument in Figure 2 allows modular
proof constructions, where the shared inputs/outputs are commit-
ted once and for all, despite their multiple appearances across the
full computation.
Another promising application is for CNN models in machine
learning context. A CNN is typically aggregated into consecutive
layers, whereas each layer is comprised of an array of identical
neurons. Our argument applies naturally to the intra-layer compu-
tation, and the inter-layer coupling can be solved by simple adaptors
link . Extended discussion on this point can be found in Section 5.
ΠCom
3.3 Performance
The protocol in Figure 2 features a proof size of roughly (m · G +
2n · Fp), counting the commitments Vj and vectors l′, r′. P’s com-
putation is dominated by mn scalar multiplications in G for comm-
mitting vj, and O(nm) multiplications in Fp. On V’s side, the most
expensive operations are to compute T ′, L′ and R′ and to run Verify
procedures for l′, r′, which amounts to (m+n) scalar multiplications
in G and O(nm) multiplications in Fp. We can further squeeze the
proof size down to (m + 2 log n) · G using the reduction technique
in Bulletproofs [11]. The main characteristics are summarised in
Table 2, where for simplicity, only the leading terms are listed.
For better illustration of its performance, in Table 2 we also com-
pare it to two other zero-knowledge argument systems for R1CS,
Groth16 zkSNARK [32], and a non-succinct version of SpartanDL [49].
These two schemes are chosen as two extremes. Groth16 requires
a trusted setup phase, and features an almost optimum proof size
and an extremely efficient verifier. On the contrary, SpartanDL is
discrete logarithmic assumption-based, and it offers arguably the
fastest prover so far among elliptic-curve-based NIZK arguments
for R1CS. For comparison, we assume a data-parallel circuit com-
prised of n sub-circuits, where each sub-circuit is of size m. For
Groth16 and SpartanDL, it is interpreted as a single large circuit of
size mn.
In many aspects, our construction is comparable to SpartanDL.
They both avoid the trusted setup phase required by Groth16. They
offer efficient provers, several times faster than that of Groth16 (con-
sidering that Groth16 needs an elliptic curve that is both pairing-
friendly and fft-friendly while SpartanDL and our construction not,
in practice the difference could be more than 10×). They have sub-
linear verifiers and proof sizes, where those of Groth16 are constant.
For ZKCP, a trusted setup phase is undesirable, the proof size is
usually not a bottleneck, and the system throughput (i.e., amount of
data exchanged end-to-end in unit time span) is jointly determined
Session 11B: Zero Knowledge II CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea3007Construction
Setup type
Groth16
Trusted
SpartanDL
This work
Public
Public
Table 2: Comparison with Groth16 and SpartanDL
Sizes
Time complexity
|𝜎|
3mn
mn
—
√
mn
—
—
n
—
—
|𝜋|
2
1
—
√
mn
—
O(log mn)
m
—
O(log mn)
Prover
4mn
mn
O(mn ∗ log mn)
mn
—
O(mn)
mn
—
O(mn)
G
G2
Fp
G
G2
Fp
G
G2
Fp
Verifier
3 Pairings
—
√
2
mn
—
√
O(
mn)
m + n
—
O(m + n)
by both the prover and the verifier. So SpartanDL and our con-
struction seem to be better choices than Groth16. In the context of
data-parallel computations, we prefer our construction to SpartanDL
for flexible proof compositions and reuse of commitments. We note
that SpartanDL can also be modified into a data-parallel form, but
the details are beyond the scope of the current work.
4 The ZKCPlus protocol
In this section we describe ZKCPlus, an extension of ZKCP, which
focuses on optimizing and scaling up the ZKCP protocol, and adapt-
ing it to practically large-scale data exchange.
4.1 ZKCP revisited
Zero-Knowledge Contingent Payment (ZKCP) protocol tackles the
problem of conducting fair exchange of digital goods and currencies
without any centralized trust. It involves three parties, a seller S, a
buyer B, and a script/smart contract implemented on a blockchain
network acting as an arbiter J. S runs on a private input of digital
good x s.t. for a prescribed predicate 𝜙, 𝜙(x) = 1 holds. B runs on a
private input of digital currency p.
Let Enc be an encryption scheme, H a cryptographic hash func-
tion, and Π an NIZK argument of knowledge. With a polynomial-
time computable predicate 𝜙, a ZKCP protocol generally runs as
follows:
1. Validate & Deliver:
• S on input of digital good x, chooses an encryption key k, and
computes ciphertext z ← Enck(x), hash image (hash-lock) h ←
H(k), and proof 𝜋 ← Π.Prove(𝜎, (z, h), (x, k)) which attests the