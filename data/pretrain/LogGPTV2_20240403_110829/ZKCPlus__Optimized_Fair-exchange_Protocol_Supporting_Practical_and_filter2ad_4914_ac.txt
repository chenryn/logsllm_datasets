### Optimized Text

#### Protocol for Data-Parallel Circuits

**Notation:**
- \(\rho_i\), \(i \in [2m]\)
- \(\tau = \sum_{i \in [2m]} \rho_i\)
- \(r = \sum_{i \in [2m]} \rho_i\)
- \(k \in [0, \log m]\)
- \(u \in F_{2m}^p\)
- \(P: l, r \leftarrow F_n^p\)
- \(s_1 = \langle l, r \circ y^n \rangle + \langle l, r \rangle\)
- \((L_d, \iota_d) \leftarrow \text{Commit}(pp, l)\)
- \((S_1, \sigma_1) \leftarrow \text{Commit}(pp, s_1)\)
- \(s_2 = \langle l, r \circ y^n \rangle\)
- \((R_d, \rho_d) \leftarrow \text{Commit}(pp, r)\)
- \((S_2, \sigma_2) \leftarrow \text{Commit}(pp, s_2)\)

**Protocol Steps:**
1. **Prover (P) to Verifier (V):**
   - \(P\) sends \(L_d, R_d, S_1, S_2\) to \(V\).

2. **Verifier (V) to Prover (P):**
   - \(V\) sends a random challenge \(e \leftarrow F_p\).

3. **Prover (P) to Verifier (V):**
   - \(l' = l + e \cdot l_d\)
   - \(\iota' = \iota + e \cdot \iota_d\)
   - \(r' = r + e \cdot r_d \circ y^n\)
   - \(\rho' = \rho + e \cdot \rho_d\)
   - \(\tau' = \tau + e \cdot \sigma_1 + e^2 \cdot \sigma_2\)
   - \(P\) sends \(l', r', \iota', \rho', \tau'\) to \(V\).

4. **Verification:**
   - \(L' = L_0 + e \cdot L_d\)
   - \(R' = R + e \cdot R_d\)
   - \(T' = \sum_{k=0}^{\log 2m} u_k \cdot T + u^{-2}_k \cdot T\)
   - Check:
     - \(\text{Check}(pp, L', l', \iota') ?= 1\)
     - \(\text{Check}(pp, R', r' \circ y^{-1}, \rho') ?= 1\)
     - \(\text{Check}(pp, T', \langle l, r \rangle, \tau') ?= 1\)

**Equations and Definitions:**
- \((y, y^2, \ldots, y^n)\) is a vector generated by the challenger \(y\).
- The \(m\) equations are combined by another challenger \(w\):
  \[
  \sum_{i \in [m]} w_i \left( \langle a_i, b_i \circ y^n \rangle - \langle c_i, y^n \rangle \right) = 0
  \]
- For simplicity, define \(\{l_i\}_{i \in [2m]}\) and \(\{r_i\}_{i \in [2m]}\) in (7) and (8), and rewrite (13) as:
  \[
  \sum_{i \in [2m]} \langle l_i, r_i \rangle = 0
  \]

**Recursive Method:**
- The protocol proceeds in \(\log m + 1\) rounds of interactions.
- In the \(k\)-th round, \(P\) sends commitments to:
  \[
  t^-_k = \sum_{i=1}^{2k} \langle l_i, r_{i+2k} \rangle, \quad t^+_k = \sum_{i=1}^{2k} \langle l_{i+2k}, r_i \rangle
  \]
- \(V\) responds with a random challenge \(u_k\).
- \(P\) computes:
  \[
  l_i \leftarrow u_k \cdot l_i + u^{-1}_k \cdot l_{i+2k}, \quad r_i \leftarrow u^{-1}_k \cdot r_i + u_k \cdot r_{i+2k}
  \]
- After the final round, we arrive at two vectors:
  \[
  l = \sum_{i=1}^{2m} z_i \cdot l_i, \quad r = \sum_{i=1}^{2m} z^{-1}_i \cdot r_i
  \]
- Where \(z\) is the binary counting structure:
  \[
  z = \begin{pmatrix}
  u_0 u_1 \cdots u_{\log m} \\
  u^{-1}_0 u_1 \cdots u_{\log m} \\
  \vdots \\
  u^{-1}_0 u^{-1}_1 \cdots u^{-1}_{\log m}
  \end{pmatrix}
  \]

**Theorem 3.1:**
- The protocol in Figure 2 for relation (11) has perfect completeness, computational witness-extended emulation, and perfect special honest-verifier zero-knowledge under the discrete logarithm relation assumption.

**Proof:**
- The proof for Theorem 3.1 is in Appendix D.
- By the Fiat-Shamir heuristic, the protocol can be converted into an NIZK argument of knowledge, which has perfect completeness, computational knowledge soundness, and perfect zero-knowledge in the random oracle model.

### Proof Composition

- The construction in Figure 2 starts with \(P\) committing private \(v_j\) as \(V_j\) for \(j \in \text{priv}\).
- A subset of \(V_j\) for \(j \in \text{cms}\) where \(\text{cms} \subset \text{priv}\) can be included as part of the public input (statement).
- The relation (11) is converted into:
  \[
  (A, B, C) \in F_{m \times m}^p, \quad \{v_j \in F_n^p\}_{j \in \text{pub}}, \quad \{V_j \in G\}_{j \in \text{cms}};
  \]
  \[
  \{v_j \in F_n^p\}_{j \in \text{priv}}, \quad \{\nu_j \in F_p\}_{j \in \text{cms}}
  \]
  \[
  a_i = \sum_{j \in [m]} A_{ij} v_j, \quad b_i = \sum_{j \in [m]} B_{ij} v_j, \quad c_i = \sum_{j \in [m]} C_{ij} v_j,
  \]
  \[
  \sum_{i \in [m]} a_i \circ b_i = c_i \land \forall j \in \text{cms} \, \text{Check}(pp, V_j, v_j, \nu_j) = 1
  \]

- Relation (19) fits the notion of RCom for CP-NIZK arguments.
- The composable nature of CP-NIZK arguments allows modular building of arguments for complex relations by linking simpler subroutines.
- Vector \(v_j \in F_n^p\) includes assignments to the same \(j\)-th entry for each of the \(n\) sub-circuits, making reusing its commitment \(V_j\) almost free of cost.
- This is particularly useful in the MapReduce model for large-scale data processing and in CNN models for machine learning.

### Performance

- The protocol in Figure 2 features a proof size of approximately \((m \cdot G + 2n \cdot F_p)\), including commitments \(V_j\) and vectors \(l', r'\).
- \(P\)'s computation is dominated by \(mn\) scalar multiplications in \(G\) for committing \(v_j\) and \(O(nm)\) multiplications in \(F_p\).
- On \(V\)'s side, the most expensive operations are computing \(T', L', R'\) and running Verify procedures, amounting to \((m+n)\) scalar multiplications in \(G\) and \(O(nm)\) multiplications in \(F_p\).
- The proof size can be reduced to \((m + 2 \log n) \cdot G\) using the reduction technique in Bulletproofs [11].

**Comparison:**
- Table 2 compares the protocol to Groth16 zkSNARK [32] and a non-succinct version of SpartanDL [49].
- Groth16 requires a trusted setup phase and offers optimal proof size and efficient verification.
- SpartanDL is based on the discrete logarithmic assumption and offers fast prover times.
- Our construction is comparable to SpartanDL, avoiding the trusted setup phase and offering efficient provers and sub-linear verifiers.

### ZKCPlus Protocol

**ZKCPlus:**
- An extension of ZKCP, focusing on optimizing and scaling up the ZKCP protocol for large-scale data exchange.
- Zero-Knowledge Contingent Payment (ZKCP) protocol involves three parties: a seller \(S\), a buyer \(B\), and a script/smart contract \(J\) on a blockchain network.
- \(S\) runs on a private input of digital good \(x\) such that \(\phi(x) = 1\).
- \(B\) runs on a private input of digital currency \(p\).

**General Steps:**
1. **Validate & Deliver:**
   - \(S\) on input of digital good \(x\), chooses an encryption key \(k\), computes ciphertext \(z \leftarrow \text{Enc}_k(x)\), hash image \(h \leftarrow H(k)\), and proof \(\pi \leftarrow \Pi.\text{Prove}(\sigma, (z, h), (x, k))\) attesting to the correctness of the encrypted good.