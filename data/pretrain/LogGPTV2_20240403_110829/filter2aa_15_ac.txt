；
/*
邮件设置
*/
$kuWebsiteMailType         = "1"
；
$kuWebsiteMailSmtpHost            = "smtp.qq.com"
；
3）安全过滤文件，安全过滤文件对我们做代码审计至关重要，关系到我们挖掘到的可疑点能不能利用，通常命名中有filter、safe、check等关键字，这类文件主要是对参数进行过滤，比较常见的是针对SQL注入和XSS过滤，还有文件路径、执行的系统命令的参数，其他的则相对少见。而目前大多数应用都会在程序的入口循环对所有参数使用addslashes（）函数进行过滤。
private static function _do_query_safe
（
$sql
）
{
      $sql = str_replace
（
array
（
'\\\\'
，
'\\\''
，
'\\"'
，
'\'\''
），
''
，
$sql
）；
      $mark = $clean = ''
；
      if
（
strpos
（
$sql
，
'/'
）
=== false && strpos
（
$sql
，
'#'
）
=== false && strpos
（
$sql
，
'--'
）
=== false && strpos
（
$sql
，
'@'
）
=== false && strpos
（
$sql
，
'`'
）
=== false
）
{
            $clean = preg_replace
（
"/'
（
.+
？）
'/s"
，
''
，
$sql
）；
      } else {
4）index文件，index是一个程序的入口文件，所以通常我们只要读一遍index文件就可以大致了解整个程序的架构、运行的流程、包含到的文件，其中核心的文件又有哪些。而不同目录的index文件也有不同的实现方式，建议最好先将几个核心目录的index文件都简单读一遍。
上面介绍了我们应该注意的部分文件，可以帮助我们更有方向地去读全部的代码，实际上在我们真正做代码审计的时候，经常会遇到各种框架，这时候就会被搞得晕头转向，所以在学习代码审计的前期建议不要去读开源框架或者使用开源框架的应用，先去chinaz、admin5之类的源码下载网站下载一些小应用来读，并且一定要多找几套程序通读全文代码，这样我们才能总结经验，等总结了一定的经验，对PHP也比较熟悉的时候，再去读一些像thinkphp、Yii、Zend Framework等开源框架，才能快速地挖掘高质量的漏洞。
通读全文代码的好处显而易见，可以更好地了解程序的架构以及业务逻辑，能够挖掘到更多、更高质量的逻辑漏洞，一般老手会比较喜欢这种方式。而缺点就是花费的时间比较多，如果程序比较大，读起来也会比较累。
骑士cms通读审计案例
我们已经介绍了代码审计中通读全文代码审计方式的思路，下面我们用案例来说明这种通读方式。
为了方便大家理解，笔者找了一款相对简单容易看懂的应用骑士cms来介绍，版本是3.5.1，具体的审计思路我们在上文中已经有过介绍。
3.2.1.1 查看应用文件结构
首先来看一下骑士cms的大致文件目录结构，如图3-8所示。
图 3-8
首先需要看看有哪些文件和文件夹，寻找名称里有没有带有api、admin、manage、include一类关键字的文件和文件夹，通常这些文件比较重要，在这个程序里，可以看到并没有什么PHP文件，就一个index.php，看到有一个名为include的文件夹，一般比较核心的文件都会放在这个文件夹中，我们先来看看大概有哪些文件，如图3-9所示。
图 3-9
3.2.1.2 查看关键文件代码
在这个文件夹里面我们看到了多个数十K的PHP文件，比如common.fun.php就是本程序的核心文件，基础函数基本在这个文件中实现，我们来看看这个文件里有哪些关键函数，一打开这个文件，立马就看到一大堆过滤函数，这是我们最应该关心的地方，首先是一个SQL注入过滤函数：
function addslashes_deep
（
$value
）
{
    if
（
empty
（
$value
））
    {
        return $value
；
    }
    else
    {
          if
（！
get_magic_quotes_gpc
（））
          {
          $value=is_array
（
$value
）？
array_map
（
'addslashes_deep'
，
$value
）：
mystrip_ tags
（
addslashes
（
$value
））；
          }
          else
          {
          $value=is_array
（
$value
）？
array_map
（
'addslashes_deep'
，
$value
）：
mystrip_tags
（
$value
）；
          }
          return $value
；
    }
}
该函数将传入的变量使用addslashes（）函数进行过滤，也就过滤掉了单引号、双引号、NULL字符以及斜杠，现在我们要记住，在挖掘SQL注入等漏洞时，只要参数在拼接到SQL语句前，除非有宽字节注入或者其他特殊情况，否则使用了这个函数就不能注入了。
再往下走是一个XSS过滤的函数mystrip_tags（），代码如下：
function mystrip_tags
（
$string
）
{
      $string = new_html_special_chars
（
$string
）；
      $string = remove_xss
（
$string
）；
      return $string
；
}
这个函数调用了new_html_special_chars（）和remove_xss（）函数来过滤XSS，就在该函数下方，代码如下：
function new_html_special_chars
（
$string
）
{
      $string = str_replace
（
array
（
'&amp
；
'
，
'&quot
；
'
，
'&lt
；
'
，
'&gt
；
'
），
array
（
'&'
，
'"'
，
''
），
$string
）；
      $string = strip_tags
（
$string
）；
      return $string
；
}
function remove_xss
（
$string
）
{
    $string = preg_replace
（
'/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]+/S'
，
''
，
$string
）；
    $parm1 = Array
（
'javascript'
，
'union'
，
'vbscript'
，
'expression'
，
'applet'
，
'xml'
，
'blink'
，
'link'
，
'script'
，
'embed'
，
'object'
，
'iframe'
，
'frame'
，
'frameset'
，
'ilayer'
，
'layer'
，
'bgsound'
，
'title'
，
'base'
）；
    $parm2 = Array
（
'onabort'
，
'onactivate'
，
'onafterprint'
，
'onafterupdate'
，
'onbeforeactivate'
，
'onbeforecopy'
，
'onbeforecut'
，
'onbeforedeactivate'
，
'onbeforeeditfocus'
，
'onbeforepaste'
，
'onbeforeprint'
，
'onbeforeunload'
，
'onbeforeupdate'
，
'onblur'
，
'onbounce'
，
'oncellchange'
，
'onchange'
，
'onclick'
，
'oncontextmenu'
，
'oncontrolselect'
，
'oncopy'
，
'oncut'
，
'ondataavailable'
，
'ondatasetchanged'
，
'ondatasetcomplete'
，
'ondblclick'
，
'ondeactivate'
，
'ondrag'
，
'ondragend'
，
'ondragenter'
，
'ondragleave'
，
'ondragover'
，
'ondragstart'
，
'ondrop'
，
'onerror'
，
'onerrorupdate'
，
'onfilterchange'
，
'onfinish'
，
'onfocus'
，
'onfocusin'
，
'onfocusout'
，
'onhelp'
，
'onkeydown'