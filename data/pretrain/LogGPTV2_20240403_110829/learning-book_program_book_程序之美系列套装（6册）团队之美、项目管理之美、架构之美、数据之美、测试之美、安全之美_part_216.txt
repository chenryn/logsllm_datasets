替换。
12.4.3声明并发：略缩图阅读器示例
下面我们介绍另一个示例，用来展示这些不同的ThreadWeaver概念
是如何整合在一起的。
它将使用作业、作业复合、资源限制、优先级和依赖关系，完成在
一个GUI程序中展示略缩图像。我们首先来看看实现该功能需要哪
些操作，它们之间有什么依赖关系，用户希望如何展示其结果。该
示例是ThreadWeaver源代码中的一部分。
在该示例中，假定载入某个数码相片的略缩图涉及三个操作：从磁
盘上读取原始文件数据，将原始数据转成大小不变的图像，然后根
据略缩图所需的尺寸进行缩放。可能有人会认为第二和第三步可以
合并成一个，但它不是本练习的目标（不是流式载入图像数据），
并且它将受限于该图像格式能够在载入时进行缩放操作。同时本例
将假定这些图像文件存储在硬盘上。由于每个文件的处理都不会影
响或依赖于其他文件的处理，所以所有文件的处理都是并行的。对
于每个文件的三个处理步骤都是按顺序进行的。
但这并不是全部内容。由于这是一个图形用户界面的示例，还需要
考虑用户的预期。在本示例中，我们假定用户对可视化反馈感兴
趣，也就是希望提供可视的进度提示。当图像可用时，应该尽快地
提供预览，以进度条的形式展示处理进度是一个不错的方法。用户
还希望程序在执行时不会阻塞计算机，例如出现过度的I/O操作。
1218
---
## Page 1220
解决这个问题，可以使用不同的ThreadWeaver工具。首先，每个文
件的处理可以实现为由三个作业组成的序列。这些作业都是很平常
的，它可以作为应用程序中预先准备的作业类工具箱的一部分。作
业包括（其类名与示例源代码是一一对应的）：
FileLoaderJob，用来从文件系统中将一个文件载入内存中。
QImageLoaderJob，用来将图像裸数据转换成Qt应用程序中的内存
图像表示（使应用程序可以访问框架和在应用程序中注册的可用图
像解码器）。
ComputeThumbNailJob，用来执行图像缩放操作，使其大小符合预
览的需要。
这些任务都将添加到JobSequence中，每个这样的序列将添加到
JobCollection中。集合类的复合实现使其与最初的问题十分接近，
因此程序员会感到十分自然和符合规范。这解决了问题的一部分，
也就是不同图像的并行处理，不过它很容易引发其他问题。采用这
种方式声明的ThreadWeaver队列会存在问题，那就是无法避免当开
始处理图像时尝试同时载入所有文件。尽管这是不太妙的，但我们
没有告诉系统其他的处理方式。要确保只有这么多的文件载入操作
同时并始，就需要使用资源药束。其代码类似于：
#include"ResourceRestrictionPolicy.h"
static QueuePolicy*resourceRestriction ()
static ResourceRestrictionPolicy policy (4) :
return&policy:
这些文件载入器只需在在其构造函数中应用该策略即可，如果使用
的是泛化机制，那么则在创建时应用：
1219
---
## Page 1221
fileloader->assignQueuePolicy (resourceRestriction () ) :
但这样仍然没有正确地按预期安排好作业的执行顺序。该队列中可
能最开始只立即启动4个文件载入器，但接下来将载入所有文件并
计算生成预览（这再次将成为不太妙的行为）。在此需要更多的工
具，需要更多的思考，要解决这一问题就将引出优先级。如果用
ThreadWeaver行话来解释这个问题，那就是文件载入器作业优先级
最低，但需要首先执行；图像载入作业优先于文件载入作业，但图
像载入器启动前文件载入作业必须完成；最后，略缩图计算作业的
优先级最高，虽然它依赖于其他两个处理阶段。由于这三个作业已
经放在一个序列中，它可以确保针对每个图像的三个步骤会按顺序
执行，将文件载入器的优先级设置为1，图像载入器的优先级设置
为2，略缩图计算作业的优先级设置为3，这样就可以解决该问题
了。这样，该队列会尽可能快地完成一个略缩图的显示，但在发现
文件载入时间槽可用时仍然不会停正图像的载入作业。由于该问题
主要是I/O的限制，因此意味着显示出所有图像略缩图的总时间只比
从硬盘中载入这些文件的总时间多一点点（当然还有一些其他因
素，如原始图像的分辨率极高）。在任何顺序式的解决方法中，其
行为可能会带来更坏的结果。
大家可能会觉得以上关于该解决方案的描述比较复杂，因此提供一
些源代码可能解释得更清楚。以下就是在用户选择了一组要处理的
图像之后生成相应作业的过程：
m_weaver->suspend () :
for (int index=0: indexresume () :
为了提供正确的进度反馈，在任务添加完成之前将暂停具体的处理
过程。只要一个作业序列处理完成，item对象就将发出一个信号以
更新整个视图。对于每个选中的文件，将会创建一个特定的item对
象，然后它将创建处理一个文件所需的iob对象：
m_fileloader=new FileLoaderJob (fi.absoluteFilePath (),
thi s ) ;
m_fileloader->assignQueuePolicy (resourceRestriction () ) ;
m_imageloader=new QImageLoaderJob (m_fileloader, this) ;
m_thumb=new ComputeThumbNailJob (m_imageloader, this) ;
m_sequence->addJob (m_fileloader) :
m_sequence->addJob (m_imageloader) ;
m_sequence->addJob (m_thumb) ;
weaver->enqueue (m_sequence);
优先级将作为作业对象的虚属性进行设置。要注意这里设置的所有
对象在添加到队列之前是不会执行的，这一点很重要，在本案例
中，只有当显式启动处理过程才会执行。因此创建这些队列和作业
的整个操作过程只需花费很短的时间，程序控制权很快会交还给用
户，一切都不会有什么问题。当预览图像可用时就会马上更新视
图。
12.4.4从并发到调度：如何系统地实现预期的行为
在前一个示例中，展示了如何分析问题以及如何实际地解决它（我
希望这个部分不会令你感到惊讶）。要确保并发处理是用来编写出
更好的程序，而不仅仅是提供一个填充线程的工具。它和调度是不
一样的：调度需要告诉程序将执行什么操作，以及按什么顺序执
行。该方法可以追溯到很早以前的PROLOG编程，有时需要采用相
1221
---
## Page 1223
似的方法进行思考。一旦充分地理解了这一理念，其回报是十分有
益的。
关于核心的Weaver类中的一个设计决策我们还没有谈及。Weaver类
的API有两个互不相关的用户组。内部的Thread对象将访问它并从中
获取要执行的任务，而程序员将使用它来管理其并行操作。为了确
保公共API最小化，在此组合使用了装饰器模式和外观（facade）模
式，以限制了向应用程序并发人员可能公开暴露的公共API的数
量。并且通过PIMPL模式进一步实现了内部实现和API的解耦，它在
KDE所有的API中都是十分常用的。
12.4.5一个疯狂的想法
早在ThreadWeaver开始开发时就提出了该想法，但彻底实现该想法
是不可能的。实际上最主要的障碍是框架的限制：在Q程序库中使
用了高级的隐性共享机制，也就是引用计数。由于这一隐性共享机
制不是线程安全的，传输的每个简单POD（PlainOldData）对象都
是同步点。作者认为这对于用户而言是不切实际的，因此推荐在任
何生产环境中使用Qt3.0所提供的原型。KDEPIM套件的开发人员
（也就是现在负责开发Akonadi的团队）真的认为ThreadWeaver是很
不错的，并且马上将其初始版本引入到了KMail中，一直沿用到现
在。由于已经遇到了ThreadWeaver承诺要解决的许多问题，KMail
的开发者很迫切地采用了它，愿意承受其作者指出的一些缺点，甚
至不顾他表达的一些愿望。
实际上，该程序库的一些未完成版就已经在KDE中获得了应用，当
其发布了beta版本时就使大家纷纷快速地移植到Qt4.0上来。因此它
甚至在KDE4.0并发周期之前就可用了，虽然它仍然是一个不属于
KDElibs的次要模块。在两年的发展过程中，其作者为该程序库做
了许多推介，提供了一些还在改进中的曾经简单或复杂的API。换
句话说，它是一个在寻找问题的解决方案。多数KDE的开发人员需
要时间来了解该程序库，这不仅仅是在理念上的了解，而且是促使
他们回头做些投入甚至重新思考一些架构性结构问题，从而对其软
件产生显著的改进。推进该程序库的发展进程的不是具体的并发人
员需求；而是十分独立地不断发展，因为他相信相关的问题正在日
益严重，同时为KDE4.0平台提供一个好的解决方案是十分重要
的。特别是在2005年的西班牙Malaga召开的Akademy年会之后，越
来越多的程序开始使用ThreadWeaver，包括KOfice、KDevelop等主
流软件，这足以催使其成为KDE4.0主程序库的一部分。
1222
---
## Page 1224
ThreadWeaver为问题提供了一种备选的方法，当程序库作者以及预
期的用户社区并始在其自己的项目中采用它的时候，就逐渐进入了
成熟期，很快也就被提议进入KDE4.0的基础框架。此后社区成员
的态度也就发生了改变，从原来适度的尝试转变成了赞赏其所带来
的效果。这个示例展示了该社区在技术决策方面的有效性，以及将
方法应用于实践时所采用的姿态。如果ThreadWeaver没有通过3～4
年朝着KDE项目方向的努力，那么无疑不会比现在的结果更好。而
这样的努力也包括KMail开发团队的过早采用。如果不是它最终获
得了成功，那么滩以想象基于KDE4.0开发的应用程序能够更好地
处理并发，并且为用户提供更好的体验。
ThreadWeaver后续的主要扩展是添加了能够可视化展示队列活动的
GUI组件，并引入了更多预先定义的作业类。另一个思想是与操作
系统的IPC机制相整合（实现全局资源限制等功能），不过这样的
需求受限于跨平台的障碍。不同操作系统所采用的方法千差万别。
KDE4.0凭借着公认的可用性，获得了广泛的用户。由于
ThreadWeaver并非为KDE定制的，因此它的下一步发展方向
（Freedesktop.org？）还悬而未决。现在，其目标仍然是为应用程
序和桌面坏境开发人员提供可靠的并发调度功能。
第五部分语言与架构
第13章软件架构：面向对象与面向函数
第14章重读经典
第13章软件架构：面向对象与面向函数
Bertrand Meyer
支持函数式编程的主要观点是它能够更好地实现模块化设计。按照
宣扬该方法的书籍中的阐述，特别是通过其针对金融契约的框架示
例，我发现了它与面向对象设计相比的优点和不足。最终的结论
是，面向对象的设计，特别是支持高级例程对象或“代理”（agent）
的现代形式，包含了函数式编程，在保留其优点的同时，又提供了
高层抽象，更好地支持扩展和复用。
13.1概述
1223
---
## Page 1225
“美”作为软件架构的口号，并不是由旁观者来判定的。其实早就存
在一些明确的标准（Meyer，1997）：
可靠性