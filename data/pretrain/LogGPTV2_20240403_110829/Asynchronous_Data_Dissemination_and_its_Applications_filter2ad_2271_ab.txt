in terms of communication. For example, the best known AVSS
protocol without any trusted setup [3] has a communication cost
of ğ‘‚(ğœ…ğ‘›2 log ğ‘›) due to two steps: a RBC on an ğ‘‚(ğœ…ğ‘›)-sized message,
and an all-to-all gossip of ğ‘‚(ğœ… log ğ‘›)-sized polynomial evaluation
proofs. Thus, we need to open the black-box of the RBC protocol
and incorporate additional techniques to improve these primitives.
problem.
In summary, we make the following contributions.
â€¢ We introduce the Asynchronous Data Dissemination (ADD)
â€¢ We design an information-theoretically secure ADD protocol
that tolerates up to 1/3 malicious nodes and has communica-
tion cost ğ‘‚(ğ‘›|ğ‘€|+ğ‘›2) for a message ğ‘€ of size |ğ‘€|. Assuming
a collision-resistant hash function, we can extend this ADD
protocol to tolerate up to 1/2 malicious nodes.
â€¢ We use ADD to design an improved asynchronous reliable
broadcast protocol for a message ğ‘€ with a communication
cost of ğ‘‚(ğ‘›|ğ‘€|+ğœ…ğ‘›2) where ğœ… is the size of the hash.
â€¢ Finally, we use our improved RBC along with additional
techniques to design asynchronous verifiable secret shar-
ing (AVSS), asynchronous complete secret sharing (ACSS),
dual-threshold ACSS, asynchronous distributed key genera-
tion, all with improved communication cost or weaker as-
sumptions comparing to the state-of-the-art solutions.
Paper organization. The rest of the paper is organized as follows.
We describe our system model, introduce notations, and provides
some necessary background Â§2. In Â§3, we formally introduce the
problem of Asynchronous Data Dissemination (ADD) and describe
our solutions to ADD. Next, in Â§4 we describe how we use ADD to
implement reliable broadcast for long messages. We then provide
improved constructions of AVSS ACSS and dual-threshold ACSS
in Â§5. In Â§6 we present lower bound results and show our protocols
are near-optimal. We describe related work in Â§7 and conclude after
a discussion in Â§8.
2 SYSTEM MODEL AND PRELIMINARIES
Cryptographic assumptions. Let G be a group of order ğ‘ where
ğ‘ is a prime number. Let Zğ‘ be the field with integer operations
modulo ğ‘. Throughout the paper, we use hash(Â·) to denote a col-
lision resistant hash function. We will use ğœ… to denote the size of
cryptographic objects, e.g., the length of the hash function output,
the size of a ciphertext of a CPA-secure encryption, or the size of
an element in the group G. These objects may slightly differ in size
Session 10C: Foundations CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2706in practice but they are on the same order; or one can interpret ğœ…
as the largest among them.
Network and adversarial assumptions. We consider an asyn-
chronous network of ğ‘› â‰¥ 3ğ‘¡ + 1 nodes where a malicious adversary
can corrupt up to ğ‘¡ nodes in the network. The corrupted nodes
can deviate arbitrarily from the protocol. The remaining nodes are
honest and strictly adhere to the protocol. We assume every pair
of honest nodes have access to pairwise reliable and authenticated
channel. The network is asynchronous, so the adversary can arbi-
trarily delay or reorder messages between honest nodes, but must
eventually deliver every message.
Error correcting code. Our ADD protocol uses error correcting
codes. For concreteness, we will use the standard Reed-Solomon
(RS) codes [46]. A (ğ‘š, ğ‘˜) RS code in Galois Field F = GF(2ğ‘) with
ğ‘š â‰¤ 2ğ‘ âˆ’ 1, encodes ğ‘˜ data symbols from GF(2ğ‘) into a codeword
of ğ‘š symbols from GF(2ğ‘). Let RSEnc(ğ‘€, ğ‘š, ğ‘˜) be the encoding
algorithm. Briefly, the RSEnc takes as input a message ğ‘€ consisting
of ğ‘˜ symbols, treats it as a polynomial of degree ğ‘˜ âˆ’ 1 and outputs
ğ‘š evaluations of the corresponding polynomial.
Let RSDec(ğ‘˜, ğ‘Ÿ,ğ‘‡ ) be the RS decoding procedure. RSDec takes
as input a set of symbols ğ‘‡ (some of which may be incorrect), and
outputs a degree ğ‘˜ âˆ’ 1 polynomial, i.e., ğ‘˜ symbols, by correcting up
to ğ‘Ÿ errors (incorrect symbols) in ğ‘‡ . It is well-known that RSDec can
correct up to ğ‘Ÿ errors in ğ‘‡ and output the original message provided
that |ğ‘‡ |â‰¥ ğ‘˜ + 2ğ‘Ÿ [38]. Concrete instantiations of RS codes include
the Berlekamp-Welch algorithm [50] and the Gao algorithm [28].
3 ASYNCHRONOUS DATA DISSEMINATION
In this section, we formally define the problem of Data Dissem-
ination. We then provide our solution to the data dissemination
problem in asynchronous network, which we refer to as Asynchro-
nous Data Dissemination (ADD). Finally, we analyze its correctness
and efficiency.
3.1 Problem Statement
Definition 3.1 (Data Dissemination). Given a network of ğ‘› nodes,
of which up to ğ‘¡ could be malicious, let ğ‘€ be a data blob that is the
input of at least ğ‘¡ + 1 honest nodes. The remaining honest nodes
have input âŠ¥. A protocol solves Data Dissemination if it ensures
that every honest node eventually outputs ğ‘€.
Here on, we refer to the honest nodes that start with the message
ğ‘€ as the sender nodes and the honest nodes that start with âŠ¥ as
the recipient nodes.
A simple but important observation is that to solve data dis-
semination in a network with ğ‘¡ malicious nodes, the number of
honest sender nodes must be at least ğ‘¡ + 1. Otherwise, to any honest
recipient node, the set of ğ‘¡ honest senders starting with ğ‘€ are in-
distinguishable from the set of ğ‘¡ malicious nodes claiming to start
with ğ‘€â€² and behaving honestly otherwise. This justifies the initial
condition of at least ğ‘¡ + 1 honest sender nodes.
The simplest data dissemination protocol just has each honest
sender send its input to all other nodes. A recipient node, upon
receiving ğ‘¡ + 1 matching copies of a message ğ‘€, outputs ğ‘€. Since
we begin with ğ‘¡ + 1 honest senders, every recipient node will even-
tually receive ğ‘¡ + 1 identical messages. Furthermore, there will
Let ğ‘€â€² := [ğ‘š1, ğ‘š2, . . . , ğ‘šğ‘›] := RSEnc(ğ‘€ğ‘–, ğ‘›, ğ‘¡ + 1)
Let ğ‘šâˆ—
send âŸ¨DISPERSE, ğ‘š ğ‘— âŸ© to node ğ‘— for every ğ‘— = 1, 2, . . . , ğ‘›
upon receiving ğ‘¡ + 1 identical âŸ¨DISPERSE, ğ‘šğ‘– âŸ© do
Algorithm 1 Pseudocode for node ğ‘– in ADD for ğ‘› = 3ğ‘¡ + 1
1: // encoding phase.
2: input ğ‘€ğ‘–: either ğ‘€ğ‘– = ğ‘€ or ğ‘€ğ‘– = âŠ¥
3: if ğ‘€ğ‘– Ì¸= âŠ¥ then
4:
5: // dispersal phase
6: if ğ‘€ğ‘– Ì¸= âŠ¥ then
ğ‘– := ğ‘šğ‘–
7:
8:
9: else
10:
ğ‘– := ğ‘šğ‘–
11:
12: // reconstruction phase
13: send âŸ¨RECONSTRUCT, ğ‘šâˆ—
14: if ğ‘€ğ‘– Ì¸= âŠ¥ then
15:
16: Let ğ‘‡ := {}
17: For every âŸ¨RECONSTRUCT, ğ‘šâˆ—
18: for 0 â‰¤ ğ‘Ÿ â‰¤ ğ‘¡ do
Wait till |ğ‘‡ |â‰¥ 2ğ‘¡ + ğ‘Ÿ + 1
19:
Let ğ‘ğ‘Ÿ (Â·) := RSDec(ğ‘¡ + 1, ğ‘Ÿ,ğ‘‡ )
20:
if 2ğ‘¡ + 1 elements (ğ‘—, ğ‘) âˆˆ ğ‘‡ satisfy ğ‘ğ‘Ÿ (ğ‘—) = ğ‘ then
21:
output coefficients of ğ‘ğ‘Ÿ (Â·) as ğ‘€ and return
22:
output ğ‘€ and return;
ğ‘— âŸ© received from node ğ‘—, add (ğ‘—, ğ‘šâˆ—
ğ‘— ) to ğ‘‡
// online Error Correction
Let ğ‘šâˆ—
ğ‘– âŸ© to all nodes
not be ğ‘¡ + 1 nodes sending a different message ğ‘€â€² since there are
only ğ‘¡ malicious nodes. The issue with this approach is that it is
not communication efficient. Specifically, this approach has a total
communication cost of ğ‘‚(ğ‘›2|ğ‘€|).
An alternate solution is to have each recipient node request ğ‘€
from the sender nodes, to which an honest sender replies by sending
ğ‘€. Again, the issue is that malicious nodes may redundantly request
ğ‘€ from all honest senders. Since there are ğ‘¡ = Î˜(ğ‘›) malicious nodes
and each malicious node requests ğ‘€ from all honest senders, this
approach also has a total communication cost of ğ‘‚(ğ‘›2|ğ‘€|).
3.2 Our Approach
As mentioned, in this paper, we focus on data dissemination in
an asynchronous network, which we refer to as the Asynchronous
Data Dissemination (ADD) problem. We present two variants of our
ADD protocol. The first variant requires ğ‘¡ < ğ‘›/3 (or equivalently
ğ‘› â‰¥ 3ğ‘¡ + 1) and is information-theoretically secure. The second
variant requires ğ‘¡ < ğ‘›/2 but needs a collision resistant hash function.
Since all the applications we consider in this paper require ğ‘¡ < ğ‘›/3
(due to reasons orthogonal to ADD), we will focus on the ğ‘¡ < ğ‘›/3
variant of our ADD protocol. We present our ADD protocol for
ğ‘¡ < ğ‘›/2 in Appendix B.
Our ADD protocol has three phases: Encoding, Dispersal, and
Reconstruction. Figure 2 illustrates our protocol in a network of
ğ‘› = 4 nodes with ğ‘¡ = 1. We provide the pseudocode of the protocol
for node ğ‘– in Algorithm 1.
Encoding phase. In the encoding phase, every sender (who holds
ğ‘€ Ì¸= âŠ¥) encodes ğ‘€ using a (ğ‘›, ğ‘¡ + 1) Reed-Solomon code, i.e., us-
ing RSEnc(Â·) described in Â§2 (Line 2 âˆ’ 4 in Algorithm 1). The en-
coded message ğ‘€â€² = RSEnc(ğ‘€, ğ‘›, ğ‘¡ + 1) can be written as a vector
ğ‘€â€² = [ğ‘š1, ğ‘š2, . . . , ğ‘šğ‘›] of ğ‘› symbols. Here each symbol ğ‘šğ‘– is of size
Session 10C: Foundations CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2707Figure 2: A example execution of our solution to ADD with 4 nodes {1, 2, 3, 4} among which node 4 is malicious and node 2 does not start with
ğ‘€. As described, after the dispersal phase, node 2 will receive 2 = ğ‘¡ + 1 identical copies of ğ‘š2 from node 1 and 4 and hence will set ğ‘š2 as ğ‘šâˆ—
2. As
a result, after the reconstruction phase, node 2 will receive 3 correct symbols of ğ‘€â€² which is sufficient for reconstructing ğ‘€.
approximately |ğ‘šğ‘–|= |ğ‘€|/(ğ‘¡ + 1) because, after encoding,
= |ğ‘€|
ğ‘¡ + 1
|ğ‘€â€²|= ğ‘›|ğ‘€|
ğ‘¡ + 1 â‡’ |ğ‘€â€²|
ğ‘›
ğ‘— sets ğ‘šâ€²
(1)
Dispersal phase. After encoding ğ‘€ into ğ‘€â€², the senders start the
dispersal phase (Line 5 âˆ’ 10 in Algorithm 1). During the dispersal
phase, every sender sends the message âŸ¨DISPERSE, ğ‘š ğ‘—âŸ© to node ğ‘—. A
recipient node ğ‘—, upon receiving ğ‘¡ +1 matching DISPERSE messages
ğ‘— as its reconstruction symbol ğ‘šâˆ—
for a symbol ğ‘šâ€²
ğ‘— . Each
honest sender node ğ‘– sets ğ‘šğ‘– as its reconstruction symbol ğ‘šâˆ—
ğ‘– .
Reconstruction phase. During the reconstruction phase, every
node ğ‘– sends âŸ¨RECONSTRUCT, ğ‘–, ğ‘šâˆ—
ğ‘– âŸ© to all other nodes. Then, every
recipient node ğ‘—, upon receiving enough symbols, uses the standard
Online Error Correcting (OEC) algorithm from [6] (line 16 âˆ’ 22
in Algorithm 1). Briefly, the OEC algorithm [6] performs up to ğ‘¡
trials of reconstruction. In the ğ‘Ÿ-th trial, the recipient waits until it
receives RECONSTRUCT messages from 2ğ‘¡ + ğ‘Ÿ + 1 nodes and tries to
decode. If the reconstructed polynomial agrees with 2ğ‘¡ + 1 points in
the RECONSTRUCT messages received so far, the recipient outputs the
decoded message; otherwise, it waits for one more RECONSTRUCT
message and tries again.
3.3 Analysis
We will prove that Algorithm 1 solves the ADD problem. Towards
this end, we will first prove that every honest node will hold the
correct reconstruction symbol at the end of the dispersal phase.
Next, we will argue that every honest node successfully reconstructs
the message ğ‘€. Recall that we refer to the nodes that start with
the message ğ‘€ as the sender nodes and the honest nodes that start
with âŠ¥ as the recipient nodes.
Lemma 3.2. After the dispersal phase each honest node ğ‘— holds ğ‘šâˆ—
where ğ‘šâˆ—
ğ‘— is the ğ‘—th coordinate of ğ‘€â€² = RSEnc(ğ‘€, ğ‘›, ğ‘¡ + 1).
ğ‘—
Proof. Recall that RSEnc encoding is deterministic. If node ğ‘— is
a sender, then it trivially holds ğ‘šâˆ—
ğ‘— . Thus, we focus on a recipient
node ğ‘—. No honest node will send DISPERSE for any ğ‘š ğ‘— Ì¸= ğ‘šâˆ—
ğ‘— . Since
node ğ‘— holds ğ‘š ğ‘— only if it receives ğ‘¡ +1 identical DISPERSE messages
for ğ‘š ğ‘—, it will not hold ğ‘š ğ‘— Ì¸= ğ‘šâˆ—
ğ‘— to
node ğ‘—. So node ğ‘— will eventually receive ğ‘¡ + 1 DISPERSE message
for ğ‘šâˆ—
â–¡
ğ‘— . All ğ‘¡ + 1 honest senders send ğ‘šâˆ—
ğ‘— at the end of the dispersal phase.
ğ‘— and will hold ğ‘šâˆ—
Next we will argue that each honest recipient will eventually
recover the message at the end of the reconstruction phase.
Lemma 3.3. At the end of the reconstruction phase of Algorithm 1,