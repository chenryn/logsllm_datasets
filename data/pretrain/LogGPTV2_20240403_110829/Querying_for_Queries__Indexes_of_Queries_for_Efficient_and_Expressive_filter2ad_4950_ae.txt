...
. . .
...
1 · · ·
0
0
0
...
0
0
0
...
0
0
0
...
0
r
0 · · ·
0 · · ·
...
. . .
0 · · ·
0
0
...
...
...
1
0
0
...
0
0
0
...
0
0
1
...
0
 .
k
Viewed in this way, it becomes apparent that we should transpose
Π with respect to its height (k) and depth (p) axes. Doing so yields
′ ∈ Fp×r ×k wherein, for each i = 1, . . . ,p and j = 1, . . . ,k,
a matrix Π
the ith “plane” corresponds to a specific search term zi in which the
vector intersecting the “layer” at depth j holds a positional query
for the jth-best matching block for zi in D. Each server will then
′. To fetch
hold one bucket from a “layer-wise” k-ary encoding of Π
the best k matches for search term zi, the user will simply encode k
copies of the standard basis vector ⃗ei in a t-private k-batch query,
at x = 0, at x = 1, and so on up to x = k − 1. We emphasize that the
user here encodes the same basis vector at each of x = 0, . . . , k − 1.
In a typical k-batch query, encoding multiple copies of the same
basis vector would provide no benefit to the user and would only
unnecessarily reduce the query’s Byzantine robustness. It is also
worth noting that the user can choose to encode just m  1 and let x1, . . . , xℓ ∈ F \ {0, . . . , k −
1} be pairwise distinct scalars. A sequence Π1, . . . , Πℓ ∈ Fp×r of
matrices is an index of k-batch queries for Goldberg’s IT-PIR with
bucket coordinates x1, . . . , xℓ if, for each i = 1, . . . , p, the matrix
...
 πi0
(cid:0) j−xn−1
πi(k−1)
xn −xn−1
· · ·
is a pseudo-permutation matrix, where, for each j ∈ [0 . .k − 1],
πij (cid:66) ⃗ei · ℓ(cid:80)
n=1
(cid:1)
(cid:0) j−x1
xn −x1
Πn ·
(cid:1)
(cid:1)(cid:0) j−xn+1
xn −xn+1
· · ·
(cid:0) j−xℓ
xn −xℓ
(cid:1)
.
We emphasize that indexes of k-batch queries are a special case
of k-batch indexes of queries; hence, Theorem 4.2 implies that t-
private queries through an index of k-batch queries Π are t-private
with respect to Π. In light of this, Theorem 5.2 is just a restatement
of Corollary 4.3.
Theorem 5.2. The construction just described implements t-
private v-Byzantine-robust(m, ℓ)-server IT-PIR for anym ≥ t +2k−1
and v ≤ m −t − 2k + 1.
9
6 RELATED WORK
This section discusses the small body of existing literature on ex-
pressive PIR queries, describing how our new techniques relate to
and differ from those prior works.
Keyword-based PIR queries. A technical report by Chor, Gilboa,
and Naor [7] proposed a mechanism through which users can fetch
blocks privately by specifying keywords of interest. Similar to our
indexes of queries, they accomplish this by augmenting the database
with an auxiliary data structure (a binary search tree, a trie, or a
minimal perfect hash function) intended to help users translate
keyword-based requests into positional PIR queries, which are
ultimately handled by the underlying PIR protocol. Specifically, the
user employs positional queries to obliviously traverse the auxiliary
data structure (which, for tree-based data structures, may require
many iterative queries) in order to learn the physical location within
the database of some record of interest, which it eventually fetches
using a final positional PIR query over the actual data.
In contrast to keyword-based PIR, indexes of queries let users
fetch data in a single round of interaction and they do not reveal any
information about the structure and layout of the underlying data
set. Indeed, the communication and computation costs incurred
while fetching records via an index of queries are decoupled from
the number of blocks in the database and are, in fact, upper bounded
by the cost of a positional PIR query over the database (such as the
one occurring in the last step of Chor et al.’s scheme).
SQL-based PIR queries. Olumofin and Goldberg [21] extended
Chor et al.’s approach to a scheme enabling users to fetch blocks
privately using simple SQL queries filtered by WHERE or HAVING
clauses. Similar to indexes of batch queries, Olumofin and Goldberg
accomplish this by having the database operator prepare (perhaps
several) inverted indexes that map sensitive search criteria to the
physical locations of associated blocks in the database. Also similar
to our approach, their technique may leak some information about
which blocks a user seeks, as it hides the sensitive search terms
that appear in a query but not the overall “shape” of the query.
Of course, because Olumofin and Goldberg’s construction di-
rectly build on keyword-based PIR, the differences we highlighted
above also differentiate our approach from theirs. Moreover, al-
though a single SQL query in their model may return a batch con-
sisting of several records, this comes at a cost of requiring the user
to perform multiple positional queries against the underlying data-
base (indeed, the user must always perform a number of queries
corresponding to the maximum possible size of a response, so as to
avoid leaking information about the actual size of the response);
indexes of batch queries, by contrast, can return such batches in a
single response using only a single query (and without leaking the
size of the response).
PIR from function secret sharing.
In terms of functionality, our
proposal is most directly comparable to the recent PIR protocols
based on Boyle, Gilboa, and Ishai’s function secret sharing (FSS) [3–
5]. FSS provides a way for clients to split certain functions f into
pairs of “function shares”, which are themselves functions that
can be evaluated at an input x to produce additive shares of f(x).
This enables the construction of expressive 2-server protocols with
which users can fetch records privately using any search criteria
expressible as a polynomial sized branching program. (FSS construc-
tions that split functions into ℓ-tuples for ℓ > 2 have also been
proposed, thus yielding analogous ℓ-server PIR protocols, but these
constructions are dramatically less efficient and require stronger
computational assumptions compared to the 2-party construction.)
In contrast to our index-of-queries approach, FSS permits key-
word searches without any need for the server to prepare auxiliary
data structures. However, this added flexibility comes at a cost
of stronger security assumptions and a (potentially) higher com-
putation cost. Specifically, unlike the information-theoretic PIR
underlying our approach, existing PIR protocols based on (2-party)
FSS schemes (i) require a comparatively stronger non-collusion
assumption (i.e., that there exists a pair of servers who may not
collude), (ii) provide only computational security even when this
maximally strong non-collusion assumption holds, and (iii) neces-
sarily incur computational cost comparable to the upper bound on
that of our index-of-queries approach.
SQL-based PIR queries from FSS. A recent paper of Wang, Yun,
Goldwasser, Vaikuntanathan, and Zaharia [27] proposed Splinter, a
system that employs function secret sharing to support a range of
queries comparable to those supported by Olumofin and Goldberg’s
SQL-based approach. Splinter provides both the best and worst of
both worlds: on one hand, Splinter supports a similar set of queries
as SQL-based PIR with improved performance (by replacing many
recursive PIR-by-keyword queries with single-round FSS queries);
on the other hand, it leaks the shape of queries (á la SQL-based
PIR) and requires both computational assumptions and rigid non-
collusion assumptions (á la FSS-based PIR).8
Despite the above benefits of indexes of queries over existing
keyword-, and SQL-, and function secret sharing-based PIR ap-
proaches, there exist use cases in which the latter are more useful—
each approach facilitates fundamentally different classes of inter-
actions. Indeed, it is not obvious how to realize efficient keyword-
based queries using indexes of queries alone, as this would require
users to somehow learn which rows in the index correspond to
which keywords. For instance, returning to our running private-
inbox-queries example, we note that while many casual interactions
with an email client leverage only the views naturally support-
able with indexes of queries, users can and do frequently rely on
keyword-based searches to locate emails of interest. Thus, an ac-
tual private email client would benefit from simultaneous support
for both indexes of queries and keyword- or SQL-based queries.
Fortunately, because none of the three approaches require any mod-
ification to the underlying database, no technical challenges prevent
the servers from supporting all of them at the same time.
8Wang et al. assert that Olumofin and Goldberg’s SQL-based PIR “requires all the
providers to be honest” [27, §8.2]; however, this claim is false. Indeed, Olumofin
and Goldberg provide the same degree of flexibility as our indexes of queries in
choosing security assumptions: the default instantiation is unconditionally private
provided at most t out of ℓ servers collude, for any choice of t ≤ ℓ including, e.g.,
ℓ = t − 1. (By contrast, existing FSS schemes, including those used by Splinter, only
support t = ℓ − 1 and, even then, only provide computational privacy against smaller
coalitions.) Moreover, one can employ either computational or hybrid PIR in Olumofin
and Golberg’s framework, thus providing computational privacy when all servers
collude and, indeed, even allowing the protocol to run with a single server. This can be
accomplished under a wide variety of computational assumptions, including Paillier’s
decisional composite residuosity assumption (DCRA) or standard lattice assumption.
Finally, setting t < ℓ − 1 allows the former scheme to provide some level of Byzantine-
robustness, which equates to better liveness and potential mitigation of active attacks
by small coalitions of servers.
10
Queries / second (r varies; p = 214; u = 4)
215
213
211
d
n
o
c
e
s
/
s
e
i
r
e
u
q
214
216
218
220
number of columns (r )
(a) 4-batch query throughput on an Nvidia Tesla K20 GPU Accelerator (massively parallel)
Queries / second (r varies; p = 214; u = 4)
213
29
d
n
o
c
e
s
/
s
e
i
r
e
u
q
25
214
216
218
220
number of columns (r )
(b) 4-batch query throughput on an Intel Core i5-2500 CPU @ 3.30GHz (single-threaded)
(cid:1)
(cid:1)
28
GF
216
GF
q ≈ 2128
q ≈ 2256
q ≈ 2512
(cid:0)
(cid:0)
(cid:0)
(cid:0)
(cid:1)
(cid:1)
28
GF
216
GF
q ≈ 2128
q ≈ 2256
q ≈ 2512
Figure 2: Number of 4-batch index of queries requests our implementation can process per second. Figure 2(a)
depicts the counts for a massively parallel implementation on an Nvidia Tesla K20 GPU Accelerator; Figure 2(b)
depicts the same counts for a single-threaded implementation on an Intel Core i5-2500 CPU. Each experiment
was repeated for 100 trials; we report here the mean number of requests per second. Error bars are omitted due
to their small size (all standard deviations were below 2% of the mean).
7 IMPLEMENTATION AND EVALUATION
All three variants of indexes of queries introduced in this paper
yield sparse matrices; thus, querying through an index of queries
is an instance of sparse matrix-vector (SpMV) multiplication, an
embarrassingly parallelizable workload that is particularly well
suited to implementation on a massively parallel compute platform,
such as a general-purpose GPU device.
In order to empirically gauge the practicality of our indexes-of-
queries approach, we implemented finite-field SpMV multiplication
and ran a series of experiments both on an Nvidia Tesla K20 GPU
Accelerator [9] and on an Intel Core i5-2500 CPU. Both implemen-