### Inter-Field Dependencies and Parsing Complexity

Inter-field dependencies, such as variable-length data, introduce complexity in parsing. In such cases, the starting offset of a field in a message is determined by the lengths of preceding fields, making the parsing process data-dependent. Consequently, parsers must often traverse many or all of the preceding fields to correctly interpret the message. Although this is less complex than a full parse, it still requires examining the lengths and values of structure-dependent fields.

### Binary Protocols and Traversers

Binary protocols are more heavily structured compared to text protocols, necessitating a parsing primitive that is both aware of the structure and maintains high performance. We refer to this type of parser as a binary traverser. Designing an efficient binary protocol traverser is challenging due to the lack of a common standard in binary protocol designs. Our study of common binary protocols revealed frequent use of constructs like C structures, arrays, length-prefixed buffers, sentinel-terminated buffers, and field-driven case evaluation (switch). The binpac protocol parser generator uses these constructs as building blocks for creating protocol parsers. While binpac has sufficient expressive power to generate parsers for complex binary protocols, it performs a full protocol parse rather than a simple binary traversal. We modified binpac to improve its performance for traversal tasks.

### Minimal Parsing and State Management

We reduced the overhead of original binpac parsers by optimizing state management and skipping the parsing of unimportant fields. Binpac carefully separates the duties of the protocol parser and the traffic analysis system, allowing us to port binpac specifications written for the Bro IDS to our system. We retained the protocol semantics and structure from the Bro versions but used our own system for managing state and expressing constraints. By optimizing binpac for traversal rather than full parsing, we achieved substantial performance improvements. Additionally, the binpac language provides exceptional expressiveness for a wide range of protocols, facilitating easier deployment on new protocols.

### Protocol Structure Flattening and Vulnerability Matching

Flattening the protocol structure allows us to ignore parts of a message that do not directly influence proper processing or vulnerability matching. However, some protocols are heavily recursive and cannot be fully flattened without significantly reducing match precision. We argue that it is rarely necessary to parse every field and structural construct of a protocol message to match a vulnerability. For example, consider an XML vulnerability in the skin processing of Trillian (CVE-2002-2366 [10]). An attacker can gain control by passing an over-length string in a file attribute, leading to a buffer overflow. Only the file attribute in the prefs/control/colors entity can trigger the vulnerability, while other instances of file in different entities are not vulnerable. To match this vulnerability, the signature author can use a minimal recursive parser that tracks only the entity open and close tags. The matcher can use a stack of currently open tags to determine if it is in the prefs/control/colors entity and match the file attributes causing the buffer overflow. This approach provides higher performance than a full parser while requiring more state management.

In rare cases, full protocol parsing may be necessary to match a vulnerability signature. Our system is designed to enhance the performance of simpler vulnerability signatures but can still generate high-performance full recursive parsers. The drawback is that the user must manage the parser state manually, which can be error-prone.

### Integration with Prior Work

While our system does not address protocol detection, it can be integrated with prior work [15] in an earlier stage of the intrusion detection system.

### Example Specification: HTTP Requests

```cpp
parser HTTP Request {
    dispatch() %{
        deploy(vers);
        deploy(ispost);
        deploy(crlf);
    }%
    
    int vers = str_matcher "HTTP/1.";
    handler handle_vers() %{
        end = next_whitespace(rest);
        to_int(rest, end);
        vers = str;
    }%
    handle_vers() %{
        // handle differently depending on version...
    }%
    
    bool ispost = str_matcher "POST";
    handler handle_post() %{
        ispost = true;
    }%
    handle_post() %{
        if (ispost) {
            deploy(content_length);
        }
    }%
    
    int content_length = str_matcher "Content-Length:";
    handler handle_cl() %{
        end = next_content_line(rest);
        length = str_to_int(rest, end);
    }%
    handle_cl() %{
        if (this->content_length) {
            // process content length
        } else {
            deploy(body);
        }
    }%
    
    handler handle_body() %{
        // process body using another layer
    }%
}
```

### High-Speed Matching Primitives

The high-speed matching primitives used by VESPA can also be used to match protocol detection signatures.

### Language and Matcher Primitives

We have developed a vulnerability signature expression language for our system. Writing a signature involves specifying matchers for the core fields of the protocol message and additional matchers to locate the vulnerability. Each protocol message is specified using a parser type, which the code generator maps to a C++ class containing each state field as a member variable. Inside a message parser, the signature author defines handler function declarations and field variable declarations with matching primitives. Additional member variables can be specified using `member vars %{ ... }%`.

Each underlying matching primitive searches for all requested strings and fields. For example, an HTTP matcher might search for "Content-Type:" even though it should only be expected in certain cases. This allows the primitive matcher to run in parallel with the state machine and constraint evaluation, though this feature is not yet implemented. It also prevents the need to backtrack to parse a newly desired field. We provide a utility to track which fields the matcher should expect and extract, controlled using the `deploy(var)` function. This function marks a variable as expected in a state mask stored inside the parser, causing the matcher to execute the variable extraction function and handler when matched.

### Matcher Primitives

There are three types of matching primitives:

1. **String Matcher (str_matcher)**: Matches a string or sequence of strings separated by `||`. It supports matching multiple semantically identical strings.
2. **Binary Traversal Primitive (bin_matcher)**: Uses a binpac specification file and record type to extract a specific field.
3. **Extended Matcher**: Allows additional extractions after matching a single string or binary field, useful for embedded fields and different extraction functions based on the expected state.

### Extraction Functions

Each variable match specifies an extraction function within `{% ... %}`. Helper functions are provided for string conversion and whitespace elimination. In a string matcher extraction function, the `rest` and `end` variables are predefined. `rest` points to the first byte of input after the matched string, and `end` allows storing the extraction endpoint. Extended matchers run immediately following the extraction function of the string matcher they depend on, in the same context.

### Handler Functions

Each matcher can have an associated handler function executed after extraction, only if the matcher is active. The handler function is defined using C++ code and can call `deploy` to enable additional matchers. Handler bodies are where vulnerability constraints can be expressed. While we do not yet address the reporting mechanism, any C++ code can be used in the handler, such as exceptions or integer codes. Handlers can also pass portions of a protocol message to another parser for layering and encapsulation.

### Implementation

#### Compiler

We designed a compiler to generate machine-executable vulnerability signature matchers from our language, implemented in Perl. The compiler leverages the "Higher Order Perl" Lexer and Parser classes, keeping the implementation complexity low. The entire compiler is 600 lines, with approximately 70% specifying the lexical and grammatical structures of our language, and the rest handling symbol rewriting, I/O stream management, and C++ syntax.

Our compiler operates on a single parser file (e.g., `myparser.p`), which defines a complete protocol parser.