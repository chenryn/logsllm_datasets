based on inter-ﬁeld dependencies (e.g., variable-length data, where the starting offset
of a ﬁeld in a message varies based on the length of earlier ﬁelds), making parsing data-
dependent. Thus, parsers must often traverse many or all of the preceding ﬁelds. This
is still simpler than a full parse, since the parser only examines the lengths and values
of structure-dependent ﬁelds.
Since binary protocols are more heavily structured than text protocols, we need a
matching primitive that is sufﬁciently aware of this structure while still maintaining
high performance. We call this type of parser a binary traverser.
Designing an efﬁcient binary protocol traverser is difﬁcult because binary protocol
designs do not adhere to any common standard. In our study of many common binary
protocols, we found that they most often utilize the following constructs: C structures,
High-Speed Matching of Vulnerability Signatures
161
arrays, length-preﬁxed buffers, sentinel-terminated buffers, and ﬁeld-driven case evalu-
ation (switch). The binpac protocol parser generator uses variations on these constructs
as building blocks for creating a protocol parser. We found binpac to have sufﬁcient
expressive power to generate parsers for complex binary protocols. However, binpac
parsers perform a full protocol parse rather than a simple binary traversal, so we use a
modiﬁcation to improve their performance.
Minimal Parsing and State Management. We reduced overhead of original binpac
parsers for state management and skipped parsing unimportant ﬁelds. Because binpac
carefully separates the duties of the protocol parser and the trafﬁc analysis system which
uses it, we were able to port binpac speciﬁcations written for the Bro IDS to our sys-
tem. We retain the protocol semantics and structure written in the Bro versions but use
our own system for managing state and expressing constraints. While we feel that ad-
ditional improvements may be made in generating fast binary traversers, we were able
to obtain substantial improvements in the performance of binpac by optimizing it to the
task of traversal rather than full parsing. Furthermore, the binpac language provides ex-
ceptional expressiveness for a wide range of protocols, allowing our system to be more
easily deployed on new protocols.
3.3 Discussion
By ﬂattening the protocol structure, we can ignore any part of a message which does not
directly inﬂuence properly processing the message or matching a speciﬁc vulnerability.
However, some protocols are heavily recursive and may not be ﬂattened completely
without signiﬁcantly reducing match precision. We argue that it is rarely necessary to
understand and parse each and every ﬁeld and structural construct of a protocol mes-
sage to match a vulnerability. Consider an XML vulnerability in the skin processing of
Trillian (CVE-2002-2366 [10]). An attacker may gain control of the program by passing
an over-length string in a file attribute, leading to a traditional buffer overﬂow. Only
the file attribute, in the prefs/control/colors entity can trigger the vulnerability,
while instances of file in other entities are not vulnerable. To match this vulnerability
with our system, the signature author can use a minimal recursive parser which only
tracks entity open and close tags. The matcher can use a stack of currently open tags
to tell whether it is in the prefs/control/colors entity and match file attributes
which will cause the buffer overﬂow. The generated parser is recursive but only for the
speciﬁc ﬁelds that are needed to match the vulnerability. This type of signature is a
middle-ground for our system—it will provide higher performance than a full parser
while requiring the user to manipulate more state than a simpler vulnerability.
In rare cases it may be necessary to do full protocol parsing to properly match a
vulnerability signature. While our system is designed to enhance the performance of
simpler vulnerability signatures, it is still able to generate high-performance full recur-
sive parsers. The drawback to our approach versus binpac or GAPA in this situation is
that the user must manage the parser state manually, which may be error prone.
We do not yet address the problem of protocol detection. However, our system can
be integrated with prior work [15] in an earlier stage of the intrusion detection system.
162
N. Schear, D.R. Albrecht, and N. Borisov
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
pa r s e r HTTP Request {
d i s p a t c h ( ) %{
d e p l o y ( v e r s ) ;
d e p l o y ( i s p o s t ) ;
d e p l o y ( c r l f ) ;
}%
i n t v e r s = s tr ma tc he r " HTTP /1."
handler h a n d l e v e r s ( )
%{
end = n e x t w h i t e s p a c e ( r e s t ) ;
t o i n t ( r e s t , end ) ;
v e r s = s t r
}%
h a n d l e v e r s ( ) %{
/ / h a n d l e d i f f e r e n t l y d e p e n d i n g on v e r s i o n . . . }%
b o o l
i s p o s t = s tr ma tc he r " POST "
handler h a n d l e p o s t ( )
%{
i s p o s t = t r u e ;
}%
h a n d l e p o s t ( ) %{
i f ( i s p o s t ) { d e p l o y ( c o n t e n t
l e n g t h ) ;
}
}%
i n t
c o n t e n t
l e n g t h = s tr ma tc he r " Content - Length :"
handler h a n d l e c l ( )
%{
end = n e x t
c o n t e n t
l i n e ( r e s t ) ;
l e n g t h = s t r
t o i n t ( r e s t , end ) ;
}%
h a n d l e c l ( ) %{
i f ( t h i s −>c o n t e n t
e l s e
{ d e p l o y ( body ) ; }
}%
l e n g t h c o n t e n t
s t o p M a c h i n e ( ) ;
}%
l e n g t h ) ;
h a n d l e b o d y ( ) %{
/ / p r o c e s s body u s i n g a n o t h e r
l a y e r
}%
}
Fig. 1. Sample Speciﬁcation for HTTP Requests (simpliﬁed)
Furthermore, the high-speed matching primitives used by VESPA may also be used to
match protocol detection signatures.
4 Language
We have developed a vulnerability signature expression language for use with our sys-
tem. We give an example vulnerability speciﬁcation for the CUPS negative content
length vulnerability in Figure 1.
Writing a signature involves specifying the matchers for the core ﬁelds of the pro-
tocol message and then specifying additional matchers to locate the vulnerability. We
specify a single protocol message using a parser type. The code generator maps this
message parser to a C++ class that will contain each state ﬁeld as a member variable.
Inside a message parser, the vulnerability signature author deﬁnes handler function
declarations and ﬁeld variable declarations with matching primitives. The author can
specify additional member variables that are not directly associated with a matcher us-
ing member vars %{ ... }%.
Each underlying matching primitive always searches for all the requested strings
and ﬁelds with which the matcher is initialized. For example, an HTTP matcher might
High-Speed Matching of Vulnerability Signatures
163
search for “Content-Type:” in a message even though this string should only be ex-
pected in certain cases. This allows the primitive matcher to run in parallel with the
state machine and constraint evaluation, though we have not yet implemented this. It
also prevents the matching primitives from needing to back up to parse a newly de-
sired ﬁeld. We provide a utility for keeping track of which ﬁelds the matcher should
expect and perform extraction and which to ignore. This state is controlled using the
deploy(var) function. This function may be called from any handler function, and
initially by the dispatch function. deploy marks a variable as expected in a state mask
stored inside the parser. This will cause the matcher to execute the variable extraction
function and handler when it is matched. A handler function may in turn enable ad-
ditional matchers (including re-enabling itself) using the deploy function. The parser
ignores any primitive match that is not set to be active using deploy.
The parser automatically calls the dispatch function each time the parser starts
parsing a new protocol message. This allows the author to deﬁne which ﬁelds should
be matched from the start of parsing. It also allows the initialization of member vari-
ables created using member vars. Conversely, the parser automatically calls destroy
to allow any resources allocated in dispatch to be freed.
4.1 Matcher Primitives
Protocol ﬁelds and matcher primitives are the heart of a vulnerability speciﬁcation. The
format of matcher primitive speciﬁcation is:
var_type symbol = matching_primitive meta-data
handler handler_func_name()
%{
// embedded C++ code to extract the value
}%
The var type speciﬁes the storage type of the ﬁeld; e.g., uint32. The symbol is the
name of the ﬁeld that will be stored as a member of the C++ parser class. There are
three types of matching primitives.
1. str matcher (string matcher primitive): The meta-data passed to this matcher are a
string or sequence of strings separated by ||, and this instructs the underlying multi-
string matching engine to match this string and then execute its extraction function.
It supports matching multiple different strings that are semantically identical using
or (“||”).
2. bin matcher (binary traversal primitive): The meta-data passed to this matcher are
the ﬁle name of a binpac speciﬁcation. This is followed by a colon and the name of a
binpac record type. The meta-data end with the name of a ﬁeld inside that record
that the author wishes to extract (e.g., IPP.binpac: IPP Message.version num). The
generated binpac parser will then call back to our system to perform the extraction
and run the handler for the requested ﬁeld.
3. extended matcher (extension to another matcher): This construct allows us to
perform additional extractions after matching a single string or binary ﬁeld. This is
often useful when multiple ﬁelds are embedded after a single match. It also allows
164
N. Schear, D.R. Albrecht, and N. Borisov
the author to specify a different extraction function depending on which state is
expected. The meta-data passed to this primitive are the name of another variable
that uses a standard matching primitive.
Each variable match also speciﬁes an extraction function within braces, %{ and }%,
which extracts a relevant ﬁeld from the message. We have provided a number of helper
functions that the author can use in the extraction function, such as string conversion
and white space elimination. In a string matcher extraction function, there are two pre-
deﬁned variables the signature author can use and modify: rest and end. The rest
variable points to the ﬁrst byte of input after the string that was matched. The parser also
deﬁnes end, which allows the extraction function to store where the extraction ends. Ex-
tended matchers run immediately following the extraction function of the string matcher
on which they depend and in the same context. Hence, any changes to the state of rest
and end should be carefully accounted for in extended matcher extraction functions.
There are two additional functions that the author can use inside the extraction func-
tion of a string matcher: stopMachine() and restartMachine(ptr). These func-
tions suspend and restart pattern matching on the input ﬁle. This is useful, for example,
to prevent the system from matching spurious strings inside the body of an HTTP mes-
sage. The restartMachine(ptr) function restarts the pattern matching at a new offset
speciﬁed by ptr. This allows the matcher to skip portions of the message.
4.2 Handlers
Each matcher may also have an associated handler function. The handler function is
executed after the extraction and only if the matcher is set to be active with deploy. The
signature author deﬁnes the body of the handler function using C++ code. In addition
to calling the deploy function, handler bodies are where vulnerability constraints can
be expressed. We do not yet address the reporting mechanism when a vulnerability is
matched. However, since any C++ code may be in the handler, the author may use a
variety of methods, such as exceptions or integer codes. The author may also use the
handler functions to pass portions of a protocol message to another parser to implement
layering and encapsulation.
While structurally different from existing protocol parser generators like GAPA and
binpac, our language is sufﬁciently expressive to model many text and binary protocols
and vulnerabilities. Porting a protocol speciﬁcation from an RFC or an existing spec
in another language (like binpac or GAPA) is fairly straightforward once the author
understands the protocol semantics.
5 Implementation
5.1 Compiler
We designed a compiler to generate machine-executable vulnerability signature match-
ers from our language. We implemented the compiler using the Perl programming lan-
guage. Our implementation leverages the “Higher Order Perl” [16] Lexer and Parser
classes, which kept down the implementation complexity: the entire compiler is 600
High-Speed Matching of Vulnerability Signatures
165
lines. Approximately 70% of the compiler code speciﬁes the lexical and grammatical
structures of our language; the balance performs symbol rewriting, I/O stream manage-
ment, and boilerplate C++ syntax.
Our compiler operates on a single parser ﬁle (e.g., myparser.p), which deﬁnes a