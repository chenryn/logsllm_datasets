---
author: Alex Chadwick
category: 树莓派
comments_data: []
count:
  commentnum: 0
  favtimes: 0
  likes: 0
  sharetimes: 0
  viewnum: 5787
date: '2019-03-04 00:52:41'
editorchoice: false
excerpt: 屏幕03 课程基于屏幕02 课程来构建，它教你如何绘制文本，和一个操作系统命令行参数上的一个小特性。
fromurl: https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen03.html
id: 10585
islctt: true
largepic: /data/attachment/album/201903/04/005129uyaaimyug6jzy3jz.jpg
permalink: /article-10585-1.html
pic: /data/attachment/album/201903/04/005129uyaaimyug6jzy3jz.jpg.thumb.jpg
related:
- displayorder: 0
  raid: 10551
- displayorder: 0
  raid: 10605
reviewer: wxy
selector: lujun9972
summary: 屏幕03 课程基于屏幕02 课程来构建，它教你如何绘制文本，和一个操作系统命令行参数上的一个小特性。
tags:
- 树莓派
thumb: false
title: 计算机实验室之树莓派：课程 8 屏幕03
titlepic: true
translator: qhwdw
updated: '2019-03-04 00:52:41'
---
![](/data/attachment/album/201903/04/005129uyaaimyug6jzy3jz.jpg)
屏幕03 课程基于屏幕02 课程来构建，它教你如何绘制文本，和一个操作系统命令行参数上的一个小特性。假设你已经有了[课程 7：屏幕02](/article-10551-1.html) 的操作系统代码，我们将以它为基础来构建。
### 1、字符串的理论知识
是的，我们的任务是为这个操作系统绘制文本。我们有几个问题需要去处理，最紧急的那个可能是如何去保存文本。令人难以置信的是，文本是迄今为止在计算机上最大的缺陷之一。原本应该是简单的数据类型却导致了操作系统的崩溃，从而削弱其他方面的加密效果，并给使用其它字母表的用户带来了许多问题。尽管如此，它仍然是极其重要的数据类型，因为它将计算机和用户很好地连接起来。文本是计算机能够理解的非常好的结构，同时人类使用它时也有足够的可读性。
那么，文本是如何保存的呢？非常简单，我们使用一种方法，给每个字母分配一个唯一的编号，然后我们保存一系列的这种编号。看起来很容易吧。问题是，那个编号的数量是不固定的。一些文本段可能比其它的长。保存普通数字，我们有一些固有的限制，即：32 位，我们不能超过这个限制，我们要添加方法去使用该长度的数字等等。“文本”这个术语，我们经常也叫它“字符串”，我们希望能够写一个可用于可变长度字符串的函数，否则就需要写很多函数！对于一般的数字来说，这不是个问题，因为只有几种通用的数字格式（字节、字、半字节、双字节）。
> 
> 可变数据类型（比如文本）要求能够进行很复杂的处理。
> 
> 
> 
因此，如何判断字符串长度？我想显而易见的答案是存储字符串的长度，然后去存储组成字符串的字符。这称为长度前缀，因为长度位于字符串的前面。不幸的是，计算机科学家的先驱们不同意这么做。他们认为使用一个称为空终止符（`NULL`）的特殊字符（用 `\0` 表示）来表示字符串结束更有意义。这样确定简化了许多字符串算法，因为你只需要持续操作直到遇到空终止符为止。不幸的是，这成为了许多安全问题的根源。如果一个恶意用户给你一个特别长的字符串会发生什么状况？如果没有足够的空间去保存这个特别长的字符串会发生什么状况？你可以使用一个字符串复制函数来做复制，直到遇到空终止符为止，但是因为字符串特别长，而覆写了你的程序，怎么办？这看上去似乎有些较真，但是，缓冲区溢出攻击还是经常发生。长度前缀可以很容易地缓解这种问题，因为它可以很容易地推算出保存这个字符串所需要的缓冲区的长度。作为一个操作系统开发者，我留下这个问题，由你去决定如何才能更好地存储文本。
> 
> 缓冲区溢出攻击祸害计算机由来已久。最近，Wii、Xbox 和 Playstation 2、以及大型系统如 Microsoft 的 Web 和数据库服务器，都遭受到缓冲区溢出攻击。
> 
> 
> 
接下来的事情是，我们需要确定的是如何最好地将字符映射到数字。幸运的是，这是高度标准化的，我们有两个主要的选择，Unicode 和 ASCII。Unicode 几乎将每个有用的符号都映射为数字，作为代价，我们需要有很多很多的数字，和一个更复杂的编码方法。ASCII 为每个字符使用一个字节，因此它仅保存拉丁字母、数字、少数符号和少数特殊字符。因此，ASCII 是非常易于实现的，与之相比，Unicode 的每个字符占用的空间并不相同，这使得字符串算法更棘手。通常，操作系统上字符使用 ASCII，并不是为了显示给最终用户的（开发者和专家用户除外），给终端用户显示信息使用 Unicode，因为 Unicode 能够支持像日语字符这样的东西，并且因此可以实现本地化。
幸运的是，在这里我们不需要去做选择，因为它们的前 128 个字符是完全相同的，并且编码也是完全一样的。
表 1.1 ASCII/Unicode 符号 0-127
|  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | a | b | c | d | e | f |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 00 | NUL | SOH | STX | ETX | EOT | ENQ | ACK | BEL | BS | HT | LF | VT | FF | CR | SO | SI |  |
| 10 | DLE | DC1 | DC2 | DC3 | DC4 | NAK | SYN | ETB | CAN | EM | SUB | ESC | FS | GS | RS | US |  |
| 20 | ! | “ | # | $ | % | & | . | ( | ) | \* | + | , | - | . | / |  |  |
| 30 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | : | ; |  | ? |  |
| 40 | @ | A | B | C | D | E | F | G | H | I | J | K | L | M | N | O |  |
| 50 | P | Q | R | S | T | U | V | W | X | Y | Z | [ | \ | ] | ^ | \_ |  |
| 60 | ` | a | b | c | d | e | f | g | h | i | j | k | l | m | n | o |  |
| 70 | p | q | r | s | t | u | v | w | x | y | z | { |  |  | } | ~ | DEL |
这个表显示了前 128 个符号。一个符号的十六进制表示是行的值加上列的值，比如 A 是 41 16。你可以惊奇地发现前两行和最后的值。这 33 个特殊字符是不可打印字符。事实上，许多人都忽略了它们。它们之所以存在是因为 ASCII 最初设计是基于计算机网络来传输数据的一种方法。因此它要发送的信息不仅仅是符号。你应该学习的重要的特殊字符是 `NUL`，它就是我们前面提到的空终止符。`HT` 水平制表符就是我们经常说的 `tab`，而 `LF` 换行符用于生成一个新行。你可能想研究和使用其它特殊字符在你的操行系统中的意义。
### 2、字符
到目前为止，我们已经知道了一些关于字符串的知识，我们可以开始想想它们是如何显示的。为了显示一个字符串，我们需要做的最基础的事情是能够显示一个字符。我们的第一个任务是编写一个 `DrawCharacter` 函数，给它一个要绘制的字符和一个位置，然后它将这个字符绘制出来。
这就很自然地引出关于字体的讨论。我们已经知道有许多方式去按照选定的字体去显示任何给定的字母。那么字体又是如何工作的呢？在计算机科学的早期阶段，字体就是所有字母的一系列小图片而已，这种字体称为位图字体，而所有的字符绘制方法就是将图片复制到屏幕上。当人们想去调整字体大小时就出问题了。有时我们需要大的字母，而有时我们需要的是小的字母。尽管我们可以为每个字体、每种大小、每个字符都绘制新图片，但这种作法过于单调乏味。所以，发明了矢量字体。矢量字体不包含字体的图像，它包含的是如何去绘制字符的描述，即：一个 `o` 可能是最大字母高度的一半为半径绘制的圆。现代操作系统都几乎仅使用这种字体，因为这种字体在任何分辨率下都很完美。
> 
> 在许多操作系统中使用的 TrueType 字体格式是很强大的，它内置有它自己的汇编语言，以确保在任何分辨率下字母看起来都是正确的。
> 
> 
> 
不幸的是，虽然我很想包含一个矢量字体的格式的实现，但它的内容太多了，将占用这个网站的剩余部分。所以，我们将去实现一个位图字体，可是，如果你想去做一个像样的图形操作系统，那么矢量字体将是很有用的。
在下载页面上的字体节中，我们提供了几个 `.bin` 文件。这些只是字体的原始二进制数据文件。为完成本教程，从等宽、单色、8x16 节中挑选你喜欢的字体。然后下载它并保存到 `source` 目录中并命名为 `font.bin` 文件。这些文件只是每个字母的单色图片，它们每个字母刚好是 8 x 16 个像素。所以，每个字母占用 16 字节，第一个字节是第一行，第二个字节是第二行，依此类推。
![](/data/attachment/album/201903/04/005217plra46ukq9pc4vu9.jpg)
这个示意图展示了等宽、单色、8x16 的字符 A 的 “Bitstream Vera Sans Mono” 字体。在这个文件中，我们可以找到，它从第 41 16 × 10 16 = 410 16 字节开始的十六进制序列：
```
00, 00, 00, 10, 28, 28, 28, 44, 44, 7C, C6, 82, 00, 00, 00, 00
```
在这里我们将使用等宽字体，因为等宽字体的每个字符大小是相同的。不幸的是，大多数字体的复杂之处就是因为它的宽度不同，从而导致它的显示代码更复杂。在下载页面上还包含有几个其它的字体，并包含了这种字体的存储格式介绍。
我们回到正题。复制下列代码到 `drawing.s` 中的 `graphicsAddress` 的 `.int 0` 之后。
```
.align 4
font:
.incbin "font.bin"
```
> 
> `.incbin "file"` 插入来自文件 “file” 中的二进制数据。
> 
> 
> 
这段代码复制文件中的字体数据到标签为 `font` 的地址。我们在这里使用了一个 `.align 4` 去确保每个字符都是从 16 字节的倍数开始，这是一个以后经常用到的用于加快访问速度的技巧。
现在我们去写绘制字符的方法。我在下面给出了伪代码，你可以尝试自己去实现它。按惯例 `>>` 的意思是逻辑右移。
```
function drawCharacter(r0 is character, r1 is x, r2 is y)
  if character > 127 then exit
  set charAddress to font + character × 16
  for row = 0 to 15
  set bits to readByte(charAddress + row)
  for bit = 0 to 7
    if test(bits >> bit, 0x1)
    then setPixel(x + bit, y + row)
    next
  next
  return r0 = 8, r1 = 16
end function
```
如果直接去实现它，这显然不是个高效率的做法。像绘制字符这样的事情，效率是最重要的。因为我们要频繁使用它。我们来探索一些改善的方法，使其成为最优化的汇编代码。首先，因为我们有一个 `× 16`，你应该会马上想到它等价于逻辑左移 4 位。紧接着我们有一个变量 `row`，它只与 `charAddress` 和 `y` 相加。所以，我们可以通过增加替代变量来消除它。现在唯一的问题是如何判断我们何时完成。这时，一个很好用的 `.align 4` 上场了。我们知道，`charAddress` 将从包含 0 的低位半字节开始。这意味着我们可以通过检查低位半字节来看到进入字符数据的程度。
虽然我们可以消除对 `bit` 的需求，但我们必须要引入新的变量才能实现，因此最好还是保留它。剩下唯一的改进就是去除嵌套的 `bits >> bit`。
```
function drawCharacter(r0 is character, r1 is x, r2 is y)
  if character > 127 then exit
  set charAddress to font + character << 4
  loop
    set bits to readByte(charAddress)
    set bit to 8
    loop
      set bits to bits << 1
      set bit to bit - 1
      if test(bits, 0x100)
      then setPixel(x + bit, y)