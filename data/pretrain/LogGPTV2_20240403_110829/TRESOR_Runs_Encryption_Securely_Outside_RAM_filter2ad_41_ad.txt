switching swaps debug registers into RAM, but it can-
not be ruled out. Anyhow, even for the hypothetical case
where such a piece of code exists, we are quite conﬁdent
that we can patch it. Hence, the feasibility of a system
like TRESOR and its fundamental idea to store secret
keys in debug registers is not at risk.
5.2 Processor attacks
Now that the key is stored inside the CPU and never en-
ters RAM, attackers may target processor registers rather
than RAM. Basically there are two ways to attack pro-
cessor registers: on software and on hardware layer.
On software layer we distinguish attackers who could
gain root access and attackers with an unprivileged ac-
cess. Naturally, for attackers with standard user privi-
leges there should be no way to read out the key. As de-
bug registers are only accessible from kernel space and
as the only way for standard users to execute kernel code
are system calls, unprivileged attackers are successfully
defeated by the ptrace patch. We veriﬁed this with a
user space utility making ptrace calls to read out de-
bug registers; as was expected, only 0 is returned to user
space. Overwriting the key via ptrace is not possible
either; here -EBUSY (dr0 to dr3) and -EPERM (dr6 and
dr7) are returned.
For root the situation is different, because for root
there are more ways to execute kernel code: via mod-
ules (LKMs) and via /dev/kmem. If Linux is compiled
with LKM or KMEM support, root can insert arbitrary
code into a running kernel and execute it with ring 0 priv-
ileges. To demonstrate this for LKMs, we have created a
small malicious module reading out the debug registers
and writing them into the kernel log ﬁle. A similar attack
is possible by writing to /dev/kmem. Thus, if com-
piled with LKM or KMEM support, root can gain full
access to the TRESOR key. On the other hand, if com-
piled without LKM and KMEM support, even root has
no ability to access the secret key – an advantage over
conventional disk encryption systems where root can al-
ways read and write the secret key from RAM. Running
TRESOR without LKM and KMEM support, the key can
be set once upon boot but never be retrieved or manipu-
lated while the system is running.
Besides the software layer, the hardware layer is crit-
ical. With physical access to the machine, new possibil-
ities open up for the attacker. First of all, for advanced
electrical engineers it may be possible to read out regis-
ters of a running CPU with an oscilloscope, by measur-
ing the electromagnetic ﬁeld around the CPU or what-
ever else. But we are not aware of any successful attacks
of this type.
Instead, we focus on a simpler scenario:
it may be
possible to reboot the machine with a malicious boot de-
vice reading out what is left in CPU registers (similar
to cold boot attacks [14]). Performing such an attack,
the interesting question is whether CPU registers are re-
set to zero upon reboot or keep their contents until they
are used otherwise. Besides the BIOS version and CPU
11
reinitialization code, the answer may depend on whether
the machine was rebooted by a software interrupt (e.g.,
by pressing CTRL-ALT-DEL) or by pressing a hardware
reset button. While the former method keeps the CPU on
power, the latter switches it off brieﬂy.
To investigate the practical impact of such an at-
tack, we developed a malicious boot device called Cobra
(Cold Boot Register Attack). First tested on virtual ma-
chines, Cobra revealed that debug registers are reset on
hardware reboots but not on software reboots. On soft-
ware reboots, Cobra was able to restore debug regis-
ters; all tested virtual machines (Qemu, Bochs, VMware
and VirtualBox) showed this behavior. If real hardware
showed this behavior as well, the consequences would
be fatal. It would be an ease to read out the secret key
and hence, TRESOR would be practically useless. For-
tunately, it turned out that all VMs have a little imple-
mentation ﬂaw regarding this attack. On real hardware,
debug registers are always reset to zero – also upon soft-
ware reboots. We veriﬁed this by testing different ma-
chines with different processors and BIOS versions. Ta-
ble 5 gives an overview of our ﬁndings.
Soft Reboot Hard Reset
-
-
-
-
-
-
-
-
-
-
-
BIOS
AMI
Phoenix
First
Phoenix
Lenovo
Bochs
Bochs
Phoenix
Athlon 64
Pentium 4
Pentium M First
Celeron M Phoenix
Core2 Duo
Core i5
Core i7
Qemu
Bochs
VMware
VirtualBox N/A
-
-
-
-
-
-
-
x
x
x
x
[-] = not vulnerable
Table 5: Cobra (Cold Boot Register Attack)
[x] = vulnerable
Overall, we argue that TRESOR is secure against
local, unprivileged attacks in any case. Beyond that,
TRESOR is even secure against attackers who could gain
root access, if the kernel is compiled without LKM and
KMEM support. On hardware level, TRESOR with-
stands cold boot attacks against both main memory and
CPU registers. This does only hold for real hardware,
but running TRESOR inside a virtual machine is insecure
anyhow as register contents of the guest are simulated in
the host’s main memory.
5.3 Side channel attacks
Last, we want to mention brieﬂy that TRESOR is resis-
tant to timing attacks [26]. This is not the achievement of
12
ourselves but that of Intel, or, to be more precise, that of
AES-NI. Intel states: “Beyond improving performance,
the AES instructions provide important security bene-
ﬁts. By running in data-independent time and not us-
ing tables, they help in eliminating the major timing and
cache-based attacks that threaten table-based software
implementations of AES.” [31] Based on this statement
and the fact that there are no input dependent branches in
the control ﬂow of our code, we argue that TRESOR is
resistant to side channel attacks, too.
6 Conclusions and Future Work
In the face of known attacks against main memory (above
all, DMA and cold boot attacks) we consider RAM as too
insecure to guarantee the conﬁdentiality of secret disk
encryption keys today. Thus we presented TRESOR, an
approach to prevent main memory attacks against AES
by implementing the encryption algorithm and its key
management entirely on the microprocessor, solely using
processor registers. We ﬁrst explained important design
choices of TRESOR and the key aspects of its imple-
mentation. We then discussed how we integrated it into
the Linux kernel. Eventually we showed that it performs
well in comparison to the generic version of AES and,
most importantly, that it satisﬁes our security policy.
6.1 Conclusions
Our primary security goal was to prevent tracing of the
secret key in volatile memory, effectively making attacks
on main memory pointless. Despite considerable effort,
we were not able to retrieve the key in RAM. Therefore,
we are conﬁdent that TRESOR is a substantial improve-
ment compared to conventional disk encryption systems.
As we took perfectly intact memory images of a run-
ning TRESOR VM and knew the key beforehand, we
had an advantage over real attackers trying to retrieve an
unknown key. This strengthens our test results, because
if we cannot retrieve the known key in an unscathed im-
age, it is even more unlikely that an attacker can retrieve
an unknown key in a partially damaged image.
Another security goal was, of course, not to intro-
duce ﬂaws which are not present in ordinary encryp-
tion systems. Therefore, we showed that TRESOR is
safe against local attacks on the software layer as well
as on the hardware layer. Interestingly, if the kernel is
compiled without LKM and KMEM support, there is no
(known) way to retrieve the secret key even though privi-
leged root access is given – again, a substantial improve-
ment compared to conventional disk encryption systems.
Besides evaluating security aspects, we collected
performance benchmarks, revealing that TRESOR is
slightly faster than common versions of AES. Further-
more, we showed that the reactivity of Linux is not af-
fected by the atomicity of encryption and decryption.
Summarizing, TRESOR runs encryption securely out-
side RAM and thereby it achieves a higher security than
any disk encryption system we know – without losing
performance or compatibility with existing applications.
To conclude, it is possible to treat RAM as untrusted and
to store secret keys in a safe place of today’s x86 standard
architecture.
6.2 Future Work
Currently, TRESOR allows only to store a single, static
key, because the debug registers cannot hold a second
one. Future versions of TRESOR may keep multiple disk
encryption keys securely inside RAM by srambling them
with a master key, like in Loop-Amnesia [27].
This idea may be extended to an even broader use case
in the future: Further AES keys to be used in conjunction
with IPSec or SSL, i.e., to be used in conjunction with the
userland, could be encrypted with the TRESOR master
key and stored securely inside RAM. Session keys could
be set and removed dynamically in any quantity. Using
such a session key to encrypt an input block, the user
space application would have to make a special system
call that: 1) invokes TRESOR to read and decrypt the de-
sired key and 2) lets TRESOR use the recently decrypted
key to encrypt the input block. Between these steps, the
session key may not leave the processor, meaning both
steps need to happen inside the same atomic section. As
a downside, such a system would require user space sup-
port and would induce a performance penalty.
Another future task is to move the secret key into reg-
isters which are even less frequently used than the debug
registers, e.g., into machine speciﬁc registers (MSRs).
As a beneﬁt, by using MSRs as cryptographic key stor-
age, debuggers would be able to use hardware break-
points and watchpoints again. However, the best way
to get round this problem would be the introduction of
a special key register into future versions of AES-NI by
Intel or AMD.
Last, we want to investigate the possibility of imple-
menting a TRESOR like system as third party applica-
tion for Windows.
Acknowledgments
We would like to thank Hans-Georg Esser, Thorsten
Holz, Ralf Hund, Stefan V¨omel, and Carsten Willems
for reading a prior version of this paper and giving us
valuable suggestions for improving it.
Availability
free
the
TRESOR is
GNU GPL v2 [32].
Its source is available at
www1.informatik.uni-erlangen.de/tresor.
software published under
References
[1] Windows BitLocker Drive Encryption Frequently Asked Ques-
http://technet.microsoft.com/en-us/
tions.
library/cc766200(WS.10).aspx, July 2009.
[2] KVM: Kernel Based Virtual Machine, 2010. http://www.
linux-kvm.org/.
[3] BECHER, M., DORNSEIF, M., AND KLEIN, C. N. FireWire
In Proceedings of the
- All Your Memory Are Belong To Us.
Annual CanSecWest Applied Security Conference (Vancouver,
British Columbia, Canada, 2005), Laboratory for Dependable
Distributed Systems, RWTH Aachen University.
[4] B ¨OCK, B. Firewire-based Physical Security Attacks on Windows
7, EFS and BitLocker. Secure Business Austria Research Lab,
Aug. 2009.
[5] BOILEAU, A. Hit by a Bus: Physical Access Attacks with
Firewire. In Proceedings of Ruxcon ’06 (Sydney, Australia, Sept.
2006). Tool (2008): http://storm.net.nz/static/
files/winlockpwn.
[6] CARRIER, B. D., AND GRAND, J. A Hardware-Based Memory
Acquisition Procedure for Digital Investigations. Digital Inves-
tigation 1, 1 (Feb. 2004), 50–60.
[7] CARSTEN MAARTMANN-MOE.
Interrogate.
http://
interrogate.sourceforge.net/, Aug. 2009.
[8] CHRISTOPHE DEVINE AND GUILLAUME VISSIAN. Compro-
mission physique par le bus PCI. In Proceedings of SSTIC ’09
(June 2009), Thales Security Systems.
[9] CON KOLIVAS.
The Linux Interactivity
Benchmark, 2006. http://users.on.net/˜ckolivas/
interbench/.
Interbench:
[10] DABROWSKI, R., J., MUNSON, AND V., E.
Is 100 Millisec-
onds Too Fast? In Proceedings of the CHI Conference on Human
Factors in Computing Systems (2001), vol. 2 of Short talks: in-
teraction techniques, ACM, pp. 317–318.
[11] FABRICE BELLARD. Qemu: Open Source Processor Emulator,
2010. http://qemu.org.
[12] FIPS. Advanced Encryption Standard (AES). Federal Informa-
tion Processing Standards Publication 197, National Institute for
Standards and Technology, Nov. 2001.
[13] GUILLAUME DELUGRE. Reverse Engineering the Broadcom Ne-
tExtreme’s ﬁrmware. In Proceedings of HACK.LU ’10 (Luxem-
bourg, Nov. 2010), Sogeti ESEC Lab.
[14] HALDERMAN, J. A., SCHOEN, S. D., HENINGER, N., CLARK-
SON, W., PAUL, W., CALANDRINO, J. A., FELDMAN, A. J.,
APPELBAUM, J., AND FELTEN, E. W. Lest We Remember:
Cold Boot Attacks on Encryptions Keys. In Proceedings of the
17th USENIX Security Symposium (San Jose, CA, Aug. 2008),
Princeton University, USENIX Association, pp. 45–60.
[15] HENINGER, N., AND FELDMAN, A. AESKeyFind. http:
//citp.princeton.edu/memory-content/src/,
July 2008.
[16] HITACHI GLOBAL STORAGE TECHNOLOGIES. Safeguarding
Your Data with Hitachi Bulk Data Encryption, July 2008.
http://www.hitachigst.com/tech/techlib.nsf/
techdocs/74D8260832F2F75E862572D7004AE077/
$file/bulk_encryption_white_paper.pdf.
13
[17] HULTON, D. Cardbus Bus-Mastering: 0wning the Laptop.
In Proceedings of ShmooCon ’06 (Washington DC, USA, Jan.
2006).
[18] INTEL CORPORATION.
Intel 64 and IA-32 Architectures Soft-
ware Developer’s Manual, Volume 3A and 3B ed., Jan. 2011.
System Programming Guide.
[19] JEFFREY KATCHER. PostMark: A New File System Bench-
mark.
http://communities-staging.netapp.
com/servlet/JiveServlet/download/2609-1551/
Katcher97-postmark-netapp-tr3022.pd,
1997.
Network Appliance, Inc.
[20] JOHN FRUEHE, DIRECTOR OF PRODUCT MARKETING. Follow-
ing Instructions. http://blogs.amd.com/work/2010/
11/22/following-instructions/, Nov. 2010. AMD.
[34] THAKKAR, S., AND HUFF, T. The Internet Streaming SIMD
Intel
IEEE Computer 32, 12 (Apr. 1999), 26–34.
Extensions.
Corporation.
[35] TOSHIBA CORPORATION.
Self-Encrypting
Apr.
http://sdd.toshiba.com/techdocs/
Drive
2009.
WaveRSADemoFinalPressRelease4152009.pdf.
RSA Conference
Technology
Toshiba
2009,
at
[36] TRUECRYPT FOUNDATION. TrueCrypt: Free Open-Source Disk
Encryption Software for Windows, Mac OS and Linux. http:
//www.truecrypt.org/, 2010.
A Appendix
[21] J ¨URGEN PABEL.
Blog:
frozenchache.blogspot.com/, Jan. 2009.
Frozen Cache.
http://
A.1 AES-128 Source Code
[22] J ¨URGEN PABEL.
FrozenCache Mitigating cold-boot at-
In 27th Chaos Com-
tacks for Full-Disk-Encryption software.
munication Congress (Berlin, Germany, Dec. 2010), CCC.
Video: http://blog.akkaya.de/jpabel/2010/12/
31/After-the-FrozenCache-presentation.
[23] MCGREGOR, P., HOLLEBEEK, T., VOLYNKIN, A., AND
WHITE, M. Braving the Cold: New Methods for Preventing
Cold Boot Attacks on Encryption Keys. In Black Hat Security
Conference (Las Vegas, USA, Aug. 2008), BitArmor Systems,
Inc.
[24] M ¨ULLER, T., DEWALD, A., AND FREILING, F. AESSE: A
Cold-Boot Resistant Implementation of AES. In Proceedings of
the Third European Workshop on System Security (EUROSEC)
(Paris, France, Apr. 2010), RWTH Aachen / Mannheim Univer-
sity, ACM, pp. 42–47.
[25] ORACLE CORPORATION. VirtualBox: x86 and AMD64 virtual-
ization, 2011. http://www.virtualbox.org.
[26] OSVIK, D. A., SHAMIR, A., AND TROMER, E. Cache Attacks
and Countermeasures: the Case of AES. In Topics in Cryptol-
ogy - The Cryptographers’ Track at the RSA Conference 2006
(San Jose, CA, USA, Nov. 2005), Weizmann Institute of Science,
Springer, pp. 1–20.
[27] PATRICK SIMMONS. Security Through Amnesia: A Software-
Based Solution to the Cold Boot Attack on Disk Encryption, Apr.
2011. University of Illinois at Urbana-Champaign.
[28] PETRONI, N. L., FRASER, T., MOLINA, J., AND ARBAUGH,