## 跳过检查的几类方式为持续交付体系搭建好静态检查服务并设置好 Rules后，你千万不要认为事情结束了，直接等着看检查结果就行了。因为，通常还会有以下问题发生：1.  代码规则可能不适合程序语言的多个版本；2.  第三方代码生成器自动产生的代码存在问题，该怎么略过静态检查；3.  静态检查受客观情况的限制，存在误报的情况；4.  某些规则对部分情况检查得过于苛刻；5.  其他尚未归类的不适合做静态检查的问题。其实，这些问题都有一个共同特点：静态检查时不该报错的地方却报错了，不该报严重问题的地方却报了严重问题。于是，我们针对这个共性问题的处理策略，可以分为三类：1.  把某些文件设置为完全不做静态检查；2.  把某些文件内部的某些类或方法设置为不做某些规则的检查；3.  调整规则的严重级别，让规则适应语言的多个版本。这样就可以提高静态检查的准确度了，接下来我们需要考虑的问题就是提高静态检查的效率了。
## 如何提高静态检查的效率？提高静态检查的效率的重要性，可以概括为以下两个方面：-   其一，能够缩短代码扫描所消耗的时间，从而提升整个持续交付过程的效率；-   其二，我们通常会采用异步的方式进行静态检查，如果这个过程耗时特别长的话，会让用户产生困惑，从而质疑执行静态检查的必要性。那么，怎么才能提升静态检查的效率呢？**除了提升静态检查平台的处理能力外，在代码合入主干前采用增量形式的静态检查，也可以提升整个静态检查的效率**。增量静态检查，是指只对本次合入涉及的文件做检查，而不用对整个工程做全量检查。当然，为了有效保证整个工程项目的代码质量，持续交付系统通常会在版本发布到用户验证环境或者上线之前，对整个工程进行全量检查。这样做，既能保证产品上线的质量，又可以提高集成过程中的检查效率。
## 如何制定规则？如果你要在实际工作中制定自己的个性化规则，又该如何进行呢？在实践中，日常的定制规则往往有两种方式：1.  从已有的规则集合中挑选团队适用的规则，必要情况下调整规则的严重等级和部分参数；2.  基于某个规则框架，编写全新的规则。这种方式需要自行编码，难度成本较大，所以我一般不推荐你采用，确实找不到现成的规则时再采用这种方案。
## Sonar 代码静态检查实例了解了代码静态检查的理论知识，我们现在就来具体实践一下。你可以从中体会，如何搭建一套Sonar 服务，并把它与实际流程结合起来。第一步：搭建 Sonar 服务，安装 CheckStyle 等插件。![](Images/3292a30959cb9252d63b45b6c42f5499.png){savepage-src="https://static001.geekbang.org/resource/image/46/71/46547bc859cdd27115d4d7b4d1de7071.png"}```{=html}```图 2 Sonar 系统配置```{=html}```第二步：设置统一的 Java 检查规则。![](Images/a18ddf3a74f674661ac67cf22f33930b.png){savepage-src="https://static001.geekbang.org/resource/image/77/67/77af0b0de82daa62dabeea8f6e643f67.png"}```{=html}```图 3 Java 规则设置```{=html}```第三步：在 IDE 中安装 SonarLint 插件后，就可以使用 SonarSource的自带规则了。![](Images/209f196ff1eb4eec3a7039761199ea5f.png){savepage-src="https://static001.geekbang.org/resource/image/94/34/943983a416e2b3e651bebd097cf09634.png"}```{=html}```图 4 IDE 插件安装```{=html}```第四步：如果 SonarLint的检查规则不能满足开发环境的要求，你可以执行相关的 mvn命令，把检查结果吐到 Sonar 服务器上再看检查结果，命令如下：    mvn org.sonarsource.scanner.maven:sonar-maven-plugin:3.2:sonar -f ./pom.xml -Dsonar.host.url=sonar 服务器地址 -Dsonar.login= 账号名称 -Dsonar.password= 账号密码 -Dsonar.profile= 检查规则的集合 -Dsonar.global.exclusions= 排除哪些文件 -Dsonar.branch= 检查的分支第五步：在 GitLab 的 Merge Request 中增加 Sonar静态检查的环节，包括检查状态和结果等。![](Images/cd655533559ba09b607d4cd10603ced0.png){savepage-src="https://static001.geekbang.org/resource/image/8d/ca/8dae6234f5003bee410fca4ae9dfb3ca.png"}```{=html}```图 5 GitLab MR 集成 Sonar 结果```{=html}```第六步：发布到用户验证环境（UAT）前，先查看静态检查结果。如果没有通过检查，则不允许发布。![](Images/9ab71b4677d628cd690f49e415dbcfdf.png){savepage-src="https://static001.geekbang.org/resource/image/94/92/94cb9ec4481d904232f6e5938fde8192.png"}```{=html}```图 6 Sonar 检查结果报告```{=html}```通过上面这六步，一套代码静态检查机制就基本被构建起来了。
## 总结在分享和你分享代码静态检查实践这个主题时，我分享了近五年国内的大型互联网公司在持续交付实践中摸爬滚打的经验。从这五年的发展实践中，我们可以清楚地看到，越来越多的研发团队把静态检查作为了一个不可或缺的环节，这也确实帮助研发团队提升了代码质量。当然，机器是死的，人是活的，我们千万不要过分迷信静态检查的结果，还要时刻擦亮眼睛，看看是否存在误报等问题。
## 思考题1.  为什么代码静态检查应尽量在开发前期就实施？2.  在你看来，一款好的静态检查工具或一套好的静态检查系统，应该具备哪些特点？感谢收听，欢迎你给我留言。![](Images/69e5b7a8ed8eecd006aa3ce5f76f78af.png){savepage-src="https://static001.geekbang.org/resource/image/55/0a/55b7b7cb930ca733523be64e3a720d0a.jpg"}
# 26 \| 越来越重要的破坏性测试你好，我是王潇俊。今天我和你分享的主题是：越来越重要的破坏性测试。其实，持续交付中涉及到的与测试相关的内容，包括了单元测试、自动化测试、冒烟测试等测试方法和理念，我为什么我把破坏性测试拿出来，和你详细讨论呢？原因无非包括两个方面：-   其一，单元测试等传统测试方法，已经非常成熟了，而且你肯定也非常熟悉了；-   其二，破坏性测试，变得越来越重要了。那么，破坏性测试到底是因为什么原因变得原来越重要呢？随着SOA、微服务等架构的演进，分布式系统对测试的要求越来越高，不再像传统的单体应用测试一样，可以很容易地无缝嵌入到持续交付体系中。因为分布式系统的测试不仅需要大量的前提准备，还存在着非常严重的服务依赖问题。这就使得分布式系统的测试工作，除了要关注运行的应用本身外，还要考虑测试环境的因素。很快，我们就发现，破坏性测试可以解决分布式系统测试的这些难题，而且还可以帮助我们解决更多的问题。它可以弥补传统持续交付体系只关注代码或应用本身，而忽略其他外部因素影响运行中代码的问题。而且，破坏性测试还能很好地证明整个分布式系统的健壮性。所以，与其老生长谈一些传统的测试方法，不如我们一起看看更新鲜、更好用的破坏性测试。
## 什么是破坏性测试？``{=html}顾名思义，破坏性测试就是通过有效的测试手段，使软件应用程序出现奔溃或失败的情况，然后测试在这样的情况下，软件运行会产生什么结果，而这些结果又是否符合预期。这里需要注意的是，我们需要使用的测试手段必须是有效的。为什么这样说呢，有两点原因。**第一，破坏性测试的手段和过程，并不是无的放矢，它们是被严格设计和执行的**。不要把破坏性测试和探索性测试混为一谈。也就是说，破坏性测试不应该出现，"试试这样会不会出问题"的假设，而且检验破坏性测试的结果也都应该是有预期的。**第二，破坏性测试，会产生切实的破坏作用，你需要权衡破坏的量和度**。因为破坏不仅仅会破坏软件，还可能会破坏硬件。通常情况下，软件被破坏后的修复成本不会太大，而硬件部分被破坏后，修复成本就不好说了。所以，你必须要事先考虑好破坏的量和度。