- Reverse substring - 这个功能和子串规则一样，但是指定的结束偏移量是从 payload 的末端开始向后计算，而长度则是从结束偏移量开始向后计算。
- Modify case - 如果适用的话，它将修改 payload 的大小写。与修改大小写 payload 类型的选项相同。
- Encode - 该选项使用各种方案对 payload 进行编码。URL、HTML、Base64、ASCII 十六进制或各种平台的构造字符串。
- Decode - 使用不同的方案对 payload 进行解码：URL、HTML、Base64 或 ASCII 十六进制或各种平台的构造字符串。URL、HTML、Base64 或 ASCII 十六进制。
- Hash - 对 payload 进行 Hash 操作。
- Add raw payload - 在当前处理值之前或之后添加原始 payload 值。例如，如果你需要以原始和散列形式提交相同的 payload ，它可能会很有用。
- Skip if matches regex - 这将检查当前处理后的值是否与指定的正则表达式相匹配，如果是，则跳过该 payload 并转到下一个。例如，如果你知道一个参数值必须有一个最小的长度，并且想跳过列表中任何短于这个长度的值，那么这个功能就很有用。
- Invoke Burp extension - 这将调用 Burp 扩展来处理 payload 。该扩展必须已经注册了一个 Intruder payload 处理器。你可以从当前加载的扩展注册的可用处理器列表中选择所需的处理器。
**Payload Encoding**
配置字典进行 URL 编码
### Options
**请求消息头设置 (Request Headers)**
这个设置主要用来控制请求消息的头部信息,它由 Update Content-Length header和Set Connection: close 两个选项组成.
其中 Update Content-Length header 如果被选中,Burp Intruder 在每个请求添加或更新 Content-Length 头为该次请求的 HTTP 体的长度正确的值.这个功能通常是为插入可变长度的 Payload 到模板的 HTTP 请求的主体的攻击中,如果没有指定正确的值,则目标服务器可能会返回一个错误,可能会到一个不完整的请求做出响应,或者可能会无限期地等待请求继续接收数据.
Set Connection: close 如果被选中,表示 Burp Intruder 在每个请求消息中添加或更新值为"关闭"的连接头,这将更迅速地执行.在某些情况下 (当服务器本身并不返回一个有效的 Content-Length 或 Transfer-Encoding 头) ,选中此选项可能允许攻击.
**请求引擎设置 (Request Engine)**
这个设置主要用来控制 Burp Intruder 攻击,合理地使用这些参数能更加有效地完成攻击过程.它有如下参数:Number of threads 并发的线程数,Number of retries on network failure 网络失败时候重试次数,Pause before retry 重试前的暂停时间间隔 (毫秒) ,Throttle between requests 请求延时 (毫秒) ,Start time 开始时间,启动攻击之后多久才开始执行.
**攻击结果设置 (Attack Results)**
这个设置主要用来控制从攻击结果中抓取哪些信息.它的参数有 : Store requests / responses 保存请求/应答消息,Make unmodified baseline request 记录请求母板的消息内容,Use denial-of-service mode 使用 Dos 方式,tore full payloads 存储所有的 Payload 值.
**Grep Match**
这个设置主要用来从响应消息中提取结果项,如果匹配,则在攻击结果中添加的新列中标明,便于排序和数据提取.比如说,在密码猜测攻击,扫描诸如"密码不正确"或"登录成功",可以找到成功的登录;在测试 SQL 注入漏洞,扫描包含"ODBC","错误"等消息可以识别脆弱的参数.
Match type 表示匹配表达式还是简单的字符串,Case sensitive match 是否大小写敏感,Exclude HTTP headers 匹配的时候,是否包含 http 消息头.
**Grep Extract**
这些设置可用于提取响应消息中的有用信息.对于列表中配置的每个项目,Burp 会增加包含提取该项目的文本的新结果列.然后,你可以排序此列 (通过单击列标题) 命令所提取的数据.此选项是从应用数据挖掘有用的,能够支持广泛的攻击.例如,如果你是通过一系列文档 ID 的循环,可以提取每个文档寻找有趣的项目的页面标题.如果你发现返回的其他应用程序用户详细信息的功能,可以通过用户 ID 重复和检索有关用户寻找管理帐户,甚至密码.如果"遗忘密码"的功能需要一个用户名作为参数,并返回一个用户配置的密码提示,你可以通过共同的用户名列表运行和收获的所有相关密码的提示,然后直观地浏览列表寻找容易被猜到密码.
**Grep Payloads**
这些设置可用于提取响应消息中是否包含 Payload 的值,比如说,你想验证反射性的 XSS 脚本是否成功,可以通过此设置此项.当此项设置后,会在响应的结果列表中,根据 Payload 组的数目,添加新的列,显示匹配的结果,你可以通过点击列标题对结果集进行排序和查找.
其设置项跟上一个类似,需要注意的是 Match against pre-URL-encoded payloads,如果你在请求消息时配置了 URL-encode payloads ,则这里表示匹配未编码之前的 Payload 值,而不是转码后的值.
**重定向 (Redirections)**
这些设置主要是用来控制执行攻击时 Burp 如何处理重定向,在实际使用中往往是必须遵循重定向,才能实现你的攻击目的.例如,在密码猜测攻击,每次尝试的结果可能是密码错误会重定向响应到一个错误消息提示页面,如果密码正确会重定向到用户中心的首页. 但设置了重定向也可能会遇到其他的问题,比如说,在某些情况下,应用程序存储你的会话中初始请求的结果,并提供重定向响应时检索此值,这时可能有必要在重定向时只使用一个单线程攻击.也可能会遇到,当你设置重定向,应用程序响应会重定向到注销页面,这时候,按照重定向可能会导致你的会话被终止时. 因其设置选项跟其他模块的重定向设置基本一致,此处就不再重叙.
---
## Repeater
`中继模块`
Burp Repeater 作为 Burp Suite 中一款手工验证 HTTP 消息的测试工具,通常用于多次重放请求响应和手工修改请求消息的修改后对服务器端响应的消息分析.
请求消息区为客户端发送的请求消息的详细信息,Burp Repeater 为每一个请求都做了请求编号,当我们在请求编码的数字上双击之后,可以修改请求的名字,这是为了方便多个请求消息时,做备注或区分用的.在编号的下方,有一个 [GO] 按钮,当我们对请求的消息编辑完之后,点击此按钮即发送请求给服务器端.服务器的请求域可以在 target 处进行修改,如上图所示.
应答消息区为对应的请求消息点击 [GO] 按钮后,服务器端的反馈消息.通过修改请求消息的参数来比对分析每次应答消息之间的差异,能更好的帮助我们分析系统可能存在的漏洞.
在我们使用 Burp Repeater 时,通常会结合 Burp 的其他工具一起使用,比如 Proxy 的历史记录,Scanner 的扫描记录、Target 的站点地图等,通过其他工具上的右击菜单,执行[Send to Repeater],跳转到 Repeater 选项卡中,然后才是对请求消息的修改以及请求重放、数据分析与漏洞验证.
**可选项设置(Options)**
与 Burp 其他工具的设置不同,Repeater 的可选项设置菜单位于整个界面顶部的菜单栏中,如图所示:
其设置主要包括以下内容:
- 更新 Content-Length 这个选项是用于控制 Burp 是否自动更新请求消息头中的 Content-Length
- 解压和压缩(Unpack gzip / deflate)这个选项主要用于控制 Burp 是否自动解压或压缩服务器端响应的内容
- 跳转控制(Follow redirections)这个选项主要用于控制 Burp 是否自动跟随服务器端作请求跳转,比如服务端返回状态码为 302,是否跟着应答跳转到 302 指向的 url 地址. 它有4个选项,分别是永不跳转(Never),站内跳转(On-site only)、目标域内跳转(In-scope only)、始终跳转(Always),其中永不跳转、始终跳转比较好理解,站内跳转是指当前的同一站点内跳转;目标域跳转是指 target scope 中配置的域可以跳转;
- 跳转中处理 Cookie(Process cookies in redirections)这个选项如果选中,则在跳转过程中设置的 Cookie 信息,将会被带到跳转指向的 URL 页面,可以进行提交.
- 视图控制(View)这个选项是用来控制 Repeater 的视图布局
- 其他操作(Action)通过子菜单方式,指向 Burp 的其他工具组件中.
---
## Sequencer
`随机数分析`
Burp Sequencer 作为 Burp Suite 中一款用于检测数据样本随机性质量的工具,通常用于检测访问令牌是否可预测、密码重置令牌是否可预测等场景,通过 Sequencer 的数据样本分析,能很好地降低这些关键数据被伪造的风险.
**Live capture**
Burp Sequencer 作为一款随机数分析的工具,在分析过程中,可能会对系统造成不可预测的影响,在你不是非常熟悉系统的情况下,建议不要在生产环境进行数据分析.它的使用步骤大体如下:
1. 首先,确认 Burp Suite 安装正确,并配置好浏览器代理,正常运行.
2. 从 Burp Proxy 的历史日志记录中,寻找 token 或类似的参数,返回右击弹出上下文菜单,点击[Send to Sequencer].
进入 Burp Sequencer 的 Live Capture 面板,选中刚才发送过来的记录,点击 [Configure] 配置需要分析的 token 或者参数.
在弹出的参数配置对话框中,选中参数的值,点击 [OK] 按钮,完成参数设置.
点击[Select Live Capture],开始进行参数值的获取.
当抓取的参数值总数大于100时,点击 [pause] 或者 [stop],这时可以进行数据分析,点击 [Analyze now] 即进行数据的随机性分析.
等分析结束,则可以看到分析结果的各种图表.
**Manual load**
当然,我们也可以把获取的数据保存起来,下一次使用的时候,从文件加载参数,进行数据分析.
**Analysis Options**
分析可选项设置的目的主要是为了控制 token 或者参数,在进行数据分析过程中,需要做什么样的处理,以及做什么类型的随机性分析.它主要由令牌处理(Token Handling)和令牌分析(Token Analysis)两部分构成.
令牌处理Token Handling主要控制令牌在数据分析中如何被处理,它的设置界面如下图所示:
其中 Pad short tokens at start / end 表示如果应用程序产生的令牌是具有可变长度的,那么这些令牌在数据分析前都需要被填充,以便于进行的统计检验.你可以选择是否填充在开始位置或每个令牌的结束位置.在大多数情况下,在开始位置填充是最合适. Pad with 表示你可以指定将用于填充的字符.在大多数情况下,数字或 ASCII 十六进制编码的令牌,用"0"填充是最合适的. Base64-decode before analyzing 表示在数据分析是否进行 base64 解码,如果令牌使用了 base64 编码的话,则需要勾选此项.
令牌分析 Token Analysis 主要用来控制对数据进行随机性分析的类型,我们可以选择多个分析类型,也可以单独启用或禁用每个字符类型级和字节级测试.有时候,执行与启用所有分析类型进行初步分析后,再禁用某些分析类型,以便更好地了解令牌的特点,或隔离由样品表现任何不寻常的特性.
其中上面两个选项是控制数据分析的字符类型级,它包含 Count 和 Transitions.
- Count 是指分析在令牌内的每个位置使用的字符的分布,如果是随机生成的样本,所用字符的分布很可能是大致均匀的.在每个位置上分析统计令牌是随机产生的分布的概率.
- Transitions 是指分析样品数据中的连续符号之间的变化.如果是随机生成的样品,出现在一个给定的位置上的字符是同样可能通过在该位置使用的字符中的任一项中的下一个标志的改变.在每个位置上统计分析令牌随机产生到变化的概率.
下面的几项设置是用于控制数据分析的字节级测试,它比字符级测试功能更强大.启用字节级分析中,每个令牌被转换成一组字节,与设置在每个字符位置的字符的大小决定的比特的总数.它包含的测试类型有以下七种.
- FIPS monobit test —— 它测试分析0和1在每个比特位置的分配,如果是随机生成的样本,1和0的数量很可能是大致相等.Burp Sequencer 记录每个位是通过还是没通过 FIPS 试验观测.值得注意的是,FIPS 测试正式规范假定样本总数为20000个时.如果你希望获得的结果与该 FIPS 规范一样严格的标准,你应该确保达到20000个令牌的样本.
- FIPS poker test —— 该测试将j比特序列划分为四个连续的、非重叠的分组,然后导出4个数,计算每个数字出现16个可能数字的次数,并采用卡方校验来评估数字的分布.如果样品是随机生成的,这个数字的分布可能是近似均匀的.在每个位置上,通过该测试方式,分析令牌是随机产生的分布的概率.
- FIPS runs tests —— 该测试将具有相同值的连续的比特序列在每一个位置进行划分成段,然后计算每一个段的长度为1,2,3,4,5,和6以及6以上.如果样品是随机生成的,那么这些段的长度很可能是由样本集的大小所确定的范围之内.在每个位置上,使用该分析方法,观察令牌是随机生成的概率.
- FIPS long runs test —— 这个测试将有相同值的连续的比特序列在每一个位置进行划分成段,统计最长的段.如果样品是随机生成的,最长的段的数量很可能是由样本集的大小所确定的范围之内.在每个位置上,使用此分析方法,观察令牌是随机产生的最长段的概率.
- Spectral tests —— 该测试是在比特序列的每个位置上做一个复杂的分析,并且能够识别某些样品是通过其他统计检验的非随机性证据.样本试验通过比特序列和将每个系列的连续的数字作为多维空间的坐标并通过它绘制在这些坐标来确定每个位置这个空间的一个点.如果是随机生成的样本,点的此空间中的分布可能是大致均匀;在该空间内的簇的外观表示数据很可能是非随机的.在每个位置,使用此种分析方法,观察令牌是随机发生的概率.
- Correlation test —— 比较每个位置具有相同值的令牌样本与每一个位置具有不同值的短令牌样本之间的熵,以测试在令牌内部的不同的比特位置中的值之间的任何统计学显著关系.如果样品是随机生成的,在给定的比特位置处的值是同样可能伴随着一个或一个零在任何其它位的位置.在每个位置上,使用此种分析方法,观察令牌是随机生成的可能性.为了防止任意的结果,当两个比特之间观察到一定程度的相关性,该测试调整,其显着性水平下是基于所有其他比特级测试的位的显着性水平.
- Compressoion test —— 这种测试不使用其他测试中使用的统计方法,而是通过简单直观的指标统计比特序列中每个位置熵的数量.该分析方法尝试使用标准ZLIB压缩比特序列的每个位置,结果表明,当它被压缩在比特序列的大小的比例减少,较高压缩程度表明数据是不太可能被随机产生的.
---
## Decoder
`编码解码工具`
Burp Decoder 的功能比较简单,作为 Burp Suite 中一款编码解码工具,它能对原始数据进行各种编码格式和散列的转换.其界面如下图,主要由输入域、输出域、编码解码选项三大部分组成.
输入域即输入需要解码的原始数据,此处可以直接填写或粘贴,也可以通过其他 Burp 工具的上下文菜单中[Send to Decoder];输出域即对输入域进行解码的结果显示出来.无论是输入域还是输出域都支持文本与 Hex 两种格式,其中编码解码选项中,由解码选项 (Decode as)、编码选项 (Encode as)、散列 (Hash) 三个构成.实际使用中,可以根据场景的需要进行设置.对于编码解码选项,目前支持URL、HTML、Base64、ASCII、16进制、8进制、2进制、GZIP共八种形式的格式转换,Hash 散列支持 SHA、SHA-224、SHA-256、SHA-384、SHA-512、MD2、MD5 格式的转换,更重要的是,对于同一个数据,我们可以在 Decoder 的界面,进行多次编码解码的转换.
---
## Comparer
`差异比对模块`
Burp Comparer 在 Burp Suite 中主要提供一个可视化的差异比对功能,来对比分析两次数据之间的区别.使用中的场景可能是:
1. 枚举用户名过程中,对比分析登录成功和失败时,服务器端反馈结果的区别.
2. 使用 Intruder 进行攻击时,对于不同的服务器端响应,可以很快的分析出两次响应的区别在哪里.
3. 进行 SQL 注入的盲注测试时,比较两次响应消息的差异,判断响应结果与注入条件的关联关系.
对于 Comparer 的使用,主要有两个环节组成,先是数据加载,然后是差异分析. Comparer 数据加载的方式常用的有:从其他 Burp 工具通过上下文菜单转发过来、直接粘贴、从文件加载三种方式.当加载完毕后,如果你选择了两次不同的请求或应答消息,则下放的比较按钮将被激活,可以选择文本比较或者字节比较.
如果点击了 [words] 或者 [bytes],则进入比对界面,页面自动通过背景颜色显示数据的差异.
其中,文本比较 (words) 是指通过文本的方式,比如说以 HTML 的方式,比较两个数据的差异;而字节比较 (bytes) 是指通过 16 进制的形式,比较两次内容的差异.
---
## Extender
`插件模块`
下载、管理 burp 的插件
官方插件商店 https://portswigger.net/bappstore
大部分插件运行需要 [Jython](https://www.jython.org/downloads.html)、[JRuby](https://www.jruby.org/download) 环境,需要在 Extender-->Options 中指定 jar 文件,或者直接安装
在 Burp Extender 面板中,有一个 BApp Store 的 Tab 页,这就是 Burp 的应用商店,内容是提供各种 Burp 的插件. 默认情况下,当你点击 [BApp Store] 的 Tab 页时,界面列表会显示插件明细,若你的环境是通过代理访问外网的,则需要在 [User Options]->[Connections]->[Upstream Proxy Servers] 进行设置
安装完成的插件,都会显示在插件列表中.
---
## Project options
**Macro**
`宏`
可编写宏规则实时获取页面字段，如 token,这里就不细讲了
相关文章
- [【技术分享】如何使用Burp Suite Macros绕过防护进行自动化fuzz测试](https://www.anquanke.com/post/id/86768)