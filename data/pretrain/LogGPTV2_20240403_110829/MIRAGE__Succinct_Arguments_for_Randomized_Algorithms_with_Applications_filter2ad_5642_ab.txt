parties is not applicable in all contexts, especially if the com-
putation being veriﬁed is not the same across many parties.
As Table 2 shows, our system is better with respect to the
proof size and veriﬁcation effort, and has competitive prover
effort, when compared with Sonic in the unhelped case. If
the universal circuit is highly utilized, i.e., N = n+ + n∗, the
prover in our case could have fewer exponentiations. Note
that the reported prover cost of our system in Table 2 uses a
slightly modiﬁed version of the naive basic circuit presented
in Section 4, that allows adding and multiplying constants
cheaply. This is why the bound N does not consider addition
or multiplication of constants. In Section 5, we also present
USENIX Association
29th USENIX Security Symposium    2131
Table 1: A comparison of the existing zero-knowledge proof systems. A ﬁlled circle indicates no trusted setup, while a half ﬁlled
circuit indicates a universal setup for a class of computations. n denotes the total number of gates, n∗ denotes the number of
multiplications, n+ denotes the number of additions, u is the size of the statement, w is the witness size, N is an upper bound on
the number of additions and multiplications and U is an upper bound on the statement size. Assuming full circuit utilization for
our construction in the naive case, N would be equal to n∗ + n+, and U would be equal to u. For Hyrax, Libra and Virgo, d is the
circuit depth and g is the width of the circuit.
Scheme
Untrusted Setup
Proof Computation
Proof Size
Veriﬁcation
QAP-based [1, 2, 7]
Ligero [21]
zk-STARKs [25]
Bulletproofs [22]
Hyrax [24]
Aurora [26]
Baum et al. [32]
Virgo [28]
Libra [27]
Groth et al. [29]
Sonic [31]
LegoUAC [30]
vnTinyRAM [4]
This Work
(cid:35)
(cid:32)
(cid:32)
(cid:32)
(cid:32)
(cid:32)
(cid:32)
(cid:32)
(cid:71)(cid:35)
(cid:71)(cid:35)
(cid:71)(cid:35)
(cid:71)(cid:35)
(cid:71)(cid:35)
(cid:71)(cid:35)
O(n∗ logn∗)
O(n∗ logn∗)
O(n∗ log2 n∗)
O(n + d · glogg)
O(n∗)
O(n∗ logn∗)
O(n∗ logn∗)
O(n + wlogw)
O(1)
√
n∗)
O(
O(log2 n∗)
√
O(logn∗)
w + d logg)
O(
O(log2 n∗)
√
n∗ logn∗)
O(
O(d logn + log2 w)
O(u)
O(n∗)
O(log2 n∗)
√
O(n∗)
w + d logg)
O(
O(n∗)
O(n∗)
O(d logn + log2 w)
O(n)
O(n∗ logn∗)
O(n∗ logn∗)
O(n)
O(N log2 N)
O(N logN)
O(d logn)
O(1)
O(1)
O(log2 n)
O(d logn)
O(u)
O(u)
O(u + log2 n)
O(1)
O(1)
O(u)
O(u)
Table 2: Comparison between current approaches for universal zk-SNARKs with constant-size proofs with respect to the
non-universal scheme of Groth16 [7] as a baseline. Besides the notation used in Table 1, m refers to the number of wires, d(cid:48)
refers to the maximum size of committed polynomials in Sonic [31], EX refers to exponentiations, P refers to pairing operations
and T refers to a bound on the number of computation steps in vnTinyRAM (T = Θ(N)). The second group of rows correspond
to schemes with universal CRS, while the last group of rows correspond to systems with universal circuits. Assuming full circuit
utilization for our construction in the naive case, N would be equal to n∗ + n+, and U would be equal to u. In all universal
schemes, the custom portion of the CRS is not generated by a trusted party.
Scheme
Prover’s Overhead
Uni. Circ. Size
Assumptions
Proof Size
Veriﬁcation
Updatable?
CRS Size
Non-universal [7]
Groth et al. [29]
Sonic [31]
Sonic (Helped)
vnTinyRAM [4]
This work
Universal
N/A
O(n2∗)
O(d(cid:48))
O(d(cid:48))
O(N logN)
O(N)
Custom
O(n∗ + m)
O(n∗ + m− u)
O(n∗)
O(n∗)
O(1)
O(1)
N/A
N/A
N/A
N/A
O(N logN)
O(N)
4n∗ + m− u EX
O(n∗ + m− u) EX
273n∗ EX
18n∗ EX
5000T EX
90N + 25U EX (naive)
128 B
128 B
1152 B
256 B
128 B
160 B
3 P + u EX
GG
5 P + u EX
13 P
10 P
3 P + u EX
4 P + u EX
GG
AGM, RO
AGM, RO
GG
GG, RO






another circuit design that can reduce the reported prover cost
further for many applications.
Comparison with concurrent work [39, 40]: MARLIN pro-
vides a preprocessing zk-SNARK that has a universal and
updatable CRS [39]. MARLIN has faster prover and veriﬁer
than Sonic, however its proof size is still 1 KB, and the re-
ported experiments showed that its veriﬁer’s performance is
about 2.6× worse than the Groth16 baseline, despite having
fewer pairings. Another work in the same line, PLONK [40],
improves upon Sonic. PLONK has a proof size of 448 to 512
bytes and a more efﬁcient prover. The estimated costs reported
in PLONK [40] could suggest that its performance is com-
parable to MARLIN’s. In comparison, our proof size is 160
bytes, and the veriﬁer’s performance is only 1.4× worse than
the Groth16 baseline, which makes MIRAGE’s veriﬁer more
suitable for applications that require efﬁcient veriﬁcation. On
the other hand, MIRAGE’s CRS is not updatable.
Smart Contracts. The emerging success of cryptocurrencies,
most notably Bitcoin [41], has motivated several other ap-
plications to utilize the decentralized blockchain setting for
supporting other functionalities. This further lead to another
generation of cryptocurrency systems that aimed at enabling
users to customize the decentralized computation, by deﬁn-
ing smart contracts. Smart contracts are executable objects
that can run autonomously on top of a blockchain and are
automatically enforced. Systems like Ethereum [42] enable
users to program smart contracts using high-level languages
and post their contracts to the chain. Besides simple trans-
2132    29th USENIX Security Symposium
USENIX Association
action veriﬁcation, the network in a smart contract system
executes the user-speciﬁed code included in the smart con-
tract. This clearly leads to a privacy issue, as all values used
by the computation will be seen by all miners.
HAWK [16] aims to address the privacy problem by using
zero knowledge proofs. For example, to support a privacy-
preserving decentralized auction, the involved parties and the
auction manager interact through a protocol whose correct ex-
ecution can be veriﬁed by a smart contract that does not learn
anything about the users’ bids or the winner. HAWK relies
on QAP-based zk-SNARKs in their implementation as they
provide succinct proofs and efﬁcient veriﬁcation. However,
one implication of using this kind of zero-knowledge proofs
is the trusted setup needed per computation. This limits the
usage of HAWK’s approach in practice. In our work, we show
how to avoid this problem through our universal circuit and
efﬁcient zk-SNARK protocol for randomized veriﬁcation.
2 Preliminaries
In this section, we provide a summary of the deﬁnitions and
the protocols we use or modify.
2.1 Quadratic Arithmetic Programs
Deﬁnition 1 Quadratic Arithmetic Program (QAP) [1, 2] A
QAP Q over ﬁeld Fq contains three sets of m + 1 polynomials
V ={vi(x)},W ={wi(x)},Y ={yi(x)}, for i = 0, . . . ,m, and a
target polynomial t(x). Let C be a circuit with m wires (a wire
can be an input to the circuit or an output of a multiplication
gate) out of which u wires are I/O wires (c1, . . . ,cu). Then
we say that Q computes C if: (c1, . . . ,cu) ∈ Fu
q is a valid
assignment of C’s inputs and outputs, if and only if there exist
coefﬁcients (cu+1, . . . ,cm) such that t(x) divides p(x), where
p(x) is the polynomial
(v0(x)+
m
∑
i=1
civi(x))(w0(x)+
m
∑
i=1
ciwi(x))−y0(x)− m
∑
i=1
ciyi(x) .
zk-SNARKs
2.2
zk-SNARKs (zero-knowledge succinct non-interactive argu-
ments of knowledge) have algorithms (Setup,Prove,Verify).
In summary Setup outputs prover and veriﬁcation keys, on in-
put a a circuit C. Algorithm Prove outputs a zero-knowledge
proof of knowledge that circuit C is satisﬁable for a ﬁxed pub-
lic statement (I/Os). Finally, Verify veriﬁes that proof, given
a public statement. For a zk-SNARK, we want perfect com-
pleteness, knowledge soundness and zero-knowledge to hold.
Perfect completeness means that an honest prover that knows
the witness to a satisﬁable statement can provide a verifying
proof. Knowledge soundness means that, given a verifying
proof for a public statement provided by a PPT adversary A,
there exists an extractor that can retrieve a valid witness by
inspecting A’s tape. Finally, zero-knowledge means that a
proof provided by an honest prover leaks nothing more than
the validity of the statement. The formal deﬁnitions of the
above three properties (and the ones we use in our proofs)
can be found in Deﬁnition 2 of Groth’s zk-SNARK [7].
2.3 Groth16 protocol
We summarize the protocol proposed by Groth [7] in the
generic group model, using the notation we use in this paper.
Protocol 1 The Groth16 Protocol [7]
• {vrkC,prkC} ← Setup(C,1λ): Let C be an arithmetic cir-
cuit with u public input and output values from Fq, i.e.,
u is the statement size. Build a QAP Q = (t(x),V,W,Y )
of size m and let n be the degree of t(x). Let Imid = {u +
1, . . . ,m}. Let e be a bilinear map e : G1 × G2 → GT ,
and let g1 be a generator of G1 and g2 be a generator of
G2.
Choose α,β,γ,δ,s ← Fq. Construct the public proving
key prkC as follows:
◦ gα
1 ,gβ
1 ,gβ
2 ,gδ
1 ,gδ
2 }n−1
1 }n−1
i=0 ,{gsi
◦ {gsi
◦ {g(βvi(s)+αwi(s)+yi(s))/δ
◦ {gsit(s)/δ
}i∈Imid
i=0
2
1
}n−2
i=0
1
Construct the veriﬁcation key vrkC as
2 ,gγ