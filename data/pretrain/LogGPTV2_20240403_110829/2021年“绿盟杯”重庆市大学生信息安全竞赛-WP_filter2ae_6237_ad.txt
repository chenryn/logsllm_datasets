        {
            state = in;                                      //把输入拼图赋值到state拼图中
            if (dfs(0, -100))                                //进行dfs搜索（实际上IDA*就是比dfs增加了最大搜索深度(限制值limit),通过这个最大搜索深度，我们就能让dfs具有bfs的功能，但代价是每次循环(加大深度时)都得需要将之前搜索过的深度再次搜索一遍)。除了这个之外，就跟普通的dfs没有什么区别。
            {
                string ans = "";                             //声明移动的标识(当dfs找到最短路径时(dfs的返回值为true))
                for (int i = 0; i > in.f[i];                                               //进行拼图的输入
            if (in.f[i] == 0)                                             //如果输入的是空位(0拼图)
            {
                in.f[i] = N2;                                             //将这个空位的值标识为16(则整个拼图为:1-16 其中，16为空位置)
                in.space = i;                                             //记录一下空位的位置(下标值)
            }
        }
        string  ans = iterative_deepening(in);                            //进行IDA*搜索,其中ans代表移动的标识(为一串字母)
        cout  150 )
              return 0;
          }
          v5 += c[j] * (b[j] - a[j]);
        }
      }
      return v5 == dword_41C040;
    }
    这里用 z3 来进行解题：
    import z3
    a = [2, 12, 26,
         20, 13,
         15, 11, 16,
         12, 12,
         15, 13, 19,
         10, 18,
         16, 1, 8,
         17, 25,
         24, 22, 24,
         24, 14,
         6, 5, 18,
         24, 5,
         6, 2, 1,
         13, 20,
         100]
    b = [8, 22, 26,
         28, 24,
         28, 11, 18,
         18, 27,
         27, 24, 28,
         23, 24,
         25, 9, 15,
         24, 26,
         24, 23, 26,
         25, 23,
         16, 25, 29,
         30, 19,
         26, 23, 18,
         24, 29,
         200]
    c = [13, 25, 13,
         46, 12,
         43, 42, 4,
         22, 46,
         22, 35, 36,
         12, 24,
         12, 48, 8,
         24, 29,
         41, 7, 15,
         6, 21,
         2, 30, 19,
         10, 33,
         38, 5, 22,
         19, 40,
         68, 101, 99, 105]
    flagbool = [z3.Int(f"flagbool{i}") for i in range(35)]
    v7 = [0] * 35
    v5 = 0
    # print(flagbool[0].eq("True"))
    for i in range(len(flagbool)):
        # if z3.And(flagbool, True):
        for j in range(a[i], b[i]):
            v7[j] += c[i] * flagbool[i]
        v5 += c[i] * (b[i] - a[i]) * flagbool[i]
    s = z3.Solver()
    s.add(v5 == 3430)
    for i in range(35):
        s.add(v7[i] = 0)
    print(s.check())
    print(s.model())
## Crypto
###  签到
    凯撒密码，位移为 3
    Flag：flag{2a2ab40b9b031723cca883b61c15fee0}
###  easyRSA
    一道简单的 dp 泄露题目
    import gmpy2
    from Crypto.Util.number import *
    e = 65537
    n = gmpy2.mpz(101031799769686356875689677901727632087789394241694537610688487381734497153370779419148195361726900364384918762158954452844358699628272550435920733825528414623691447245900175499950458168333742756118038555364836309568598646312353874247656710732472018288962454506789615632015856961278964493826919853082813244227)
    dp = gmpy2.mpz(1089885100013347250801674176717862346181995027932544377293216564837464201546385463279055643089303360817423261428901834798955985043080308895369226243973673)
    c = gmpy2.mpz(59381302046219861703693321495442496884448849866535616496729805734326661742228038342690865965545318011599241185017546760846698815333545820228348501022889423901773651749628741238050559441761853071976079031678640014602919526148731936437472217369575554448232401310265267205034644121488774398730319347479771423197)
    for x in range(1, e):
        if(e*dp%x==1):
            p=(e*dp-1)//x+1
            if(n%p!=0):
                continue
            q=n//p
            phin=(p-1)*(q-1)
            d=gmpy2.invert(e, phin)
            m=gmpy2.powmod(c, d, n)
            if(len(hex(m)[2:])%2==1):
                continue
            print(long_to_bytes(m))
    Flag：flag{38c60aa8ddcfb50afa3021f40f0acdac}