其中，type 栏里的 ALL 值表明，将执行一次全表扫描，检查所有行。possible_keys 栏
possible_keys: NULL
口
查找，以在t2表里定位到符合条件的行。
select_type:
来寻找符合条件的行。
针对t1表里的每个行，对t2表执行一次全表扫描；同时，使用WHERE子句里的信息
第5章查询优化
key_len:
key_len:
WHERE t1.i1 = t2.i2\G
Extra: Using where; Using index
table:
Extr
type:
rows:
type
rows: 1000
key:
key:
ref:
ref:
key:
id:
id:
sampdb.t1.i1
NULL
SIMPLE
************2.rOW
1000
NULL
NULL
SIMPLE
Using where;Using join buffer
NULL
NULL
。t1 表的 EXPLAIN 结果表明，对它执行仍是全表扫描，但优化程序对
优化程序并没有发现任何有助于提高这条查询命令执行效率的信
---
## Page 233
到更准确的rows 估算值。
这将使服务器生成关于键值分布情况的统计数据。分析这些表，并再次运行EXPLAIN，便可得
到这样的结果。
优化程序只使用来自索引的信息即可完成查询任务，而无需进行查找便能获得行时，你也会看
道可以从索引文件里获得所需要的全部信息时，你便会看到这样的结果。对于InnoDB 表，当
可以直接从这个索引里读取值，而不用再去读取数据文件了。对于MyISAM表，当优化程序知
index。这些变化表明，虽然仍需要对已索引过的那些值进行完整的扫描，但是优化程序现在
容有了一些变化。其中，type 的值从 NULL变成了index，而 Extra 的值从空白变成了Using
加上索引，然后再次运行EXPLAIN。
一个表执行全表扫描，而全表扫描是不需要索引的。为看看它到底有无影响，可先给t1.i1列
接下来，为了帮助优化程序获得更有价值的估算值，将进一步运行ANALYSETABLE命令。
mysql>
这里的输出结果与前一条EXPLAIN的结果很相似。不过，在新增索引之后，t1表的输出内
possible_keys:
possible_keys:
mysql>
mySql> ALTER TABLE t1 ADD INDEX (i1);
有必要为t1表也加上索引吗？要知道，对于这个特定的连接操作，无论如何也需要对其中
口row的值从1000下降到了10，这表明优化程序相信：对于t1表里的每个行，在t2表
******
**********
口该引l用值被指定在ref字段里，即sampdb.t1.i1。
select_type:
select_type
select_type:
万估算值减少许多。
值。）现在，行组合的总估算值为1000×10=10000。这比之前没有任何索引时的100
t2表里只会有1个行与之匹配。稍后会看到，我们将如何帮助优化程序改进这个估计
里只需要检查10个行即可。
key_len:
key_len:
EXPLAIN
table:
Extra:
table:
Extr
table:
type:
rows:
ref:
type:
type:
key
id:
id:
index
t1
SIMPLE
SELECT t1.i1,
sampdb.t1.i1
22
SIMPLE
1000
index
SIMPLE
***
****
t2.i2 FROM t1INNERJOIN t2
（这是个保守估计。事实上，对于t1表里的每个行，在
*******************
5.2MySQL查询优化程序
￥**
***
213
---
## Page 234
选用 BLOB可以让每个值节省2个字节。（对于TEXT类型，也有类似的考虑。）
值的长度，而LONGBLOB类型会使用4个字节。如果要存储的值的长度没有超过64KB，那么
成CHAR（40），而不要定义为CHAR（255）。
CHAR列，则不要把它们设置得太长。如果存储在列里的最长值有 40个字符，那么就把它定义
够用，就不选BIGINT。如果FLOAT足以满足精度要求，就不选DOUBLE。如果选用固定长度的
性能。除了索引能加快查询速度以外，短键值的处理速度也较长键值的快。
得更小，从而减少在磁盘读写方面的开销。对于那些带索引的列，较短小的值还能进一步提升
对于字符串，其处理时间与长度有直接关系。选用较小类型的另一个好处是，可以让整个表变
的转换。）
例，不管你做何选择，INET_ATON（）和INET_NTOA（）函数都可以帮你完成两种表示形式之
还必须根据数据的具体用途和用法，为它们选择一种最合适的表示形式。（对于IP地址这个示
匹配。或许，你还可以用位掩码运算来做这样的事情。这类问题说明：不能只能考虑空间问题，
INT值又会给模式匹配运算带来困难，例如，你想要查找给定子网里的IP地址，就要用到模式
转换成整数形式，即可以把构成IP地址的4组数字依次存入INTUNSIGNED类型的4个字
例如，以点记号表示的IP地址，如192.168.0.4，通常就是一个字符串。但这种IP地址很容
运算所带来的好处。这些类型在内部是以数字形式表示的，处理效率更高。
字符与字符的比较才能完成，而且字符串越长，比较的次数越多。
之间的比较，可以在一个运算里完成。而字符串之间的比较，则需要进行多次字节与字节，或
建议，它们有助于提高查询命令的运行速度。
5.3
214
里。整数不仅节约存储空间，而且还可以加快检索速度。但从另一方面来看，把IP地址表示成
由
对于可变长度的类型，选用较小的类型仍可以节约空间。BLOB类型会使用2个字节来记录
对于使用固定长度数据类型的列，应该根据其取值范围选用最小的类型。如果 MEDIUMINT
当较小类型够用时，就不用较大类型。MySQL 处理较小类型的速度比较大类型快。尤其是
一起来看看字符串的其他表示方法。有时候，把字符串值表示成数字可以显著改善性能。
如果字符串类型列的取值个数有限，那么可以选用ENUM或SET类型，
多用数字运算，少用字符串运算。数字运算通常比字符串运算更快。以比较运算为例。数字
对数据类型的选择，会在许多方面影响查询性能。本节提供了一些与数据类型选择有关的
把数据列声明成 NOT NULL。如果数据列为 NOT NULL，那么 MySQL 对它的处理速度也会更
此时，优化程序估计：对于t1表里的每一个值，在t2表里只会有一个行与之匹配。
possible_keys:
possible_keys:
选择利于高效查询的数据类型
select_typ
第5章查询优化
Extr
type:
rows:
ref:
key:
key:
ref:
ra:
id:
Using where; Using index
1000
sampdb.t1.i1
SIMPLE
NULL
.2
S11
，这样可以获得数字
节
间
易
---
## Page 235
数据类型来存储它们。
用的散列算法有可能生成带有尾部空格的字符串，那么请不要选用那些会自动去除尾部空格的
应用程序里用你自己的算法来计算散列值。请记住，数字型散列值的存储效率非常高。如果
散列值可以通过MD5（）函数来生成。也可以选择使用函数SHA1（）或CRC32（）。当然，还可以不
精确匹配型查询。（散列值对于使用像“=”这样的运算符实现的范围搜索毫无用处。)
列值，把它存储到一个单独的列里。然后通过搜索散列值来检索行。不过，这个技术只适用
多个行所填补。可以使用前面讨论过的碎片处理技术来解决这个问题。
操作时。
表的结构，并且在修改问卷时不需要更改表的结构。
需要容
的答案
构的数据，然后再把它插到单个的 BLOB或TEXT列里。例如，可以使用XML来表示各个问卷
来往表里增加列。
里各个题目的答案。
2章对ALTERTABLE语句的讨论里，
办法特别适用于存储那些难以用标准表结构表示的数据，或者那些会随时间变化的数据。在
压缩和解压缩的数据，能够达到使用单个检索操作（而非多个操作）找出所有内容的目的。
然后再利用这个转储文件重建它：
费，并
产生
必须读取更多的磁盘块，才能获得有效的行，而这无疑会降低性能。包含可变长度行的表都会
生大量碎片。
高的类型。想要更改列的类型，可以使用 ALTER TABLE。
对于 ENUM类型的定义，其可读性很差。
256个字节（可以根据实际情况更改这些值)。
PROCEDUREANALYSE（）不要建议这样的ENUM类型：它包含的值超过16个，或者总长度超过
的信息：
成 ENUM列。ENUM值的处理速度很快，因为它们的内部表示形式皆为数字。
简单的查询，因为不用再把NULL当作一种特例去检查，并且更简单的查询处理起来通常会更快。
快。这是因为在查询处理期间，不再需要检查该列的值是否为NULL。这样可以让你编写出更为
使用合成索引。合成索引列有时很有用。一种做法是，先根据表里的其他列计算出一个散
这类问题的另一种解决方案是：让负责处理Web表单的应用程序把答案数据压缩成某种结
使用 PROCEDURE ANALYSE（）。运行 PROCEDUREANALYSE（），可以看到许多关于表里各列
另一方面，BLOB 和TEXT 值也会带来一些麻烦，尤其是在执行大量的 DELETE 或UPDATE
并有助于防止性能降低。适用于各种存储引擎的碎片整理方法是：先用mysqldump 转储表，
定期使用OPTIMIZE TABLE，可以消除或减少碎片化的 MyISAM或InnoDB表里的空间浪
考虑使用ENUM列。如果字符串列的基数低（即差异值的个数很少），则可以考虑把它转换
客户端对数据进行编码（当从表中检索行时，还需要对数据进行解码），但是它大大简化）
案，然后把这个XML字符串存储到一个TEXT列里。这种做法会增加客户端应用的负担，
把数据压缩到 BLOB或TEXT列。使用BLOB或TEXT列来存储那些可在应用程序里对其进行
整理表碎片
基于PROCEDUREANALYSE（）的输出，
输出结果里的一列，对适用于表里各个列的优化数据类型给出了建议。第二个示例会告知
碎片，但是
SELECT *FROM tbl_name PROCEDURE ANALYSE(16,256);
SELECT *FROM tbl_name PROCEDURE ANALYSE(）;
mysql db_namedump.sql
，删除这些值会在表里留下大量的空白，而这些空白在将来会被一个行或者长短不同的
是 BLOB或TEXT列受到的影响特别显著，因为它们的大小变化非常大。
碎片是有害的，因为它会造成存储表的磁盘块空间的浪费。随着时间的推移，你
片。对于那些频繁修改的表，尤其是那些包含有可变长度数据列的表，往往会产
。该示例讨论了，当需要往那个问卷里增加新题目时，如何用ALTERTABLE
，其中有一个示例处理了一个表，这个表中存储了Web问
你可能会发现，
。如果不加这些限制，那么输出结果可能会很长；
5.3
，可以修改一下自己的表，利用效率更
选择利于高效查询的数据类型
215
选
在
第
此
---
## Page 236
此
曹
的存储量。对于最大长度为n的列，VARCHAR 平均占用的空间比CHAR 更少，并且减少了存储
所以使用CHAR 列在本质上不会比使用VARCHAR 列更简单。因此，主要的性能因素在于行占月
作CHAR 来对待，因此不管你选择哪一个都没关系。
处理固定长度的行的速度，比变长的行快。对于那些会频繁修改，并因此而产生大量碎片的表，
要关心的内容，并且可以负担空间代价，那么可以使用（固定长度的）CHAR列，因为MyISAM
平均占用的空间只有它的一半，因此如果空间很紧张，则需要使用VARCHAR列。如果速度是主
间要多做综合考虑。对于最大长度为n的列，CHAR在每一行都要占用n个字符空间。而VARCHAR
列的长度都是可变的，那么它会使用可变长度的行。对于字符串列，可以通过是选用CHAR
合适的格式提供了一些一般性的指导，但对于某个具体的应用，最好的做法是执行测试，以进
5.4
处。此外，它还能让你在主表上运行 SELECT*查询，不用通过网络拉取大的 BLOB或TEXT值。
更
离出来，存入一个附表，可能会更有意义，前提是，这样做可以让你把这个表的其他列转换成
BLOB或TEXT值检索出来。
诸