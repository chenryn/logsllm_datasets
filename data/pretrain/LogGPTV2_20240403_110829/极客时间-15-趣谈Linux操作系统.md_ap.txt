# ./staticcreateprocess
# total 40-rw-r--r--. 1 root root 1572 Oct 24 18:38 CentOS-Base.repo......静态链接库一旦链接进去，代码和变量的 section都合并了，因而程序运行的时候，就不依赖于这个库是否存在。但是这样有一个缺点，就是相同的代码段，如果被多个程序使用的话，在内存里面就有多份，而且一旦静态链接库更新了，如果二进制执行文件不重新编译，也不随着更新。因而就出现了另一种，**动态链接库**（SharedLibraries），不仅仅是一组对象文件的简单归档，而是多个对象文件的重新组合，可被多个程序共享。    gcc -shared -fPIC -o libdynamicprocess.so process.o当一个动态链接库被链接到一个程序文件中的时候，最后的程序文件并不包括动态链接库中的代码，而仅仅包括对动态链接库的引用，并且不保存动态链接库的全路径，仅仅保存动态链接库的名称。    gcc -o dynamiccreateprocess createprocess.o -L. -ldynamicprocess当运行这个程序的时候，首先寻找动态链接库，然后加载它。默认情况下，系统在/lib 和 /usr/lib文件夹下寻找动态链接库。如果找不到就会报错，我们可以设定 LD_LIBRARY_PATH环境变量，程序运行时会在此环境变量指定的文件夹下寻找动态链接库。    
# export LD_LIBRARY_PATH=.
# ./dynamiccreateprocess
# total 40-rw-r--r--. 1 root root 1572 Oct 24 18:38 CentOS-Base.repo......动态链接库，就是 ELF 的第三种类型，**共享对象文件**（Shared Object）。基于动态连接库创建出来的二进制文件格式还是 ELF，但是稍有不同。首先，多了一个.interp 的 Segment，这里面是ld-linux.so，这是动态链接器，也就是说，运行时的链接动作都是它做的。另外，ELF 文件中还多了两个 section，一个是.plt，过程链接表（ProcedureLinkage Table，PLT），一个是.got.plt，全局偏移量表（Global OffsetTable，GOT）。它们是怎么工作的，使得程序运行的时候，可以将 so文件动态链接到进程空间的呢？dynamiccreateprocess 这个程序要调用 libdynamicprocess.so 里的create_process函数。由于是运行时才去找，编译的时候，压根不知道这个函数在哪里，所以就在PLT 里面建立一项PLT\[x\]。这一项也是一些代码，有点像一个本地的代理，在二进制程序里面，不直接调用create_process 函数，而是调用 PLT\[x\里面的代理代码，这个代理代码会在运行的时候找真正的 create_process 函数。去哪里找代理代码呢？这就用到了 GOT，这里面也会为 create_process函数创建一项 GOT\[y\]。这一项是运行时 create_process函数在内存中真正的地址。如果这个地址在，dynamiccreateprocess 调用 PLT\[x\里面的代理代码，代理代码调用 GOT 表中对应项GOT\[y\]，调用的就是加载到内存中的 libdynamicprocess.so 里面的create_process 函数了。但是 GOT 怎么知道的呢？对于 create_process 函数，GOT 一开始就会创建一项GOT\[y\]，但是这里面没有真正的地址，因为它也不知道，但是它有办法，它又回调PLT，告诉它，你里面的代理代码来找我要 create_process函数的真实地址，我不知道，你想想办法吧。PLT 这个时候会转而调用 PLT\[0\]，也即第一项，PLT\[0\] 转而调用GOT\[2\]，这里面是 ld-linux.so 的入口函数，这个函数会找到加载到内存中的libdynamicprocess.so 里面的 create_process函数的地址，然后把这个地址放在 GOT\[y\] 里面。下次，PLT\[x\的代理函数就能够直接调用了。这个过程有点绕，但是是不是也很巧妙？
## 运行程序为进程知道了 ELF这个格式，这个时候它还是个程序，那怎么把这个文件加载到内存里面呢？在内核中，有这样一个数据结构，用来定义加载二进制文件的方法。    struct linux_binfmt {        struct list_head lh;        struct module *module;        int (*load_binary)(struct linux_binprm *);        int (*load_shlib)(struct file *);        int (*core_dump)(struct coredump_params *cprm);        unsigned long min_coredump;     /* minimal dump size */} __randomize_layout;对于 ELF 文件格式，有对应的实现。    static struct linux_binfmt elf_format = {        .module         = THIS_MODULE,        .load_binary    = load_elf_binary,        .load_shlib     = load_elf_library,        .core_dump      = elf_core_dump,        .min_coredump   = ELF_EXEC_PAGESIZE,};load_elf_binary是不是你很熟悉？没错，我们加载内核镜像的时候，用的也是这种格式。还记得当时是谁调用的 load_elf_binary函数吗？具体是这样的：do_execve-\>do_execveat_common-\>exec_binprm-\>search_binary_handler。那 do_execve 又是被谁调用的呢？我们看下面的代码。    SYSCALL_DEFINE3(execve,const char __user *, filename,const char __user *const __user *, argv,const char __user *const __user *, envp){return do_execve(getname(filename), argv, envp);}学过了系统调用一节，你会发现，原理是 exec 这个系统调用最终调用的load_elf_binary。exec 比较特殊，它是一组函数：-   包含 p 的函数（execvp, execlp）会在 PATH 路径下面寻找程序；-   不包含 p 的函数需要输入程序的全路径；-   包含 v 的函数（execv, execvp, execve）以数组的形式接收参数；-   包含 l 的函数（execl, execlp, execle）以列表的形式接收参数；-   包含 e 的函数（execve, execle）以数组的形式接收环境变量。![](Images/35ed5572a7b404aa564bc76dc318cc24.png){savepage-src="https://static001.geekbang.org/resource/image/46/f6/465b740b86ccc6ad3f8e38de25336bf6.jpg"}在上面 process.c 的代码中，我们创建 ls 进程，也是通过 exec。