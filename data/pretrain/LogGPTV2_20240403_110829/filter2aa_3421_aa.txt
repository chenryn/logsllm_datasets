Porosity
Decompiling Ethereum Smart-Contracts
Matt Suiche (@msuiche)
Founder, Comae Technologies
PI:EMAIL
Whoami
 @msuiche
 Comae Technologies 
 OPCDE - www.opcde.com 
 First time in Vegas since BlackHat 2011
 Mainly Windows-related stuff
 CloudVolumes (VMware App Volumes)
 Memory Forensics for DFIR (Hibr2Bin, DumpIt etc.)
 “looks like such fun guy” – TheShadowBrokers
 Didn’t know much about blockchain before this project
Just so you know…
 We won’t talk about POW/POS stuff
 We won’t talk about Merkle Trees
 We won’t talk about how to becoming a crypto-currency millionaire
 We will talk about the Ethereum EVM
 We will talk about Solidity
 We will talk about smart-contract bytecodes
 And yes, the tool isn’t perfect ☺
Agenda
 Ethereum Virtual Machine (EVM)
 Memory Management
 Addresses
 Call Types
 Type Discovery
 Smart-Contract
 Code Analysis
 Known Bugs
 Future
Solidity
 Solidity the quality or state of being firm or strong in 
structure.
 But also the name of Ethereum’s smart-contracts compiler
 Porosity is the quality of being porous, or full of tiny holes. 
Liquids go right through things that have porosity. 
 But also the name of Comae’s smart-contract decompiler.
Ethereum Virtual Machine (EVM)
 Account/Contract/Blockchain
 A Smart-Contract is made of bytecode stored in the blockchain.
 An address is a 160-bits value & corresponds to an “account”
 Operates 256-bits pseudo-registers
 EVM does not really have registers, but uses a virtual stack to replace them.
Solidity & “Smart Contracts”
 Solidity compiles JavaScript-like code into Ethereum bytecode.
contract Coin {
// The keyword "public" makes those variables
// readable from outside.
address public minter;
mapping (address => uint) public balances;
// Events allow light clients to react on
// changes efficiently.
event Sent(address from, address to, uint amount);
// This is the constructor whose code is
// run only when the contract is created.
function Coin() {
minter = msg.sender;
}
function mint(address receiver, uint amount) {
if (msg.sender != minter) return;
balances[receiver] += amount;
}
function send(address receiver, uint amount) {
if (balances[msg.sender] < amount) return;
balances[msg.sender] -= amount;
balances[receiver] += amount;
Sent(msg.sender, receiver, amount);
}
}
Memory Management
 Stack
 Virtual stack is being used for operations to pass parameters to opcodes.
 256-bit values/entries
 Maximum size of 1024 elements
 Storage (Persistent)
 Key-value storage mapping (256-to-256-bit integers)
 Can’t be enumerated.
 SSTORE/SLOAD
 Memory (Volatile)
 256-bit values (lots of AND operations, useful for type discovery)
 MSTORE/MLOAD
Basic Blocks
 Usually start with the JUMPDEST instruction – except few cases.
 JUMP* instruction jump to the address contained in the 1st element 
of the stack.
 JUMP* instruction are (almost always) preceded by PUSH instruction
 This allows to push the destination address in the stack, instead of 
hardcoding the destination offset.
 SWAP/DUP/POP stack manipulation instructions can make jump 
destination address harder to retrieve
 This requires dynamic analysis to rebuild the relationship between each 
basic block.
EVM functions/instructions 
 EVM instructions are more like functions, such as:
 Arithmetic, Comparison & Bitwise Logic Operations
 SHA3
 Environmental & Block Information
 Stack, Memory, Storage and Flow Operations
 Logging & System Operations
Instruction call - Addition
 The above translates at the EVM-pseudo code:
 add(0x2, 0x1)
Offset
Instruction
Stack[0]
Stack[2]
n
PUSH1 0x1
0x1
n + 1
PUSH1 0x2
0x2
0x1
n + 2
ADD
0x3
EVM Call
 Can be identified by the CALL instruction.
 Call external accounts/contracts pointed by the second 
parameter
 The second parameter contains the actual 160 address of the 
external contract
 With the exception of 4 hardcoded contracts:
 1 – elliptic curve public key recovery function
 2- SHA2 function
 3- RIPEMD160 function
 4- Identity function
call(
gasLimit,
to,
value,
inputOffset,
inputSize,
outputOffset,
outputSize
)
User-Defined functions (Solidity)
 CALLDATALOAD instruction is used to read the Environmental 
Information Block (EIB) such as parameters.
 First 4 bytes of the EIB contains the 32-bits hash of the called 
function.
 Followed by the parameters based on their respective types. 
 e.g. int would be a 256 bits word.
 a = calldataload(0x4)
 b = calldataload(0x24)
 add(calldataload(0x4), calldataload(0x24)
function foo(int a, int b) {
return a + b;
}
Type Discovery - Addresses
 As an example, addresses are 160-bit words
 Since stack registers are 256-bit words, they can easily be identified 
through AND operations using the 
0xffffffffffffffffffffffffffffffffffffffff mask.
 Mask can be static or computed dynamically
Ethereum Assembly
Translation (msg.sender)
CALLER
PUSH1 0x01
PUSH 0xA0
PUSH1 0x02
EXP
SUB
AND
and(reg256, sub(exp(2, 0xa0), 1)) (EVM)
reg256 & (2 ** 0xA0) - 1) (Intermediate)
address (Solidity)
Bytecode
 The bytecode is divided in two categories:
 Pre-loader code
 Found at the beginning that contains the routine to bootstrap 
the contract
 Runtime code of the contract
 The core code written by the user that got compiled by 
Solidity
 Each contract contain a dispatch function that redirects the 
call to the corresponding function based on the provided 
hash function.
Bytecode – Pre-loader
 CODECOPY copies the runtime part of the contract into the EVM 
memory – which gets executed at base address 0x0
00000000 6060
00000002 6040
00000004 52
00000005 6000
00000007 6001
00000009 6000
0000000b 610001
0000000e 0a
0000000f 81
00000010 54
00000011 81
00000012 60ff
00000014 02
00000015 19
00000016 16
00000017 90
00000018 83
00000019 02
0000001a 17
0000001b 90
0000001c 55
0000001d 50
0000001e 61bb01
00000021 80
00000022 612b00
00000025 6000
00000027 39
00000028 6000
0000002a f3
PUSH1 60
PUSH1 40
MSTORE
PUSH1 00
PUSH1 01
PUSH1 00
PUSH2 0001
EXP
DUP2
SLOAD
DUP2
PUSH1 ff
MUL
NOT
AND
SWAP1
DUP4
MUL
OR
SWAP1
SSTORE
POP
PUSH2 bb01
DUP1
PUSH2 2b00
PUSH1 00
CODECOPY
PUSH1 00
RETURN
Bytecode – Dispatcher (--list)
loc_00000000:
0x00000000 60 60                      PUSH1 60 
0x00000002 60 40                      PUSH1 40 
0x00000004 52                         MSTORE 
0x00000005 60 e0                      PUSH1 e0 
0x00000007 60 02                      PUSH1 02 
0x00000009 0a                         EXP 
0x0000000a 60 00                      PUSH1 00 
0x0000000c 35                         CALLDATALOAD 
0x0000000d 04                         DIV 
0x0000000e 63 06  72  e9  ee
PUSH4 06 72 e9 ee
0x00000013 81                         DUP2 
0x00000014 14                         EQ 
0x00000015 60 24                      PUSH1 24
0x00000017 57                         JUMPI 
loc_00000018:
0x00000018 80                         DUP1 
0x00000019 63 9d  04  0a  f4          PUSH4 9d 04 0a f4 
0x0000001e 14                         EQ 
0x0000001f 60 35                      PUSH1 35
0x00000021 57                         JUMPI 
loc_00000022:
0x00000022 5b                         JUMPDEST 
0x00000023 00                         STOP
double(uint256):
0x00000024 5b                         JUMPDEST 
0x00000025 60 45                      PUSH1 45 
0x00000027 60 04                      PUSH1 04 
0x00000029 35                         CALLDATALOAD 
0x0000002a 60 00                      PUSH1 00 
0x0000002c 60 4f                      PUSH1 4f 
0x0000002e 82                         DUP3 
0x0000002f 60 02                      PUSH1 02 
loc_00000031:
0x00000031 5b                         JUMPDEST 
0x00000032 02                         MUL 
0x00000033 90                         SWAP1 
0x00000034 56                         JUMP 
triple(uint256):
0x00000035 5b                         JUMPDEST 
0x00000036 60 45                      PUSH1 45 
0x00000038 60 04                      PUSH1 04 
0x0000003a 35                         CALLDATALOAD 
0x0000003b 60 00                      PUSH1 00 
0x0000003d 60 4f                      PUSH1 4f 
0x0000003f 82                         DUP3 
0x00000040 60 03                      PUSH1 03 
0x00000042 60 31                      PUSH1 31 
0x00000044 56                         JUMP 
calldataload(0x0) / exp(0x2, 0xe0)
Function Hashes
 The 4 bytes of the sha3 (keccak256) value for the string 
functionName(param1Type, param2Type, etc)
[ 
{ 
"constant":false,
"inputs":[{ "name":"a", "type":"uint256" }],
"name":"double",
"outputs":[{ "name":"", "type":"uint256" }],
"type":"function"
}
]