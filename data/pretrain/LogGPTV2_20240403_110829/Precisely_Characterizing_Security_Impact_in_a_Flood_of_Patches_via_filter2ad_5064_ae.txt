#
85
65
13
Security impacts
Use-after-free/Double-free
Permission bypass
#
67
13
TABLE XI: Security impacts for the identified security bugs
found by SID, and 1,339 CVE-assigned vulnerabilities. The
statistical results are shown in Figure 5. We can find that
security bugs and vulnerabilities are highly similar in terms
of the number of changed lines in their patches—both have a
smaller number then general bugs patches have. The finding is
consistent with the results found by Li et al. [27]. Also, the
patches for vulnerabilities and security bugs tend to change
fewer files than patches for general bugs. Patches for general
bugs changed 3.0 files on average, which in contrast to 2.3
files for patches of vulnerabilities and security bugs found by
SID.
Another finding is that among the git commits for the
1,339 vulnerabilities, 814 (60.8%) of them did not mention
any security impacts such as use-after-free, double-free, etc.
This result implies that one cannot reliably determine the
security impacts solely based on the textual information in
patch commits.
14
VII. DISCUSSION
The generality of SID. SID can be extended to determine
the security impacts of patches for other well maintained open-
source programs such as Firefox, Chrome, and FreeBSD. Our
patch model is general, which can be used to describe the
security operations and vulnerable operations in a program-
agnostic manner. To extend SID to other programs, only the pre-
processing part requires new manual effort. For example, for out-
of-bound access vulnerabilities, for different target programs,
we need to collect functions for memory access and bound
checks.
The extensibility of SID.
In our work, SID is only used to
support the common classes of vulnerabilities. However, other
classes of vulnerabilities can also be supported by specifying the
security rules for them—how these vulnerabilities violate the
security rules. In addition, the rules for constructing constraints
from security operations and security rules should also be
specified. Table XII shows that we can naturally extend SID to
support more classes of bugs by modeling the three components
of their patches. For example, numerical-error vulnerabilities
such as divide-by-zero can be supported. The security rule is
that the divisor cannot be zero. Correspondingly, the vulnerable
operation is division, and the security operation can be a zero-
check for the divisor. Similarly, NULL-pointer dereference
also fits SID’s model. The security rule is that a dereferenced
pointer cannot be NULL. Therefore, the vulnerable operation
is pointer dereferencing, and the security operations can be
a NULL check. After including these types, Sid can cover
at least 51% of vulnerabilities (13% more).In the future, we
would like to support more classes of vulnerabilities.
In addition, the current implementation of SID considers
only simple patching patterns for vulnerabilities because we
find that the average distance between a security operation and
a vulnerable operation is 6.6 lines of code, and the longest
distance is 65 lines of code. This result is consistent with the
finding of SPIDER [32]—94.4% of safe patches affect less than
20 lines of code. Therefore, the under-constrained symbolic
execution can handle most of them efficiently. In the future,
SID can also be extended to support complicated patterns.
For example, some patches use multiple security operations
together to fix a vulnerability. These cases can be described
using complex security rules and represented with multiple
200020040060080010001200140016000%10%20%30%40%50%60%70%80%90%03060901201501802102402700%10%20%30%40%50%60%70%80%90%General bugsCVE vulnerabilitiesSecurity bugs found by SID(1) Patching-time window (days)(2) Security impacts delayed time  (days)(3) Number of changed lines in diﬀerent patches 010203040506070809010030%40%50%60%70%80%90%CDFGeneral bugsCVE vulnerabilitiesSecurity bugs found by SIDSecurity bugs (by root cause)
Security impact
Security operation
Vulnerable operation
Critical Variable
Missing release
Missing NULL check
Missing zero check
Missing/wrong locks/unlocks
Memory leak
NULL dereference
Divide by zero
Race condition
(UAF/DF and etc.)
Release operation
NULL check
Zero check
Lock/unlock
Allocation operation
Pointer dereference
Use as divisor
Operations in critical section
Allocated pointer
Checked pointer
Divisor
Lock variable
SR in PV or
SO in UPV
SR in UPV or
SO in PV
FLAGCV = 0
FLAGCV = 0
FLAGCV = 0
FLAGCV = 1
FLAGCV = 1
FLAGCV = 1
FLAGCV = 0
FLAGCV = 1
TABLE XII: The key components of patches and constraints modeling for more types of bugs. SO = security operations; SR = security rules;
PV = patched version; UPV = unpatched version.
constraints.
Reducing false negatives. First, the conservativeness of
the under-constrained symbolic execution indeed introduces a
significant number of false negatives, because in the current
implementation, the constraints for the slice paths are collected
only from the security operation to the vulnerable operation.
Therefore, the constraints are under-constrained. As an improve-
ment, in the future, we can extend the constraint collection
beyond the security operation—backwardly collecting as many
constraints as possible from the security operation and adding
them to the final constraint set. This method could reduce at
most 17% of false negatives in our evaluation.
Second, the incompleteness of the security and vulnerable
operations sets also causes false negatives. To reduce them, we
can collect more custom functions for security and vulnerable
operations. Such functions can be modeled based on dynamic
analysis [63] and wrapper-function analysis [21, 62]. Covering
more security and vulnerable operations can reduce at most 31%
of false negatives. For example, if we model the lock/unlock
operations for use-after-free, we can additionally cover 25%
of use-after-free vulnerabilities in the evaluation. But to do
so, more manually analysis work on patches and engineering
efforts are needed. Therefore, we put these works in future
works.
VIII. RELATED WORK
Mining security-critical vulnerabilities from bugs. Wi-
jayasekara et al. [53] show the hidden impact vulnerabilities
that were first identified as non-security bugs and publicized
and later were identified as vulnerabilities due to exploits.
In addition, previous work [5, 15, 23, 50, 54, 65] has used
supervised and unsupervised learning techniques to classify the
vulnerabilities and general bugs based on the textual information
of the patches. Tyo [50] showed that the Naive Bayes and
Support Vector Machine classifiers always have the best
performance. However, such work cannot handle the patches
without descriptions or if they have incomplete/inaccurate
descriptions. Moreover,
these works focused only on dif-
ferentiating vulnerabilities from general bugs, which cannot
determine the specific security impacts of the bugs or pinpoint
the vulnerable operations resulting in the security impacts.
Recent work, SPIDER [32], identifies fixes as security fixes as
long as they do not disrupt the intended functionalities. This
assumption does not hold for some patches, such as the ones
only improving code readability or replacing equivalent APIs.
In contrast to these papers, SID can precisely determine the
security impacts of a patched bug and provide details on the
vulnerable operations even when the commit description is not
available. Moreover, SID is not based on the assumptions used
by SPIDER.
Testing the exploitability of bugs. Several prior studies have
attempted to test the exploitability of a particular class of bugs.
Specifically, Lu et al. [30] showed how to exploit uninitialized-
use bugs using symbolic execution and fuzzing in the Linux
kernel. Xu et al. [58] presented a memory collision strategy
to exploit the use-after-free vulnerabilities in the Linux kernel.
You et al. [61] presented SemFuzz, which guides the automatic
generation of proof-of-concept exploits for vulnerabilities.
Thanassis et al. [4] proposed AEG, a symbolic execution–based
automatic exploit generation tool that can automatically exploit
memory-corruption bugs such as buffer overflow. Wu et al. [55]
presented FUZE, which can automatically exploit use-after-free
vulnerabilities in the Linux kernel. Unlike these studies, SID
does not focus on the exploitability of a specific class of
vulnerability. Instead, SID aims to automatically determine the
security impacts of a bug once it is triggered. Moreover, SID
is not limited to a specific vulnerability class.
Bug-severity assessment. Mell et al. [33] presented the
common vulnerability scoring system (CVSS), which is the
most widely used vulnerability scoring system. CVSS requires
manual scoring of the severity of vulnerabilities based on their
confidentiality, integrity, and availability. However, Munaiah
et al. [37] showed that CVSS is often biased in determining
the severity. For example, it does not treat code execution
and privilege escalation as important factors when analyzing
the severity of vulnerabilities. Most of the severity-analysis
techniques [9, 34, 40, 43] are based on bug reports, which also
cannot handle the bug patches without a description or if they
have incomplete descriptions.
Symbolic execution. Symbolic execution has been used for
decades. Cadar et al. [7] proposed a symbolic execution method
to generate inputs to trigger bugs in real code automatically.
Later, Cadar et al. developed KLEE [6], which is a widely-
used symbolic execution engine. Both of these tools need
the complete constraints in the program; thus, they can only
symbolically execute from the entry of a program. Such
symbolic execution does not scale well to large programs.
Under-constrained symbolic execution [17, 41], implemented
in UC-KLEE, lifts this limitation by treating symbolic values
coming from unexecuted parts of the code especially. This
approach makes symbolic execution much more flexible and
expands the possible applications. Because under-constrained
symbolic execution is unaware of properties of data established
by the unexecuted code, it can still produce false-positive
error reports that would not occur when executing a complete
program. Similar to UC-KLEE, SID also uses under-constrained
symbolic execution to execute from an arbitrary point in a
15
function symbolically. However, SID minimizes false positives
by combining the constraints from security rules and differential
analysis. Also, different from UC-KLEE, which detects bugs
introduced by new patches, SID determines the security impacts
of patches.
IX. CONCLUSION
Maintainers of large software programs are bombarded with
a large number of bug reports without a reliable description of
security impacts. With limited resources, maintainers have to
prioritize the patching for bugs with security impacts, which is
however challenging, and de-prioritizing a security-critical bug
will lead to critical security problems. This paper presented
SID, an automated approach to determining the security impacts
for a massive number of bug patches. The core of SID is the
symbolic rule comparison mechanism that employs differential,
under-constrained symbolic execution to precisely confirm
the security impacts of a bug. SID can further automatically
classify vulnerabilities based on their security impacts. We
have implemented SID and applied it to determine the security
impacts of Linux-kernel bugs. As a result, SID have found
227 security bugs from 54K valid commits patches in the
Linux kernel, and 21 of them remain unpatched in the latest
Android kernel (version 4.14), which may cause critical security
problems to Android devices. Many of the identified security
bugs have been assigned with a CVE ID and a high CVSS score.
The evaluation results show the precision and effectiveness of
SID in automatically determining security impacts.
X. ACKNOWLEDGMENT
The authors would like to thank the anonymous reviewers
for their helpful feedback. This research was supported in part
by the NSF awards CNS-1815621 and CNS-1931208. Any
opinions, findings, conclusions or recommendations expressed
in this material are those of the authors and do not necessarily
reflect the views of NSF.
REFERENCES
[1] Linux syscall reference, 2019. https://syscalls.kernelgrok.com/.
[2] J. Anvik, L. Hiew, and G. C. Murphy. Coping with an open bug repository.
In Proceedings of the 2005 OOPSLA workshop on Eclipse Technology
eXchange, ETX, pages 35–39, Oct. 2005.
[3] J. Arnold, T. Abbott, W. Daher, G. Price, N. Elhage, G. Thomas,
and A. Kaseorg. Security impact ratings considered harmful.
In
Proceedings of HotOS’09: 12th Workshop on Hot Topics in Operat-
ing Systems, May 2009. https://www.usenix.org/conference/hotos-xii/
security-impact-ratings-considered-harmful.
[4] T. Avgerinos, S. K. Cha, A. Rebert, E. J. Schwartz, M. Woo, and
D. Brumley. Automatic exploit generation. Communications of the
ACM, 57(2):74–84, 2014.
[5] D. Behl, S. Handa, and A. Arora. A bug mining tool to identify and
In Optimization,
analyze security bugs using naive bayes and tf-idf.
Reliabilty, and Information Technology (ICROIT), 2014 International
Conference on, pages 294–299. IEEE, 2014.
[6] C. Cadar, D. Dunbar, D. R. Engler, et al. Klee: Unassisted and automatic
In
generation of high-coverage tests for complex systems programs.
OSDI, volume 8, pages 209–224, 2008.
[7] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and D. R. Engler.
Exe: automatically generating inputs of death. ACM Transactions on
Information and System Security (TISSEC), 12(2):10, 2008.
[8] O. Chaparro, J. Lu, F. Zampetti, L. Moreno, M. Di Penta, A. Marcus,
G. Bavota, and V. Ng. Detecting missing information in bug descriptions.
In Proceedings of the 2017 11th Joint Meeting on Foundations of Software
Engineering, pages 396–407. ACM, 2017.
[9] K. Chaturvedi and V. Singh. Determining bug severity using machine
In 2012 CSI Sixth International Conference on
learning techniques.
Software Engineering (CONSEG), pages 1–6. IEEE, 2012.
[10] J. Corina, A. Machiry, C. Salls, Y. Shoshitaishvili, S. Hao, C. Kruegel,
and G. Vigna. Difuze: Interface aware fuzzing for kernel drivers. In
Proceedings of the 2017 ACM SIGSAC Conference on Computer and
Communications Security, pages 2123–2138. ACM, 2017.
[11] J. Corina, A. Machiry, C. Salls, Y. Shoshitaishvili, S. Hao, C. Kruegel,
and G. Vigna. Fuzzer for linux kernel drivers, 2019. https://github.com/
ucsb-seclab/difuze.
[12] M. Corporation. Common weakness enumeration (cwe), 2019. https:
//cwe.mitre.org/data/definitions/1000.html.
[13] M. Corporation. Common vulnerabilities and exposures, 2019. https:
//cve.mitre.org/cgi-bin/cvekey.cgi?keyword=linux+kernel.
[14] S. Counte. Mobile operating system market share worldwide, 2019.
http://gs.statcounter.com/os-market-share/mobile/worldwide.
[15] D. C. Das and M. R. Rahman. Security and performance bug reports
identification with class-imbalance sampling and feature selection. In
2018 Joint 7th International Conference on Informatics, Electronics &
Vision (ICIEV) and 2018 2nd International Conference on Imaging, Vision
& Pattern Recognition (icIVPR), pages 316–321. IEEE, 2018.
[16] E. W. Dijkstra et al. A note on two problems in connexion with graphs.
Numerische mathematik, 1(1):269–271, 1959.
[17] D. R. Engler and D. Dunbar. Under-constrained execution: making
In Proceedings of
automatic code destruction easy and scalable.
the ACM/SIGSOFT International Symposium on Software Testing and
Analysis (ISSTA), pages 1–4, July 2007.
[18] X. Ge, N. Talele, M. Payer, and T. Jaeger. Fine-Grained Control-Flow
Integrity for Kernel Software. In 2016 IEEE European Symposium on
Security and Privacy (EuroS&P), pages 179–194. IEEE, 2016.
[19] M. Gegick, P. Rotella, and T. Xie. Identifying security bug reports via
text mining: An industrial case study. The 7th IEEE Working Conference
on Mining Software Repositories (MSR’10), 2010.
[20] A. Y. Gerasimov, L. V. Kruglov, M. Ermakov, and S. P. Vartanov. An
approach to reachability determination for static analysis defects with
the help of dynamic symbolic execution. Programming and Computer
Software, 44(6):467–475, 2018.
[21] R. Ghiya, D. Lavery, and D. Sehr. On the importance of points-to analysis
and other memory disambiguation methods for c programs. In ACM
SIGPLAN Notices, volume 36, pages 47–58. ACM, 2001.
[22] Google. Android security rewards program rules, 2019. https://www.
google.com/about/appsecurity/android-rewards/.
[23] K. Goseva-Popstojanova and J. Tyo. Identification of security related bug
reports via text mining using supervised and unsupervised classification.
In 2018 IEEE International Conference on Software Quality, Reliability
and Security (QRS), pages 344–355. IEEE, 2018.
Survey shows linux the top operating system for in-
things devices, 2018.
https://www.itprotoday.com/iot/
[24] C. Hall.
ternet of
survey-shows-linux-top-operating-system-internet-things-devices.
[25] P. Hooimeijer and W. Weimer. Modeling bug report quality.
In
Proceedings of the twenty-second IEEE/ACM international conference
on Automated software engineering, pages 34–43. ACM, 2007.
[26] B. Lee, L. Lu, T. Wang, T. Kim, and W. Lee. From zygote to morula:
In 2014 IEEE Symposium on
Fortifying weakened aslr on android.
Security and Privacy, pages 424–439. IEEE, 2014.
[27] F. Li and V. Paxson. A large-scale empirical study of security patches.
In Proceedings of the 2017 ACM SIGSAC Conference on Computer and
Communications Security, pages 2201–2215. ACM, 2017.
[28] K. Lu and H. Hu. Where does it go? refining indirect-call targets with
In Proceedings of the 2019 ACM SIGSAC
multi-layer type analysis.
Conference on Computer and Communications Security, pages 1867–
1881, 2019.
[29] K. Lu, C. Song, B. Lee, S. P. Chung, T. Kim, and W. Lee. Aslr-guard:
Stopping address space leakage for code reuse attacks. In Proceedings of
the 22nd ACM SIGSAC Conference on Computer and Communications
Security, pages 280–291. ACM, 2015.
16
[53] D. Wijayasekara, M. Manic, J. L. Wright, and M. McQueen. Mining
In 2012 5th
bug databases for unidentified software vulnerabilities.
International Conference on Human System Interactions, pages 89–96.
IEEE, 2012.
[54] D. Wijayasekara, M. Manic, and M. McQueen. Vulnerability identification
and classification via text mining bug databases. In IECON 2014-40th
Annual Conference of the IEEE Industrial Electronics Society, pages
3612–3618. IEEE, 2014.
[55] W. Wu, Y. Chen, J. Xu, X. Xing, X. Gong, and W. Zou. {FUZE}: Towards
facilitating exploit generation for kernel use-after-free vulnerabilities. In
27th {USENIX} Security Symposium ({USENIX} Security 18), pages
781–797, 2018.
[56] T. Xie, N. Tillmann, J. De Halleux, and W. Schulte. Fitness-guided
path exploration in dynamic symbolic execution. In 2009 IEEE/IFIP
International Conference on Dependable Systems & Networks, pages
359–368. IEEE, 2009.
[57] M. Xu, C. Qian, K. Lu, M. Backes, and T. Kim. Precise and Scalable
Detection of Double-Fetch Bugs in OS Kernels. In Proceedings of the
39th IEEE Symposium on Security and Privacy (Oakland), San Francisco,
CA, May 2018.
[58] W. Xu, J. Li, J. Shu, W. Yang, T. Xie, Y. Zhang, and D. Gu. From collision
to exploitation: Unleashing use-after-free vulnerabilities in linux kernel.
In Proceedings of the 22nd ACM SIGSAC Conference on Computer and
Communications Security, pages 414–425. ACM, 2015.
[59] W. Xu, H. Moon, S. Kashyap, P.-N. Tseng, and T. Kim. Fuzzing file
In 2019 IEEE
systems via two-dimensional input space exploration.
Symposium on Security and Privacy (SP). IEEE, May 2019.
[60] J. Yang, C. Sar, P. Twohey, C. Cadar, and D. R. Engler. Automatically
In 2006 IEEE
generating malicious disks using symbolic execution.
Symposium on Security and Privacy (S&P 2006), pages 243–257, May
2006.
[61] W. You, P. Zong, K. Chen, X. Wang, X. Liao, P. Bian, and B. Liang.
Semfuzz: Semantics-based automatic generation of proof-of-concept
In Proceedings of the 2017 ACM SIGSAC Conference on
exploits.
Computer and Communications Security, pages 2139–2154. ACM, 2017.
[62] T. Zhang, W. Shen, D. Lee, C. Jung, A. M. Azab, and R. Wang. Pex: a
permission check analysis framework for linux kernel. In 28th {USENIX}
Security Symposium ({USENIX} Security 19), pages 1205–1220, 2019.
[63] Z. Zhang, Y. Wang, and Z. Fan. Similarity analysis between scale model
and prototype of large vibrating screen. Shock and Vibration, 2015, 2015.
[64] X. Zhou, Y. Lee, N. Zhang, M. Naveed, and X. Wang. The peril of
fragmentation: Security hazards in android device driver customizations.
In Proceedings of the 2014 IEEE Symposium on Security and Privacy,
SP ’14, pages 409–423, 2014. ISBN 978-1-4799-4686-0.
[65] Y. Zhou and A. Sharma. Automated identification of security issues from
commit messages and bug reports. In Proceedings of the 2017 11th Joint
Meeting on Foundations of Software Engineering, pages 914–919. ACM,
2017.
APPENDIX
[30] K. Lu, M.-T. Walter, D. Pfaff, S. Nümberger, W. Lee, and M. Backes.
Unleashing use-before-initialization vulnerabilities in the linux kernel
using targeted stack spraying. In NDSS, 2017.
[31] K. Lu, A. Pakki, and Q. Wu. Detecting missing-check bugs via semantic-
and context-aware criticalness and constraints inferences. In 28th USENIX