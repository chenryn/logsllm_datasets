new DGA
models
DGA Modeling
NXDomain
clusters
DGA Filtering
ﬁlter out noise and 
known DGAs
DGA-like
NXDomain
clusters
4
NXDomains
Active
Domains
1
Local DNS 
Server
Test NXDomain
clusters
3
NXDomain 
Clustering
NXDomains
2
Figure 1: A high level overview of Pleiades.
Naturally, because this clustering step is unsupervised,
some of the output NXDomain clusters may contain
groups of domains that happen to be similar by chance
(e.g., NXDomains due to common typos or to mis-
conﬁgured applications). Therefore, we apply a subse-
quent ﬁltering step. We use a supervised DGA Classiﬁer
to prune NXDomain clusters that appear to be generated
by DGAs that we have previously discovered and mod-
eled, or that contain domain names that are similar to
popular legitimate domains. The ﬁnal output of the DGA
Discovery module is a set of NXDomain clusters, each
of which likely represents the NXDomains generated by
previously unknown or not yet modeled DGA-bots.
3.2 DGA Classiﬁcation and C&C Detection
Every time a new DGA is discovered, we use a su-
pervised learning approach to build models of what the
domains generated by this new DGA “look like”. In par-
ticular, we build two different statistical models: (1) a
statistical multi-class classiﬁer that focuses on assign-
ing a speciﬁc DGA label (e.g., DGA-Conficker.C)
to the set of NXDomains generated by a host hi and (2)
a Hidden Markov Model (HMM) that focuses on ﬁnding
single active domain names queried by hi that are likely
generated by a DGA (e.g., DGA-Conficker.C) run-
ning on the host, and are therefore good candidate C&C
domains.
The DGA Modeling component
receives differ-
ent sets of domains labeled as Legitimate (i.e.,
“non-DGA”), DGA-Bobax, DGA-Torpig/Sinowal,
DGA-Conficker.C, New-DGA-v1, New-DGA-v2,
etc., and performs the training of the multi-class DGA
Classiﬁer and the HMM-based C&C Detection module.
The DGA Classiﬁcation module works as follows.
Similar to the DGA Discovery module, we monitor the
stream of NXDomains generated by each client machine
“below” the local recursive DNS server.
Given a subset of NXDomains generated by a ma-
chine, we extract a number of statistical features related
to the NXDomain strings. Then, we ask the DGA Clas-
siﬁer to identify whether this subset of NXDomains re-
sembles the NXDomains generated by previously dis-
covered DGAs. That is, the classiﬁer will either label the
subset of NXDomains as generated by a known DGA,
or tell us that it does not ﬁt any model.
If the subset
of NXDomains is assigned a speciﬁc DGA label (e.g.,
DGA-Conficker.C), the host that generated the NX-
Domains is deemed to be compromised by the related
DGA-bot.
Once we obtain the list of machines that appear to be
compromised with DGA-based bots, we take detection
one step further. While all previous steps focused on NX-
Domains, we now turn our attention to domain names for
which we observe valid resolutions. Our goal is to iden-
tify which domain names, among the ones generated by
the discovered DGA-based bots, actually resolve into a
valid IP address. In other words, we aim to identify the
botnet’s active C&C server.
To achieve this goal, we consider all domain names
that are successfully resolved by hosts which have been
classiﬁed as running a given DGA, say New-DGA-vX,
by the DGA Classiﬁer. Then, we test these successfully
resolved domains against an HMM speciﬁcally trained
to recognize domains generated by New-DGA-vX. The
HMM analyzes the sequence of characters that compose
a domain name d, and computes the likelihood that d is
generated by New-DGA-vX.
We use an HMM, rather than the DGA Classiﬁer, be-
cause for the C&C detection phase we need to classify
single domain names. The DGA Classiﬁer is not suitable
for this task because it expects as input sets of NXDo-
mains generated by a given host to assign a label to the
DGA-bot running on that host. Some of the features used
by the DGA Classiﬁer cannot be reliably extracted from
a single domain name (see Sections 4.1.1 and 5.2).
4 DGA Discovery
The DGA Discovery module analyzes sequences of
NXDomains generated by hosts in a monitored network,
and in a completely unsupervised way, clusters NXDo-
mains that are being automatically generated by a DGA.
We achieve this goal in multiple steps (see Figure 1).
First (Step 1), we collect sequences of NXDomains gen-
erated by each host during an epoch E. Afterwards (Step
2), we split the overall set of NXDomains generated by
all monitored hosts into small subsets, and translate each
set into a statistical feature vector (see Section 4.1.1).
We then apply the X-means clustering algorithm [24] to
group these domain subsets into larger clusters of domain
names that have similar string-based characteristics.
Separately (Step 3), we cluster the NXDomains based
on a completely different approach that takes into ac-
count whether two NXDomains are being queried by
overlapping sets of hosts. First, we build a bipartite host
association graph in which the two sets of vertices repre-
sent distinct hosts and distinct NXDomains, respectively.
A host vertex Vhi is connected to an NXDomain vertex
Vn j if host hi queried NXDomain n j. This allows us to
identify different NXDomains that have been queried by
overlapping sets of hosts. Intuitively, if two NXDomains
are queried by multiple common hosts, this indicates that
the querying hosts may be running the same DGA. We
can then leverage this deﬁnition of similarity between
NXDomains to cluster them (see Section 4.1.3).
These two distinct views of similarities among NXDo-
mains are then reconciled in a cluster correlation phase
(Step 4). This step improves the quality of the ﬁnal NX-
Domains clusters by combining the clustering results ob-
tained in Step 2 and Step 3, and reduces possible noise
introduced by clusters of domains that may appear sim-
ilar purely by chance, for example due to similar typos
originating from different network users.
The ﬁnal clusters represent different groups of NX-
Domains, each containing domain names that are highly
likely to be generated by the same DGA. For each of
the obtained NXDomain clusters, the question remains
if they belong to a known DGA, or a newly discovered
one. To answer this question (Step 5), we use the DGA
Classiﬁer described in Section 5.2, which is speciﬁcally
trained to distinguish between sets of NXDomains gen-
erated by currently known DGAs. Clusters that match
previously modeled DGAs are discarded. On the other
hand, if a cluster of NXDomains does not resemble any
previously seen DGAs, we identify the cluster of NXDo-
mains as having been generated by a new, previously un-
known DGA. These NXDomains will then be sent (Step
6) to the DGA Modeling module, which will update (i.e.,
re-train) the DGA Classiﬁer component.
4.1 NXDomain Clustering
We now describe the NXDomain Clustering module in
detail. First, we introduce the statistical features Pleiades
uses to translate small sets of NXDomains into feature
vectors, and then discuss how these feature vectors are
clustered to ﬁnd similar NXDomains.
4.1.1 Statistical Features
To ease the presentation of how the statistical features
are computed, we ﬁrst introduce some notation that we
will be using throughout this section.
Deﬁnitions and Notation A domain name d con-
sists of a set of
labels separated by dots, e.g.,
www.example.com. The rightmost label is called
the top-level domain (TLD or T LD(d)), e.g., com.
The second-level domain (2LD or 2LD(d))
repre-
sents the two rightmost labels separated by a period,
e.g., example.com. The third-level domain (3LD
or 3LD(d)) contains the three rightmost labels, e.g.,
www.example.com, and so on.
(or
We will often refer to splitting a sequence NX =
into a number of
{d1, d2, ..., dm} of NXDomains
length a , NXk =
subsequences
subsets) of
{dr, dr+1, ..., dr+a −1}, where r = a (k − 1) + 1 and k =
1,2, ..., ⌊ m
a ⌋. Subscript k indicates the k-th subsequence
of length a
in the sequence of m NXDomains NX. Each
of the NXk domain sequences can be translated into a
feature vector, as described below.
n-gram Features Given a subsequence NXk of a NX-
Domains, we measure the frequency distribution of n-
grams across the domain name strings, with n = 1, ..,4.
For example, for n = 2, we compute the frequency of
each 2-gram. At this point, we can compute the median,
average and standard deviation of the obtained distribu-
tion of 2-gram frequency values, thus obtaining three fea-
tures. We do this for each value of n = 1, ...,4, producing
12 statistical features in total. By measuring the median,
average and standard deviation, we are trying to capture
the shape of the frequency distribution of the n-grams.
Entropy-based Features This group of features com-
putes the entropy of the character distribution for sep-
arate domain levels. For example, we separately com-
pute the character entropy for the 2LDs and 3LDs ex-
tracted from the domains in NXk. To better understand
how these features are measured, consider a set NXk of
a domains. We ﬁrst extract the 2LD of each domain
di ∈ NXk, and for each domain we compute the entropy
H(2LD(di)) of the characters of its 2LD. Then, we com-
pute the average and standard deviation of the set of val-
ues {H(2LD(di))}i=1...a . We repeat this for 3LDs and
for the overall domain name strings. We measure a total
of six features, which capture the “level of randomness”
in the domains. The intuition is that most DGAs pro-
duce random-looking domain name strings, and we want
to account for this characteristic of the DGAs.
Structural Domain Features This group of features
is used to summarize information about the structure of
the NXDomains in NXk, such as their length, the num-
ber of unique TLDs, and the number of domain levels.
In total, we compute 14 features. Speciﬁcally, given
NXk, we compute the average, median, standard devi-
ation, and variance of the length of the domain names
(four features), and of the number of domain levels (four
features). Also, we compute the number of distinct char-
acters that appear in these NXDomains (one feature), the
number of distinct TLDs, and the ratio between the num-
ber of domains under the .com TLD and the number of
domains that use other TLDs (two features). The remain-
ing features measure the average, median, and standard
deviation of the occurrence frequency distribution for the
different TLDs (three features).
4.1.2 Clustering using Statistical Features
To ﬁnd clusters of similar NXDomains, we proceed as
follows. Given the set NX of all NXDomains that we ob-
served from all hosts in the monitored network, we split
NX into subsets of size a , as mentioned in Section 4.1.1.
Assuming m is the number of distinct NXDomains in
NX, we split the set NX into ⌊ m
a ⌋ different subsets where
a = 10.
For each of the obtained subsets NXk of NX, we com-
pute the aforementioned 33 statistical features. After we
have translated each NXk into its corresponding feature
vector, we apply the X-means clustering algorithm [24].
X-means will group the NXk into X clusters, where X is
automatically computed by an optimization process in-
ternal to X-means itself. At this point, given a cluster
C = {NXk}k=1..l of l NXDomain subsets, we simply take
the union of the NXk in C as an NXDomain cluster.
4.1.3 Clustering using Bipartite Graphs
Hosts that are compromised with the same DGA-
based malware naturally tend to generate (with high
probability) partially overlapping sets of NXDomains.
On the other hand, other “non-DGA” NXDomains are
unlikely to be queried by multiple hosts. For example,
it is unlikely that multiple distinct users make identical
typos in a given epoch. This motivates us to consider
NXDomains that are queried by several common hosts as
similar, and in turn use this similarity measure to cluster
NXDomains that are likely generated by the same DGA.
To this end, we build a sparse association matrix M,
where columns represent NXDomains and rows repre-
sent hosts that query more than two of the column NX-
Domains over the course of an epoch. We discard hosts
INPUT : Sparse matrix M ∈ ´
l×k, in which the rows represent
l hosts and the columns represent k NXDomains.
[1] : Normalize M: ∀ j = 1, .., k
Mi, j = 1
l(cid:229)
i=1
[2] : Compute the similarity matrix S from M: S = MT · M
[3] : Compute the ﬁrst r eigenvectors from S by
eigen-decomposition.
Let U ∈ ´
r resulting from the eigen-decomposition of S
(a vector ui is a reduced r -dimensional representation of the i-th
NXDomain).
r ×k be the matrix containing k vectors u1, ..., uk of size
[4] : Cluster the vectors (i.e., the NXDomains) {ui}i=1,..,k using
the X-means algorithm
OUTPUT: Clusters of NXDomains
Algorithm 1: Spectral clustering of NXDomains.
that query only one NXDomain to reduce the dimension-
ality of the matrix, since they are extremely unlikely to
be running a DGA given the low volume of NXDomains
they produce. Let a matrix element Mi, j = 0, if host hi
did not query NXDomain n j. Conversely, let Mi, j = wi if
hi did query n j, where wi is a weight.
All non-zero entries related to a host hi are assigned
the same weight wi ∼ 1
, where ki is the number of NX-
ki
Domains queried by host hi. Clearly, M can be seen as a
representation of a bipartite graph, in which a host ver-
tex Vhi is connected to an NXDomains vertex Vn j with an
edge of weight wi if host hi queried NXDomain n j dur-
ing the epoch under consideration. The intuition behind
the particular method we use to compute the weights wi
is that we expect that the higher the number of unique
NXDomains queried by a host hi (i.e., the higher ki) the
less likely the host is “representative” of the NXDomains
it queries. This is in a way analogous to the inverse doc-
ument frequency used in the text mining domain [1, 7].
Once M is computed, we apply a graph partitioning
strategy based on spectral clustering [21, 22], as sum-
marized in Algorithm 1. As a ﬁrst step, we compute
the ﬁrst r eigenvectors of M (we use r = 15 in our
experiments), and then we map each NXDomain (each
column of M) into a r -dimensional vector.
In effect,
this mapping greatly reduces the dimensionality of the
NXDomain vectors from the total number of hosts (the
number of rows in M) to r . We then used the obtained
r -dimensional NXDomain representations and apply X-
means to cluster the NXDomains based on their “host as-
sociations”. Namely, NXDomains are grouped together
if they have been queried by a similar set of hosts.