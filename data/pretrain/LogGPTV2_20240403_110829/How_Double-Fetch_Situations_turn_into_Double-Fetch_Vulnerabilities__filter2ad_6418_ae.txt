the identiﬁed bugs (5/6).
5.4
Interpretation of Results
Double fetches are a fundamental problem for kernel de-
velopment. Popular operating systems like Windows,
Linux, Android, and FreeBSD all had double-fetch bugs
and vulnerabilities in the past. Double-fetch issues have
a long history, and one bug we identiﬁed (CVE-2016-
6480) has existed for over ten years.
Double fetches are prevalent and sometimes inevitable
in kernels. We categorized three typical double fetch
scenarios from the occurrences we detected. 63% of
these double fetches occur in drivers, which implies that
drivers are the hard-hit area. Four out of the ﬁve new
bugs belong to size checking scenarios, indicating that
variable length message processing needs vetting for
double-fetch bugs.
In the Linux kernel, double-fetch bugs are more com-
plex than in Windows because transfer functions separate
the fetches from the uses in a double-fetch bug, mak-
ing it harder to separate benign from vulnerable double
fetches. A previous dynamic approach has not found
any double-fetch bug in Linux, where our static approach
found some, demonstrating the power of a simple static
analysis.
Our approach requires manual inspection, however,
the manual inspection does not have to be repeated
for the full kernel as future analyses can be limited to
changed ﬁles. Moreover, developing a static analysis that
automatically identiﬁes double-fetch bugs with higher
accuracy would have cost much more time than develop-
ing our current approach, running it on diﬀerent kernels,
and the manual investigating the results together. Also,
before our analysis and categorization, it was not known
in which situations double-fetch bugs occur in the Linux
kernel—knowledge that was needed in order to design a
more precise static double-fetch bug analysis. With the
reﬁned approach, one would only have had to look at the
53 potential double-fetch bugs, not at all 90 double-fetch
situations. Therefore, the manual analysis part of our ap-
proach is inevitable but highly beneﬁcial.
As for prevention, all of the four size checking bugs
are patched by the Compare Data method, indicating the
double fetches are not avoided completely as the patched
situations still abort the client program by returning an
error. Moreover, even benign double-fetch situations are
not safe because they can turn into harmful ones easily.
One such bug (CVE-2016-5728 ) was introduced from
a benign double-fetch situation by a code update. How-
ever, most of these potential cases are not ﬁxed as they
are currently not vulnerable.
Even if a double fetch is benign, i.e., is not vulnera-
ble, it can be considered a performance issue since one
of the fetches (invocations of the transfer functions) is
redundant.
5.5 Limitations
We focused on analyzing situations in which double
fetches occur in Linux with a pattern-based analysis of
the source code. However, the nature of the analysis
prevents the detection of double fetches that occur on a
lower level, e.g., in preprocessed or compiled code.
USENIX Association
26th USENIX Security Symposium    13
Double-fetch bugs can even occur in macros. In one
such case [24], the macro fetches a pointer twice, the
ﬁrst time to test for NULL and the second time to use it.
However, due to the potential pointer change between the
two fetches, a null-pointer crash may be caused.
A double-fetch bug can also be introduced through
compiler optimization.
It then occurs in the compiled
binary but not in the source code. Wilhelm [37] recently
found such a compiler-generated double-fetch bug in the
Xen Hypervisor, which is because the pointers to shared
memory regions are not labeled as volatile, allowing the
compiler to turn a single memory access into multiple ac-
cesses at the binary level, since it assumes that the mem-
ory will not be changed.
6 Related Work
So far, research conducted on double-fetch analysis has
exclusively focused on dynamic analysis, whereas we
proposed a static analysis approach. In addition to the
already discussed work on Bochspwn [14, 13], there are
also a few related studies as follows.
Wilhelm [37] used a similar approach to Bochspwn
to analyze memory access pattern of para-virtualized de-
vices’ backend components. His analysis identiﬁed 39
potential double fetch issues and discovered three novel
security vulnerabilities in security-critical backend com-
ponents. One of the discovered vulnerabilities does not
exist in the source code but is introduced through com-
piler optimization (see the discussion in Section 5.5).
Moreover, another discovered vulnerability in the source
code is usually not exploitable because the compiler opti-
mizes the code in a way that the second fetch is replaced
with a reuse of the value of the ﬁrst fetch.
Double-fetch race conditions are very similar to Time-
Of-Check to Time-Of-Use (TOCTOU) race conditions
caused by changes occurring between checking a con-
dition and the use of the check’s result (by which the
condition no longer holds). The data inconsistency in
TOCTOU is usually caused by a race condition that re-
sults from improper synchronized concurrent accesses to
a shared object. There are varieties of shared objects in
any computer system, such as ﬁles [2], sockets [36] and
memory locations [39], therefore, a TOCTOU can exist
in diﬀerent layers throughout the system. TOCTOU race
conditions often occur in ﬁle systems and numerous ap-
proaches [5, 9, 18, 4, 27] have been proposed to solve
these problems, but there is still no general, secure way
for applications to access ﬁle systems in a race-free way.
Watson [36] worked on exploiting wrapper concur-
rency vulnerabilities that come from system call inter-
position. He focused on the wrapper vulnerabilities
that will lead to security issues such as privilege esca-
lation and audit bypass. By identifying resources rel-
evant to access control, audit, or other security func-
tionality that are accessed concurrently across a trust
boundary, he found vulnerabilities from the wrappers and
demonstrated the exploit techniques with examples. He
also categorized the Time-Of-Audit to Time-Of-Use and
Time-Of-Replacement to Time-Of-Use issues in addition
to the Time-Of-Check to Time-Of-Use issue. However,
he focused on the system call interposition security ex-
tensions rather than the kernel as we do. He did not pro-
vide details of how he found these vulnerabilities either.
Yang et al. [39] cataloged concurrency attacks in the
wild by studying 46 diﬀerent types of exploits and pre-
sented their characteristics. They pointed out that the risk
of concurrency attacks was proportional to the duration
of the vulnerability window. Moreover, they found that
previous TOCTOU detection and prevention techniques
are too speciﬁc and cannot detect or prevent general con-
currency attacks.
Coccinelle [17], the program matching and transfor-
mation engine we use in our approach, was initially tar-
geted for collateral evolution in Linux drivers, but now is
widely used for ﬁnding and ﬁxing bugs in systems code.
With Coccinelle, Nicolas et al. [26, 25] performed a
study of all the versions of Linux released between 2003
and 2011, ten years after the work of Chou et al. [7], who
gave the ﬁrst thorough study on faults found in Linux.
Nicolas et al. pointed out that the kind of faults con-
sidered ten years ago were still relevant, and were still
present in both new and existing ﬁles. They also found
that the rate of the considered kinds of faults were falling
in the driver directory, which supported Chou et al.
7 Conclusion
This work provides the ﬁrst (to the best of our knowl-
edge) static analysis of double fetches in the Linux
kernel.
It is the ﬁrst approach able to detect double-
fetch vulnerabilities in the complete kernel including all
drivers and all hardware architectures (which was impos-
sible using dynamic approaches). Based on our pattern-
based static analysis, we categorized three typical sce-
narios in which double fetches are prone to occur. We
also provide recommended solutions, speciﬁc to typical
double-fetch scenarios we found in our study, to prevent
double-fetch bugs and vulnerabilities. One solution is
used to automatically patch double-fetch bugs, which is
able to automatically patch all discovered bugs occurring
in the size-checking scenario.
Where a known dynamic analysis of the Linux,
FreeBSD, and OpenBSD kernels found no double-fetch
bug, our static analysis discovered six real double-fetch
bugs, ﬁve of which are previously unknown bugs, and
three of which are exploitable double-fetch vulnerabili-
ties. All of the reported bugs have been conﬁrmed and
14    26th USENIX Security Symposium
USENIX Association
ﬁxed by the maintainers. Our approach has been adopted
by the Coccinelle team and is currently being integrated
into the Linux kernel patch vetting.
Acknowledgments
The authors would like to sincerely thank all the re-
viewers for your time and expertise on this paper.
Your insightful comments help us improve this work.
This work is partially supported by the The National
Key Research and Development Program of China
(2016YFB0200401), by the program for New Century
Excellent Talents in University, by the National Sci-
ence Foundation (NSF) China 61402492, 61402486,
61379146, 61472437,and by the laboratory pre-research
fund (9140C810106150C81001).
References
[1] Bug 166248 – CAN-2005-2490 sendmsg compat stack over-
https://bugzilla.redhat.com/show bug.cgi?id=
ﬂow.
166248.
[2] Bishop, M., Dilger, M., et al. Checking for race conditions in
ﬁle accesses. Computing systems 2, 2 (1996), 131–152.
[3] Brunel, J., Doligez, D., Hansen, R. R., Lawall, J. L., and
Muller, G. A foundation for ﬂow-based program matching: Us-
In Proceedings of the
ing temporal logic and model checking.
36th Annual ACM SIGPLAN-SIGACT Symposium on Principles
of Programming Languages (POPL) (2009).
[4] Cai, X., Gui, Y., and Johnson, R. Exploiting UNIX ﬁle-system
races via algorithmic complexity attacks. In 30th IEEE Sympo-
sium on Security and Privacy (2009), pp. 27–41.
[5] Chen, H., and Wagner, D. MOPS: an infrastructure for examining
security properties of software. In Proceedings of the 9th ACM
conference on Computer and communications security (2002),
pp. 235–244.
[6] Chen, J., and MacDonald, S. Towards a better collaboration of
static and dynamic analyses for testing concurrent programs. In
Proceedings of the 6th workshop on Parallel and distributed sys-
tems: testing, analysis, and debugging (2008), p. 8.
[7] Chou, A., Yang, J., Chelf, B., Hallem, S., and Engler, D. An
empirical study of operating systems errors. In Proceedings of
the Eighteenth ACM Symposium on Operating Systems Principles
(SOSP) (2001).
[8] Corbet, J., Rubini, A., and Kroah-Hartman, G. Linux Device
Drivers. O’Reilly Media, Inc., 2005.
[9] Cowan, C., Beattie, S., Wright, C., and Kroah-Hartman, G.
RaceGuard: Kernel protection from temporary ﬁle race vulner-
abilities. In USENIX Security Symposium (2001), pp. 165–176.
[10] Engler, D., and Ashcraft, K. RacerX: eﬀective, static detection
In Proceedings of the Nine-
of race conditions and deadlocks.
teenth ACM Symposium on Operating Systems Principles (SOSP
’03) (2003), ACM, pp. 237–252.
[11] Hammou, S.
Exploiting Windows drivers: Double-fetch
http://resources.
race condition vulnerability, 2016.
infosecinstitute.com/exploiting-windows-drivers-
double-fetch-race-condition-vulnerability/.
[13] Jurczyk, M., and Coldwind, G.
Identify-
ing 0-days via system-wide memory access pattern analy-
sis. Black Hat 2013, 2013.
http://vexillium.org/dl.
php?BH2013 Mateusz Jurczyk Gynvael Coldwind.pdf.
Bochspwn:
[14] Jurczyk, M., and Coldwind, G. Identifying and exploiting win-
dows kernel race conditions via memory access patterns. Tech.
rep., Google Research, 2013. http://research.google.com/
pubs/archive/42189.pdf.
[15] Kasikci, B., Zamfir, C., and Candea, G. Data races vs. data race
bugs: telling the diﬀerence with portend. In Proceedings of the
Seventeenth International Conference on Architectural Support
for Programming Languages and Operating Systems (ASPLOS)
(2012), pp. 185–198.
[16] Kasikci, B., Zamfir, C., and Candea, G. RaceMob: crowdsourced
In Proceedings of the twenty-fourth ACM
data race detection.
symposium on operating systems principles (2013), pp. 406–422.
[17] Lawall, J., Laurie, B., Hansen, R. R., Palix, N., and Muller, G.
Finding error handling bugs in OpenSSL using Coccinelle.
In
European Dependable Computing Conference (EDCC) (2010),
pp. 191–196.
[18] Lhee, K.-S., and Chapin, S. J. Detection of ﬁle-based race con-
International Journal of Information Security 4, 1-2
ditions.
(2005), 105–119.
[19] Lu, K., Wu, Z., Wang, X., Chen, C., and Zhou, X. RaceChecker:
eﬃcient identiﬁcation of harmful data races. In 2015 23rd Eu-
romicro International Conference on Parallel, Distributed, and
Network-Based Processing (2015), pp. 78–85.
[20] Lu, S., Park, S., Seo, E., and Zhou, Y. Learning from mistakes:
a comprehensive study on real world concurrency bug character-
In Proceedings of the 13th International Conference on
istics.
Architectural Support for Programming Languages and Operat-
ing Systems (ASPLOS) (2008), pp. 329–339.
[21] Lu, S., Park, S., and Zhou, Y. Finding atomicity-violation bugs
through unserializable interleaving testing. IEEE Transactions on
Software Engineering 38, 4 (2012), 844–860.
[22] Lu, S., Tucek, J., Qin, F., and Zhou, Y. AVIO: detecting atomicity
violations via access interleaving invariants. In ACM SIGARCH
Computer Architecture News (2006), vol. 34, pp. 37–48.
[23] Lucia, B., Ceze, L., and Strauss, K. Colorsafe: architectural
support for debugging and dynamically avoiding multi-variable
atomicity violations. ACM SIGARCH computer architecture
news 38, 3 (2010), 222–233.
list:
in
hlist entry safe(), 2013. https://lists.linuxfoundation.
org/pipermail/containers/2013-March/031996.html.
Fix double fetch of pointer
[24] McKenney, P. E.
[25] Palix, N., Thomas, G., Saha, S., Calv`es, C., Lawall, J., and
Muller, G. Faults in Linux: Ten years later. In Proceedings of
the Sixteenth International Conference on Architectural Support
for Programming Languages and Operating Systems (ASPLOS)
(2011).
[26] Palix, N., Thomas, G., Saha, S., Calves, C., Muller, G., and
Lawall, J. Faults in Linux 2.6. ACM Transactions on Computer
Systems (TOCS) 32, 2 (2014), 4.
[27] Payer, M., and Gross, T. R. Protecting applications against
TOCTTOU races by user-space caching of ﬁle metadata. In Pro-
ceedings of the 8th ACM SIGPLAN/SIGOPS Conference on Vir-
tual Execution Environments (2012), pp. 215–226.
[28] Pratikakis, P., Foster, J. S., and Hicks, M. LOCKSMITH: Prac-
tical static race detection for C. ACM Transactions on Program-
ming Languages and Systems (TOPLAS) 33, 1 (2011), 3.
[12] Huang, J., and Zhang, C. Persuasive prediction of concurrency
access anomalies. In Proceedings of the 2011 International Sym-
posium on Software Testing and Analysis (2011), pp. 144–154.
[29] Ryzhyk, L., Chubb, P., Kuz, I., and Heiser, G. Dingo: Taming de-
vice drivers. In Proceedings of the 4th ACM European conference
on Computer systems (2009), pp. 275–288.
USENIX Association
26th USENIX Security Symposium    15
[30] Savage, S., Burrows, M., Nelson, G., Sobalvarro, P., and Ander-
son, T. Eraser: A dynamic data race detector for multithreaded
programs. ACM Transactions on Computer Systems (TOCS) 15,
4 (1997), 391–411.
[31] Sen, K. Race directed random testing of concurrent programs.
ACM SIGPLAN Notices 43, 6 (2008), 11–21.
[32] Serna, F. J. MS08-061:
the case of the kernel mode double-
https://blogs.technet.microsoft.com/
fetch, 2008.
srd/2008/10/14/ms08-061-the-case-of-the-kernel-
mode-double-fetch/.
[33] Shi, Y., Park, S., Yin, Z., Lu, S., Zhou, Y., Chen, W., and Zheng,
W. Do i use the wrong deﬁnition?: Defuse: deﬁnition-use in-
variants for detecting concurrency and sequential bugs. In ACM
Sigplan Notices (2010), vol. 45, ACM, pp. 160–174.
[34] Swift, M. M., Bershad, B. N., and Levy, H. M. Improving the
reliability of commodity operating systems. ACM Trans. Comput.
Syst. 23, 1 (Feb. 2005), 77–110.
[35] Voung, J. W., Jhala, R., and Lerner, S. RELAY: static race de-
In Proceedings of the the
tection on millions of lines of code.
6th joint meeting of the European software engineering confer-
ence and the ACM SIGSOFT symposium on The foundations of
software engineering (2007), pp. 205–214.
[36] Watson, R. N. Exploiting concurrency vulnerabilities in system
call wrappers. In First USENIX Workshop on Oﬀensive Technolo-
gies (WOOT) (2007).
[37] Wilhelm, F. Tracing privileged memory accesses to discover soft-
ware vulnerabilities. Master’s thesis, Karlsruher Institut f¨ur Tech-
nologie, 2015.
[38] Wu, Z., Lu, K., Wang, X., and Zhou, X. Collaborative technique
for concurrency bug detection. International Journal of Parallel
Programming 43, 2 (2015), 260–285.
[39] Yang, J., Cui, A., Stolfo, S., and Sethumadhavan, S. Concurrency
attacks. In Proceedings of the 4th USENIX Conference on Hot
Topics in Parallelism (2012).
[40] Zhang, M., Wu, Y., Lu, S., Qi, S., Ren, J., and Zheng, W. Ai:
In Pro-
a lightweight system for tolerating concurrency bugs.
ceedings of the 22nd ACM SIGSOFT International Symposium
on Foundations of Software Engineering (2014), ACM, pp. 330–
340.
[41] Zhang, W., Sun, C., and Lu, S. ConMem: detecting severe con-
currency bugs through an eﬀect-oriented approach. In Proceed-
ings of the Fifteenth Edition of ASPLOS on Architectural Support
for Programming Languages and Operating Systems (ASPLOS
XV) (2010), pp. 179–192.
16    26th USENIX Security Symposium
USENIX Association