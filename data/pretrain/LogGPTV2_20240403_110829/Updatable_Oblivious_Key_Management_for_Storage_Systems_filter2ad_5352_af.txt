with a proxy (or gateway) in a way that all operations by the client are identical to the single-server
case. The proxy will send the values (a, b) generated by the client to the servers and will aggregate
the responses Ai, Bi into a single response that can be veriﬁed with the public key gk. Before
sending to the client, the proxy can verify if the aggregation veriﬁes correctly. If not, it needs to
check the individual values sent by each server and discard the bad ones – all of this is done without
any awareness by the client. Thus resulting in fully client-transparent solution.
19
OKMS Client Operations (Single Thread)
Unwrap
Hash to Curve
Generate Blind
Apply Blind
Create Challenge
Inverse Blind
Remove Blind
Verify Response
Total Time (µs)
Operations / Second
Wrap
58.26
1.58
68.07
83.27
16.95
68.07
106.67
402.86
2,482
58.26
1.58
68.07
-
16.95
68.07
-
212.92
4,696
Figure 7: Client operation time and Op/s in OKMS
Interpolation Layer Performance (Single Thread)
(t+1)-of-N Time (µs)
1-of-1
3-of-5
5-of-9
5-of-15
6-of-11
81.68
155.99
236.72
236.66
280.04
Ops / Second
12,242
6,410
4,224
4,225
3,570
Figure 8: Interpolation layer performance for various threshold parameters
6
Implementation and Performance
We report on implementation and performance of the OKMS and UOKMS schemes from Section
2.1 (Fig. 2) and Section 2.2 (Fig. 4), respectively.
Microbenchmarks. Implementations of all necessary client and server operations were written
in C++ using the OpenSSL library (version 1.1.1-pre5) to provide cryptographic functionality.
Performance tests were conducted on a machine with an Intel(R) Xeon(R) CPU E5-2666 v3 @
2.90GHz having 15 GB of memory. The implementation was compiled with the gcc compiler with
optimization level 3.
The following tables detail the run times of each operation averaged over 10,000 trials. These
tests used only a single thread and CPU core; results could be improved by performing these
operations concurrently across multiple CPU cores.
In these tests, all elliptic curve operations were based on NIST P-256. Field operations (for
Shamir and blinding factors) were deﬁned over the prime order of NIST P-256. Hashing to the
curve (as required by the OPRF deﬁned in Fig. 3) was performed using SHA-256 and the constant
time Simpliﬁed SWU algorithm [12].
Client operations in the OKMS scheme are shown in Fig. 7 for both encryption (“wrapping”)
and decryption (“unwrapping”). The two operations diﬀer only in that interactive veriﬁability
is performed for wrap operations, while for unwrapping (the more common operation) regular
symmetric key veriﬁcation suﬃces.
When the (U)OKMS servers are deployed in a threshold architecture then some entity must per-
form polynomial interpolation “in the exponent”. This can be implemented as a multi-exponentiation
of the individual server’s contributions together with the corresponding Lagrange coeﬃcients. This
interpolation operation could variously be performed by one of the servers, by the client, or by a
dedicated intermediate entity.
20
(U)OKMS Server Operations (Single Thread)
Time (µs)
Ops / Second
Wrap
Unwrap
136.13
68.07
7,345
14,691
Figure 9: (U)OKMS Server performance for wrap and unwrap
UOKMS Operations (Single Thread)
Time (µs) Operations / Second
Wrap
Unwrap
Update
24.24
162.33
68.07
41,261
6,160
14,691
Figure 10: Client operation time and Op/s in UOKMS
We observe that the multi-exponentiation time dominates the cost of the interpolation (com-
puting the Lagrange coeﬃcients is correspondingly cheap), and we ﬁnd that the total cost depends
on the threshold rather than the total number of servers. We report interpolation times in Fig. 8.
Server operations, measured for the single server and threshold variants of this (U)OKMS scheme
(implemented with protocol tdh-pop) are shown in Fig. 9. This includes only performing an ex-
ponentiation (EC scalar multiply) in the curve for each input provided by the client (the wrap
operation is more costly as it includes an additional exponentiation to support the interactive
veriﬁcation procedure from Section 5.2).
Total time and operations per second is not signiﬁcantly diﬀerent for the threshold case, as each
of the involved servers computes the same function in parallel.
Client performance in the UOKMS scheme (Sec. 2.2) is shown in Fig. 10. This setting beneﬁts
from being able to perform wrap operations without server involvement, and can further beneﬁt
from precomputation tables for exponentiation of g and gk. In our testing, precomputation provided
more than a 600% speed up (11.33 vs. 68.20 µs). We summarize the number of operations per second
the client can perform in the UOKMS.
(U)OKMS Server. To evaluate performance and scalability we hosted our (U)OKMS server
implementation on Amazon’s Elastic Compute Cloud (EC2)[3] using a c4.2xlarge instance type.
This instance type provides 8 virtual CPUS with an Intel(R) Xeon(R) CPU E5-2666 v3 @ 2.90GHz
having 15 GB of memory and was the same instance type used to obtain the microbenchmark
numbers above.
Requests to this server were issued over HTTP and the web server, nginx, was conﬁgured with
8 worker processes (one per CPU). OKMS functionality was added to this web server as a natively
compiled module which used the OpenSSL library (version 1.1.1-pre5) to provide cryptographic
functionality. The server ran Ubuntu 16.04 as its operating system.
Throughput. To measure throughput a client machine (also c4.2xlarge) was deployed in the same
Amazon Web Service (AWS) availability zone as the server. We used the HTTP load generating
tool hey to measure the throughput for each scheme. hey was conﬁgured with a concurrency level of
80 and all results were averaged over 50,000 requests. All requests were for an unwrap operation and
were sent over HTTPS using (TLS 1.2 with ECDHE-ECDSA-AES256-GCM-SHA384). The server
used a self-signed certiﬁcate with an EC key on the NIST P-256 curve. Computation time dominates
in the LAN setting due to almost negligible network latency, with the CPU cores reaching near
100% utilization during the LAN throughput tests. To gauge the limits of the server performance,
21
(U)OKMS Server Throughput (8 CPU cores)
Scheme
KeepAlive No KeepAlive
Static Page
OPRF (Unwrap)
65,018
32,094
6,462
6,349
Figure 11: (U)OKMS Server Requests/s on EC2 instance (LAN setting)
client-side operations of blinding and veriﬁcation were not performed by the load generator.
For each scheme, we tested with session KeepAlive on and oﬀ. When oﬀ, a new TCP connection
and TLS session must be negotiated for each request. When on, the connection setup costs are
amortized over all requests, which is in line with a client that must unwrap many keys.
The table in Figure 11 details the observed throughput in requests per second (RPS) for the
various schemes and two KeepAlive conﬁgurations (all over TLS). We compare these schemes to a
static page as a baseline.
We observe that for the No KeepAlive conﬁguration, the cost of creating the new connection
and establishing the TLS session dominates resulting in very little diﬀerence in RPS between the
schemes. For the KeepAlive conﬁguration, throughput is signiﬁcantly better, achieving over 30,000
RPS for the OPRF/T-OPRF case. Thus our (U)OKMS implementation can handle a large number
of clients with a single server. For comparison, Amazon’s object storage service reported a peak
load of 1.1 million requests per second [34]. If needed, the KMS implementation can be scaled with
standard techniques, such as deploying a greater number of servers. With a few dozen servers in
the KMS, a unique key could be supplied each time an object is written to or read from Amazon’s
service.
Hardware Security Modules. A best practice for securing master keys is to keep them within
Hardware Security Modules (HSMs)[4] to prevent their export to less secure locations. Fortu-
nately, the methods described in this paper are supported by existing commercial HSMs. Indeed,
most HSMs support the PKCS#11 standard[43]. This speciﬁcation deﬁnes an API method called
CKM_ECDH1_DERIVE which takes an arbitrary point as an input and returns the x-coordinate of the
point resulting from a scalar multiplication of the input point using an HSM-held private key as
the scalar.
We tested three HSM implementations and found all supported the ECDH1 derive method.
The returned x-coordinate is suﬃcient to perform an oblivious key derivarion, and veriﬁcation, but
veriﬁcation (only needed in the OKMS setting and for threshold implementations of the OPRF)
requires that both positive and negative solutions for the y-coordinate be checked By importing
an elliptic curve private key computed as a Shamir share, existing HSMs can be used as part of a
threshold implementation. Due to obliviousness, interpolating the result from a threshold of HSMs
can be done external to the HSM without sacriﬁcing conﬁdentiality.
We note two potential limitations of using an HSM to hold the OPRF key. The ﬁrst is that
HSMs are often limited in the curves they support. While all of the HSMs we evaluated supported
standard NIST curves, none supported Curve25519. The second limitation is performance. While
high end commercial HSMs can achieve up to 22,000 scalar multiplications per second[49], this is
roughly equivalent to what a single core can achieve in a multi-core server CPU.
While software implementations of symmetric key wrapping algorithms can be several orders of
magnitude faster than asymmetric operations, we found HSMs often employ specialized hardware to
accelerate the normally slower asymmetric operations. In some cases, HSMs[49] including those used
by leading cloud providers[39], the number of supported ECC operations per second is comparable
to that of supported symmetric encryption operations per second.
22
In conclusion, while in the traditional key-wrapping approach (Fig. 1) one can secure wrapping
keys diligently e.g., in HSMs, the plain data encryption keys (dek) travel over much less secure TLS
channels (sometimes ending or visible in multiple points outside the HSM boundary), and are po-
tentially exposed to rogue administrators, accidental logging, etc. In contrast, these vulnerabilities
are eliminated by the oblivious computation approach where as long as the OPRF key is secure,
nothing can be learned about the data (other than by corrupting the client). Fortunately, securing
these OPRF keys in HSMs is practical today as noted above, and while symmetric operations are
less expensive than OPRF ones in general, HSMs with 20,000 EC op/sec can hardly be the system’s