ASN.1 parsing creates a tension in TLS implementa-
tions: TLS critically relies on ASN.1, but it requires only
a subset of DER encoding, and, since certiﬁcates are usu-
ally pre-generated, needs very little in the way of writing.
For the purposes of TLS, it is therefore sufﬁcient to im-
plement just a partial parser.
When implementing ASN.1, a decision has to be made
on how to encode the actual abstract grammar that will
drive the parsing process, given by various TLS and
X.509-related standards. OpenSSL, PolarSSL, JSSE and
others, with the notable exception of GnuTLS, do not
make any attempts to separate the grammar deﬁnition
from the parsing process. The leaf rules of ASN.1 are
implemented as subroutines, which are exercised in the
order required by the grammar in every routine that acts
as parser. In other words, they implement the parsers as
ad-hoc procedures that interleave the code that performs
the actual parsing with the encoding of the grammar to be
parsed. Therefore the code that describes the high-level
structure of data also contains details of invocation of
low-lever parsers and, in the case of C, memory manage-
ment. Unsurprisingly, ASN.1 parsers provide a steady
stream of exploits in popular TLS implementations.
We retain the full separation of the abstract syntax rep-
resentation from the parsing code, avoiding the complex-
ity of the code that fuses the two. At the same time, we
avoid parser generators which output source code that is
hard to understand.
Instead, we created a library for declaratively describ-
ing ASN.1 grammars in OCaml, using a functional tech-
nique known as combinatory parsing [21].
It exposes
an opaque data type that describes ASN.1 grammar in-
stances and provides a set of constants (corresponding
to terminals) and functions over them (corresponding to
productions). Nested applications of these functions to
create data that describes ASN.1 grammars follow the
shape of the actual ASN.1 grammar deﬁnitions. Inter-
nally, this tree-like type is traversed at initialisation-time
to construct the parsing and serialisation functions.
This approach allows us to create “grammar ex-
pressions” which encode ASN.1 grammars, and derive
parsers and serialisers. As the ASN.1-language we cre-
ate is a fragment of OCaml, we retain all the bene-
ﬁts of its static type checking. Types of functions over
grammar representations correspond to restrictions in the
production rules, so type-checking grammar expressions
amounts to checking their well-formedness without writ-
ing a separate parser for the grammar formalism. More-
over, type inference automatically derives the OCaml
representation of the types deﬁned by ASN.1 grammars.
Such an approach also makes testing much easier. The
grammar type is traversed to generate random inhabi-
tants of the particular grammar, which can be serialised
and parsed back to check that the two directions match
in their interpretation of the underlying ASN.1 encoding
and to exercise all of the code paths in both.
interpret
A derived parsing function does not
the
grammar data, but as its connections to component pars-
ing functions are known only when synthesis takes place
at run-time, we do not retain the beneﬁt of inlining
and inter-function optimisation a truly compiled parser
would have. Nonetheless, given that it parses roughly
50 000 certiﬁcates per second, this approach does not
create a major performance bottleneck. The result is
a signiﬁcant reduction in code complexity:
the ASN.1
parsing logic amounts to 620 lines of OCaml, and the
ASN.1 grammar code for X.509 certiﬁcates and signa-
tures is around 1 000 lines. For comparison, PolarSSL
1.3.7 needs around 7 500 lines to parse ASN.1, while
OpenSSL 1.0.1h has around 25 000 in its ASN.1 parser.
5 Using nqsb-TLS as a test oracle
One use of nqsb-TLS is as an executable test oracle,
an application which reads a recorded TLS session trace
and checks whether it (together with some conﬁguration
information) adheres to the speciﬁcation that nqsb-TLS
embodies. This recorded session can be a packet capture
(using tcpdump) of a TLS session between various im-
plementations (e.g. OpenSSL, PolarSSL, nqsb-TLS), or,
for basic testing, a trace generated by nqsb-TLS itself.
To do this we must deal with the looseness of the TLS
speciﬁcation: a TLS client chooses its random nonce, set
of ciphersuites, protocol version, and handshake exten-
sions, while a TLS server picks its random nonce, the
protocol version, the ciphersuite, possibly the DH group,
and possibly extensions. Our test oracle does not make
USENIX Association  
24th USENIX Security Symposium  231
9
Trace
Checker
ASN.1
X.509
TLS
Nocrypto
Predictable 
RNG
domU
Protocols
IMAP
XMPP
HTTP
Conduit
ASN.1
X.509
TLS
CrunchFS
Certs
Conﬁg
Nocrypto
CSPRNG
Trace Checker
pcap
Logger
TLSFlow
TCP/IP
NetFront
Certs
Conﬁg
OpenSSL
Packet 
Traces
Conﬁg Certs
nqsb-TLS
dom0
Xenconsoled
NetBack
Xentropyd
Figure 2: nqsb-TLS acts as a trace checker: the RNG
is predictable, conﬁguration and certiﬁcates are inputs,
driven by packet traces from OpenSSL (or other stacks).
Figure 3: nqsb-TLS as a unikernel domU VM on Xen: a
dom0 Xentropyd proxies host entropy, conﬁg and certiﬁ-
cates are compiled in, various protocols run over TLS.
those decisions, but rather takes the parameters recorded
in the given session. To make this possible, given the on-
the-wire encryption, some conﬁguration information has
to be provided to the trace checker, including private key
material. In addition, both records and sub-protocols can
be fragmented; our test oracle normalises the records to
not contain any fragmentation for comparison.
Figure 2 shows how nqsb-TLS can be used to build
such a test oracle (note that it does not instantiate the
entropy source for this usage). The test oracle produces
its initial protocol state from the given session. It cal-
culates handle tls with its state and the record input
of the given session, together with the particular selec-
tion of protocol version, etc., resulting in an output state,
potentially an output record, and potentially decrypted
application data. It then compares equality of the out-
put record and the given session. If successful, it uses
the output state and next recorded input of the given ses-
sion to evaluate handle tls again, and repeats to the
end of the trace. It thus terminates either when the entire
trace has been accepted, which means success; or with a
discrepancy between the nqsb-TLS speciﬁcation and the
recorded session, which means failure and needs further
investigation. Such a discrepancy might indicate an error
in the TLS stack being tested, an error in the nqsb-TLS
speciﬁcation, or an ambiguity in what TLS actually is.
A ﬁrst test of this infrastructure was to use a recorded
session of the change cipher spec injection (CVE-2014-
0224): our test oracle correctly denied this session, iden-
tifying an unexpected message. We ran our test ora-
cle and validated our 30 000 interoperability traces (see
§7.1) and our Pi˜nata traces (see §7.2), and also validated
recorded TLS sessions between various implementations
(OpenSSL, PolarSSL, nqsb-TLS) using tcpdump.
While running the test oracle we discovered interest-
ingly varied choices in fragmentation of messages among
existing stacks, which may be useful in ﬁngerprinting.
The test oracle opens up the prospect of extensive test-
ing of the behaviour of different TLS implementations,
especially if combined with automated test generation.
6 Using nqsb-TLS in applications
Another use of nqsb-TLS is as a TLS implementation in
applications. We ported nqsb-TLS to two distinct envi-
ronments and developed a series of applications, some
for demonstration purposes, others for regular use.
6.1 Porting nqsb-TLS
To use nqsb-TLS as an executable implementation, we
have to provide it with implementations of entropy and
ﬂow (see Figure 1), and an effectful piece of code that
communicates via the network and drives the core.
We pay special attention to prevent common client
bugs which arise from complexity of conﬁguring TLS
stacks and correspondingly large APIs. In each instance,
there is only one function to construct a TLS conﬁg-
uration which can be turned into an I/O interface, the
function does extensive validation of the requested pa-
rameters, and the resulting conﬁguration object is im-
mutable. This restricts potentially error-prone interac-
tions that conﬁgure TLS to a single API point.
Unix
Porting nqsb-TLS to Unix was straightforward;
we use the POSIX sockets API to build a ﬂow and
/dev/urandom as the entropy source. The exposed
interface provides convenience functions to read cer-
tiﬁcates and private keys from ﬁles, and analogues of
listen, connect, accept, read, write, and close
for communication.
MirageOS The MirageOS variant allows nqsb-TLS to
be compiled into a unikernel VM (see Figure 3). It uses
the MirageOS OCaml TCP/IP library [31] to provide the
232  24th USENIX Security Symposium 
USENIX Association
10
I/O ﬂow, which is in turn coupled to Xen device drivers
that communicate with the backend physical network de-
vice via shared memory rings [44]. The logger outputs
directly to the VM console, and the certiﬁcates and the
secret keys are compiled into OCaml data structures at
build time and become part of the VM image. A key
challenge when running in a virtualised environment is
providing a suitable entropy source [18], especially in the
common case of a VM having no access to physical hard-
ware. Since specialised unikernels have very determin-
istic boot-sequences that make sources of entropy even
scarcer, we had to extend MirageOS and Xen to avoid
cryptographic weaknesses [25].
One way in which we solve this is by relying on dom0
to provide cross-domain entropy injection. We devel-
oped Xentropyd, a dom0 daemon which reads bytes from
/dev/urandom and makes them available to VMs via
an inter-VM shared memory channel. The entropy de-
vice is plugged in as a standard Xen device driver via
Xenstore [22], and MirageOS has a frontend library that
periodically injects entropy into the nqsb-TLS CSPRNG.
To avoid being fully reliant on dom0, we implement
additional entropy harvesting within the unikernel itself.
We do this by trapping the MirageOS event loop and us-
ing RDTSCP instruction to read the Time Stamp Counter
(TSC) register on each external event. This provides us
with the unpredictability inherent in the ambient events.
This source is augmented with readings from the CPU
RNG where available: we feed the results of RDSEED (or
RDRAND) instruction into the entropy pool on each event.
To make the RNG more resilient, we do extra entropy
harvesting at boot time. Following Whirlwind RNG [18],
we employ a timing loop early in the boot phase, de-
signed to take advantage of nondeterminism inherent in
the CPU by way of internal races in the CPU state. This
provides an initial entropy boost in the absence of Xen-
tropyd and helps mitigate resumption-based attacks [18].
In an ideal scenario the entropy would be provided
through both mechanisms, but we expect the usage to
rely on one or the other, depending on deployment: on
an ARM board lacking high-resolution timing and CPU
RNG, the user is likely to have control over the hypervi-
sor and be able to install Xentropyd. Conversely, in com-
mercial hosting scenarios where the assistance of dom0
might not be available but the extra CPU features are, we
expect the user to rely on the internal entropy harvesting.
6.2 Applications
An example application using the Unix interface is the
terminal-based instant messaging client jackline using
XMPP. The XMPP protocol negotiates features, such as
TLS, over a plaintext TCP connection. Jackline performs
an upgrade to TLS via the STARTTLS mechanism before
authentication credentials are exchanged. The Unix port
of nqsb-TLS contains an API that supports upgrading an
already established TCP connection to TLS. Jackline can
use either of the authentication APIs (path and ﬁngerprint
validation) depending on user conﬁguration.
tlstunnel also runs on Unix and accepts a TLS connec-
tion, forwards the application data to another service via
TCP, similar to stud and stunnel. This has been deployed
since months on some websites.
The Unix application certify generates RSA private
keys, self-signed certiﬁcates, and certiﬁcate signing re-
quests in PEM format. It uses nocrypto and X.509.
The OCaml Conduit library (also illustrated in Fig. 3)
supports communication transports that include TCP,
inter-VM shared memory rings. It provides a high-level
API that maps URIs into speciﬁc transport mechanisms.
We added nqsb-TLS support to Conduit so that any appli-
cation that links to it can choose between the use of nqsb-
TLS or OpenSSL, depending on an environment vari-
able. As of February 2015, 42 different libraries (both
client and server) use Conduit and its provided API and
can thus indirectly use nqsb-TLS for secure connections.
The OPAM package manager uses nqsb-TLS as part of
its mirror infrastructure to fetch 2 500 distribution ﬁles,
with no HTTPS-related regressions encountered.
7 Evaluation
We now assess the interoperability, security, and perfor-
mance of nqsb-TLS.
Interoperability
7.1
We assess the interoperability of nqsb-TLS in several
ways: testing against OpenSSL and PolarSSL on every
commit; successfully connecting to most of the Fortune
500 web sites; testing X.509 certiﬁcates from ZMap; and
by running a web server.
This web server, running since mid 2014, displays the
live sequence diagram of a successful TLS session es-