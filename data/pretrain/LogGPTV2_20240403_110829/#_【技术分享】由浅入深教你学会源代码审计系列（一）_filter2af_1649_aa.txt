# 【技术分享】由浅入深教你学会源代码审计系列（一）
|
##### 译文声明
本文是翻译文章，文章来源：安全客
译文仅供参考，具体内容表达以及含义原文为准。
****
****
**作者：**[ **hac425**
****](http://bobao.360.cn/member/contribute?uid=2553709124)
**稿费：500RMB（不服你也来投稿啊！）**
**投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿**
**代码审计总论**
安全圈里有句老话：一切的用户输入都是有害的。的确，我们的所有安全测试都是基于这一点的。既然用户的一切输入都是有害的，那么怎样使这个危害显现出来呢？这就引入了安全的另一句话：有害的数据进入了危险的函数便产生了漏洞
，因此我们可以总结出安全的两个基本点，数据和函数，我们所做的所有安全相关的工作都是基于这两点。代码审计自然也不例外。
根据这两点，代码审计中又出现了两大审计的基本方法，分别是
**1\. 跟踪用户的输入数据，判断数据进入的每一个代码逻辑是否有可利用的点，此处的代码逻辑可以是一个函数，或者是条小小的条件判断语句。**
**2\.
根据不同编程语言的特性，及其历史上经常产生漏洞的一些函数，功能，把这些点找出来，在分析函数调用时的参数，如果参数是用户可控，就很有可能引发安全漏洞**
这两种方法各有所长，使用第一种方法我们能最大限度的找到程序的安全漏洞，但是跟踪数据的走向是一件工作量极大的事情，如果想跟一套程序死磕，此法
极好，因为在跟踪变量的时候，就是对程序的一个理解的过程，跟的越多，我们走过的
程序流程就越多，对程序的理解就会越深厚，对程序理解的越深，就越有可能挖掘出精彩的漏洞。
第二种方法的优点就是我们能够尽快的找到安全漏洞，但是由于我们没有跟踪完所有的用户参数，我们就必定会有所疏漏，不可能找到程序的所有漏洞，同时回溯参
数，寻找函数的调用点，在一些情况下也是一件非常头疼的事情，不过相比第一种方法我们工作量还是少了不少。总而言之，我们想要快速的找到漏洞，需要灵活的
使用两种方法，怎么灵活，这就要靠经验了，最后提一句，这东西入门后就是体力活了。。。。。
**审计辅助工具：**
**sublime 一款十分好用的编辑器 匹配规则 搜索函数 简单的跟踪变量**
**各种对应编程语言的 IDE 用于调试程序，追踪变量**
**  
**
**真正寻找漏洞之前**
现在的cms大致可分为两种，单入口模式和多入口模式.所谓多入口模式cms在前几年是一种非常常见的程序设计模式，它的形式是我们使用程序的每一个功能都需要访问不同的文件，比如：我要使用注册功能就要访问regest.php文件，使用评论功能就要访问comment.php，这种模式的程序在现在来说，在asp的cms中居多，php中已经很罕见了。
单入口模式的cms，是伴随着一种叫做MVC的开发模式出来的，这种模式我在这简单提一下 ，所谓MVC编程架构，即将 程序分为三个层次，分别实现三大功能
**数据以何种形式展示给用户**
**程序的具体实现逻辑**
**数据的处理**
而我们审计的重点应该在`数据的处理层`，因为我们之前我已经说过，`用户的有害输入加上合适的函数就形成了漏洞`
，而`数据处理层`恰好就是处理我们输入数据的一个层次。由于这种编程模式拥有很多优点，现在大量的程序采用了这种编程模式，因此如果我们要审计这类程序，也必须要熟悉这种开发模式，至于怎么熟悉，请自行百度。
单入口模式程序的特点是，我们要使用程序的每一个功能只需要访问一个，或者两个文件 普通用户一个入口文件 、管理员一个入口文件
,要调用其他的文件中的具体的功能实现代码，我们只需向该入口文件提供特定的参数即可。这种 cms 的案例有很多，比如 wordpress,phpcms……
在审计代码时，审计`多入口`模式的程序会相对的比较简单，因为我们在找到漏洞后可以很快的找到进入漏洞的代码的方法，而`单入口`模式的程序，在正式审计之前，我们还需要理解程序各个文件之间的调用规则，当然这也是一件比较简单的事情，一般情况下，我们从入口文件跟一次程序的执行流程，就能基本理清程序的流程，其实在有了一定的经验之后，我们就能从参数的值猜出程序的执行流程。在理清程序的各个文件之间的调用关系之后，我们需要做的是，查看程序的一些配置文件，全局函数文件，这些文件里面很可能包含一定的过滤函数，能早一点发现
程序对参数的处理过程，我们就能及时地确定一些无法利用的漏洞点，这可以有助于减少我们的工作量。搞完这些工作之后，就开始进入具体漏洞搜寻工作。就像前
面说的那样，我们在进行漏洞搜寻时，我们有两种方式:
**第一种，我们通过搜索一些获取用户输入数据的函数，来找到用户输入数据的源头，之后我们从这里为起
点，跟踪数据的流向，分析在这整个过程中数据的处理情况，进而定位可能触发漏洞的点。**
**第二种，我们通过搜索一些经常产生安全问题的函数，比如执行数
据库查询的函数，执行系统命令的函数，文件操作类函数等等，在通过回溯这些函数在被调用时参数，判断参数是否我们可控，进而定位漏洞点。**
最后贴上我常用的正则：
    PHP
    $_SERVER|$_COOKIE|$_REQUEST|$_GET|$_POST    获取用户输入
    eval(|assert(|system(                         命令执行
    require(|require_once(|include(|include_once(                     文件包含
    file_get_contents(|file(|fopen(|highlight_file(|show_source(|unlink      文件读取，写入，删除
    simplexml_load_string                          XXE
    unserialize                                   反序列化漏洞
ASP 的话，因为程序的流程相对比较简单，代码量也比较少，所以我一般选择直接跟变量，我就搜索 Request 关键字就能找到所有的数据输入点
.NET 搞的很少
，而且这一类程序往往需要反编译才能继续审计，因此对于这种程序，我没有什么好方法，我是一个一个函数去看的，如果各位有一些好的方法，敬请告知，谢谢。
jsp 没搞过。。。。
**一、代码审计之SQL注入篇**
在我们的日常日站中，相信SQL
注入漏洞是我们遇到最多，也可能是最希望遇到的一种漏洞了，这种漏洞出现了很久，危害也是十分巨大，具体危害就不多说了，相信大家都懂。。。我们大多数时候发现SQL注入漏洞是通过扫描器等黑盒测试手法来发现的，今天我来谈谈SQL注入漏洞的白盒审计手法。
首先我们从一个相对比较简单的 `asp` 程序开始讲，这次讲的是shop7z这套cms，该cms 是一个 `多入口`
的程序，也就是说它的每一个大的功能基本对应一个URL，我个人认为这样的程序是比较简单的，因为当我们找了可能触发的漏洞点后，就可以很快的进行验证，不需要太多的前期准备工作。既然是asp程序，我的一般做法是
直接搜索
request来找到我们用户所有可控的输入点。当然在此之前，我们还需要看看各个文件的开头，确定一些被多次的包含的文件，这些文件一般就是一些全局配置文件，全局函数文件，安全过滤文件。
总而言之就是一些相对来说比较重要的文件。通过查看shop7z这套程序的一些从名称上看比较重要的文件，我发现了一个比较有趣的文件：shop7z_safe.asp从文件名我们就能够猜出来，这个文件就是拿来，对用户参数进行过滤的，那我们进入文件中看看：
    曹script"
    '----------------------------------    %>
    "" Then
    For Each Fy_Post In Request.Form
    For Fy_Xh=0 To Ubound(Fy_Inf)
    If Instr(LCase(Request.FormFy_Post)),Fy_Inf(Fy_Xh))<>0 Then
    (
    Response.Write "xxx"
    Response.End
    End If
    Next
    Next
    End If
    '----------------------------------    '--------GET部份-------------------    If Request.QueryString<>"" Then
    For Each Fy_Get In Request.QueryString
    For Fy_Xh=0 To Ubound(Fy_Inf)
    If Instr(LCase(Request.QueryString(Fy_Get)),Fy_Inf(Fy_Xh))<>0 Then
    Response.Write "xxx"
    Response.End
    End If
    Next
    Next
    End If
    %>
可以看到，的确如我所料，这个文件就是拿来对我们的参数进行过滤的，不过这个过滤策略是很有问题的，首先这个过滤文件只是针对 SQL
注入攻击进行了过滤，而对其他漏洞，如 xss ，还有一个更大的问题，就是它只对 GET ,POST 参数进行了过滤，而忽视从 cookie
中过来的参数，这就很有可能会造成 cookie 注入。理解了程序对用户参数的过滤操作，你是否感到目标更加的明确，通过上面的分析我们可以制定这样的审计策略。
通过使用 sublime 的文件搜索功能，搜索 request 来获取用户的输入点，因为在 asp 程序中获取用户输入，使用的几个函数及其作用分别为：
request.QueryString（获取GET请求的参数)
request.form() (获取POST请求的参数)
request.cookie() (获取通过cookie传来的参数 request )
所以我们要找 SQL 注入漏洞的话，我们应该关注的输入点函数就是 能从
cookie中获取参数的函数，有了思路，就可以开始行动了，我们开始搜索，之后一个一个的跟进每一个搜索结果，我们就能发现 N
处注入了下面我选择一处来说明下吧：
漏洞文件： news.asp：
    searchkey=request("searchkey")
    searchkind=request("searchkind")
    if searchkey<>"" then
        sql3="select * from e_contect where c_parent2="&request.QueryString("l_id")&" and (c_title like '%"&searchkey&"%' or c_contect like '%"&searchkey&"%') order by c_num desc,c_addtime desc"
    else
        sql3="select * from e_contect where c_parent2="&request.QueryString("l_id")&" order by c_num desc,c_addtime desc"
    end if
    set rs3=server.CreateObject("adodb.recordset")
    rs3.open sql3,conn,1,1
虽然该文件也包含了，全局过滤文件，但是这里用了 request() 函数来获取参数，那么我们就能通过 cookie 来传输参数值，而 cookie
中的值是没有经过过滤的，所以出现了注入，当我提交：
    GET /news.asp?l_id=1 HTTP/1.1
    Host: 127.0.0.1:99
    Cache-Control: max-age=0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
    User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36 SE 2.X MetaSr 1.0
    Accept-Encoding: gzip,deflate,sdch
    Accept-Language: zh-CN,zh;q=0.8
    Cookie: _ga=GA1.1.1929133354.1465629589; COSPTLCBWXNQVBUKXIOJ=KSBKFPQVGIRJWBOELVYRTMRCNPDSIWYDIWYHQYNQ; searchkey=sss'and#
执行的语句是：
    select * from e_contect where c_parent2=1 and (c_title like '%sss'and#%' or c_contect like '%sss'and#%') order by c_num desc,c_addtime desc
成功带入了查询，，，
下面我们来看一套 单入口 模式的 php 程序，这套 cms 的名称为 乐尚商城cms,这是一套典型的采用 MVC 编程模型编写的程序，而且它还将 URL
路由进行了重写，也就是说他的 URL 如果按照国际标准去解析他，是没有什么实际意义的，所以遇到这种程序，我们还需要理清它 URL
路由规则，找到参数名，与参数值的位置关系。
我们先来看看他的 URL 到底是怎样的：
前台：
后台：
下面我们来看看他的目录结构，
单入口的程序一般都采用类似这样的目录结构来编写，接着查看 index.php
文件，分析一下程序的执行流程，既然是单入口程序，那么程序的各个文件之间的调用关系必定都会在再 index.php
文件内实现。我们要理清程序的执行流程，这一步是必不可少的。
    <?php
        /**
         * 单一入口文件
         */
        include("./temp.inc.php");
        define("TPLSTYLE", $temp['template']);//默认模板存放的目录
        define("BROPHP", "./brophp");  //框架源文件的位置
        define("APP", "./home");   //设置当前应用的目录
        define("PAGENUM",$temp['home_page_num']); //默认每页显示记录数