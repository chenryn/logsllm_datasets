donate(x,B )
−−−−−−−−−−→ ⟨B, v⟩y | Γ′
[Dep-Donate]
⃗x = x1 · · · xn
(cid:16) ∥ i∈1. .n⟨Ai, vi⟩xi
j ∈ 1..n y fresh (except in destroy authorizations for ⃗x)
(cid:17) | Aj [⃗x, j ▷ y] | Γ
Aj :⃗x, j
(cid:17) | Γ
−−−−−→(cid:16) ∥ i∈1. .n⟨Ai, vi⟩xi
(cid:16) ∥ i∈1. .n⟨Ai, vi⟩xi
(cid:16) ∥ i∈1. .n Ai [⃗x, i ▷ y](cid:17) | Γ′
(cid:17) | Γ
−−−−−−−−→ Γ′
destroy(⃗x )
Γ =
⃗x = x1 · · · xn
[Dep-Destroy]
[Dep-AuthDestroy]
Figure 3: Semantics of untimed configurations: rules for deposits.
{G }C contains at least one participant in Hon
a fresh, for each A:secret a in G
Γ contains ⟨Ai, vi⟩xi
Γ contains ⟨Ai, vi⟩xi
for all Ai :! vi @ xi in {G }C
for all Ai :? vi @ xi in {G }C
[C-Advertise]
a1 · · · ak secrets of A in G
∀i ∈ 1..k : ∄N : {A : ai #N } ∈ Γ
∆ = {A : a1#N1} | · · · | {A : ak #Nk }
advertise({G }C )
−−−−−−−−−−−−−→ {G }C | Γ
Γ
∀i ∈ 1..k : Ni ∈
N
N ∪ {⊥}
if A ∈ Hon
otherwise
{G }C | Γ
A:{G }C , ∆
−−−−−−−−−→ {G }C | Γ | ∆ | A[# ▷ {G }C ]
[C-AuthCommit]
Γ contains B[# ▷ {G }C ] for all B in G
G = A:! v @ x | · · ·
(cid:16) ∥ i∈I Ai :! vi @ xi
{G }C | Γ
A:{G }C ,x
−−−−−−−−−→ {G }C | Γ | A[x ▷ {G }C ]
(cid:17) | (cid:16) ∥ i∈J Bi :? v′
(cid:17) | (cid:16) ∥ i∈K Ci :secret ai
(cid:17)
(cid:17) | (cid:16) ∥ A∈G A[# ▷ {G }C ](cid:17) | (cid:16) ∥ i∈I Ai [xi ▷ {G }C ](cid:17) init (G ,C )
−−−−−−−−→ ⟨C ,(cid:80)
x fresh
i @ yi
[C-AuthInit]
{G }C | Γ | (cid:16) ∥ i∈I⟨Ai, vi⟩xi
G =
[C-Init]
i∈I vi⟩x | Γ
Figure 4: Semantics of untimed configurations: rules for advertisement and stipulation.
A, B, . . . ∈ Part
x, y, . . .
a, a′, b, . . .
t, t′, δ, . . . ∈ N
v, v′ . . . ∈ 10−8N
G, G′, . . .
C , C ′, . . .
D, D′, . . .
{G }C
Participants
Deposit names
Secrets names
Delays
Currency values
Preconditions
Contracts
Guarded contracts
Advertisement
Γ, ∆, . . .
Γ | t
α, α′, . . .
Rs, ˙Rs, . . .
Rs∗, ˙Rs∗, . . .
λs
Λs
Σs
A
Badv (·)
Configuration (untimed)
Configuration (timed)
Labels (including delays)
Symbolic runs
Stripped symb. runs
Symbolic label
Set of symbolic labels
Symbolic strategy
Compiler
Random generator
Random nonce (of A)
Bitstrings
Transactions
r
rA
m, m′, . . .
T, T′, . . .
Rc, ˙Rc, . . . Computational runs
Rc∗ , ˙Rc∗ , . . .
Stripped comp. runs
Computational label
λc
Set of computational labels
Λc
Computational strategy
Σc
A
ℵ(·)
Strategy mapping
Table 1: Summary of notation.
17
⃗v = v1 · · · vk
⃗C = C1 · · · Ck
⟨split ⃗v → ⃗C , v′⟩y | Γ
(cid:80)k
−−−−−−→(cid:16) ∥ k
i =1 vk = v′
split (y )
i =1⟨Ci, vi⟩xi
Γ = ∥ m
∆ = ∥ n
⃗x = x1 · · · xm
⃗a = a1 · · · an
i =1⟨Ai, vi⟩xi
i =1Bi : ai #Ni
⟨put ⃗x & reveal ⃗a if p . C , v⟩y | Γ | ∆ | Γ′ put (⃗x, ⃗a,y )
N (cid:44) ⊥
{A : a#N } A:a−−−→ A : a#N
[C-AuthRev]
[C-Split]
x1 · · · xk fresh
(cid:17) | Γ
(cid:74)p(cid:75)∆ = true
−−−−−−−−−→ ⟨C , v +(cid:80)m
z fresh
D ≡ A : D′
[C-PutRev]
i =1 vi⟩z | ∆ | Γ′
x fresh
−−−−−−−−−−−−−−→ ⟨A, v⟩x | Γ
withdraw(A,v,y )
[C-Withdraw]
⟨withdraw A, v⟩y | Γ
D ≡ A1 : · · · : Ak : after t1 : · · · : after tm : D′ D′ (cid:46) A : · · · D′ (cid:46) after t : · · ·
⟨D + C , v⟩x | Γ
A:x, D−−−−−−→ ⟨D + C , v⟩x | A[x ▷ D ] | Γ
[C-AuthControl]
⟨D′, v⟩x | Γ
α−→ Γ′
x ∈ cv (α )
[C-Control]
(cid:74)true(cid:75)Γ = true
⟨D + C , v⟩x | ∥ k
(cid:74)p1 ∧ p2(cid:75)Γ =(cid:74)p1(cid:75)Γ and(cid:74)p2(cid:75)Γ
i =1Ai [x ▷ D ] | Γ
(cid:74)¬p(cid:75)Γ = not(cid:74)p(cid:75)Γ
(cid:74)|a |(cid:75)Γ = N if Γ contains A : a#N
(cid:74)N(cid:75)Γ = N
(cid:74)E1 ◦ E2(cid:75)Γ =(cid:74)E1(cid:75)Γ ◦(cid:74)E2(cid:75)Γ
(cid:74)E1 • E2(cid:75)Γ =(cid:74)E1(cid:75)Γ •(cid:74)E2(cid:75)Γ
(• ∈ {+, −})
α−−−→ Γ′
(◦ ∈ {=,  0
Γ | t δ−→ Γ | t + δ
[Delay]
D ≡ after t1 : · · · : after tm : D′ D′ (cid:46) after t′ : · · ·
⟨D, v⟩x | Γ
t ≥ t1, . . . , tm
x ∈ cv (α )
α−→ Γ′
⟨D + C , v⟩x | Γ | t α−→ Γ′ | t
[Timeout]
Figure 6: Semantics of timed configurations.
taking as input a stripped symbolic run Rs∗ and a random sequence
rA. The output is a finite sequence of α-moves such that the follow-
ing constraints hold:
(1) if α ∈ Σs
A (strip(Rs ), rA ), then Rs α−→;
(2) if B : · · · ∈ Σs
(3) if A : {G}C , ∆ and A : {G}C , ∆′ in Σs
A (strip(Rs ), rA ), then B = A;
∆ = ∆′;
(4) if α ∈ Σs
A (strip( ˙Rs ), rA ).
Σs
A (strip(Rs ), rA ) and Rs
A (strip(Rs ), rA ), then
α1−−→ ˙Rs
α−→, then α ∈
⋄
The constraints in Definition 10 are needed to rule out ill-formed
only chooses moves enabled by
strategies. (1) requires that Σs
A
the semantics; (2) states that Σs
cannot choose moves of B; (3)
A
guarantees that the lengths of secrets are chosen coherently (i.e., A
cannot choose different lengths for the same secret); (4) requires the
strategy to be persistent: if on a run Σs
chooses α, and α is not taken
A
as the next step in the run (e.g., because some other participant acts
earlier), then Σs
must still choose α after that step, if still enabled.
A
Definition 11 (Symbolic adversary strategies). A symbolic ad-
versary strategy is a PPTIME algorithm Σs
Adv (Rs∗ , rAdv , ⃗Λs ), tak-
ing as input a stripped symbolic run Rs∗, a random sequence rAdv,
and a list ⃗Λs = Λs1 · · · Λs
of sequences of stripped moves for each
Ai ∈ Hon = {A1, . . . , Ak}. The output is a single adversary action λs
such that, for all symbolic runs Rs, if Σs
Adv (strip(Rs ), rAdv , ⃗Λs ) = λs,
one of the following holds:
k
(1) λs = (Ai , j), Λs
i
= α1 · · · αm, and αj = Ai : · · ·;
18
Adv (Rs∗ , rAdv , ϵ )
(2) λs = α, α (cid:44) A : · · · for any A, α (cid:60) N, and Rs α−→;
(3) λs = B : · · ·, λs (cid:44) B : a for any a, B (cid:60) Hon and Rs λs−−→;
: δi ≥ δ
(4) λs = δ, where ∀i ∈ 1..k :(cid:16)
= ∅ or ∃δi ∈ Λs
(cid:17).
Λs
i
i
(5) λs = B : a, where:
(i) B (cid:60) Hon;
(ii) Γstrip(Rs )
(iii) for some prefix Rs∗ of strip(Rs ), we have Σs
contains {B : a#⊥};
= B : {G}C , ∆ where {B : a#N} in ∆, for some N (cid:44) ⊥
and {G}C.
Adv (strip(Rs ), rAdv , ⃗Λs ) = B : {G}C , ∆ for B (cid:60) Hon, we ask that
If Σs
Adv (strip(Rs ), rAdv , ϵ ) = B : {G}C , ∆.
⋄
Σs
Conditions (1)–(4) are straightforward; in (5) the adversary makes
a dishonest participant B reveal a secret a. In such case, we require
that the (stripped) run contains the corresponding committed secret
{B : a#⊥}, and that, at some previous point Rs∗ in the (stripped) run,
chose a non-⊥ length N for a. This requirement is achieved
Σs
Adv
by considering Σs
Adv (Rs∗ , rAdv , ϵ ), where the use of ϵ is due to the
ignorance of the parameter ⃗Λs generated at the point Rs∗. We con-
sequently require that the N chosen by Σs
does not depend on
⃗Λs. This restriction does not limit the power of Adv, who can first
perform a sequence of actions λs depending on ⃗Λs, appending them
to Rs, and then choose N depending on such actions λs.
Lemma 4. Let Rs∗ = strip(Rs ) for some symbolic run Rs . Also, let
Hon = {A1, . . . , Ak}, and let ⃗Λs = Λs1 · · · Λs
(Rs∗ , rAi )
for i ∈ 1..k. If Σs
Adv (Rs∗ , r, ⃗Λs ) = λs , then:
k , where Λs
i
= Σs
Ai
Adv
i
Adv
= α1 · · · αm;