and  emit  outgoing  packets, and  to  pace  the  execution
with  real-time.    The  honeypot  emulation  setup  is
shown in Fi
  Processors 
gure 8
.
In  our  PDNS execution,
two types  of  PDNS
instances run  in  the  public network: AFAP  and  Real. 
The  PDNS-Real  instances  instantiate  an  emulator
object  which  registers  itself  with  the proxy  server.
During registration,  the  emulator  object sends  the
instance ID  and  the  IP  address  range  it  covers.  Using
this information the proxy maintains a connection table
to route traffic to/from simulated from/to the honeypot.
A TCP connection is established between the emulator
and  the  proxy  during  the  registration process  and  is
held  open  throughout  the  simulation  to  exchange
packets with the proxy server.
4.2.1
Experimental Hardware Setup
Figure 9
shows the  hardware setup for  honeypot
emulation.    The  machine  running  the proxy  server  is
equipped  with  two  network  interfaces  to  bridge  the
public  and  the  private  network. A  DHCP daemon  is
started  on  one  of  the  network  cards,  which  acts  as  a 
gateway for honeyd. Since honeyd simulates virtual IP 
addresses,  a  route  entry  is  added  to  forward  packets
destined  to  the  virtual  IP  addresses on  to  this  network
card.
PDNS- AFAP
Worm
Node
Models
n
n
n
n
n
n
PDNS- Real
Emulated
Nodes
PDNS- Real
Emulated
Nodes
PDNS- AFAP
Worm
Node
Models
n
n
n
n
n
n
Packet capture
with iptables
Emulator
Emulator
TCP
sockets
Proxy
honeyd
Network
Interface-1
Network
Interface-2
Traffic
Conversion
Real
installation
Public Network
Private Network
Figure 8: Constructive emulation setup of the Honeyd
honeypot with parallel simulation of PDNS worm models.
To  avoid  the runtime  overhead  of ARP  lookups  at
the  proxy  server  for honeyd’s  virtual  IP  addresses, we
hardcoded  the  mapping  of  the virtual  IP  addresses  to
honeyd’s MAC address in the proxy’s ARP table.  The 
proxy server listens for packets from both sides of the
network  (PDNS  and honeyd).  It  uses  a  set  of 
iptables[25]  rules  to  capture  packets from honeyd  and
encapsulate  them  to  insert  into  PDNS,  and  uses  raw 
sockets  to  emit  forwarded packets onto  the  honeyd
side.
Figure 9: Hardware hosting platform for constructive
emulation: user installation (honeyd) is connected over a 
wide area connection to a compute cluster that executes
worm models in PDNS.  The user installation of network
defense could be a single end-host or an entire subnet.
4.3
Emulation Issues
Several issues arose in implementing a constructive
emulation  architecture.    Some  of  these  issues  are
discussed next.
4.3.1
Traffic Conversion
In  PDNS,  sequence numbers  for  TCP  connections 
always  start  at  a  fixed  value  (zero).  But,  in  real  TCP 
implementations,  such  as  used  in  the honeypot,  TCP
packets start at randomly generated sequence numbers.
The  sequence  numbers  need 
to  be  dynamically 
translated  to  match  the  receiver’s  view,  to  prevent
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 11:36:04 UTC from IEEE Xplore.  Restrictions apply. 
incorrect  packet  drops  or packet  buffering. We  have
solved  this  problem  by  bridging  the gap  with a
conversion  module  inside  the  emulated  TCP  agents  in
PDNS.  Similarly, both TCP and IP checksums are not
modeled  in  PDNS,  but  are  required  for  real  packets.
Again, we  resolved  this  by  generating (stripping)
checksums 
emission
(reception) in the emulated TCP agent.
(after)  packet
just  before 
Note that such conversions need to be performed on
per-connection basis,  and  hence  state  needs  to  be
per-connection basis,  and  hence  state  needs  to  be
a
maintained for each connection (e.g., starting sequence
maintained for each connection (e.g., starting sequence
numbers).    The  emulated  TCP  agents are  natural
numbers).    The  emulated  TCP  agents are  natural
holding points for such state.
holding points for such state.
4.3.2
4.3.2
Real-time pacing
Real-time pacing
In a network simulator, p
In a network simulator, p
acket events are processed
acket events are processed
 dequeueing the next earliest event and advancing to
 dequeueing the next earliest event and advancing to
by
by
its  timestamp. Thus,  the  simulator  finishes  processing
its  timestamp. Thus,  the  simulator  finishes  processing
all events in an as-fast-as-possible (AFAP) mode.  But
all events in an as-fast-as-possible (AFAP) mode.  But
when interfaced with a real network, packet arrivals are
when interfaced with a real network, packet arrivals are
dynamic.  Packets  can  arrive  at  unpredictable  times
dynamic.  Packets  can  arrive  at  unpredictable  times
from  the  real  network.    This  prevents  the  simulator
from  the  real  network.    This  prevents  the  simulator
from running as fast as possible, and instead mandates
from running as fast as possible, and instead mandates
real  time  pacing.    Real  time pacing  was  hence  added
real  time  pacing.    Real  time pacing  was  hence  added
into the main event processing loop of PDNS. 
into the main event processing loop of PDNS. 
Constructive  emulation  shares  this real tim
Constructive  emulation  shares  this real tim
e aspect
e aspect
th  traditional  emulation.   However,  a  nuance  is  that
th  traditional  emulation.   However,  a  nuance  is  that
wi
wi
the  simulator  executes  in  parallel.    To  maximize
the  simulator  executes  in  parallel.    To  maximize
runtime  performance,  we  implemented  a  scheme  by
runtime  performance,  we  implemented  a  scheme  by
which  AFAP  instances  are  never  constrained  by  real-
which  AFAP  instances  are  never  constrained  by  real-
time, but only the non-AFAP instances are paced with
time, but only the non-AFAP instances are paced with
real-time.    This  helps one  to  intelligently  balance  the 
real-time.    This  helps one  to  intelligently  balance  the 
simulation  load  across  processors,  so  that  most  of  the
simulation  load  across  processors,  so  that  most  of  the
simulated  network  is  simulated  in  AFAP  mode,  while
simulated  network  is  simulated  in  AFAP  mode,  while
only the few processors containing emulated nodes are
only the few processors containing emulated nodes are
constrained by real-time.
constrained by real-time.
for
for
efficient  parallel  execution  of 
efficient  parallel  execution  of 
Another  sticky  issue is
Another  sticky  issue is
again  related  to  parallel
again  related  to  parallel
ecution. A factor called lookahead [26]  (LA)  is
ecution. A factor called lookahead [26]  (LA)  is
ex
ex
crucial 
the
the
crucial 
simulators. We expand this notion using two kinds of
simulators. We expand this notion using two kinds of
LA:  simulation  LA  and  emulation  LA. We omit  the
LA:  simulation  LA  and  emulation  LA. We omit  the
details  of  these  schemes  here,  in  interest  of  space.
details  of  these  schemes  here,  in  interest  of  space.
Both  schemes  are  essential  to  ensuring  maximal
Both  schemes  are  essential  to  ensuring  maximal
parallelism in the entire system.
parallelism in the entire system.
4.4
4.4
Sample Execution 
Sample Execution 
we  used  two  laptops  (an
we  used  two  laptops  (an
In  an  experimental  setup,
In  an  experimental  setup,
IB
IB
M  Pentium-4  ThinkPad,  and  an  IBM  Pentium-III
M  Pentium-4  ThinkPad,  and  an  IBM  Pentium-III
ThinkPad),  running  the proxy  server  and  honeyd
ThinkPad),  running  the proxy  server  and  honeyd
respectively. The Code Red II worm model previously
respectively. The Code Red II worm model previously
described was  used  to  attack  a  network  in  which
described was  used  to  attack  a  network  in  which
honeyd was implanted into a 2-CPU PDNS execution.
honeyd was implanted into a 2-CPU PDNS execution.
As  expected,  honeyd  received  and  logged  incoming
As  expected,  honeyd  received  and  logged  incoming
TCP  malicious  connections.    As  no other  traffic  is
TCP  malicious  connections.    As  no other  traffic  is
destined 
destined 
incoming TCP
incoming TCP
a worm
connection 
connection 
a worm
the  honeypot,  every 
the  honeypot,  every 
at 
at 
constituted
constituted
honeyd 
honeyd 
to 
to 
scan/infection  attempt. We used honeyd’s  virtual
scan/infection  attempt. We used honeyd’s  virtual
subsystem feature to log the number of infections.
subsystem feature to log the number of infections.
a. Infections in honeypot
  b. Infections in entire network   
Figure 10: Tracking infections with honeypot emulation.
Figure 10: Tracking infections with honeypot emulation.
Figure 10 a & b show the propagation of the worm
Figure 10
a & b show the propagation of the worm
in  a  sample  200-node network  (simulated  on  2  CPUs)
in  a  sample  200-node network  (simulated  on  2  CPUs)
and  the number of  infection  attempts  logged by
and  the number of  infection  attempts  logged by
honeyd. As can be expected, the number of infections
honeyd. As can be expected, the number of infections
in  the honeypot  roughly  tracks  the  total  infections  in
in  the honeypot  roughly  tracks  the  total  infections  in
the  entire  network,  accurately  reflecting  the  fact  that
the  entire  network,  accurately  reflecting  the  fact  that
uniformly  random  addresses  are  generated by  our
uniformly  random  addresses  are  generated by  our
worm model.  In larger experiments, we are able to run 
worm model.  In larger experiments, we are able to run 
the  honeypot  with  networks  with  tens  of  thousands  of
the  honeypot  with  networks  with  tens  of  thousands  of
nodes (by employing suitably larger number of CPUs).
nodes (by employing suitably larger number of CPUs).
We  note that  while  honeypot-based tracking is  not
We  note that  while  honeypot-based tracking is  not
novel, 
to  plug-in  actual  honeypot
to  plug-in  actual  honeypot
novel, 
installations  into  large virtual  network has  not  been
installations  into  large virtual  network has  not  been
realized before.
realized before.
ability 
ability 
the
the
5
5
Full System Virtualization
Full System Virtualization
are 
are 
that 
that 
hard 
hard 
long  way 
long  way 
to  even higher
to  even higher
Packet-level  modeling  goes  a 