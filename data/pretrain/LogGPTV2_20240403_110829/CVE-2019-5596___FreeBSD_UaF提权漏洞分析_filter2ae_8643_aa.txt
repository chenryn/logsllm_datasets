# CVE-2019-5596 : FreeBSD UaF提权漏洞分析
##### 译文声明
本文是翻译文章，文章原作者 secfault-security，文章来源：secfault-security.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 0x01 引言
2019年2月，`FreeBSD`项目发布了一份关于文件描述符处理可能存在漏洞的[报告](https://www.freebsd.org/security/advisories/FreeBSD-SA-19:02.fd.asc)。
类UNIX系统（如FreeBSD）允许通过`UNIX域套接字`将文件描述符发送给其他进程。例如，将文件访问权限传递给接收进程。
在内核中，文件描述符是用于间接引用存储文件对象的相关信息的C结构。例如，对vnode的引用（vnode描述文件系统的文件、文件类型或访问权限）。
如果使用UNIX域套接字将文件描述符发送到另一个进程，会发生这样的情况：对于接收进程，在内核内部会创建对此结构的引用。新文件描述符和原文件描述符是对同一文件对象的引用，因此将继承所有的信息。例如正常情况下进程的所有者无法写文件，如果存在此漏洞，将允许该进程对设备上的文件进行写操作。
该报告描述了`FreeBSD
12.0`在此机制中引入的一个错误。由于文件描述符信息是通过套接字发送的，因此发送方和接收方必须为该过程分配缓冲区。如果接收缓冲区不够大，FreeBSD内核会尝试关闭收到的文件描述符，以防止描述符泄漏给发送方。但是，当处理函数关闭文件描述符时，它无法将文件描述符中的引用释放到文件对象。这可能导致引用计数器换行。
该报告进一步指出，此错误可能导致本地权限提升，以获得root权限或越权逃逸。但是，报告的作者并没有提供概念验证。
本文抓住了这一点，并描述了Secfault Security的研究，以利用该bug提权获得root权限。
> 在下一节中，将分析漏洞，以便对错误类进行声明，并猜测可能的利用方法。  
>  之后，解决了漏洞触发问题。  
>  讨论了三种开发策略，同时讨论了其中两种方法失败的原因。  
>  倒数第二节中，讨论了工作漏洞原语。它介绍了（至少根据作者的知识）针对FreeBSD中这些漏洞的新开发技术。解决了exploit的稳定性问题。  
>  最后一部分进行总结，并指出了下一步的工作及挑战。  
>  此外，附录部分描述了加速漏洞测试的条件，包括测试设置和内核补丁。
应该提到的是，该漏洞被回迁到了FreeBSD 11开发分支中。目前，此分支中的漏洞也已修复，因此它不会出现在11.3版本中。
该问题指定的CVE为[CVE-2019-5596](https://nvd.nist.gov/vuln/detail/CVE-2019-5596)。
> 注意：所有引用的代码都指的是最初的FreeBSD
> 12版本附带的易受攻击的源代码。如果没有另外提及，可以在[此处](https://download.freebsd.org/ftp/releases/amd64/amd64/12.0-RELEASE/src.txz)找到源代码。
所有PoC代码都可以在[这里下载](https://secfault-security.com/stuff/heavy_cyber_weapon.tbz)。
## 0x02 漏洞分析
为寻找漏洞的第一个线索，可以从查看发布的FreeBSD
12工程分支修订版`r343790`中的补丁开始。该修订在报告中提到过。它可以在FreeBSD开源平台的实例：[FreeBSD’s Phrabricator
instance. ](https://reviews.freebsd.org/rS343790)中找到。此修订版的修复内容如下：
      1578  void
      1579  m_dispose_extcontrolm(struct mbuf *m)
      1580  {
      ...
      1606          while (nfd-- > 0) {
      1607          fd = *fds++;
      1608          error = fget(td, fd, &cap_no_rights,
      1609                       &fp);
    - 1610              if (error == 0)
    + 1610              if (error == 0) {
      1611                  fdclose(td, fp, fd);
    + 1612                  fdrop(fp, td);
    + 1613              }
      1614          }
      ...
      1621  }
仅在文件`uipc_syscalls.c`中的`m_dispose_extcontrol()`函数中的添加了一个调用。该函数缺少对宏`fdrop()`的调用引入了漏洞。很自然的会有一个问题：这个宏是干什么用的？
fdrop()有两个参数，`fp`和`td`。后者是当前线程的内核指针。前者是指向struct文件对象的指针，该对象在`sys/sys/file.h`的第170行中定义。
    170  struct file {
    171  void *f_data;    /* 文件描述符特定数据*/
    172  struct fileops    *f_ops;        /* 文件操作*/
    173      struct ucred    *f_cred;    /* 相关凭据 */
    174      struct vnode     *f_vnode;    /*NULL或适用的vnode */
    175      short    f_type;        /* 描述符类型*/
    176      short    f_vnread_flags;     /*(f)睡眠锁定*/
    177      volatile u_int    f_flag;        /* 见fcntl.h*/
    178      volatile u_int     f_count;    /* 参考计数 */
    179      /*
    180    * DTYPE_VNODE特定字段 
    181 */
    182      int    f_seqcount;    /* （a）顺序访问次数 */
    183      off_t    f_nextoff;    /* 下一个预期的读/写偏移量 */
    184      union {
    185          struct cdev_privdata *fvn_cdevpriv;
    186                  /* （d）cdev的私人数据 */
    187          struct fadvise_info *fvn_advice;
    188      } f_vnun;
    189      /*
    190    *DFLAG_SEEKABLE特定字段
    191    */
    192      off_t    f_offset;
    193      /*
    194    *强制访问控制信息
    195    */
    196      void    *f_label;    /*  MAC标签的占位符*/
    197  };
`fdrop()`本身是一个宏，它先调用`refcount_release()`。此函数自动将struct定义的第178行中的`f_count`减1，如果在调用函数之前`f_count`小于或等于1则返回1，否则返回0。
如果返回值为1，则宏调用`_fdrop()`函数。
`_fdrop()`在`sys/kern/kern_descrip.c`中定义。
    2943  int __noinline
    2944  _fdrop(struct file *fp, struct thread *td)
    2945  {
    2946      int error;
    2947  
    2948      if (fp->f_count != 0)
    2949          panic("fdrop: count %d", fp->f_count);
    2950      error = fo_close(fp, td);
    2951      atomic_subtract_int(&openfiles, 1);
    2952      crfree(fp->f_cred);
    2953      free(fp->f_advice, M_FADVISE);
    2954      uma_zfree(file_zone, fp);
    2955  
    2956      return (error);
    2957  }
有趣的是第2954行，这里调用了`uma_zfree()`函数。这是一个内核内置的函数，可以释放堆上已分配的块。内核堆管理的细节超出了本文的讨论范围。内核分配器的内部工作原理由argp和karl在[Phrack
#0x42, Phile
#0x08](http://phrack.org/issues/66/8.html#article)中讲解。另一个资源是McKusick等人编写的“The
Design and Implementation of the FreeBSD Operating System”一书。
对于本篇文章，以下有关内核堆的知识就足够了：FreeBSD内核的堆分配器允许定义“区域（zones）”。每个区域用于通过创建“桶（buckets）”来管理特定大小的页面块。要在内核堆上分配块，必须调用`uma_zalloc()`函数并使用指定区域的参数。该函数返回一个指向取自该区域的“桶”的指针。如果“桶”为空，则为该区域分配新页面并按区域的块大小切块。
例如，套接字区域用于分配大小为872字节的块，内核使用这些块来为套接字对象分配堆空间。还有一些匿名区域，如256，它们被内核中的malloc()调用。
可以使用命令`vmstat -z`查看所有可用区域，包括其统计信息。
当内核通过`uma_zalloc()`释放堆块时，释放的堆块将被放回到区域的”桶”中。后续调用`malloc()`或`uma_zalloc()`函数时，将以LIFO（后进先出）式从这些存储“桶”中获取块。
目前，有趣的见解是：
> uma_zfree()被file_zone调用  
>  file_zone指的是一个名为Files的用于存放struct文件类型的特殊区域  
>  如果另一个函数从Files分配一个struct文件，它最终会收到_fdrop()释放的指针
最新观察结果：在`sys/kern/kern_descrip.c`的fdclose()函数的第2384行调用了fdrop()。
    2376  fdclose(struct thread *td, struct file *fp, int idx)
    2377  {
    2378      struct filedesc *fdp = td->td_proc->p_fd;
    2379  
    2380      FILEDESC_XLOCK(fdp);
    2381      if (fdp->fd_ofiles[idx].fde_file == fp) {
    2382          fdfree(fdp, idx);
    2383          FILEDESC_XUNLOCK(fdp);
    2384          fdrop(fp, td);
    2385      } else
    2386          FILEDESC_XUNLOCK(fdp);
    2387  }
漏洞的描述中提到了引用计数器的包装，可以看到缺少第二个fdrop()会导致相应struct文件中的引用计数器`f_count`溢出。这可能会导致`use-after-free（UaF）`漏洞（Vitaly
Nikolenko的[https://ruxcon.org.au/assets/2016/slides/ruxcon2016-Vitaly.pdf，](https://ruxcon.org.au/assets/2016/slides/ruxcon2016-Vitaly.pdf%EF%BC%8C)
获得相似的漏洞示例）。
为了捋清这个问题，我们将研究`m_dispose_extcontrolm()`的确切目的和易受攻击路径。
## 0x03 漏洞触发路径
引入`m_dispose_extcontrolm()`函数的[目的](https://reviews.freebsd.org/D16561)，是为了使用UNIX域套接字发送文件描述符。发送文件描述符是由`sendmsg()`函数完成的，它允许将所谓的控制数据放入消息中（有关详细信息，请参阅手册页）。文件描述符是由控制消息类型`SCM_RIGHTS`负责发送的。
[很久以前就观察到](https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=131876)，如果接收器的缓冲区太小，会导致文件描述符的泄漏。列出的漏洞条目表明，在接收缓冲区不够大的情况下，接收进程必须关闭已打开的文件描述符，因为并非所有描述符都被接收了。但是，由于接收到的文件描述符被处理并且创建了对文件对象的引用（如引言中所述），如果没有关闭文件描述符，这些文件描述符就有可能被泄露。
因此，引入了新函数`m_dispose_extcontrol()`解决这一问题。看`sys/kern/uipc_syscalls.c`中`kern_recvit()`的第998行进入判断后，在第1033行中的调用。
    902  int
    903  kern_recvit(struct thread *td, int s, struct msghdr *mp, enum uio_seg fromseg,
    904      struct mbuf **controlp)
    905  {
    ...
    998      if (mp->msg_control && controlp == NULL) {
    999  #ifdef COMPAT_OLDSOCK
    ...
    1018  #endif
    1019          ctlbuf = mp->msg_control;
    1020          len = mp->msg_controllen;
    1021          mp->msg_controllen = 0;