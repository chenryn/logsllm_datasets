  by	
  forging	
  the	
  self-­‐
checksum	
– We	
  can	
  counter	
  this	
  with	
  "strongly	
  ordered	
func2on"	
  like	
  A	
  +	
  B	
  C	
  +	
  D	
  E	
  +	
  F	
  etc.	
  Because	
the	
  longer	
  the	
  chain,	
  the	
  less	
  likely	
((((A+B)	
  C)+D)	
  E)+F)==(A+B)	
  (C+D)	
  (E+F)	
  for	
instance.	
22	
© 2012 The MITRE Corporation. All rights reserved. 
Problems	
  with	
  Selfcheck()	
  .01	
•  There	
  is	
  poten2ally	
  lots	
  of	
  wasted	
  cycles,	
  so	
an	
  aGacker	
  may	
  be	
  able	
  to	
  add	
  an	
  if()	
  case	
with	
  no	
  overhead.	
– So	
  we	
  need	
  to	
  handcode	
  assembly,	
  and	
  try	
  to	
make	
  sure	
  it	
  is	
  using	
  as	
  much	
  of	
  the	
microarchitecture	
  components	
  as	
  possible	
  so	
there	
  is	
  no	
  "free"	
  computa2on	
  available	
  to	
  an	
aGacker.	
  Otherwise	
  he	
  can	
  just	
  do…	
23	
© 2012 The MITRE Corporation. All rights reserved. 
Selfcheck()	
  .01	
  aGack	
void	
  Selfcheck(int	
  *	
  selfchecksum,	
  int	
  nonce){	
  int	
  *	
  DP	
  =	
  GetMyCodeStart();	
  int	
  *	
  end	
  =	
  GetMyCodeEnd();	
  while(DP	
  <	
  end){	
  selfchecksum[0]	
  +=	
  nonce;	
  if(DP	
  ==	
  badbits)	
  selfchecksum[1]	
  +=	
  cleanbits;	
  else	
  selfchecksum[1]	
  +=	
  *DP;	
  __asm{	
  call	
  $+5;	
  pop	
  eax;	
  mov	
  EIP,	
  eax;}	
  selfchecksum[2]	
  +=	
  EIP;	
  mix(selfchecksum);	
  DP++;	
  }	
}	
24	
© 2012 The MITRE Corporation. All rights reserved. 
Network	
  Timing	
  Implementa2on	
Server	
Client	
Measurement	
  Type:	
  FOO,	
Nonce	
  =	
  0xf005ba11	
Selfcheck	
  (Nonce	
  =	
  0xf005ba11)	
Self-­‐Checksum,	
Nonce	
  =	
  0xf005ba11	
FOO	
  measurement	
FOO	
  measurement	
  results	
Time	
Δt	
25	
© 2012 The MITRE Corporation. All rights reserved. 
Network	
  Timing	
  Implementa2on	
(with	
  aGack)	
Server	
Client	
Measurement	
  Type:	
  FOO,	
Nonce	
  =	
  0xf005ba11	
Selfcheck	
  (Nonce	
  =	
  0xf005ba11)	
Selfchecksum,	
Nonce	
  =	
  0xf005ba11	
FOO	
  measurement	
FOO	
  measurement	
  results	
Time	
Δt	
26	
© 2012 The MITRE Corporation. All rights reserved. 
One	
  more	
  problem	
  with	
  Selfcheck()	
  .01	
•  Also,	
  no2ce	
  that	
  EIP	
  will	
  actually	
  always	
  be	
  the	
exact	
  same	
  value	
  each	
  2me	
  through	
  the	
  loop.	
  So	
the	
  aGacker	
  could	
  create	
  his	
  own	
  checksum	
rou2ne	
  oﬀ	
  to	
  the	
  side,	
  which	
  instead	
  of	
calcula2ng	
  EIP,	
  just	
  hardcodes	
  it	
  based	
  on	
wherever	
  the	
  self-­‐check	
  got	
  loaded	
  into	
  memory.	
–  We	
  need	
  to	
  make	
  it	
  so	
  that	
  the	
  aGacker	
  can't	
hardcode	
  the	
  EIP.	
  We	
  can	
  do	
  this	
  by	
  breaking	
  the	
  self-­‐
check	
  into	
  mul2ple	
  blocks,	
  and	
  pseudo-­‐randomly	
picking	
  a	
  diﬀerent	
  block	
  each	
  2me	
  through	
  the	
  loop	
27	
© 2012 The MITRE Corporation. All rights reserved. 
28	
From	
  A.	
  Seshadri,	
  M.	
  Luk,	
  E.	
  Shi,	
  A.	
  Perrig,	
  L.	
  van	
  Doorn,	
  and	
  P.	
  Khosla.	
Pioneer:	
  verifying	
  code	
  integrity	
  and	
  enforcing	
  untampered	
  code	
  execu2on	
  on	
  legacy	
  systems.	
© 2012 The MITRE Corporation. All rights reserved. 
PRNG	
•  But	
  now	
  we	
  need	
  a	
  pseudo-­‐random	
  number	
generator,	
  seeded	
  by	
  our	
  nonce.	
•  We	
  used	
  the	
  same	
  one	
  Pioneer	
  did:	
•  PRNnew	
  =	
  PRNcurrent	
  *	
  (PRN2
current	
  OR	
  5)	
29	
© 2012 The MITRE Corporation. All rights reserved. 
New	
  self-­‐check	
  .02	
  pseudocode	
Prolog();	
BLOCK0_MACRO	
  (expanded)	
  if(loopcounter	
  ==	
  0)	
  jmp	
  done;
  //This	
  used	
  to	
  be	
  our	
  while	
  loop	
  loopcounter-­‐-­‐;	
  add	
  ecx,	
  [esp]; 	
  //aPer	
  this	
  ecx	
  (accumulator)	
  =	
  EIP_SRC	
  +	
  EIP_DST	
  xor	
  ecx,	
  PRN;
  //ecx	
  =	
  EIP_SRC	
  +	
  EIP_DST	
  XOR	
  PRN	
  add	
  ecx,	
  DP;
  //ecx	
  =	
  EIP_SRC	
  +	
  EIP_DST	
  XOR	
  PRN	
  +	
  DP	
  xor	
  ecx,	
  [DP];
  //ecx	
  =	
  EIP_SRC	
  +	
  EIP_DST	
  XOR	
  PRN	
  +	
  DP	
  XOR	
  [DP]	
  updatePRN();
  //New	
  PRN	
  in	
  each	
  block	
  updateDP();	
  //We	
  pick	
  a	
  new	
  DP	
  based	
  on	
  the	
  PRN	
  mix(selfchecksum,ecx);	
  //Rotates	
  checksum	
  by	
  1	
  bit	
  to	
  add	
  diﬀusion	
  ecx	
  =	
  block0Base	
  +	
  (blockSize*(PRN	
  &	
  3));	
  //Calc	
  next	
  block	
  based	
  on	
  PRN	
  call	
  ecx;
  //goto	
  next	
  block,	
  EIP_DST	
  in	
  ecx,	
  EIP_SRC	
  on	
  stack	
BLOCK1_MACRO	
BLOCK2_MACRO	
…	
BLOCK7_MACRO	
done:	
Epilog();	
30	
© 2012 The MITRE Corporation. All rights reserved. 
Public	
  released	
  self-­‐check	
31	
© 2012 The MITRE Corporation. All rights reserved. 
Memory	
  Copy	
  AGacks	
32	
AGacker	
  gets	
free	
  DP	
  or	
  EIP	
forgery	
  thanks	
to	
  ASLR.	
We	
  had	
  the	
least	
  overhead	
with	
  this	
  aGack	
By	
  deﬁni2on,	
more	
  overhead	
than	
  (b)	
  or	
  (c).	
Not	
  a	
  good	
  idea.	
Figure	
  From	
  Pioneer	
© 2012 The MITRE Corporation. All rights reserved. 
VFUNC	
Filter	
Packet	
Measure	
System	
Original	
  copy	
  of	
  self-­‐checking	
kernel	
  module	
How	
  it	
  works	
  without	
  aGacker	
Veriﬁer	
  1	
Call	
Send(Selfchecksum)	
Send(BaseVA=0x1000)	
2	
  3	
ret	
  4	
call	
Send(Measurement)	
5	
MeasurementRequest	
Nonce	
  =	
  0xf005ba11	
  I	
N	
T	
R	
A	
N	
E	
T	
BaseVA	
=	
  0x1000	
© 2012 The MITRE Corporation. All rights reserved. 
VFUNC	
Filter	
Packet	
Measure	
System	
Original	
  copy	
  of	
  self-­‐checking	
kernel	
  module	
MeasurementRequest	
Nonce	
  =	
  0xf005ba11	
Our	
  current	
  fastest	
  PoC	
  aGack	
(built	
  into	
  the	
  public	
  released	
  code	
  for	
  easy	
  toggling)	
  1	
Call	
Send(Selfchecksum)	
Send(BaseVA=0x2000)	
3	
  4	
ret	
  5	
call	
Send(Measurement)	
(lies	
  that	
  system	
  is	
  clean)	
6	
  I	
N	
T	
R	
A	
N	
E	
T	
Clean	
  copy	
  of	
  complete	
kernel	
  module	
EVILVFUNC	
Inline	
  Hook	
BaseVA	
=	
  0x1000	
BaseVA	
=	
  0x2000	
  2	
jmp	
DP	
  (free	
  forgery)	
Corrupted	
EVILVFUNC	
  forges	
  EIP	
to	
  be	
  at	
  the	
  right	
  oﬀset	
In	
  the	
  lied-­‐about	
  DP	
  range	
FORGED	
VFUNC	
  EIP	
RANGE	
© 2012 The MITRE Corporation. All rights reserved. 
Other	
  tricks	
•  Not	
  discussed	
  in	
  depth	
  due	
  to	
  lack	
  of	
  2me,	
  see	
  our	
  full	
  paper,	
  the	
related	
  work,	
  and	
  the	
  source	
  code	
•  "The	
  stack	
  trick"	
  –	
  if	
  you	
  store	
  part	
  of	
  your	
  self-­‐checksum	
  *below*	
esp,	
  then	
  you	
  can	
  guarantee	
  that	
  if	
  someone	
  causes	
  an	
  interrupt	
during	
  your	