title:On the Security of RC4 in TLS
author:Nadhem J. AlFardan and
Daniel J. Bernstein and
Kenneth G. Paterson and
Bertram Poettering and
Jacob C. N. Schuldt
On the Security of RC4 in TLS
Nadhem AlFardan, Royal Holloway, University of London;  
Daniel J. Bernstein, University of Illinois at Chicago and Technische Universiteit Eindhoven; 
Kenneth G. Paterson, Bertram Poettering, and Jacob C.N. Schuldt,  
Royal Holloway, University of London
Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4On the Security of RC4 in TLS1
Nadhem J. AlFardan
Information Security Group,
Royal Holloway, University of London
Daniel J. Bernstein
University of Illinois at Chicago and
Technische Universiteit Eindhoven
Kenneth G. Paterson
Information Security Group,
Royal Holloway, University of London
Bertram Poettering
Information Security Group,
Jacob C. N. Schuldt
Information Security Group,
Royal Holloway, University of London
Royal Holloway, University of London
Abstract
The Transport Layer Security (TLS) protocol aims to
provide conﬁdentiality and integrity of data in transit
across untrusted networks. TLS has become the de facto
protocol standard for secured Internet and mobile ap-
plications. TLS supports several symmetric encryption
options, including a scheme based on the RC4 stream
cipher. In this paper, we present ciphertext-only plain-
text recovery attacks against TLS when RC4 is selected
for encryption. Our attacks build on recent advances in
the statistical analysis of RC4, and on new ﬁndings an-
nounced in this paper. Our results are supported by an
experimental evaluation of the feasibility of the attacks.
We also discuss countermeasures.
1
Introduction
TLS is arguably the most widely used secure communi-
cations protocol on the Internet today. Starting life as
SSL, the protocol was adopted by the IETF and speciﬁed
as an RFC standard under the name of TLS 1.0 [7]. It
has since evolved through TLS 1.1 [8] to the current ver-
sion TLS 1.2 [9]. Various other RFCs deﬁne additional
TLS cryptographic algorithms and extensions. TLS is
now used for securing a wide variety of application-level
trafﬁc: It serves, for example, as the basis of the HTTPS
protocol for encrypted web browsing, it is used in con-
junction with IMAP or SMTP to cryptographically pro-
tect email trafﬁc, and it is a popular tool to secure com-
munication with embedded systems, mobile devices, and
in payment systems.
Technically speaking, TLS sessions consist of two
consecutive phases: the execution of the TLS Handshake
Protocol which typically deploys asymmetric techniques
to establish a secure session key, followed by the exe-
cution of the TLS Record Protocol which uses symmet-
ric key cryptography (block ciphers, the RC4 stream ci-
pher, MAC algorithms) in combination with the estab-
lished session key and sequence numbers to build a se-
cure channel for transporting application-layer data. In
the Record Protocol, there are mainly three encryption
options:
• HMAC followed by CBC-mode encryption using a
block cipher,
• HMAC followed by encryption using the RC4
stream cipher, or
• authenticated encryption using GCM or CCM mode
of operation of a block cipher.
The third of these three options is only available with
TLS 1.2 [21, 18], which is yet to see widespread adop-
tion.2 The ﬁrst option has seen signiﬁcant cryptanalysis
(padding oracle attacks [6], BEAST [10], Lucky 13 [3]).
While countermeasures to the attacks on CBC-mode in
TLS exist, many commentators now recommend, and
many servers now offer, RC4-based encryption options
ahead of CBC-mode.3 Indeed, the ICSI Certiﬁcate No-
tary4 recently performed an analysis of 16 billion TLS
connections and found that around 50% of the trafﬁc was
protected using RC4 ciphersuites [5].
This makes it timely to examine the security of RC4 in
TLS. While the RC4 algorithm is known to have a variety
of cryptographic weaknesses (see [23] for an excellent
survey), it has not been previously explored how these
weaknesses can be exploited in the context of TLS. Here
we show that new and recently discovered biases in the
RC4 keystream do create serious vulnerabilities in TLS
when using RC4 as its encryption algorithm.
While the main focus of this paper lies on the security
of RC4 in TLS, our attacks (or variants thereof) might
also be applicable to other protocols where RC4 is meant
to ensure data conﬁdentiality. Indeed, the WPA proto-
col used for encrypting wireless network trafﬁc also uti-
lizes the RC4 stream cipher in a way that allows (partial)
plaintext recovery in speciﬁc settings — using basically
the same attack strategies as in the TLS case.
USENIX Association  
22nd USENIX Security Symposium  305
1
We hope that this work will help spur the adoption of
TLS 1.2 and its authenticated encryption algorithms, as
well as the transition from WPA to (the hopefully more
secure) WPA2.
1.1 Overview of Results
We present two plaintext recovery attacks on RC4 that
are exploitable in speciﬁc but realistic circumstances
when this cipher is used for encryption in TLS. Both at-
tacks require a ﬁxed plaintext to be RC4-encrypted and
transmitted many times in succession (in the same, or in
multiple independent RC4 keystreams). Interesting can-
didates for such plaintexts include passwords and, in the
setting of secure web browsing, HTTP cookies.
A statistical analysis of ciphertexts forms the core of
our attacks. We stress that the attacks are ciphertext-
only: no sophisticated timing measurement is needed on
the part of the adversary, the attacker does not need to be
located close to the server, and no packet injection capa-
bility is required (all premises for Lucky 13). Instead, it
sufﬁces for the adversary to record encrypted trafﬁc for
later ofﬂine analysis. Provoking the required repeated
encryption and transmission of the target plaintext, how-
ever, might require more explicit action: e.g., resetting
TCP connections or guiding the victim to a website with
specially prepared JavaScript (see examples below).
Since both our attacks require large amounts of cipher-
text, their practical relevance could be questioned. How-
ever, they do show that the strength of RC4 in TLS is
much lower than the employed 128-bit key would sug-
gest. We freely admit that our attacks are not particularly
deep, nor sophisticated: they only require an understand-
ing of how TLS uses RC4, solid statistics on the biases
in RC4 keystreams, and some experience of how modern
browsers handle cookies. We consider it both surprising
and alarming that such simple attacks are possible for
such an important and heavily-studied protocol as TLS.
We further discuss the implications of our attack in Sec-
tion 6 and in the full version of this paper [4].
1.1.1 Our single-byte bias attack
Our ﬁrst attack targets the initial 256 bytes of RC4 ci-
phertext. It is ﬁxed-plaintext and multi-session, meaning
that it requires a ﬁxed sequence of plaintext bytes to be
independently encrypted under a large number of (ran-
dom) keys. This setting corresponds to what is called a
“broadcast attack” in [17, 15, 23]. As we argue below,
such attacks are a realistic attack vector in TLS. Observe
that, in TLS, the ﬁrst 36 bytes of the RC4 keystream are
used to encrypt a TLS Handshake Finished message.
This message is not ﬁxed across TLS sessions. As a con-
sequence, our methods can be applied only to recover up
to 220 bytes of the TLS application plaintext.
Our attack exploits statistical biases occurring in the
ﬁrst 256 bytes of RC4 keystream. Such biases, i.e., devi-
ations from uniform in the distributions of the keystream
bytes at certain positions, have been reported and the-
oretically analyzed by [17], [15], and [23]. The corre-
sponding authors also propose algorithms to exploit such
biases for plaintext recovery. In this paper, we discuss
shortcomings of their algorithms, empirically obtain a
complete view of all single-byte biases occurring in the
ﬁrst 256 keystream positions, and propose a generalized
algorithm that fully exploits all these biases for advanced
plaintext recovery. As a side result of our research, in
Section 3.1 we report on signiﬁcant biases in the RC4
keystream that seemingly follow speciﬁc patterns and
that have not been identiﬁed or analysed previously.
For concreteness, we describe how our single-byte
bias attack could be applied to recover cookies in HTTPS
trafﬁc. Crucial here is to ﬁnd an automated mechanism
for efﬁciently generating a large number of encryptions
of the target cookie. In line with the scenario employed
by the BEAST and Lucky 13 attacks against CBC-mode
encryption in TLS [3, 10], a candidate mechanism is
for JavaScript malware downloaded from an attacker-
controlled website and running in the victim’s browser
to repeatedly send HTTPS requests to a remote server.
The corresponding cookies are automatically included in
each of these requests in a predictable location, and can
thus be targeted in our attack.
If client and server are
conﬁgured to use TLS session resumption, the renewal of
RC4 keys could be arranged to happen with particularly
high frequency — as required for our attack to be suc-
cessful.5 Alternatively, the attacker can cause the TLS
session to be terminated after the target encrypted cookie
is sent; the browser will automatically establish a new
TLS session when the next HTTPS request is sent.
As a second example, consider the case where IMAP
passwords6 are attacked. In a setup where an email client
regularly connects to an IMAP server for (password-
authenticated) mail retrieval, let the adversary reset the
TCP connection between client and server immediately
after the encrypted password is transmitted.
In some
client conﬁgurations this might trigger an automatic re-
sumption of the session, including a retransmission of the
(encrypted) password. If this is the case, the adversary
is in the position to harvest a large set of independently
encrypted copies of the password —one per reset— pre-
cisely fulﬁlling the precondition of our attack.
Our single-byte bias attack is on the verge of prac-
ticality.
In our experiments, the ﬁrst 40 bytes of TLS
application data after the Finished message were re-
covered with a success rate of over 50% per byte, using
226 sessions. With 232 sessions, the per-byte success rate
is more than 96% for the ﬁrst 220 bytes (and is 100%
306  22nd USENIX Security Symposium 
USENIX Association
2
for all but 12 of these bytes). If, for example, a target
plaintext byte is known to be a character from a set of
cardinality 16 (e.g., in a 4-bits-per-byte-encoded HTTP
cookie), our algorithm recovers the ﬁrst 112 bytes of
plaintext with a success rate of more than 50% per byte,
using 226 sessions. For further details, see Section 5.
1.1.2 Our double-byte bias attack
As we have seen, our single-byte bias attack on RC4 is
quite effective in recovering ‘early’ plaintext bytes in the
ﬁxed-plaintext multi-session setting. It has, however, a
couple of limitations when it comes to attacking practi-
cal systems that employ TLS. Focussing on the recovery
of cookies in HTTPS-secured web sessions, we note that
modern web browsers typically send a large number of
HTTP headers before any cookies (these headers carry
information about the particular client or server software,
accepted MIME types, compression options, etc.).
In
practice, cookie data appears only at positions that come
after the attackable initial 220 bytes of the ciphertext7.
Independently of this issue, in the attack scenarios pro-
posed above, a large number of HTTPS sessions would
have to be established and torn down again, inducing
non-negligible computing and bandwidth overheads via
the TLS Handshake. Lastly, it has been proposed to rou-
tinely drop the ﬁrst few hundred keystream bytes of RC4
before starting encryption in order to avoid the relatively
strong early keystream biases [19] — if this were to be
implemented in TLS, our single-byte bias attack would
effectively be defeated.
Complementary to our single-byte bias attack, we
present a second ﬁxed-plaintext ciphertext-only attack
on RC4.
It exploits biases that appear in the entire
keystream (and not just in the ﬁrst 256 positions) and
does not assume, but tolerates, frequent changes of the
encryption key. Our second attack hence covers some
scenarios where our single-byte bias attack does not
seem to be applicable; it would, for example, be able to
recover cookies from (long-persisting) HTTPS sessions.
It would also be applicable if the initial keystream bytes
were to be discarded.
In contrast to our ﬁrst attack, our second attack ex-
ploits certain biases in consecutive pairs of bytes in the
RC4 keystream that were ﬁrst reported by Fluhrer and
McGrew [12]. We empirically evaluate the probability
of occurrence for each possible pair of bytes beginning at
each position (modulo 256), obtaining a complete view
of the distributions of pairs of bytes in positions (i,i + 1)
(modulo 256). Our analysis strongly suggests that there
are no further biases in consecutive positions of the same
strength as the Fluhrer-McGrew biases. We use the ob-
tained results in a specially designed attack algorithm to
recover repeatedly encrypted plaintexts.
Our double-byte bias attack is again close to being
practical. In our experiments, we focus on our attack’s
ability to correctly recover 16 consecutive bytes of plain-
text, roughly equating to an HTTP cookie. With 13· 230
encryptions of the plaintext, we achieve a success rate of
100% in recovering all 16 bytes. We obtain better suc-
cess rates for restricted plaintexts, as in the single-byte
case. For further details, see Section 5.
1.2 Related Work
In independent and concurrent work, Isobe et al. [13]
have considered the security of RC4 against broadcast
attacks. They present attacks based on both single-byte
and multi-byte biases. They identify three biases in the
ﬁrst output bytes Zr of RC4 that we also identify (speciﬁ-
cally, the biases towards Z3 = 0x83, Zr = r, and Zr = −r
when r is a multiple of 16) as well as a new conditional
bias Z1 = 0|Z2 = 0.
The single-byte bias attack in [13] only considers the
strongest bias at each position, whereas our single-byte
bias attack simultaneously exploits all biases in each
keystream position. Speciﬁcally, we use Bayes’s law to
compute the a posteriori plaintext distribution from the a
priori plaintext distribution and the precomputed distri-
butions of the Zr. This explains why our single-byte at-
tack out-performs that of [13]. For example, we achieve
reliable plaintext recovery in the ﬁrst 256 positions with
232 ciphertexts, while Isobe et al. [13] require 234 cipher-
texts. We also achieve uniformly higher success rates for
lower numbers of sessions. Previous authors exploring
broadcast attacks on RC4 also only used single biases,
leading to attacks that simply do not work [15, 23] or
which have inferior performance to ours [22].
The multi-byte bias attack in [13] exploits the positive
bias towards the pattern ABSAB that was identiﬁed by
Mantin [16]. Here A and B are keystream bytes and S
is a short string consisting of any keystream bytes (pos-
sibly of length 0). The attack in [13] assumes that 3-
out-of-4 bytes in particular positions are known and uses
the Mantin bias to recover the fourth. A limited ex-
perimental evaluation of the attack is reported in [13]:
the attack is applied only to recovery of plaintext bytes
258-261, assuming all previous plaintext bytes have been
successfully recovered, with success rates of 1 (for each
of the 4 targeted bytes) using 234 ciphertexts. As ex-
plained in [13], this multi-byte attack would fail if the
initial bytes of RC4 output were to be discarded. By
contrast, our double-byte bias attack, which exploits the
Fluhrer-McGrew biases, recovers more bytes with com-
parable success rate using slightly fewer ciphertexts and
is resilient to initial byte discarding. It is an interesting
open problem to determine whether the Mantin ABSAB
bias can be combined with the Fluhrer-McGrew biases to
USENIX Association  
22nd USENIX Security Symposium  307
3
gain enhanced attack performance.
A further point of comparison between our work and
that of [13] concerns practical implementation. We have
extensively explored the applicability of our attacks to
RC4 as used in TLS, while [13] makes only brief men-
tion of TLS in its concluding section and gives no mech-
anisms for generating the large numbers of ciphertexts
needed for the attacks.
Finally, the authors of [13] claim in their abstract that
their methods “can recover the ﬁrst 250 bytes ≈ 1000 T
bytes of the plaintext, with probability close to 1, from
only 234 ciphertexts”. We point out that their methods
would only recover 216 distinct bytes of output, rather
than the advertised 250 bytes, since their attacks require
the same plaintext to be encrypted 234 times. Further-
more, their multi-byte bias attack is not resilient to er-
rors occurring in the recovery of early plaintext bytes
(whereas ours is), so this claim would only be true if their
multi-byte bias attack does not fail at any stage, and this
is as yet untested.