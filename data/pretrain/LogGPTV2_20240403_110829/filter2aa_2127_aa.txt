代 码 混 淆 研 究 的 新 方 向
程瑞
西安交通大学软件学院
南子龙 西安交通大学微电子学院
范铭
西安交通大学网安学院
# 我们是谁
• 程瑞
西安交通大学软件工程学院大二
智能网络与网络安全教育部重点实验室实习生
研究方向包括程序分析、模糊测试、恶意软件检测、IoT
• 南子龙
西安交通大学微电子学院大四
智能网络与网安安全教育部重点实验室实习生
研究方向包括IoT安全、密码学应用、量子器件、同态芯片
• 范铭
西安交通大学网络空间安全学院副教授
研究方向包括可解释性AI技术、AI安全、移动软件安全
# 目录
• PART I（程瑞）
• 引言：代码混淆的定义以及应用
• 现状：研究现状
• 动机：已有研究存在的不足
• 方法：我们提出的若干改进方法
• 实验：实验验证我们提出的方法是否有效
• PART II（南子龙）
• 同态加密 & 混淆电路
• 前沿密码学成果如何在代码混淆研究中落地化
引言
代码混淆的定义以及应用
# 代码混淆的定义
O(P) = P’
P
P’
• P’ vs P
分析难度增加
 更多的流程转移指令
 更多的算术运算指令
语义应是相等
 接收相同且合法的输入，P与P’产
生相同输出
• P’的执行环境
不可信环境
 任意时刻中断程序修改代码
 任意时刻读/写程序内存
代码混淆
恶意软件
数字版权保护
 APT载荷
 C2客户端
 蠕虫木马
 …
 VMProtect
 Themida
 O-LLVM
 …
# 代码混淆的应用
现状
学界与业界的研究现状
# 代码混淆的分类
• 控制流混淆
变换程序控制流, 使程序控制结构变得更加复杂
• 数据流混淆
变换程序数据流, 使程序数据流向变得更加复杂
• 布局混淆
删除或修改二进制程序中对攻击者有效的信息, 如调试信息等
• 预防性混淆
针对某种特定的反混淆工具或方法的混淆方法
[1]Collberg C, Thomborson C, Low D. A taxonomy of obfuscating transformations[R]. Department of Computer Science, The 
University of Auckland, New Zealand, 1997.
# 逻辑门
• VMProtect万用门
Nand
Nor
• 量子逻辑门 （或许也是三输入门
Fredkin
Toffoli
• 三输入门
AOI
OAI
# 足够安全吗
源文件
编译优化后
x86-64 Clang 12.01, -O3
# 三输入门
源文件
编译优化后
那么…
# 为什么不安全
• 三输入门 vs 二输入门
AOI(a, b, -1) = ~(a|(b&-1)) = ~(a|b) = Nor(a, b), b & -1 = b
b & -1 = b, a & 0 = 0, a | 0 = a, …, 那么… 从内联角度来看, 三输入门 等
价于 二输入门
• 击败二输入门
布尔代数中明确的运算规则
A + AB = (1 + A)B = A
(A + B)(A + C) = A + AC + AB + BC = A + BC
…
LLVM InstCombine Pass
lib/Transforms/InstCombine/Inst
CombineAndOrXor.cpp
# 不透明谓词
原程序控制流
混淆后
• 不透明谓词
永真/假型
插入的后继基本块中必有一个不被执行
可真可假型
插入的两个后继基本块的语义应相同
基本块1
基本块2
基本块1
基本块2
基本块3
# 安全性的问题
•
O-LLVM
 x * (x + 1) % 2 == 0
 …
 Angr检测出它们所需时间极短[1]
•
基于API构造
 CreateFile接受错误输入返回0
 …
 可以拓展符号执行工具为API实现输入正确性检测
[1]“Manufacturing resilient bi-opaque predicates against symbolic execution,” Hui Xu, Yangfan Zhou, Yu Kang, Fengzhi Tu 
and Michael R. Lyu, in Proc. of the 48th IEEE/IFIP International Conference on Dependable Systems and Networks (DSN), 
Luxembourg City, Luxembourg, June 1-5, 2018.
# RANGE DIVIDER
[1]Banescu S, Collberg C, Ganesh V, et al. Code obfuscation against symbolic execution attacks[C]//Proceedings of the 
32nd Annual Conference on Computer Security Applications. 2016: 189-200.
unsigned int hash = 0;
for (int i = 0; i  44)
hash = (hash > 8;
int ch3 = (i1 & 0xFF0000) >> 16;
char c1, c2, c3;
for (int i = 0; i  1) {
if (y % 2 == 1)
y = 3 * y + 1;
else
y = y / 2;
if ((x - y > 28) && (x + y  1) {
if (y % 2 == 1)
y = 3 * y + 1;
else
y = y / 2;
if ((x - y > 28) && (x + y < 32)) {
do_m();
break;
过去的研究都表明3x+1混淆能有效抵抗符号执行工具
的路径探索
•
3x+1猜想的个数是有限的
•
猜想值迭代回1的循环次数是非常高的
•
5000-5500范围内初始值迭代回1所需次数大部
分在50-125之间
我们的改进想法是
•
研究混淆中的哪一部分使符号执行工具难以处理
•
寻找构造这类混淆方法的框架
已有研究已经证明Sharif等人的方法是有效的，然而，直接应用HASH函数的方法实在是过于粗糙
•
MD5、SHA256等HASH算法的输入都是以块为单位的，一般而言，我们要加密的常数C不过是8字
节。显而易见，直接使用它们造成了许多不必要的开销
•
HASH算法的个数是有限的