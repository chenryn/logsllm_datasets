# Path to Verifiably Secure Operating Systems

## Distribution of Bugs and Warnings in the Linux Kernel
Bugs and warnings are not uniformly distributed throughout the kernel. In our analysis of Linux 2.4.23, we found eleven bugs, with all but two located in device drivers. Given that there are approximately 1500KLOC (thousand lines of code) in drivers and 700KLOC in the rest of the kernel, this translates to a defect rate of about one bug per 200KLOC for driver code and one bug per 400KLOC for the rest of the kernel. It is important to note that these numbers should be interpreted with caution due to the small sample size. This distribution suggests that the core kernel code is more rigorously vetted than device driver code. However, the bugs we identified were not confined to obscure drivers; four were found in the widely used PCMCIA driver subsystem. Similarly, warnings were more prevalent in driver files, with 196 out of 264 unique warnings occurring in driver files.

## Bug Turnover in the Linux Kernel
Our analysis also revealed significant bug turnover. Between Linux kernels 2.4.20 and 2.4.23, seven user/kernel security bugs were fixed, while five new ones were introduced. This indicates that even in stable, mature, and slowly changing software systems, a substantial number of undiscovered security vulnerabilities may still exist, waiting to be exploited.

## False Positives Analysis
We conducted an in-depth analysis of false positives generated by CQUAL in the Linux kernel 2.4.23. This investigation serves two purposes:

1. **Improving Developer Discipline**: Since it is impossible to build a program verification tool that is both sound and complete, any system for developing provably secure software must rely on both program analysis tools and programmer discipline. Based on our false positive analysis, we propose two simple rules to help developers write verifiably secure code.
2. **Guiding Future Research**: Our detailed classification of false positives can guide future research in program verification tools by highlighting the programming idioms encountered in real code and identifying which ones are crucial for precise and useful analysis.

### Types of False Positives and Their Frequency
The table below summarizes the types of false positives generated by CQUAL, their frequency, and whether they indicate code that could be simplified or improved.

| Source                      | Frequency | Useful?   | Fix Suggestion                               |
|-----------------------------|-----------|-----------|----------------------------------------------|
| User flag                   | 50        | Maybe     | Pass two pointers instead of a user flag      |
| Address of array            | 24        | Yes       | Don’t take the address of arrays              |
| Non-subtyping               | 20        | No        | Enable subtyping                             |
| C type misuse               | 19        | Yes       | Declare explicit, detailed types              |
| Field unification           | 18        | No        | None                                         |
| Field update                | 15        | No        | None                                         |
| Open structure              | 5         | Yes       | Use C99 open structure support               |
| Temporary variable          | 4         | Yes       | Don’t reuse temporary variables              |
| User-kernel assignment      | 3         | Yes       | Set user pointers to NULL                    |
| Device buffer access        | 2         | Maybe     | None                                         |
| FS Tricks                   | 2         | Maybe     | None                                         |

### Methodology
To determine the cause of each warning, we attempted to modify the kernel source code to eliminate the warning while preserving its functionality. We documented the nature of our changes and their effect on CQUAL’s output. The total number of false positives is less than 264 because fixing one false positive can often eliminate several others simultaneously. The extended version of this paper provides a detailed explanation of each type of false positive and how to avoid them.

### Simple Rules for Reducing False Positives
Based on our analysis, we have developed two simple rules that can help programmers write verifiably secure code. These rules are not specific to CQUAL and can reduce the false positive rate of any data-flow oriented program analysis tool.

**Rule 1: Give separate names to separate logical entities.**
- **Example**: If a temporary variable sometimes holds a user pointer and sometimes a kernel pointer, replace it with two temporary variables, one for each logical use. This makes the code clearer and, with a modern compiler, does not increase memory usage. Reusing temporary variables may have improved performance in the past, but now it just makes the code more confusing and harder to verify automatically.

**Rule 2: Declare objects with C types that closely reflect their conceptual types.**
- **Example**: If a variable is conceptually a pointer, declare it as a pointer, not as a `long` or `unsigned int`. We observed code where a local variable was declared as an `unsigned long` but cast to a pointer every time it was used. This is an extreme example, but subtler applications of these rules are discussed in the extended version of this paper.

Following these rules is straightforward and has minimal impact on performance, but can significantly reduce the number of false positives generated by tools like CQUAL. By making a few simple changes, kernel programmers could eliminate all but 37 of the false positives we observed, resulting in a fourfold reduction.

## Related Work
CQUAL has been used in various security-related analyses. For instance, Shankar et al. used CQUAL to find format string bugs in security-critical programs, and Zhang et al. used it to verify the placement of authorization hooks in the Linux kernel. Other tools, such as Sparse by Linus Torvalds, also use type qualifiers to find user/kernel pointer bugs. However, Sparse requires extensive annotations and type qualifier casts, which can render its results unsound. MECA, developed by Yang et al., aims for a very low false positive rate at the cost of missing some bugs, while CQUAL aims to detect all bugs, even if it increases the false positive rate.

## Conclusion
We have demonstrated that type qualifier inference is an effective technique for finding user/kernel bugs and has the potential to contribute to the formal verification of security properties in critical software. We have also described refinements to the basic type inference methodology that significantly reduce the number of false positives generated by CQUAL, enabling it to analyze complex software systems like the Linux kernel. Additionally, we have analyzed the false positives generated by CQUAL and developed simple rules that programmers can follow to write verifiable code. These rules are applicable to other program analysis tools as well.

Our research suggests several directions for future work, including improving structure-handling, adding flow-sensitivity, and investigating alternative programming idioms that enable clear and verifiable code. Our findings on Linux 2.4.20 and 2.4.23 suggest that widely deployed, mature systems may have more latent security holes than previously thought. Tools like CQUAL can help measure the number of bugs in software, identify development habits that produce exceptionally buggy or secure software, and assist users in evaluating the risks of deploying software.

## Availability
The extended version of this paper is available at [http://www.cs.berkeley.edu/~rtjohnso/](http://www.cs.berkeley.edu/~rtjohnso/). CQUAL is open-source software hosted on SourceForge and can be accessed at [http://www.cs.umd.edu/~jfoster/cqual/](http://www.cs.umd.edu/~jfoster/cqual/).

## Acknowledgements
We thank Jeff Foster for creating CQUAL and assisting us in using and improving it. We also thank John Kodumal for implementing an early version of polymorphism in CQUAL and for his theoretical contributions. We are grateful to the anonymous reviewers for their valuable suggestions.