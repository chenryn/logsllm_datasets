WebRTC。WebRTC是一套W3C标准，支持原生(无插件)浏览器应用，如语音和视频聊天。设备可通过枚举支持的WebRTC功能和媒体设备（如麦克风和网络摄像头）来进行指纹识别。对于哪些类型的设备可以在未经用户许可的情况下进行枚举，各浏览器的做法不同。WebRTC还公开了分配给设备上所有网络接口的IP地址，包括由用户分配的私有IP地址、NAT路由器或VPN。
（g）
密码自动填充。JavaScript可以用来检测密码是用户输入，还是被浏览器或密码管理器自动填充。使用事件监听器来检测用户是否在密码字段中输入字符，为keydown和keypress分配一个事件监听器，由于事件是由物理按键触发的，缺失则表明密码是通过自动填充输入。
第二类：基于设备行为推断。不仅可以通过浏览器提供信息，还可在浏览器上执行特定JavaScript代码观察效果，如测量执行时间或分析输出来收集设备的信息，包括：
（a）
HTML5画布指纹。通过JavaScript在用户端执行HTML5画布渲染各种文本和图形，并向服务器发送位图图像的哈希。不同软/硬件设备生成的图像有细微不同，例如字体和抗锯齿会随操作系统和显卡驱动变化，表情符号随操作系统和手机厂商变化。使用预定义字体列表渲染文本，可以进行字体检测。使用WebGL渲染复杂的图形，可进一步提供指纹多样性。
（b） 系统性能。在一系列计算密集型操作上运行JavaScript引擎基准，对运行时间进行测量，可推断设备性能特点；
（c） 硬件传感器。移动设备传感器可以根据制造和工厂校准变化进行指纹识别，例如，测量手机加速度计的校准误差（通过JavaScript访问）或扬声器-麦克风系统的频率响应；
（d）
滚轮指纹。监听WheelEvent事件，可通过JavaScript推断用户设备，当用户使用鼠标滚轮或触摸板滚动时，就会触发该事件。鼠标滚轮在触发时以固定增量滚动页面，触摸板则以不同增量滚动。测量文档的滚动速度可以显示用户滚动行为的信息和操作系统的滚动速度值。
（e）
CSS特征检测。浏览器厂商和版本可通过检测CSS特征来推断，因为各浏览器不统一。在目标元素上设置所需的CSS属性，然后查询该元素判断是否应用更改。这个向量可从user-agent获取。如果设备指纹已经通过另一个向量提取了user-agent，那么这里也用来测试信息是否被篡改。
（f）
JavaScript标准的一致性。浏览器对JavaScript标准的符合性不同，各种JavaScript一致性测试要数千个测试用例，加起来可能需要30多分钟。Mulazzani等人开发了一种技术，方法是使用决策树来选择一个非常小的子集，这些子集的运行时间可以忽略不计，可用来验证user-agent中报告的浏览器供应商和版本。
（g） URL scheme handler。有些浏览器在访问本地资源时使用了非标准方案。例如，res://在Microsoft
IE中是存储在Windows系统目录下DLL文件，Firefox中的moz-icon://、jar:resource://和resource://公开了内置浏览器和操作系统资源。因此网站可以创建HTML图片标签，将源地址设置为本地资源，并使用onerror事件处理来检测图片是否加载。通过迭代不同浏览器或操作系统版本预加载资源列表，向量可以列举。这算是一个替代方案，因为很多新版本浏览器出于隐私考虑，不再支持。
（h） 显卡RAM检测。GPU可用RAM(VRAM)数量，虽然不能通过WebGL
API明确获得，但可以通过反复分配纹理来推断，直到VRAM满了，之后纹理开始被交换到系统主内存。通过每次纹理分配的时间长度，并记录观察到的较大峰值，可推断GPU
VRAM已达到充分利用的状态。在这之后，浏览器可以继续分配纹理，直到出现OUT OF MEMORY错误。
（i）
字体检测。虽然不能通过JavaScript枚举已安装的字体，但可以用预定义列表中的字体来格式化文本，产生的文本尺寸可以区分不同的字体渲染设置，因此推断每种字体的存在。
（j） 音频处理。HTML5 AudioContext
API通过提供音频播放的实时频域和时域分析接口，允许创建音频可视化。和HTML5画布指纹一样，音频处理因浏览器和软/硬件不同而不同。
第三类：浏览器扩展插件。包括：
（a）
浏览器插件指纹。浏览器插件，如Java、Flash和Silverlight，可以被查询(通过嵌入网页插件对象)，以采集系统信息，而且比JavaScript提供的信息更详细。例如，Flash提供了完整的操作系统内核版本，Flash和Java插件都允许枚举所有系统字体，甚至系统字体的列举顺序在不同的系统中也会有所不同，增加了指纹的可区分性。
（b）
浏览器扩展指纹。如果安装了NoScript扩展(默认情况下，除了用户白名单上外，所有网站都禁用JavaScript)，网站可以尝试从一大批网站(如Alexa
Top
1000)加载脚本，检测哪些网站在用户白名单上。同样，广告拦截器也可以通过嵌入一个虚假广告来检测，比如一个隐藏的图片或iframe，其源URL中包含广告拦截器常用的黑名单词（比如
“广告”），然后JavaScript可以检测假广告是否被加载，并将结果返回服务器。其他扩展也有不同方法进行指纹识别，比如一些浏览器扩展会添加自定义HTTP
headers。
（c）
系统指纹插件。网站可能会安装专门的插件，例如早年的网上银行，这样可提供更强大指纹信息，包括硬件标识符、操作系统安装日期和已安装驱动程序版本，不过这种插件现在一般会被杀毒软件报出。
第四类：网络和协议级技术。前面几类涉及在客户端上访问API，而网络和协议层面的技术也可给设备打指纹，包括：
（a）
IP地址。众所周知IP可用来做判断，也可查询WHOIS获得更多信息，比如所在自治系统和注册组织名称。虽然IP地址比AS号更精确，但AS更稳定，在校验用户位置时可以作为交叉检查。
（b） Geolocation。地理位置可以通过几种机制来确定，浏览器通常会暴露API(例如通过navigator
BOM对象)，通过这些API，可以请求用户允许获取当前位置(GPS硬件、蜂窝三角、WiFi信息或用户提供的信息)。基于网络的机制也包括基于IP地址的WHOIS查询、基于路由数据的推理以及基于地理定位。
（c）
主动式TCP/IP协议栈指纹。由于网络和操作系统TCP/IP实现之间的差异，可以通过向设备发送针对性探针并分析响应包头字段(如RTT、TCP初始窗口大小)或链路特征(如MTU、延迟)来确定指纹。这种方法与浏览器无关，可以在任何互联网主机使用。可以理解为Nmap之类的扫描，具有主机发现、端口扫描和操作系统检测能力，可以发送各种探测数据包，通过内置数据库中的启发式方法来区分成千上万的系统。这种向用户端发送特殊的探测数据包，称之为主动指纹，但可能会触发防火墙、IDS警报。
（d）
被动TCP/IP协议栈指纹。被动指纹是侵入性较低的方法，但效果也较弱，通过嗅探网络通信，但使用主动指纹的启发式方法来识别主机，例如p0f这种工具。被动方法是比较合适的指纹向量，因为对现有header分析不需要制造新数据包，不具有侵入性。
（e） 协议指纹。协议指纹用于更高级别的协议，用来区分浏览器软件、版本、配置，例如HTTP header、user-agent、支持语言、字符编码列表以及DoNotTrack参数。此外，浏览器的TLS库可以用ClientHello数据包从协商参数的握手序列中获得指纹，相关信息包括用户端TLS版本、支持的密码套件、它们的顺序、压缩选项和扩展列表(相关参数如椭圆曲线参数)。
（f）
DNS解析。很多用户默认DNS解析器是运营商配置的，但少数用户可能会设置其他DNS，如阿里云或OpenDNS。于是就产生了一种比较骚的方法，服务器向浏览器发送一份文件，文件包含一份随机生成子域名，但该域名的权威DNS服务器由网站所有者控制。当用户端试图解析时，网站的DNS服务器会收到来自用户端DNS解析请求，然后将随机生成子域与最初为用户生成的进行关联。
（g） 时钟偏移。可以被动分析TCP时间戳，来测量用户时钟偏移—用户时钟和真实时间的偏离率。
（h） 计算NAT后面的主机。Bellovin最早提出来计算NAT后面的主机数量，通过被动分析IPv4
ID字段(用于片段重构)来计算NAT后面的主机数量。Kohno则又提出使用时钟偏移来区分NAT后面的主机。这些技术可以通过上层信息来增强，例如在指纹中加入从同一IP地址访问的其他用户账户。
（i） 广告拦截器检测。虽然广告拦截器检测可以用JavaScript在用户端进行，但也可以在服务器监控用户端是否请求了虚假广告。