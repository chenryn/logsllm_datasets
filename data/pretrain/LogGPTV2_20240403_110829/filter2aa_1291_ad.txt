k
ets
can
b
e
dropp
ed
when
their
pac
k
ets
are
not
resen
t
Also
b
ecause
b
ytes
are
ac
kno
wledged
rather
than
pac
k
ets
it
is
often
not
clear
whether
a
giv
en
pac
k
et
got
through
further
complicating
the
question
of
whether
a
bit
w
as
deliv
ered

TCP
Sp
ecic
Challenges
Rewriting
TCP
timestamps
presen
ts
some
additional
c
hallenges
o
v
er
and
ab
o
v
e
a
standard
implemen
tation
of
the
proto
col
from
Section

Timestamps
m
ust
b
e
monotonically
increasing
Timestamps
m
ust
reect
a
reasonable
progression
of
time
And
when
timestamps
are
rewritten
it
can
cause
the
nonce
in
the
rest
of
the
pac
k
et
to
c
hange
Timestamps
m
ust
b
e
monotonically
increasing
Because
timestamps
are
to
reect
the
actual
passing
of
time
no
legitimate
system
w
ould
pro
duce
earlier
timestamps
for
later
pac
k
ets
W
ere
this
done
it
could
b
e
observ
ed
b
y
c
hec
king
the
in
v
arian
t
that
a
pac
k
et
with
a
larger
sequence
n
um
b
er
in
a
stream
also
has
a
timestamp
greater
than
or
equal
to
other
pac
k
ets
in
that
stream
When
rewriting
timestamps
w
e
m
ust
honor
this
in
v
arian
t
As
a
result
if
presen
ted
with
the
timestamp

and
needing
to
send
the
bit
w
e
m
ust
rewrite
to

rather
than

Additionally
w
e
m
ust
mak
e
sure
than
an
y
follo
wing
pac
k
et
has
a
timestamp
of
not
less
than

ev
en
if
the
correct
timestamp
migh
t
still
b
e

Timestamps
m
ust
reect
a
reasonable
progression
of
time
Though
times
tamps
are
implemen
tation
dep
enden
t
and
their
lo
w
order
bits
random
the
pro
gression
of
the
higher
order
bits
m
ust
reect
w
all
clo
c
k
time
in
most
implemen
tations
Because
an
adv
ersary
can
b
e
presumed
to
kno
w
the
implemen
tation
of
the
unmo
died
TCP
stac
k
they
are
a
w
are
of
what
the
correct
v
alues
of
times
tamps
are
In
order
to
send
out
pac
k
ets
with
mo
died
timestamps
and
k
eep
timestamps
monotonically
increasing
streams
m
ust
b
e
slo
w
ed
so
that
the
times
tamps
on
pac
k
ets
are
v
alid
when
they
are
sen
t
Th
us
w
e
can
b
e
though
t
of
as
not
rewriting
timestamps
but
as
dela
ying
pac
k
ets
As
an
additional
c
hallenge
b
ecause
w
e
m
ust
only
increase
timestamps
w
e
will
sometimes
cause
the
high
order
bits
of
the
timestamp
to
c
hange
T
o
decrease
the
c
hance
of
nonce
rep
etition
w
e
include
the
higherorder
bits
of
the
timestamp
in
the
nonce
When
incremen
ting
timestamps
these
bits
ma
y
c
hange
and
the
nonce
will
c
hange
When
the
nonce
c
hanges
w
e
will
ha
v
e
to
recompute
n
and
k
and
th
us
ma
y
ha
v
e
to
further
incremen
t
the
timestamp
Ho
w
ev
er
at
this
p
oin
t
the
lo
w
bit
of
the
timestamp
will
b
e
and
so
incremen
ting
will
not
c
hange
the
nonce
This
algorithm
can
b
e
seen
in
Figure


Cho
osing
P
arameters
for
TCP
F
or
a
c
hec
ksum
of
size
n
bits
a
collision
can
b
e
exp
ected
one
time
in

n
As
suming
a
sustained
pac
k
et
rate
of
ten
pac
k
ets
p
er
second
an
upp
er
b
ound
w
e
will
see
a
collision
ev
ery

n

seconds
W
e
selected
our
c
hec
ksum
to
b
e
a
m
ultiple
of
eigh
t
and
a
p
o
w
er
of
t
w
o
to
k
eep
the
c
hec
ksum
b
yte
aligned
and
to
mak
e
it
consisten
t
with
standard
hash
functions
A
c
hec
ksum
size
of

bits
is
clearly
to
o
small
as
it
results
in
collisions
ev
ery
t
w
o
hours
A

bit
c
hec
ksum
raises
this
time
to

y
ears
whic
h
w
e
deem
to
b
e
an
acceptable
without
making
the
amoun
t
of
data
p
er
blo
c
k
to
o
small

Implemen
tation

Sending
Messages
Our
sender
is
implemen
ted
on
top
of
the
Lin
ux
k
ernel
The
curren
t
implemen
tation
of
a
sender
is
a
minor
source
mo
dication
to
pro
vide
a
ho
ok
to
rewrite
timestamps
and
a
k
ernel
mo
dule
to
implemen
t
the
rewrite
pro
cess
to
trac
k
the
curren
t
transmission
and
to
pro
vide
access
to
the
co
v
ert
c
hannel
messaging
to
applications
The
curren
t
system
only
pro
vides
one
c
hannel
to
one
host
at
a
time
but
generalizing
to
m
ultiple
c
hannels
should
not
b
e
dicult
W
e
selected
SHA
as
the
hash
It
is
a
standard
hash
function
b
eliev
ed
to
b
e
collision
resistan
t
and
onew
a
y
Source
is
freely
a
v
ailable
whic
h
made
it
ev
en
more
attractiv
e
W
e
needed
to
put
our
o
wn
in
terface
on
SHA
and
mo
dify
the
co
de
so
that
it
could
b
e
used
in
b
oth
the
k
ernel
co
de
and
in
the
receiving
application
The
basic
algorithm
is
for
eac
h
pac
k
et
compute
the
cipher
text
bit
to
b
e
included
in
that
pac
k
et
according
to
Figure

Then
the
timestamp
is
rewrit
ten
according
to
the
metho
d
describ
ed
in
Figure

This
is
a
simple
function
implemen
ting
the
rewriting
algorithm
describ
ed
in
Section

This
algorithm
can
b
e
seen
in
the
pseudo
co
de
of
Figure

particularly
in
the
recursiv
e
call
to
EncodeP
a
cket
T
o
enco
de
a
pac
k
et
the
timestamp
is
incremen
ted
un
til
it
has
the
prop
er
v
alue
to
b
e
sen
t
When
a
pac
k
et
is
ready
to
b
e
sen
t
the
o
ccupation
n
um
b
er
for
the
bit
in
the
pac
k
et
is
increased
Occupation
n
um
b
ers
are
trac
k
ed
in
the
arra
y
T
ransmitCoun
t
If
the
minim
um
o
ccupation
n
um
b
er
of
ev
ery
bit
in
the
blo
c
k
is
ev
er
higher
than
the
required
o
ccupation
n
um
b
er
the
blo
c
k
is
presumed
receiv
ed
and
the
next
blo
c
k
b
egins
transmission

Receiving
Messages
The
receiving
pro
cess
is
designed
to
b
e
p
ortable
and
en
tirely
lo
cated
in
user
space
It
is
m
uc
h
simpler
than
the
sender
side
and
the
primary
in
teresting
part
is
Start
LSB of timestamp
=
cipher text bit?
Increment
timestamp
Recompute
cipher text bit
Done
Did the high order
bits change?
NO
YES
YES
NO
Fig

Rewriting
Timestamps
SHA1
Index
KeyBit
Plain Text Bit
Cipher Text Bit
Secret Key
Packet Header
Hash of Headers and Key
bit 8
bits 0−7
Current Message Block
Fig

Sender
EncodeP
a
cketP
ac
k
et
P
TimeStamp
T
GetHeadersP
P
ac
k
etHeader
SHAP
ac
k
etHeaders
Index
Curren
tBlo
c
kIndex
PlainT
extBit
SHAP
ac
k
etHeaders
KeyBit
PlainT
extBit
KeyBit
CipherT
extBit
if
T

CipherT
extBit
then
T

T
if
T
then
return
Enco
deP
ac
k
etP
T
end
if
T
ransmitCoun
tIndex
if
Minim
umT
ransmitCoun
t
Minim
umT
ransmitCoun
t
then
NextBlo
c
k
Curren
tBlo
c
k
end
if
end
if
SendP
ac
k
etP
T
Fig

Pseudo
co
de
for
EncodeP
a
cket
Secret Key
Packet Header
SHA1
Hash of Headers and Key
Index
Plain Text Bit
Current Message Block
KeyBit
Cipher Text Bit
Timestamp
bits 0−7
bit 8
Fig

Receiv
er
ReceiveP
a
cketP
ac
k
et
P
TimeStamp
T
GetHeadersP
P
ac
k
etHeader
SHAP
ac
k
etHeaders
Index
T
CipherT
extBit
SHAP
ac
k
etHeaders
KeyBit
CipherT
extBit
KeyBit
PlainT
extBit
PlainT
extBit
Curren
tBlo
c
kIndex
if
V
alidateChec
ksumCurren
tBlo
c
k
then
OutputBlo
c
k
end
if
Fig

Pseudo
co
de
for
ReceiveP
a
cket
determining
when
w
e
are
done
with
a
blo
c
k
and
the
b
oundaries
b
et
w
een
dieren
t
data
blo
c
ks
P
ac
k
ets
are
collected
b
y
the
receiv
er
using
the
libpcap
in
terface
to
the
Berk
e
ley
P
ac
k
et
Filter
This
library
is
part
of
the
standard
utilit
y
tcp
dump
and
has
b
een
p
orted
to
a
wide
v
ariet
y
of
platforms
Our
receiv
er
is
simple
C
using
only
libpcap
and
our
SHA
library
Unlik
e
the
sender
it
is
not
tied
to
the
Lin
ux
platform
and
will
probably
run
an
ywhere
that
libpcap
will
run
The
receiv
er
main
tains
a
buer
initialized
to
all
zero
es
whic
h
represen
ts
the
curren
t
data
blo
c
k
to
b
e
deco
ded
As
pac
k
ets
are
receiv
ed
the
receiv
er
computes
the
hash
of
the
pac
k
et
headers
concatenated
with
the
shared
secret
He
then
X
ORs
bit

of
the
hash
with
the
lo
w
order
bit
of
the
timestamp
of
the
pac
k
et
he
places
the
result
in
the
buer
at
the
place
indicated
b
y
the
index
In
actualit
y
the
data
blo
c
k
con
tains
less
than
BLOCKSIZE
bits
of
data
App
ended
to
it
is
a
c
hec
ksum
of
the
data
The
purp
ose
is
the
c
hec
ksum
is
to
inform
the
receiv
er
when
he
has
receiv
ed
the
en
tire
v
alid
blo
c
k
and
should
output
plain
text
and
allo
cate
a
new
blo
c
k
buer
The
receiv
er
calculates
this
hash
ev