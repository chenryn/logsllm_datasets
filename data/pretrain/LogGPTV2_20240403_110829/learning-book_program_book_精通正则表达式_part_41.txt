---
## Page 267
常见优化措施
241
不幸的是，这并不常见（而且愚蠢）（注4），虽然在极少数情况下这样做可以节省大量的时
间，但其他情况下速度降低的代价比这高得多。
优化各有不同
Everyone ‘s Lunch is Different
在讲解各种优化措施时，请务必记住一点“优化各有不同（everyone'slunchis different）”。
虽然我尽量使用简单清晰的名字来命名每种措施，但不同的引擎必然可能以不同的方式来
优化。对某个正则表达式进行细微的改动，在某个实现方式中可能会带来速度的大幅提升，
而在另一个实现方式中大大降低速度。
正则表达式的应用原理
The Mechanics of Regex Application
我们必须先掌握正则表达式应用的店本知识，然后讲解先进系统的优化原理及利用方式。
之前已经了解了回溯的细节，在本节我们要进行更全面地学习。
正则表达式应用到目标字符串的过程大致分为下面几步：
1.正则表达式编译检查正则表达式的语法正确性，如果正确，就将其编译为内部形式
(internalform)。
3.元素检测引擎开始测试正则表达式和文本，依次测试正则表达式的各个元素（comp
onent)，如第4章所说的那样。我们已经详细考察了NFA的回溯，但是还有儿点需要补
充：
相连元素，例如Subject中的's、u、b、'ji、ej等等，会依次尝试，只有当某个
元素匹配失败时才会停止。
量词修饰的元素，控制权在量词（检查量词是否应该继续匹配）和被限定的元素（测
试能否匹配）之间轮换。
控制权在捕获型括号内外进行切换会带来一些开销。括号内的表达式匹配的文本必
须保留，这样才能通过S1来引用。因为一对括号可能属于某个回溯分支，括号的状
态就是用于回溯的状态的一部分，所以进人和退出捕获型括号时需要修改状态。
注4：事实上，我曾在测试中使用b\Bi来保证正则表达式的某个部分匹配失败。例如，我可能
把\b\B；橘入..（thisithisother)…标记的状态中，保证第一个多选分支的失败。
现在，当我使用“必须失败”的元素时，我使用（？！），你可以在第333页找到这个与Per
相关的例子。
---
## Page 268
242
第6章：打造高效正则表达式
4.寻找匹配结果如果找到一个匹配结果，传统型NFA会“锁定”在当前状态，报告匹配
成功。而对POSIXNFA来说，如果这个匹配是迄今为正最长的，它会记住这个可能的匹
配，然后从可用的保存状态继续下去。保存的状态都测试完毕之后返回最长的匹配。
5.传动装置的驱动过程如果没有找到匹配，传动装置就会驱动引擎，从文本中的下一个字
符开始新轮的尝试（回到步骤3）。
尝试都失败了，就会报告匹配彻底失败。
下面几节讲解高级的实现方式如何减少这些处理，以及如何应用这些技巧。
应用之前的优化措施
Pre-Application Optimizalions
优秀的正则引擎实现方式能够在正则表达式实际应用之前就进行优化，它有时候甚至能迅
速判断出，某个正则表达式无论如何也无法匹配，所以根本不必应用这个表达式。
编译缓存
第2章的E-mail处理程序中，用于处理header各行的主循环体中是这样的：
while(….)(
if（Sline =~ m/\e*$/）..
if (Sline =~ m/^Subject:(. *)/)
if ($line =~ m/^Date:（.*)/)
if (S1ine =~ m/^Reply-To:(\S+)/)
if（$line=~m/From:（\S+）\（（[^（)]*)\)/)
正则表达式使用之前要做的第一件事情是进行错误检查，如果没有问题则编译为内部形式。
编译之后的内部形式能用来检查各种字符事，但是这段程序的情况如何？显然，每次循环
都要重新编译所有正则表达式，这很浪费时间。相反，在第一次编译之后就把内部形式保
存或缓存下来，在此后的循环中重复使用它们，显然会提高速度（只是要消耗些内存）。
具体做法取决于应用程序提供的正则表达式处理方式。93页已经说过，有3种处理方式：
集成式、程序式和面向对象式。
---
## Page 269
常见优化措施
243
集成式处理中的编译缓存
Perl和awk使用的就是集成式处理方法，非常容易进行编译缓存。从内部来说，每个正则
表达式都关联到代码的某一一部分，第一次执行时在编译结果与代码之间建立关联，下次执
行时只需要引用即可。这样最节省时间，代价就是需要一部分内存来保存缓存的表达式。
DFA，Tc1与手工调校正则表达式
本章中介绍的大部分优化措施并不适用于DFA。第242页介绍的编译寿却适用于所
有的引擎，但是本章讨论的所有手工调校都不适用于DFA。第4章已经澄清，逻辑上
相等的正则表达式'thislthati和'th（islat）s，对DFA来说是等价的。之所以要写本
章，是因为它们对NFA来说不相等。
HenrySpencer（r88）为Tcl专门开发的，它成功地融合了DFA和NFA的优点。在
2000年4月的Usenetposting中，Henry这样写到：
总的来说，与传统的正则引擎相比，Tcl的引擎对正则表达式的具体形式的敏感
度要低得多。无论正则表达式写成怎么样，该快的就快，该慢的就慢。传统的正
财表达式手工优化在这里不适用。
Henry的Tcl正则引擎是一大进步。如果其中的技术流行开来，本章的许多内容就毫无
意义了。
变量插值功能（variableinterpolation，即将变量的值作为正则表达式的一部分）可能会给缓
存造成麻烦。例如对m/^Subject：\Q$DesiredSubject\E\s*$/来说，每次循环中正则
表达式的内容可能会发生改变，因为它取决于插值变量，而这个变量的值可能会变化。如
果每次都会不同，那幺正则表达式每次都需要编译，完全不能重复利用。
尽管正则表达式可能每次循环都会变化，但这并不是说任何时候都需要重新编译。折中的
优化措施就是检查插值后的结果（也就是正则表达式的具体值），只有当具体值发生变化时
SL
---
## Page 270
244
第6章：打造高效正则表达式
才重新编译。不过，如果变化的几率很小，大多数时候就只需要检查（而不需要编译），优
化效果很明显。
程序式处理中的编译缓存
在集成式处理中，正则表达式的使用与其在程序中所处的具体位置相关，所以再次执行这
段代码时，编译好的正则表达式就能够缓存和重复使用。但是，程序式处理中只有通用的
“应用此表达式”的函数。也就是说，编译形式并不与程序的具体位置相连，下次调用此
函数时，正则表达式必须重新编译。从理论上来说就是如此，但是在实际应用中，禁止尝
试缓存的效率无疑很低。相反，优化通常是把最近使用的正则表达式模式（regexpattern）
保存下来，关联到最终的编译形式。
调用“应用此表达式”函数之后，作为参数的正则表达式模式会与保存的正则表达式相比
较，如果存在于缓存中，就使用缓存的版本。如果没有，就直接编译这个正则表达式，将
其存入缓存（如果缓存有容量限制，可能会替换一个旧的表达式）。如果缓存用完了，就必
须放弃（thrownout）一个编译形式，通常是最久未使用的那个。
GNUEmacs的缓存能够保存最多20个正则表达式，Tcl能保存30个。PHP能保存四千多
个。.NETFramework在默认情况下能保存15个表达式，不过数量可以动态设置，也可以禁
止此功能（432）。
缓存的大小很重要，因为如果缓存装不下循环中用到的所有正则表达式，在循环重新开始
时，最并始的正则表达式会被清除出缓存，结果每个正则表达式都需要重新编译。
面向对象式处理中的编译缓存
在面向对象式处理中，正则表达式何时编译完全由程序员决定。正则表达式的编译是用户
通过NewRegex、re.compile和Pattern.compile（分别对应.NET、Python和java.util.
regex）之类的构造函数来进行的。第3章的简单示例对此做了介绍（从第95页开始），编
译在正则表达式实际应用之前完成，但是它们也可以更早完成（有时候可以在循环之前，
或者是程序的初始化阶段），然后可以随意使用。在第235、237和238页的性能测试中体
现了这一点。
在面向对象式处理中，程序员通过对象析构函数抛弃（thrownaway）编译好的正则表达式。
---
## Page 271
常见优化措施
245
及时抛弃不需要的编译形式能够节省内存。
预查必须字符/子学符串优化
级”的操作，所以某些系统会在编译阶段做些额外的分析，判断是否存在成功匹配必须的
字符或者字符串。在实际应用正则表达式之前，在目标字符串中快速扫描，检查所需的字
符或者字符串一一如果不存在，根本就不需要进行任何尝试。
或者使用Boyer-Moore搜索算法（这是一种很快的文件检索算法，字符串越长，效率越高）。
没有采用Boyer-Moore算法的程序进行逐个字符检查也可以提高效率。选择自标字符串中
不太可能出现的字符（例如‘Subject：’中的‘t’之后的‘：'）能够进-一步提高效率。
正则引擎必须能识别出，^Subject：·（.*）的一部分是固定的文本字符串，对任意匹配来说，
识别出thisithatlotheri中‘th’是必须的，需要更多的工夫，而且大多数正则引擎不
会这样做。此问题的答案并不是黑白分明的，某个实现方式或许不能识别出‘th”是必须
的，但能够识别出‘h’和‘t’都是必须的，所以至少可以检查一个字符。
不同的应用程序能够识别出的必须字符和字符事有很大差别。许多系统会受到多选结构的
干扰。在这种系统中，使用'th（islat）i的表现好于thisithat)。同样，请参考第247页
的“开头字符/字符组/子串识别优化”。
长度判断优化
^Subject：·（.*）能匹配文本的长度是不固定的，但是至少必须包含9个字符。所以，如
果目标字符事的长度小于9则根本不必尝试。当然，需要匹配的字符更长优化的效果才更
明显，例如：\d（79）：（至少需要81个字符）。
请参见第247页的“长度识别传动优化”。
---
## Page 272
246
第6章：打造高效正则表达式
通过传动装置进行优化
OptinizationswifhtheTransmission
即使正则引擎无法预知某个字符串能否匹配，也能够减少传动装置真正应用正则表达式的
位置。
字符串起始/行锚点优化
配，所以只需要在这些位置应用即可。
在“预查必须字符/子字符串优化”中提到，正则引擎必须判断对某个正则表达式来说有哪
些可行的优化，在这里同样有效。任何使用此优化的实现方式都必须能够识别：如果
^（thislthat）匹配成功，必须能够匹配，但许多实现方式不能识别“this|^thati。此
时，用~（this|that）或者（?：thislthat）能够提高匹配的速度。
同样的优化措施还对A有效，如果匹配多次进行，对\G也有效。
隐式锚点优化
能使用此种优化的引擎知道，如果正则表达式以.*或".+开头，而且没有全局性多选结构
-节的“字符串起始/行锚点优化”，节省大量的时间。
更聪明的系统能够认识到，即使开头的".*或.+在括号内，也可以进行同样的优化，但是
在遇到捕获括号时必须小心。例如，（.+)X\1期望匹配的是字符串在‘X’两侧是相同的，
添加就不能匹配‘1234x2345’（注5）。
字符串结束/行锚点优化
这种优化遇到末尾为'$或者其他结束锚点（129）的正则表达式时，能够从字符串末尾倒
数若干字符的位置开始尝试匹配。例如正则表达式regex（es）?$匹配只可能从字符串末尾
）
可能的字符。
注5：有趣的是，Perl的这个“优化过度”的bug，在10年里都无人关注，最后由Perl开发人员
JeffPinyan在2002年早期发现（并修正）。显然，（.+）X\1)之类的表达式并不常见、否则
这个bug就不会这么迟才被发现了。
注6：在这里，我说8个字符，而不是7个，因为在许多流派中，S1能够匹配字符串末尾的换行
符之前的位置（129）。
---
## Page 273
常见优化措施
247
并头字符/学符组/子串识别优化
达式的任何匹配必须以特定字符或文字子字符串开头），容许传动装置进行快速子字符事检
查，所以它能够在字符事中合适的位置应用正则表达式。例如，thislthat|other只能从
[ot的位置开始匹配，所以传动装置预先检查字符事中的每个字符，只在可能匹配的位
置进行应用，这样能节省大量的时间。能够预先检查的子串越长，“错误的开始位置”就越
少。
内嵌文字字符串检查优化
这有点类似初始字符串识别优化，不过更加高级，它针对的是在匹配中固定位置出现的文
字字符串。如果正则表达式是\b（perl1java）\.regex\.info\bi，那么任何匹配中都要有
.regex.info'，所以智能的传动装置能够使用高速的Boyer-Moore字符申检索算法寻找
.regex.info'，然后往前数4个字符，开始实际应用正则表达式。
一般来说，这种优化只有在内嵌文字字符串与表达式起始位置的距离固定时才能进行。因
符串与匹配文本起始位置的距离是不确定的（2个或4个字符）。这种优化同样也不能用于
\b（\w+）\.regex\.info\b)，因为（\w+）可能匹配任意数目的字符。
长度识别传动优化
此优化与245页的长度识别优化直接相关，如果当前位置距离字符串末尾的长度小于成功
匹配所需最小长度，传动装置会停止匹配尝试。
优化正则表达式本身
Optinizationsof theRegexItself
文字字符串连接优化
也许最基本的优化就是，引擎可以把abc当作“一个元素”，而不是三个元素“aJ，然后
是b，然后是'c”。如果能够这样，整个部分就可以作为匹配选代的-个单元，而不需要进
行三次迭代。
化简量词优化
约束普通元素一例如文字字符或者字符组一的加号、星号之类的量词，通常要经过优
---
## Page 274
248
第6章：打造高效正则表达式
化，避免普通NFA引擎的大部分逐步处理开销（step-by-stepoverhead)。正则引擎内的主循
环必须通用（general），能够处理引擎支持的所有结构。而在程序设计中，“通用”意味着
“速度慢”，所以此种优化把.*之类的简单量词作为一个“整体”，正则引擎便不必按照
通用的办法处理，而使用高速的，专门化的处理程序。这样，通用引擎就绕过（short-circuit）
了这些结构。
举例来说，.*和（？：.)*在逻辑上是相等的，但是在进行此优化的系统中，.*实际上更
快。举一些例子：在java.uti1.regex中，性能提升在10%左右，但是在Ruby和.NET中，
大概是2.5倍。在Python中，大概是50倍。在PHP/PCRE中，大概是150倍。因为Perl
实现了下一节介绍的优化措施，.*和（？：.）*的速度是一样的（请参考下一页的补充内容，
了解如何解释这些数据）。
消除无必要括号
如果某种实现方式认为"（？：.)*与.*是完全等价的，那么它就会用后者替换前者。
消除不需要的字符组
只包含单个字符的字符组有点儿多余，因为它要按照字符组来处理，而这么做完全没有必
要。所以，聪明的实现方式会在内部把.]转换为.1。
忽略优先量词之后的学符优化
尤其是对上文中“化简量词优化”的匹配优先限定结构来说，更是如此。另一个原因是，
如果忽略优先量词在捕获型括号之内，控制权就必须在括号内外切换，这样会带来额外的
开销。
所以这种优化的原理是，如果文字字符跟在忽略优先量词之后，只要引擎没有触及那个文
字字符，忽略优先量词可以作为普通的匹配优先量词来处理。所以，包含此优化的实现方
式在这种情况下会切换到特殊的忽略优先量词，迅速检测目标文本中的文字字符，在遇到
此文字字符之前，跳过常规的“忽略”状态。
此优化还有各种其他形式，例如预查一组字符，而不是特殊的一个字符（例如，检查【·"）