Application Platform）电路板的一行申口初始化代码即可。实现这个修改的补丁（kgdb-tuna
usb-serial.diff）和表10-1中配置的模板都包含在本章的补充材料中.可在http://www.wiley.com/go
androidhackershandbook下载。
编译内核请参照10.3节。将tuna_defconfig模板替换成材料中的tunakgdb_defconfig。
需要运行的命令如下：
dev:~/android/src/kerne1/omap $ make tunakgdb_defconfig
dev:/android/src/kernel/omap $ make -§ 6 : make modules
[..-]
[. . -]
在编译内核的同时，可以开始编译自定义RAM盘。需要编一个自定义的initrd.img来通过
ADB访问设备。要记住，GalaxyNexus的MicroUSB口现在被用作串口，所以USB上的ADB
服务无法使用。好在ADB可以通过设置service，adb，tcp，port系统属性来监听TCP端口，
相关命令如下所示：
dev:~/android/sre/kerne1/omap $ mkdir -p initrd &s cd $_
~ /andro1d/takju-jdq39 /boot . img
dev:-/android/src/kernel/omap/ Initrd $ abootimg-unpack-initrd
[..-】
dev:~/android/sre/kerne1/omap/initrd $ patch -p0  \
tcpadb-initrd.img
警告abootimg-pack-initrd 命令不会生成与Nexus 系列设备兼容的 initrd镜像，应当使
用ASOP仓库中system/core/cpio目录下的mkbootfs。这个工具会在AOSP镜像编译的
时候生成。
---
## Page 285
10.4调试内核
269
首先，从原厂 boot.img镜像中提取 initrd.img。然后使用abootimg-unpack-initrd 命令
解压缩 initrd.img，得到一个ramdisk 目录。接下来，为 init.rc打一个补丁来打开 TCP上的 ADB
（补丁见本章补充材料）。最后，将修改后的内容重打包成tcpadb-initrd.img。
最后一步就是编译内核，完成后执行一些熟悉的命令：
dev:~/android/sre/kerne1/omap/initrd $ mkbooting =-kerne1 \
Sut yooqpfx o- 5ut *pxatusqpeda xapues-- abeuz/oo/wre/uore/**
dev: ~/android/sre/kerne1/omap/initrd $ adb reboot bootloader
dev:~/android/sre/kerne1/omap/initrd $ fastboot flash boot kgdbboot .img
dev:=/android/sre/kernel/omap/initrd $ fastboot reboot
这时设备会重启，然后开始运行新的内核，并会启用TCP上的ADB。确保设备可以通过
Wi-Fi连接桌面环境，然后使用TCP上的ADB来连接设备，如下所示：
dev:~/android/sre/kernel/omap $ adb connect 10.0.0.22
dev:~/android/src/kernel/omap $ adb -s 10.0.0.22:5555 she11
connected to 10.0.0.22:5555
shel19android: / $
最后需要注意的是，这种配置方式会导致一些不正常的情况出现。当设备屏幕变暗或关闭时，
会发生两件事：Wi-Fi性能急剧下降和申口被禁用。更糖糕的是，保持屏幕被点亮的内置选项无
法使用。使用正常的设置菜单最多将屏幕变暗的等待时间设置为10分钟，还是不能满足需要。
串口线时，设备的电池不会充电。幸运的是，Google Play 中有一些应用能够让设备的屏幕永久
保持点亮。在设备启动后，选择一款这样的App非常有用。
2.准备主机
要实现调试设备的内核，目前只剩下配置主机的几个步骤了。准备设备的时候，已经在主机
上配置好了编译环境，生成了包含所有符号的内核二进制文件。在连接调试器之前，只需做最后
一件事。
配置内核时，设置内核命令来用串口达到两个目的。首先，通过配置kgdboc参数告诉内核：
KGDB使用串口。第二，通过配置androidboot.console参数告诉内核：串口是控制台。为
了区分这两种数据流，使用一个叫作 agent-proxy 的程序，可以在Limux Kemel的 Git 仓库
（git:/git.kemel.org/pub/scm/utils/kemel/kgdb/agent-proxy.git）下载。下面的命令展示了如何使用
agent-proxy:
dev:~/android/sre/kermel/omap $ /agent-proxy/agent-proxy 4440~4441 0 1
Agent Proxy 1.96 Started vith: 4440^4441 0 /dev/ttyUsB0.115200
Agent Proxy running. pid: 28314
dev:~/android/src/kerne1/omap $ nc -t -d 1ocalhost 4440 & sleep 1
[ 4364.177001] max17040 4-0036: online = 1 vce11 - 3896250 soc = 77 status =
[2]  28425
health = 1 temp = 310 charger status = 0
[ + + • ]
---
## Page 286
270第10章攻击内核
在后台运行agent-proxy，并将KGDB和控制台的流量分别分离至4440端口和4441端口。
配置好串口和波特率，就可以使用了。通过Netcat连接端口4440时，得到的就是控制台输出。
真棒！
3.连接调试器
现在所有的准备工作都已经完成，连接调试器的方法十分简单直接。下面的GDB脚本自动
化了这个步骤：
set remotebaud 115200
target remote :4441
执行arm-eabi-gdb，如下所示：
Reading symbo1s from /home/dev/androfd/sre/kerne1/omap/vmlinux...done.
dev:~/android/src/kerne1/omap $ azn-eabi-gdb -q -x kgdb-gdb -/vmlinux
[· . · ]
除了让GDB运行上面的脚本以外，还需要告诉GDB将二进制文件vmlinux作为可执行文件。
目的是告诉GDB从哪里获得内核的符号，以及如何找到对应的源代码。
GDB客户端这时候正在等待一些动作发生。如果希望取得控制权，可以在设备上使用root
权限运行如下命令：
rooteandroid:/ + echo g > /proc/sysrq-trigger
然后可以看到GDB客户端显示如下：
Program received signa1 SIGTRAP, Trace/breakpoint trap.
954
kgdb_breakpoint () at kernel/debug/debug_core.c:954
arch_kgdb_breakpoint () :
(gdb)
在此，就可以设置断点、查看代码、修改内核内存，等等。我们已经实现了交互式源代码级
的真机内核远程调试！
4.在模块中设置断点
本节介绍如何在“HelloWorld”模块中设置断点，作为内核调试的最后一个例子。在KGDB
中处理内核模块需要一些额外的步骤。模块加载后，查看加载位置：
rooteandroid:/data/local/tmp + echo 1 > /proc/sys/kernel/kptr_restrict
root9android: /data/1oca1/tmp + 1smod
ahh_he11owor1d_mod 657 0 - Live 0xbf010000
要看到模块地址，需首先降低kptr_restrict限制。然后通过使用1smod命令或查看
/proc/modules来列出所有加载模块。使用这个地址信息就可以让GDB找到相应的模块：
(gdb)add-symbo1fi1e drivers/ahh_hel1owor1d/ahh_be11owor1d_mod.ko 0xbf010000
add symbol cable from file *drivers/ahh_helloworld/ahh_helloworld_mod.ko* at
-text_addr - 0xbf010000
(gdb)x/1 0xbf010000
(y or n) y
0xbf010000 1
movr12,8p
---
## Page 287
10.5内核漏洞利用271
(gdb) 1 init_module
[..-]
12
Int init_module (void)
1.3
14
printk(KER3_INrO *4s: HELLO wORLD1941@#\,n*, _this_module .name) :
[-.-]
(gdb)break cleanup_module
Breakpoint 1 at 0xbf010034: E:1e drivers/ahh_he11owor1d/ahh_he1lowor1d_mod.c,
line 20.
(gdb) cont
GDB加载符号后就能知道模块的源代码。也可以使用源代码信息来设置断点。当模块被
unload时，断点会触发：
Breakpoint 1, 0xbt010034 In cleanup_module () at
drivers/ahh_he11owoxld/ahh_hel1owox1d_nod. c:20
0Z
1
不管选择何种方法，调试内核都是捕捉和利用漏润的必要步骤。无论是通过前溃dump进行
离线调试，还是使用交互式的在线调试，都能帮助研究人员或者开发者更加深入地理解当前发生
的问题。
10.5内核漏洞利用
代号“果冻豆”（JellyBean）的Android4.1在Android安全发展过程中是一个关键点。正如
第12章中讨论的，这个版本的发布使得用户空间的漏润利用更加困难。另外，Android团队下了
很大功夫才将SELinux引人平台。综合以上两点考虑，攻击Linux内核变成了很明确的选择。作
为攻击目标而言，Linux内核并不难以攻破。尽管有一些有效的防御措施，但是还有许多可以攻
击的地方。
在过去的10年里，有很多介绍内核漏洞利用的资源得到公开。在这些演讲稿件、博客、白
皮书和利用代码中，有一本书尤其突出：EnricoPerla和MassimilianoOldani合著的AGuide to
KernelExploitarion:Anacking rhe Core。这本书包含的内容很广，甚至涉及Linux 以外的内核，但
是并没有介绍ARM架构的相关主题。本节通过讨论典型的内核配置，引人Android设备中Linux
内核漏润的利用，并介绍几个漏洞利用案例。
10.5.1典型Android内核
对于不同的Android设备，其使用的Linux内核也不相同。这些差别包括内核版本号、配置
选项、和特定设备的驱动等。尽管存在差异，但也有许多共同点。本节描述Android设备中Linux
内核的差异和相似之处。
1.内核版本
Android设备使用的内核虽然有差别，但是主要分为4组：2.6.x、3.0.x、3.1.x和3.4.x。可以
认为这些特定的组别是设备的代数，例如第一代设备使用2.6.x内核，最新一代使用3.4.x内核。
---
## Page 288
272第10章攻击内核
豆（Android 4.1）设备，例如 2012年的 Nexus 7，使用的是3.1.x内核。搭载Android 4.2系统的
Nexus4是首次使用3.4.x内核的机型。尽管最新的Linux内核版本是3.12.但撰写本书的时候，
还没有Android设备使用3.4.x版本以上的内核。
2.配置
这些年来，Android 团队一直在修改Android设备的内核配置。Android开发者文档和 CDD
详细说明了这些配置。另外，兼容性测试套件（CTS）验证了一些符合要求的内核配置。例如，
对于较新的Android版本，CTS会检查两个特殊的配置选项：CONFIG_IKCONFIG和
CONFIG_MODULES。也许是基于安全考虑，这些配置必须被关闭。由于禁用了可加载模块的支持，
要想在获得roo4权限的手机内核空间中运行代码就变得非常困难。CTS也会检查内核配置嵌入的
选项是否被禁用，因为把内核配置文件编译进内核会通过CONFIG_PHYS_OFFSET泄露内核的基
址。这两个配置之外的检查选项会在第12章中介绍。如果深人查看大量设备内核配置的变动，
会有其他有趣的发现。
3.内核堆
堆内存和内核配置细节的相关度较高。Linux内核有许多内存分配的API，大多数都基于下
层的kma11oc。编译时，工程师必须在三种堆的实现中进行选择：SLAB，SLUB和SLOB。大
多数Android设备使用SLAB分配器，少数使用SLUB分配器。尽管没有Android设备使用 SLOB
分配器，但目前很难完全将其排除。
在内核地址空间中，堆分配有一些不确定性。内核堆的实际状态受到很多因素的影响。首先，
从启动到运行漏洞利用程序的这段时间内，堆内存的操作大部分是未知的。其次，从远程或较低
权限发起攻击，都意味着攻击者对于正在运行的操作有着很少的控制，所以堆很可能在利用程序
运行时受到影响。
从编程人员的角度来看，堆实现的细节并不是十分重要；但是对于利用程序开发者来说，这
些细节决定了发生的是可靠的代码执行利用，还是毫无价值的前溃。AGuidetoKerme/Exploitarion
和Phrack杂志的文章提供了关于SLAB和SLUB分配器的利用方法。此外，DanRosenberg在2012
年的Infiltrate会议上讨论了SLOB分配器的利用技术。其论文和幻灯片的标题为“堆的麻烦：攻
破Linux内核SLOB分配器“，随后发布在：http:/infiltratecon.com/archives.html。
4.地址空间布局
现代操作系统将虚拟地址空间分为内核空间和用户空间，分界线依具体设备而定。大部分
Android设备使用传统的3G划分方案，即内核使用位于高地址的1G空间（0xc0000000及以上），
用户空间使用位于低地址的3G空间（0xc0000000以下）。在大多数Linux系统中，包括所有的
Android设备，内核可以直接访问用户空间的内存。内核不仅可以读写内核空间的内存，而且可
以在其中执行代码。
本章之前提到，内核是一个单独的镜像，因此所有的全局符号都位于内存的静态地址中。利
用程序开发者可以利用这些位于静态地址中的全局符号，轻松开发出利用代码。另外，在ARM
的Linux内核中，除了近期发布的版本，大多数代码区是可读可写可执行的。最后，Linux内核大
---
## Page 289