if (all_data_received)
{
ExecuteTransaction(transaction);
}
else
{
// send interim response
}
EternalChampion Patch
SrvSmbTransaction/SrvSmbNtTransaction():
if (all_data_received)
{
transaction->Executing = TRUE;
ExecuteTransaction(transaction);
}
else
{
// send interim response
}
EternalRomance
PTRANSACTION SrvFindTransaction (
    IN PCONNECTION Connection,
    IN PSMB_HEADER SmbHeader,
    IN USHORT Fid OPTIONAL)
{
if (SmbHeader->Command == SMB_COM_WRITE_ANDX)
OtherInfo = Fid;
else
OtherInfo = SmbHeader->Mid;
// search TransactionList by UID/TID/PID/OtherInfo
}
SrvSmbWriteAndX ( PWORK_CONTEXT )
{
transaction = SrvFindTransaction(connection, header, fid);
if (writeMode & SMB_WMODE_WRITE_RAW_NAMED_PIPE)
{
RtlCopyMemory(transaction->InData, ...);
transaction->InData += writeLength;
transaction->DataCount += writeLength;
}
}
Type Confusion Sequence
Type Confusion Sequence
Type Confusion Sequence
Pointer Shift Sequence
Pointer Shift Sequence
Pointer Shift Sequence
Pointer Shift Sequence
Info Leak
●
Bug #1 - TRANS_PEEK_NMPIPE
○
Expects MaxParameterCount=16
■
But takes client value
○
MaxParameterCount to fill min. Space
○
MaxDataCount=1
Info Leak
●
Bug #1 - TRANS_PEEK_NMPIPE
○
Expects MaxParameterCount=16
■
But takes client value
○
MaxParameterCount to fill min. Space
○
MaxDataCount=1
●
Bug #2 - DataCount > MaxDataCount
○
Put >1 data in pipe
○
Peek
Paged Pool Grooming Methods
1.
Fish-in-a-Barrel
○
“Remote API” (MS-RAP)
■
Fish/Dynamite
2.
Matched Pairs
○
“Lattice”
■
Brides/Grooms → Romance?
3.
Classic
○
“Sandwich”
■
Frag/Padding
●
Each: 3 exploit attempts
Fish-In-A-Barrel
●
SrvXsPortMemoryHeap - 1MiB
○
Private heap, Pre-allocated
■
No fighting in the paged pool with other kernel allocations
○
MS-RAP transactions only, Rarely used
■
Babby's first heap feng shui
●
Removed in 7+
○
SMAP?
○
privesc??
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Fish-In-A-Barrel
Free Heap memory
Fish (victim)
Dynamite (exploit)
Matched Pairs “Lattice”
●
All versions of Windows
○
Including, 7+
●
Must overcome pool contention
○
Not a private heap
■
Normal, Paged Pool
■
PASSIVE_LEVEL
Matched Pairs “Lattice”
Free Heap memory
Grooms
Brides (victim)
Exploit (pointer shift)
Matched Pairs “Lattice”
Free Heap memory
Grooms
Brides (victim)
Exploit (pointer shift)
Matched Pairs “Lattice”
Free Heap memory
Grooms
Brides (victim)
Exploit (pointer shift)
Matched Pairs “Lattice”
Free Heap memory
Grooms
Brides (victim)
Exploit (pointer shift)
Matched Pairs “Lattice”
Free Heap memory
Grooms
Brides (victim)
Exploit (pointer shift)
Matched Pairs “Lattice”
Free Heap memory
Grooms
Brides (victim)
Exploit (pointer shift)
Matched Pairs “Lattice”
Free Heap memory
Grooms
Brides (victim)
Exploit (pointer shift)
Matched Pairs “Lattice”
Free Heap memory
Grooms
Brides (victim)
Exploit (pointer shift)
Matched Pairs “Lattice”
Free Heap memory
Grooms
Brides (victim)
Exploit (pointer shift)
Matched Pairs “Lattice”
Free Heap memory
Grooms
Brides (victim)
Exploit (pointer shift)
Matched Pairs “Lattice”
Free Heap memory
Grooms
Brides (victim)
Exploit (pointer shift)
Matched Pairs “Lattice”
Free Heap memory
Grooms
Brides (victim)
Exploit (pointer shift)
Matched Pairs “Lattice”
Free Heap memory
Grooms
Brides (victim)
Exploit (pointer shift)
Write-What-Where Primitive
Write-What-Where Primitive
1.
Exploit Transaction (PID=X)
○
Set VictimTrans->InData to &WHERE
○
Set VictimTrans->Executing to FALSE
○
Increase reference count!
■
Don’t want it to get freed
○
etc...
Write-What-Where Primitive
1.
Exploit Transaction (PID=X)
○
Set VictimTrans->InData to &WHERE
○
Set VictimTrans->Executing to FALSE
○
Increase reference count!
■
Don’t want it to get freed
○
etc...
2.
VictimTrans Secondary (MID=0)
○
Trans Data Block = WHAT[]
Read-Where Primitive
Read-Where Primitive
1.
Exploit Transaction (PID=X)
○
Modify VictimTrans to point at LeakTrans
■
Address inferred by its contents
■
VictimTrans now modifies LeakTrans
Read-Where Primitive
1.
Exploit Transaction (PID=X)
○
Modify VictimTrans to point at LeakTrans
■
Address inferred by its contents
■
VictimTrans now modifies LeakTrans
2.
VictimTrans Trans_Secondary (MID=0)
○
LeakTrans->OutData = &WHERE
○
LeakTrans->Setup = TRANS_PEEK_NMPIPE
○
LeakTrans->MaxDataCount = size_t
Read-Where Primitive
1.
Exploit Transaction (PID=X)
○
Modify VictimTrans to point at LeakTrans
■
Address inferred by its contents
■
VictimTrans now modifies LeakTrans
2.
VictimTrans Trans_Secondary (MID=0)
○
LeakTrans->OutData = &WHERE
○
LeakTrans->Setup = TRANS_PEEK_NMPIPE
○
LeakTrans->MaxDataCount = size_t
3.
LeakTrans Trans_Secondary
○
Echos back the LeakTrans->OutData
Quest for RWX NonPagedPool
1.
Exploit Trans
○
Set VictimTrans->OutParameters = NULL
2.
Send Secondary Victim Transaction
if (VictimTrans->OutParameters == NULL)
VictimTrans->OutParameters = WorkContext->ResponseBuffer;
3.
Read Primitive
○
Read address just set
4.
Write Primitive
○
Send shellcode
Quest to Execute the Shellcode
1.
Locate Transaction2DispatchTable
○
FIND in srv.sys .data section (read primitive)
2.
Hook a Trans2 subcommand
○
REPLACE a pointer in table (write primitive)
3.
Fake Trans2 executes the hook
○
Subcommand = hooked index
○
Similar methodology as DOUBLEPULSAR
●
Given:
○
Read/write primitives
○
Leaked TRANSACTION has CONNECTION pointer
Locate Transaction2DispatchTable
1.
Read in LeakTrans->CONNECTION
Locate Transaction2DispatchTable
1.
Read in LeakTrans->CONNECTION
2.
CONNECTION->EndpointSpinLock
○
SrvGlobalSpinLocks
■
Inside PE .data section
Locate Transaction2DispatchTable
1.
Read in LeakTrans->CONNECTION
2.
CONNECTION->EndpointSpinLock
○
SrvGlobalSpinLocks
■
Inside PE .data section
3.
Read backwards, SrvSmbWordCount
○
Illegal commands = -2 (0xfe)
○
If we see a bunch of fefe, we're close
Locate Transaction2DispatchTable
1.
Read in LeakTrans->CONNECTION
2.
CONNECTION->EndpointSpinLock
○
SrvGlobalSpinLocks
■
Inside PE .data section
3.
Read backwards, SrvSmbWordCount
○
Illegal commands = -2 (0xfe)
○
If we see a bunch of fefe, we're close
4.
Transaction2DispatchTable
○
Function pointers #0x14 == #0x15
■
SrvTransactionNotImplemented
EternalRomance Info Leak Patch #1
SrvSmbTransaction() Before:
if (subCommand == TRANS_PEEK_NMPIPE)
{
maxParameterCount = MAX(16, maxParameterCount);
}
SrvAllocateTransaction(&Transaction, ...);
Transaction->MaxParameterCount = maxParameterCount;
EternalRomance Info Leak Patch #1
SrvSmbTransaction() After:
if (subCommand == TRANS_PEEK_NMPIPE)
{
maxParameterCount = 16;
}
SrvAllocateTransaction(&Transaction, ...);
Transaction->MaxParameterCount = maxParameterCount;
MS17-010 Scanners
●
Max TRANSACTION allocation size=0x10400
○
0xC0000205 - STATUS_INSUFF_SERVER_RESOURCES
●
Send MaxParameterCount+MaxDataCount > 0x10400
MS17-010 Scanners
●
Max TRANSACTION allocation size=0x10400
○
0xC0000205 - STATUS_INSUFF_SERVER_RESOURCES
●
Send MaxParameterCount+MaxDataCount > 0x10400
○
Patch fixes MaxParameterCount to 16
■
Passes allocation routine!
○
Different NT error (i.e. invalid FID)
EternalRomance Info Leak Patch #2
SrvCompleteExecuteTransaction() New Code:
if (transaction->DataCount > transaction->MaxDataCount)
transaction->DataCount = transaction->MaxDataCount;
if (transaction->ParameterCount  > transaction->MaxParameterCount )
transaction->ParameterCount  = transaction->MaxParameterCount ;
EternalRomance RCE Patch #1
SrvSmbWriteAndX() Before:
RtlCopyMemory(transaction-> InData, ...);
transaction->InData += writeLength;
transaction->DataCount += writeLength;
EternalRomance RCE Patch #1
SrvSmbWriteAndX() After:
RtlCopyMemory(transaction-> InData + transaction->DataCount, ...);
transaction->InData += writeLength;
transaction->DataCount += writeLength;
EternalRomance RCE Patch #2
1.
SrvSmbNtTransaction/SrvSmbTransaction() New Code:
SrvAllocateTransaction(&Transaction, ...)
Transaction->SecondaryCommand = 
/* 0x38 */
SMB_COM_NT_TRANS_SECONDARY; 
SrvInsertTransaction(&Transaction);
EternalRomance RCE Patch #2
1.
SrvSmbNtTransaction/SrvSmbTransaction() New Code:
SrvAllocateTransaction(&Transaction, ...)
Transaction->SecondaryCommand = 
/* 0x38 */
SMB_COM_NT_TRANS_SECONDARY; 
SrvInsertTransaction(&Transaction);
2.
SrvFindTransaction() New Code:
if (FoundTrans->SecondaryCommand != NewSmb->Command)
return NULL;
EternalSynergy
EternalSynergy 1.0.1
●
Same buffalo overflow, read/writes, as EternalRomance
○
Matched pairs
○
"Classic"
●
Same info leak as EternalChampion
○
NT_Rename Race Condition
■
TRANS_PEEK_NAMED_PIPE is fixed…
●
Srv.sys is using NonPagedPoolNx for Work Items!
○
Needs DEP bypass
Quest for RWX Memory (via remote read)
●
Given: Connection
Type
Pointer Dereference
Offset
WORK_QUEUE
Connection->PreferredWorkQueue
variadic
Quest for RWX Memory (via remote read)
●
Given: Connection
Type
Pointer Dereference
Offset
WORK_QUEUE
Connection->PreferredWorkQueue
variadic
KTHREAD
PreferredWorkQueue->IrpThread
0x198
Quest for RWX Memory (via remote read)
●
Given: Connection
Type
Pointer Dereference
Offset
WORK_QUEUE
Connection->PreferredWorkQueue
variadic
KTHREAD
PreferredWorkQueue->IrpThread
0x198
KPROCESS
IrpThread->Process
0x220
Quest for RWX Memory (via remote read)
●
Given: Connection
●
Obtain: ProcessListEntry.Blink
○
nt!KiProcessListHead*
Type
Pointer Dereference
Offset
WORK_QUEUE
Connection->PreferredWorkQueue
variadic
KTHREAD
PreferredWorkQueue->IrpThread
0x198
KPROCESS
IrpThread->Process
0x220
PVOID
KProcess->ProcessListEntry.Blink
0x240
*  https://www.geoffchappell.com/studies/windows/km/ntoskrnl/structs/kprocess/index.htm
Quest for RWX Memory (via remote read)
●
Given: Connection
●
Obtain: ProcessListEntry.Blink
○
nt!KiProcessListHead*
●
Search backwards by page size for 'MZ'
○
ntoskrnl.exe PE header
Type
Pointer Dereference
Offset
WORK_QUEUE
Connection->PreferredWorkQueue
variadic
KTHREAD
PreferredWorkQueue->IrpThread
0x198
KPROCESS
IrpThread->Process
0x220
PVOID
KProcess->ProcessListEntry.Blink
0x240
*  https://www.geoffchappell.com/studies/windows/km/ntoskrnl/structs/kprocess/index.htm
ntoskrnl.exe RWEXEC Section
●
Remote read offset 0x250 into &ntoskrnl.exe
●
Check section headers:
○
+0x08
== 
0x1000 
(Virtual Size: 4096)
○
+0x0C 
<= 
0x800000 
(Virtual Addr: 0x271000 &KxUnexpectedInterrupt)
○
+0x24 
== 
0xE80000A0 
(Segment permissions: RWX)
Additional Research
●
@sleepya_
○
https://github.com/worawit/MS17-010
●
@n_joly
○
https://hitcon.org/2017/CMT/slide-files/d2_s2_r0.pdf
●
@jennamagius and @zerosum0x0
○
https://keybase.pub/jennamagius/EternalBlue_RiskSense-Exploit-Analysis-and-Port-to-Microsoft-Windows-10.pdf
●
@msftsecresponse
○
https://blogs.technet.microsoft.com/srd/2017/06/29/eternal-champion-exploit-analysis/
○
https://blogs.technet.microsoft.com/srd/2017/07/13/eternal-synergy-exploit-analysis/
●
@swithak
○
https://swithak.github.io/SH20TAATSB18/Home/
●
@francisckrs
○
https://speakerdeck.com/francisck/danderspritz-how-the-equation-groups-2013-tools-still-pwn-in-2017
●
@msuiche
○
https://www.comae.io/reports/us-17-Suiche-TheShadowBrokers-Cyber-Fear-Game-Changers.pdf
Thanks!
zerosum0x0