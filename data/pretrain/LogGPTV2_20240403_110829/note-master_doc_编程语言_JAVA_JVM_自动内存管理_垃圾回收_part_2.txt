```
使用弱引用而非强引用可以避免当 ThreadLocal 变量置为 null时，ThreadLocalMap 中的 key 不会还指着 ThreadLocal 变量
内存泄漏的情况在于，ThreadLocal 变量被回收，即 key 的值变成null, 但是 ThreadLocalMap 仍持有着对 Entry 的引用，此时发生内存泄露
除了手动调用 remove 方法之外，只要保证有着对 ThreadLocal 变量的强引用，也能避免内存泄露
#### 虚引用
```java
Object obj = new Object();
PhantomReference pf = new PhantomReference(obj, null);
obj = null;
```
这里虚引用get永远会返回null
- 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知，用于对象回收跟踪
应用场景：管理堆外内存
#### 引用队列
创建各种引用并关联到相应对象时，可以选择是否需要关联引用队列，JVM 会在特定时机将引用 enqueue 到队列里，我们可以从队列里获取引用进行相关后续逻辑
```java
var que = new ReferenceQueue<>();
var a = new Object();
WeakReference ref = newWeakReference<>(a, que);
a = null;
System.gc();
Reference ref1 = que.remove();
if (ref1 != null) {
    System.out.println(ref1.get());
}
```
#### 总结
引用类型 | 强引用  | 软引用           | 弱引用           | 虚引用
---- | ---- | ------------- | ------------- | ----------------
类型   | 正常赋值 | SoftReference | WeakReference | PhantomReference
回收时间 | 不回收  | 内存紧张时回收       | GC就回收         | 随时可能被回收
### 方法区的回收
方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。
为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。
常量回收：如果一个常量没有再被使用，那么就可以被回收
类的卸载，需要满足三个条件才有可能被回收：
- 该类所有的实例都已经被回收
- 加载该类的类加载器已经被回收
- 该类对应的java.lang.Class对象没有在任何地方被引用
可以控制Xnoclassgc参数让HotSpot进行回收类
## 垃圾回收算法
垃圾回收类型：
- 部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集
  - 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集
  - 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集
  - 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集 只有G1收集器会有这种行为
- 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集
### 分代收集理论
前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（Generational Collection）的理论
建立在以下两个分代假说上：
- 弱分代假说：绝大多数对象都是朝生夕灭的
- 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡
- 根据上面两条假说得到 -> 跨代引用假说：跨代引用相对于同代引用来说仅占极少数
### 标记-清除算法
> GC 标记-清除算法由标记阶段和清除阶段构成。在标记阶段会把所有的活动对象都做上标记，然后在清除阶段会把没有标记的对象，也就是非活动对象回收，该算法一般应用于老年代,因为老年代的对象生命周期比较长
后续的收集算法大多都是以标记-清除算法为基础，对其缺点进行改进而得到的
![202031685456](/assets/202031685456.png)
- 可以解决循环引用的问题 
- 必要时才回收(内存不足时) 
- **回收时，应用需要挂起，也就是stop the world。**
- **标记和清除的效率不高**
- **会造成内存碎片**
### 标记-复制算法
> 把内存分为两个空间一个是From空间，一个是To空间，对象一开始只在From空间分配，To空间是空闲的。GC时把存活的对象从From空间复制粘贴到To空间，之后把To空间变成新的From空间，原来的From空间变成To空间，这也是JVM年轻代所使用的的回收算法
![20203169025](/assets/20203169025.png)
商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。
当进行GC时，将Eden与使用过的Survivor中存活的对象移动到另外一个Survivor中，然后清除Eden与使用过的Survivor
HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%
- 在存活对象不多的情况下，性能高，能解决内存碎片和java垃圾回收算法之-标记清除 中导致的引用更新问题。
- **会造成一部分的内存浪费。不过可以根据实际情况，将内存块大小比例适当调整；如果存活对象的数量比较大，coping的性能会变得很差**
### 标记-整理算法
> 其中标记阶段跟标记-复制算法中的标记阶段是一样的,而对于整理阶段，它的工作就是移动所有的可达对象到堆内存的同一个区域中，使他们紧凑的排列在一起，从而将所有非可达对象释放出来的空闲内存都集中在一起，通过这样的方式来达到减少内存碎片的目的
但这种方式需要移动大量对象，处理效率比较低，同时也会STW
是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算
![20203168564](/assets/20203168564.png)
- 任意顺序 : 即不考虑原先对象的排列顺序，也不考虑对象之间的引用关系，随意移动对象；
- 线性顺序 : 考虑对象的引用关系，例如a对象引用了b对象，则尽可能将a和b移动到一块；
- 滑动顺序 : 按照对象原来在堆中的顺序滑动到堆的一端。
### 分代收集
>除Epsilon ZGC Shenandoah之外的GC都是使用逻辑分代模型
G1是逻辑分代，物理不分代
除此之外不仅逻辑分代，而且物理分代
![批注 2020-05-08 164208](/assets/批注%202020-05-08%20164208.png)
不同对象使用不同的回收算法
- 新生代
  - 主要存放短暂生命周期的对象
  - 新创建的对象都先放入新生代，大部分新建对象在第一次gc时被回收
  - 新生代 GC（Minor GC/Young GC）：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快
  - **使用复制清除算法**
- 老年代
  - 一个对象经过几次gc仍存活，则放入老年代
  - 具体是超过`XX:MaxTenuringThreshold`
  - 这些对象可以活很长时间，或者伴随程序一生，需要常驻内存的，可以减少回收次数
  - 老年代 GC（Major GC  / Full GC）：指发生在老年代的 GC
  - **使用标记清除 或者标记压缩算法**
## HotSport算法细节实现
### 根节点枚举
迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行
在HotSpot的解决方案里，是使用一组称为OopMap的数据结构来保存着对象的引用
### 安全点
导致OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外存储空间，HotSpot通过只记录位于安全点的指令的方式来让其他线程在这个点开始进行垃圾回收
线程会通过主动式中断，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起，这个时候线程就是暂停起来的
HotSpot将这个轮询操作精简到了一条汇编指令
### 安全区域
安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，这个区域可以安全地进行垃圾回收
如果线程要离开安全区域，要检查虚拟机是否已经完成了根节点枚举，如果完成了枚举，就可以离开，否则就要一直等待 直到收到了可以离开的信号
### 记忆集与卡表
垃圾收集器在新生代中建立了名为记忆集（Remembered Set）的数据结构，用以避免把整个老年代加进GC Roots扫描范围
记忆集的实现精度有：
- 字长精度 精确到一个机器字长
- 对象精度 精确到一个对象
- 卡精度 精确到一块内存区域
![屏幕截图 2020-10-19 140228](/assets/屏幕截图%202020-10-19%20140228.png)
通过卡表就可以使用比较少的内存来记录，一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，脏卡页在垃圾回收时也会一起被扫描
### 写屏障
HotSpot通过写屏障（和并发操作的内存读写屏障非同一概念），这里的写屏障类似于虚拟机在解释字节码时的AOP环绕通知，即插入一条修改指令，修改内存的同时更新卡表
### 三色标记
把遍历对象图过程中遇到的对象，按照“是否访问过”这个条件标记成以下三种颜色：
- 白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达
- 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过
- 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过
![屏幕截图 2020-10-19 142719](/assets/屏幕截图%202020-10-19%20142719.png)
当以下两个条件同时满足，则会出现将原本应该是黑色的对象被误标为白色：
- 赋值器插入了一条或多条从黑色对象到白色对象的新引用
- 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用
增量更新破坏第一个条件：黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了
原始快照破坏第二个条件：无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索
CMS是基于增量更新来做并发标记的，G1、Shenandoah则是用原始快照来实现
## 内存分配
### 内存配置常见参数
```
-XX:+PrintGC      每次触发GC的时候打印相关日志
-XX:+UseSerialGC      串行回收
-XX:+PrintGCDetails  更详细的GC日志
-Xms               堆初始值
-Xmx               堆最大可用值
-Xmn               新生代堆最大可用值
-XX:SurvivorRatio  用来设置新生代中eden空间和from/to空间的比例.
-XX:NewRatio       配置新生代与老年代占比 1:2
含以-XX:SurvivorRatio=eden/from=den/to
总结:在实际工作中，我们可以直接将初始的堆大小与最大堆大小相等，
这样的好处是可以减少程序运行时垃圾回收次数，从而提高效率。
-XX:SurvivorRatio     用来设置新生代中eden空间和from/to空间的比例.
```
### OutOfMemoryError异常
- Java堆溢出
```java
java.lang.OutOfMemoryError: Java heap space 堆内存溢出
```
因为堆内存无法满足内存申请需要
设置堆内存大小解决`-Xmx`
- 虚拟机栈溢出
```java
java.lang.StackOverflowError  栈内存溢出
```
由于方法调用栈过深