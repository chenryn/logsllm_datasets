00 :00 :00 -bash
501
1.841
0/d zt 0
0 14:22 pta/0
00:00:00 baah
501
2546
501
2562
00 :00:00 bash
501
2.5·46
0 14 :24
pts/0
00 :00:00 bash
2585
2.5 62
0/d 6= T
- ed 00=00=00
bashshell程序可使用命令行参数修改shel启动方式。表5-1列举了bash中可用的命令行参数。
表5-1bash命令行参数
参
数
描
述
-c string
从atring中读取命令并进行处理
启动一个能够接收用户输人的交互shell
1
以登录she的形式启动
启动一个受限shel，用户会被限制在默认目录中
·8
从标准输人中谈取命令
可以输人man bash获得关于bash命令的更多帮助信息，了解更多的命令行参数。bash
--help命令也会提供一些额外的协助。
可以利用exit命令有条不素地退出子shell。
S exit
exit
S ps --forest
---
## Page 106
5.2shell的父子关系
91
AL αId
TINE CND
1841 pts/0
00:00 :00 bash
2546 pta/0
0/eqd εe5z
00 : 00 : 00
00 :00 : 00
_ baah
00 : 00 : 00
_ba.sh
2602 ptα/0
ps
S exit
ex1t
S exit
ex1:
S ps --forest
1841 pta/0
PID TTY
TINE CMD
00:00 :00 bash
2604 ptα/0
00 : 00 : 00
_ pa
exit命令不仅能退出子shell，还能用来登出当前的虚拟控制台终端或终端仿真器软件。只需
要在父shell中输人exit，就能够从容退出CLI了。
运行shell脚本也能够创建出子shell。在第11章，你将会学习到相关话题的更多知识。
就算是不使用bash shell命令或是运行shell脚本，你也可以生成子shell。一种方法就是使用进
程列表。
5.2.1
进程列表
你可以在一行中指定要依次运行的一系列命令。这可以通过命令列表来实现，只需要在命令
之间加人分号（；）即可。
BT : pnd : po : pnd :oao/ po =BT + pad S
Deaktop
/home /ChxIatLne
Downloada
Music
Pub1ic
V1deog
Documenta
Junk,dat
Plctures
Templatea
/home /Chx1 at Lne
/etc
Desktop
Down.1oada
Music
Pub1ic
Videos
Docaenta
Junk, dat
Plctures
Templatea
在上面的例子中，所有的命令依次执行，不存在任何问题。不过这并不是进程列表。命令列
表要想成为进程列表，这些命令必须包含在括号里。
S (pwd ; 1s ; cd /ete : pwd : cd : pud ; 1s)
/home /ChxiatLne
Desktop
Downloads
Mus1c
Pub1ic
Documenta junk,dat
V1deos
Plctures
Templatea
/et.c
/home /Chx1at.1ne
Desktop
Downloads
Mus 1c
Pub1ic
V1de08
Documenta junk,dat
Plctures
Template.a
---
## Page 107
第5章理解shell
尽管多出来的括号看起来没有什么太大的不同，但起到的效果确是非同寻常。括号的加入使
命令列表变成了进程列表，生成了一个子shell来执行对应的命令。
说明进程列表是一种命令分组（commandgrouping）。另一种命令分组是将命令放入花括号中，
并在命令列表尾部加上分号（；）。语法为（command：1。使用花括号进行命令分组并不
会像进程列表那样创建出子shell。
要想知道是否生成了子shell，得借助一个使用了环境变量的命令。（环境变量会在第6章中详
述。）这个命令就是echo $BASH_SUBSHELL。如果该命令返回o，就表明没有子shell。如果返回
1或者其他更大的数字，就表明存在子shell。
下面的例子中使用了一个命令列表，列表尾部是echoSBASH_SUBSHELL。
S pwd ; 1a ; cd /etc : pud : cd : pvd : 1s : echo $BAS8_sUBSH8LL
/home/Chriat1ne
Desktop
Downloads Muslc
Pub1lc
Videoa
Docunenta  Junk Gat
Pictures  Tenplates
/home/ChriatLne
/etc
Docunentajunk datI
Desktop
Downloads Muslc
Pictures Tenplates
Pub11c
Video.8
在命令输出的最后，显示的是数字0。这就表明这些命令不是在子shell中运行的。
要是使用进程列表的话，结果就不一样了。在列表最后加人echo $BASH_SUBSHELL。
$ (pud : 1s : cd /etc : pvd ; cd : pvd ; 1e / echo sBASB_sUBsHELL)
Deaktop
/home/Chriat1ne
Downloads Mus1c
Pub11c
V1deo8
Docunenta_Junk, dat
Pictures Tenplates
/home/ChriatLne
/etc
Desktop
DownloadsMus1c
Pub11c
Video.8
Docunentajunk,dat Pictures Tenplates
这次在命令输人的最后显示出了数字1。这表明的确创建了子shell，并用于执行这些命令。
所以说，命令列表就是使用括号包围起来的一组命令，它能够创建出子shel来执行这些命令。
你甚至可以在命令列表中嵌套括号来创建子shell的子shell。
S( pud : echo $BASH_SUBSH8LL)
/home/ChriatLne
S( pud ;(echo $BASB_SUBSHELL) )
/home/ChriatLne
注意，在第一个进程列表中，数字1表明了一个子shell，这个结果和预期的一样。但是在第
二个进程列表中，在命令echoSBASH_SUBSHELL外面又多出了一对括号。这对括号在子shell中
---
## Page 108
5.2shell的父子关系
93
产生了另一个子shell来执行命令。因此数字2表明的就是这个子shell。
在shell脚本中，经常使用子shell进行多进程处理。但是采用子shell的成本不非，会明显拖慢
处理速度。在交互式的CLIshell会话中，子shell同样存在问题。它并非真正的多进程处理，因为
终端控制着子shell的I/O。
5.2.2别出心裁的子shell用法
在交互式的shell CLI中，还有很多更富有成效的子shell用法。进程列表、协程和管道（第11
章会讲到）都利用了子shell。它们都可以有效地在交互式shell中使用。
在交互式shell中，一个高效的子shell用法就是使用后台模式。在讨论如果将后台模式与子shell
搭配使用之前，你得先搞明白什么是后台模式。
1.探索后台模式
在后台模式中运行命令可以在处理命令的同时让出CLI，以供他用。演示后台模式的一个经
典命令就是sleep。
sleep命令接受一个参数，该参数是你希望进程等待（睡眠）的秒数。这个命令在胸本中常
用于引人一段时间的暂停。命令sleep10会将会话暂停10秒钟，然后返回shellCLI提示符。
S sleep 10
要想将命令置人后台模式，可以在命令末尾加上字符&。把s1eep命令置人后台模式可以让找
们利用ps命令来小窥一番。
S sleep 30006
[1]2396
S p8 -f
UID
PID1
PPID C STIHE TTY
christi+
TIME CMD
2396 2338 0 10:17 pts/9
LEE℃
0 10:13 pts/9
00:00:00 e1eep 3000
00 :00 : 00 -bash
christi+
christi+
2397 2338 0 10:17 pts/9
00:00:00 ps -f
sleep命令会在后台（&）睡眠3000秒（50分钟）。当它被置入后台，在shell CLI提示符返回
之前，会出现两条信息。第一条信息是显示在方括号中的后台作业（background job）号（1）。
第二条是后台作业的进程ID（2396）。
ps命令用来显示各种进程。我们可以注意到命令sleep3000已经被列出来了。在第二列显
示的进程ID（PID）和命令进人后台时所显示的PID是一样的，都是2396。
除了ps命令，你也可以使用jobs命令来显示后台作业信息。jobs命令可以显示出当前运行
在后台模式中的所有用户的进程（作业）。
$ jobs
[1] + Running
sleep 3000 &
jobs命令在方括号中显示出作业号（1）。它还显示了作业的当前状态（running）以及对
---
## Page 109
94
第5章理解shell
应的命令（sleep3000&）。
利用jobs命令的-1（字母L的小写形式）选项，你还能够看到更多的相关信息。除了默认信
息之外，-1选项还能够显示出命令的PID。
$jobs -1
[1] + 2396 Running
sleep 3000 &
一旦后台作业完成，就会显示出结束状态。
[1] +Done
s1eep 3000 &
窍门需要提醒的是：后台作业的结束状态可未必会一直等待到合适的时候才现身。当作业结
束状态突然出现在屏幕上的时候，你可别吃惊啊。
后台模式非常方便，它可以让我们在CLI中创建出有实用价值的子shell。
2.将进程列表置入后台
之前说过，进程列表是运行在子shell中的一条或多条命令。使用包含了sleep命令的进程列
表，并显示出变量BASH_SUBSHELL，结果和期望的一样。
(sleep 2 : ecbo $BASH_SUBSHELL ;sleep 2)
1
在上面的例子中，有一个2秒钟的暂停，显示出的数字1表明只有一个子shell，在返回提示符
之前又经历了另一个2秒钟的暂停。没什么大事。
将相同的进程列表置人后台模式会在命令输出上表现出些许不同。
(sleep 2;ecbo $BASH_SUBSHZLL 1sleep 2)&
(2]  2401
$ 1
[2] +Done
(s1eep 21 echo SBASH_SUBSHELL) sleep 2 )
把进程列表置人后台会产生一个作业号和进程ID，然后返回到提示符。不过奇怪的是表明单
一级子shell的数字1显示在了提示符的旁边！不要不知所措，只需要按一下回车键，就会得到另
一个提示符。
在CLI中运用子shell的创造性方法之一就是将进程列表置入后台模式。你既可以在子shell中
进行繁重的处理工作，同时也不会让子shell的I/O受制于终端。
当然了，sleep和echo命令的进程列表只是作为一个示例而已。使用tar（参见第4章）创
建备份文件是有效利用后台进程列表的一个更实用的例子。
 (tar -cf Rich.tar /bome/rich ; tar =cf Hy.tar /hone/christine)&
[3]  2423
---
## Page 110
5.2shell的父子关系
95
将进程列表置入后台模式并不是子shell在CLI中仅有的创造性用法。协程就是另一种方法。
3.协程
协程可以同时做两件事。它在后台生成一个子shell，并在这个子shell中执行命令。
要进行协程处理，得使用coproc命令，还有要在子shell中执行的命令。
S coproc sleep 10
[1]  2544
除了会创建子shell之外，协程基本上就是将命令置人后台模式。当输人coproc命令及其参
数之后，你会发现启用了一个后台作业。屏幕上会显示出后台作业号（1）以及进程ID（2544）。
jobs命令能够显示出协程的处理状态。
[1] +Running
S jobs
coproc COPROC aleep 10 &
在上面的例子中可以看到在子shell中执行的后台命令是coproc COPROCsleep 10。COPROC
是coproc命令给进程起的名字。你可以使用命令的扩展语法自己设置这个名字。
S coproc My_Job ( sleep 10; }
[1] 2570
S jobs
fupuung+ [t]
coproc My_Job ( aleep 10; ) &
通过使用扩展语法，协程的名字被设置成by_Job。这里要注意的是，扩展语法写起来有点
麻烦。必须确保在第一个花括号（{）和命令名之间有一个空格。还必须保证命令以分号（；）结