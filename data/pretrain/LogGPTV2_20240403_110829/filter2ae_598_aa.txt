前几天 PortSwigger 发布了 [Top 10 web hacking techniques of
2019](https://portswigger.net/research/top-10-web-hacking-techniques-of-2019)，榜上的攻击技术都比较有意思，p牛也肯定会在小密圈做分享的（如果没有话本菜也会在自己[博客](https://blog.zeddyu.info)做做学习分享），所以我们这里就不聊
Top 10 技术了，就看看在 Top 10 提名结果没上榜但是依旧很有意思的技术 Dom Clobbering。
## Basics
From [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction):
> ​ The Document Object Model (DOM) is a programming interface for HTML and
> XML documents. It represents the page so that programs can change the
> document structure, style, and content. The DOM represents the document as
> nodes and objects. That way, programming languages can connect to the page.
>
> A Web page is a document. This document can be either displayed in the
> browser window or as the HTML source. But it is the same document in both
> cases. The Document Object Model (DOM) represents that same document so it
> can be manipulated. The DOM is an object-oriented representation of the web
> page, which can be modified with a scripting language such as JavaScript.
>
> The [W3C DOM](http://www.w3.org/DOM/) and [WHATWG
> DOM](https://dom.spec.whatwg.org/) standards are implemented in most modern
> browsers. Many browsers extend the standard, so care must be exercised when
> using them on the web where documents may be accessed by various browsers
> with different DOMs.
DOM 最初是在没有任何标准化的情况下诞生和实现的，这导致了许多特殊的行为，但是为了保持兼容性，很多浏览器仍然支持异常的 DOM 。
DOM 的旧版本（即DOM Level 0 & 1）仅提供了有限的通过 JavaScript
引用元素的方式，一些经常使用的元素具有专用的集合（例如`document.forms`），而其他元素可以通过`Window`和`Document`对象上的`name`属性和`id`属性来引用，
显然，支持这些引用方式会引起混淆，即使较新的规范试图解决此问题，但是为了向后兼容，大多数行为都不能轻易更改。并且，浏览器之间没有共识，因此每个浏览器可能遵循不同的规范（甚至根本没有标准）。显然，缺乏标准化意味着确保DOM的安全是一项重大挑战。
由于非标准化的 DOM 行为，浏览器有时可能会向各种 DOM 元素添加 name & id 属性，作为对文档或全局对象的属性引用，但是，这会导致覆盖掉
document原有的属性或全局变量，或者劫持一些变量的内容，而且不同的浏览器还有不同的解析方式，所以本文的内容如果没有特别标注，均默认在 **Chrome
80.0.3987.116** 版本上进行。
Dom Clobbering 就是一种将 HTML 代码注入页面中以操纵 DOM 并最终更改页面上 JavaScript 行为的技术。 在无法直接 XSS
的情况下，我们就可以往 DOM Clobbering 这方向考虑了。
## Simple Example
其实 Dom Clobbering 比较简单，我们看几个简单的例子就能知道它是干什么了的。
### Exmaple 1 - Create
从图中我们可以看到通过 id 或者 name 属性，我们可以在`document`或者`window`对象下创建一个对象。
### Example 2 - Overwrite
可以看到`document.cookie`已经被我们用 img 标签给覆盖了
### Example 3 - Overwrite2
可以看到我们通过多层覆盖掉了`document.body.appendChild`方法。
## Attack Method
既然我们可以通过这种方式去创建或者覆盖 document 或者 window
对象的某些值，但是看起来我们举的例子只是利用标签创建或者覆盖最终得到的也是标签，是一个`HTMLElment`对象。
但是对于大多数情况来说，我们可能更需要将其转换为一个可控的字符串类型，以便我们进行操作。
### toString
所以我们可以通过以下代码来进行 fuzz 得到可以通过`toString`方法将其转换成字符串类型的标签：
    Object.getOwnPropertyNames(window)
    .filter(p => p.match(/Element$/))
    .map(p => window[p])
    .filter(p => p && p.prototype && p.prototype.toString !== Object.prototype.toString)
我们可以得到两种标签对象：`HTMLAreaElement ()`& `HTMLAnchorElement
()`，这两个标签对象我们都可以利用`href`属性来进行字符串转换。
### HTMLCollection
但是如果我们需要的是`x.y`这种形式呢？两层结构我们应该怎么办呢？我们可以尝试上述的办法：
这里无论第一个标签怎么组合，得到的结果都只是`undefined`。但是我们可以通过另一种方法加入引入 name 属性就会有其他的效果。
`HTMLCollection`是一个`element`的“集合”类，在最新的 [Dom
标准](https://dom.spec.whatwg.org/#interface-htmlcollection)中 IDL 描述如下：
> [Exposed=Window, LegacyUnenumerableNamedProperties]  
>  interface HTMLCollection {  
>  readonly attribute unsigned long length;  
>  getter Element? item(unsigned long index);  
>  getter Element? namedItem(DOMString name);  
>  };
文中也提到了
> ​ `HTMLCollection` _is a historical artifact we cannot rid the web of. While
> developers are of course welcome to keep using it, new API standard
> designers ought not to use it (use_ `sequence` _in IDL instead)._
它是一种历史产物，并且在今天我们也可以继续使用这个类，只是对于 API 标准设计者不推荐再使用。
关于它的用法：
> collection . `length`
>
> ​ Returns the number of [elements](https://dom.spec.whatwg.org/#concept-> element) in the [collection](https://dom.spec.whatwg.org/#concept-> collection).
>
> element = collection . `item(index)`
>
> element = collection[index]
>
> ​ Returns the [element](https://dom.spec.whatwg.org/#concept-element) with
> index index from the [collection](https://dom.spec.whatwg.org/#concept-> collection). The [elements](https://dom.spec.whatwg.org/#concept-element)
> are sorted in [tree order](https://dom.spec.whatwg.org/#concept-tree-order).
>
> element = collection . `namedItem(name)`
>
> element = collection[name]
>
> ​ Returns the first [element](https://dom.spec.whatwg.org/#concept-element)
> with [ID](https://dom.spec.whatwg.org/#concept-id) or name name from the
> collection.
让我们值得注意的是我们可以通过`collection[name]`的形式来调用其中的元素，所以我们似乎可以通过先构建一个`HTMLCollection`，再通过`collection[name]`的形式来调用。
### HTML Relationships
再者，我们也可以通过利用 HTML 标签之间存在的关系来构建层级关系。
    var log=[];
    var html = ["a","abbr","acronym","address","applet","area","article","aside","audio","b","base","basefont","bdi","bdo","bgsound","big","blink","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","command","content","data","datalist","dd","del","details","dfn","dialog","dir","div","dl","dt","element","em","embed","fieldset","figcaption","figure","font","footer","form","frame","frameset","h1","head","header","hgroup","hr","html","i","iframe","image","img","input","ins","isindex","kbd","keygen","label","legend","li","link","listing","main","map","mark","marquee","menu","menuitem","meta","meter","multicol","nav","nextid","nobr","noembed","noframes","noscript","object","ol","optgroup","option","output","p","param","picture","plaintext","pre","progress","q","rb","rp","rt","rtc","ruby","s","samp","script","section","select","shadow","slot","small","source","spacer","span","strike","strong","style","sub","summary","sup","svg","table","tbody","td","template","textarea","tfoot","th","thead","time","title","tr","track","tt","u","ul","var","video","wbr","xmp"], logs = [];
    div=document.createElement('div');
    for(var i=0;i'+'';
        document.body.appendChild(div);
        if(window.element1 && element1.element2){
           log.push(html[i]+','+html[j]);
        }
        document.body.removeChild(div);
      }
    }
    console.log(log.join('\n'));
以上代码测试了现在 HTML5 基本上所有的标签，使用两层的层级关系进行 fuzz
，注意这里只使用了`id`，并没有使用`name`，遇上文的`HTMLCollection`并不是一种方法。
我们可以得到的是以下关系：
    form->button
    form->fieldset
    form->image
    form->img
    form->input
    form->object
    form->output
    form->select
    form->textarea
如果我们想要构建`x.y`的形式，我们可以这么构建：
    I've been clobbered
### Three Level
三级的层级关系我们就需要用到以上两种技巧来构建了
    I've been clobbered
这个也比较简单，先用一个`HTMLCollection`获取第二级，再在第一个表单中用`output`标签即可。
### More
三层层级以上的我们就需要用到`iframe`与`srcdoc`来进行配合
    test' name=b>">
因为需要等待所有的`iframe`加载完毕我们才能获得这个层级关系，所以需要用到延时，不用延时也可以通过网络请求来进行延缓：
    test' name=b>">
### Custom
以上我们都是通过 id 或者 name 来利用，那我们能不能通过自定义属性来构造呢？
很明显，这意味着任何未定义的属性都不会具有 DOM 属性，所以就返回了 `undefined`
我们可以尝试一下 fuzz 所有标签的有没有字符串类型的属性可供我们使用：
    var html = [...]//HTML elements array
    var props=[];
    for(i=0;i';
        if(document.getElementById('x')[prop] == 1) {
           props.push(html[i]+':'+prop);
        }
        }catch(e){}
      }
     }
    }
    console.log([...new Set(props)].join('\n'));
我们可以得到一系列的标签以及其属性名称，例如我们可以利用其中的`a:title`来进行组合
其中在我们第一步得到的属性中比较有意思的是 a
标签的`username`跟`password`属性，虽然我们不能直接通过`title`这种形式利用，但是我们可以通过`href`的形式来进行利用：
    alert(x.username)//Clobbered-username