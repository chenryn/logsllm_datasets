C:A J
C:K Q6 2
SOUTH
S: Q 2
H: A 10 96 5
D: 5 4 3
C: 9 7 4
---
## Page 205
附录B部分习题答案
197
下面的程序生成从1到52的整数的一个随机排列，排列结果存放到数组deck中.数组被均分成四段，
一.
函数permute（k,n）使用Floyd算法（习题5.2)从1到n的整数中随机生成一个长度为k的
梅列.函数sort（x,Y）使用插入排序（见7.1节），对deck[x..y]中的元素进行排序.最后，函数
prhands 按照上面的风格，格式化并输出每一手牌.
199
#bridge - generate random bridge hands
BEGIN { split(permute(52,52), deck)
generate a random deck
sort(1,13) ; sort(14, 26); sort(27,39) ; sort(40,52) # sort hands
prhands ()
# format and print the four hands
function permute(k, n,
i,P,r)(generate a random permutation
srand(); p = " "
 of k integers between 1 and n
for (i = n-k+1; i  left && deck[j-1] 39 && card  9 13 && card x=q）o
clbs = clbs " " fvcard(deck[card])
function fvcard(i) {
 compute face value of card i
if (i & 13 == 0) return "A"
else if (i & 13 == 12) return "K"
  =  ） 
else if (i & 13 == 10) return "J"
else return (i  13) + 1
200
Exercise5.5如果想要聪明地解决这个问题，其实是比较固难的.最简单的办法是跟踪到目前为止
已经输出的字符数，如果发现输出得太多了，就打印一条错误消息并停止，更复杂一点的做法是，在函数
gen中，如果发现推导过程已经变得太长了，就在下一次推导时，只选择空字符串或终结符，不幸的是，
这种做法并非每次都奏效，一种比较保险的做法要求事先知道每个非终结符可以产生的最短输出，当推
导过程变得过长时，就强制按照最短输出规则来推导，这需要对语法进行大量的修改，以及一些特殊的知
识.
Exercise5.6我们为产生式的每一个终止添加概率.这些概率首先被读取到数组rhsprob中.语
法规则读取完毕后，修改rhsprob，使得它不仅可以表示当前这条产生式的概率，还可以表示前面任意
一条产生式的概率这样做可以让gen中的测试更简单一点，否则的话，概率就会被重复累加，
# sentgen1 - random sentence generator with probabilities
#
input:  grammar file; sequence of nonterminals
#
output: random sentences generated by the grammar
BEGIN {# read rules from grammar file
(0) 
° After the grammar has been read, rhapzob is changed so that it represents the probability af this ar any previous production, rathe
than this production
---
## Page 207
附录B部分习题答案
199
if ($2 == "->"）{
i = ++lhs[$1]
count lhs
rhsprob[$1, i] = $NF
0 rhsprob[sym, i]; i++)
for (j = 1; j "）{
i = ++1hs[$1]
count lhs
---
## Page 208
附录B部分习题答案
200
rhscnt[$1, i] = NF-2
#how many in rhs
for（j= 3;j= 1) {
()dod = uAs
if (sym in lhs) {
#a nonterminal
i = int(lhs[sym]* rand()) + 1# random production
for (j = rhscnt[sym, i]; j >= 1; j--) # expand rhs's
push(rhslist[sym, i, j1)
}else
printf ("$s ", sym)
{ =[ds++lxe ） (s)sn uoug
function pop() ( return stack[stp--])
Exercise5.9最简单的办法是在开始时，随机生成一个从1到ng的排列，然后按照这个顺序来提
问.
Exercise5.10在awk中，对大小写进行转换的最简洁的方式是创建一个数组，数组包含了每个字
母的大小写映射关系，这种做法非常笨拙，所以如果可能的话，可以利用某些Unix命令来完成，比如tr.
Exercise5.13我们把单词存放在数组中，如果要在一行内打印cnt个单词，那就有cnt-1个缝
隙需要填充空格，如果有n个空格，那么每个缝隙占用n/（cnt-1）个.对每一个单词，程序计算缝隙占
用的空格数，然后递减缝隙和空格的数量.如果额外的空格分布地并不均匀，那么多出来的空格就会轮流
地从左边，或从右边分散到后面的连续的行中.
202
#fmt.just - formatter with right justification
---
## Page 209
附录B部分习题答案
201
/./{ for (i = 1;i  60)
printline("yes")
line[++cnt] = w
size += length(w)
function printline(f,
i, nb, nsp, holes){
if (f == "no" 1l cnt == 1) {
for (i = 1; i  1){
dir = 1 - dir
# alternate side for extra blanks
nb = 60 - size
# number of blanks needed
holes = cnt - 1
#holes
for (i = 1; holes > 0; i++) {
nsp = int((nb-dir) / holes) + dir
printf ("$s&s", 1ine[i], substr (blanks, 1, nsp))
nb == nsp
holes--
}
print line[cnt]
size = cnt = 0
）
给printline传递一个参数“no”可以避免对段落的最后一行进行右对齐.
Exercise5.15这取决于遗漏了下划线的符号名是否在文档中的其他地方出现，如果是，那么这些
内容就会被错误地替换摔.
Exercise 5.16
/^\.#/（printf("(gsub(/s/,\"$d\")）\n"，$2，++count[$1])
if (saw[$2])
print NR ": redefinition of", $2, "from line", saw[$2]
saw[$2] = NR
{
END
{ printf("1/^[.1#/\n"）}
---
## Page 210
附录B部分习题答案
202
Exercise 5.18
/^\.#/{ s[$2]= ++count[$1]; next }
(for ( i in s)
gsub(i, s[i])
print
}
符号名必须在它被使用之前定义
Exereise5.19符合分而治之策略的最简单的解决办法是：为管道添加一个过滤，删除掉那些以停
止列表中的单词作为开始的旋转行。
203
awk '$1 !~ /^(a|an|and|by|for|if|in|is|of|on|the|to)S/' |
sort -f
Exercise5.23如何辨别字面上的一与作为空格使用的一是一个风格问题.我们选择使用awk的
转义序列约定：当想要字面上的字符时，我们就在字符前加一个反斜杠\.我们将只考虑波浪号一，对于
其他字符，ix.genkey和ix.format都作了详尽的阐述，为了显示~，我们把所有的\-实例替换成某
个不可能出现的字符串，这个字符串由一个制表符和一个1组成，1排在制表符之后，不会出现带有制表
符的字符串，因为制表符是字段分隔符，剩下的波浪号被替换掉，然后再把转义过的字符事放回原处，最
后把它们恢复成转义前的样子.于是，ix.genkey的第一个gsub被替换成：
gsub(/\-/，"\t1"，S1)protect quoted tildes
gsub(/-/，""，$1)
 unprotected tildes now become blanks
gsub(/\t1/,"~"，$1)#restore protected tildes
另外，不能再在排序键中把波浪号删除摔.
Exercise 6.1只需要添加4行代码，2行添加在第1次遍历，另外2行添加到第2次遥历中，
ASSEMBLER PASS 1
nextmem =0
#new
FS = "[ \t]+"
while (getline  0) {
input[nextmem] = $0
 new: remember source line
sub(/#.*/, "")
strip comments
symtab[S1]= nextmem #remember 1abel 1ocation
if （S2 != ""）{
save op, addr if present
print $2 "\t" $3 >tempfile
nextmem++
close(tempfile)
---
## Page 211
附录B部分习题答案
ASSEMBLER PASS 2
nextmem = 0
>
if ($2 1~/^[0-9]*$/)# if symbolic addr,
$2 = symtab[$2]
#replace by numeric value
for (i = 0; i< nextmem; i++)
 new: print memory
printf("&3d:&05d&s\n", i, mem[i], input[i])#new
Exercise 6.6如果只想对graph进行一些很简单的修改，就能完成这件工作—实际上这是非常
困难的，因为x与y所需要的信息嵌入在整个程序和许多变量中（例如 bticks和lticks）.或许更
好的做法是定义一个对输入进行处理的过滤器transpose.这里提供了过滤器的一个实现，通过修改
graph来得到：
204
# transpose - input and output suitable for graph
#
input:data and specification of a graph
output: data and specification for the transposed graph