试之上进行的。
如图17-1所示，
传统测试
传统软件测试由单元测试开始（unit test）。更复杂的测试都是在单元测
单元测试
集成测试
系统测试
一个常见的例子是通过依赖
软件测试的类型
159
186
---
## Page 202
黑盒测试。生产测试对运行一个可靠的生产环境来说是必要的。
环境中。这些测试和黑盒监控在很多地方十分类似（参见第6章），有的时候也被称为
回归测试（regression test）
性能测试（performance test）
160
生产测试和一个已经部署在生产环境中的业务系统直接交互，而不是运行在密闭的测试
生产测试
冒烟测试（smoketest）
可以端到端地测试系统功能。系统测试包括以下几种类型。
块（Module）都会被装载到系统中（例如通过集成测试的软件服务器）。接下来工程师
系统测试（system test）是一个在未部署的系统上运行的大型测试。某个组件的所有模
系统测试
复的 Bug又带回来。
另外一种系统测试可保证之前的Bug不会重现。回归测试可以被理解为曾经发生过
变成了50ms，随后变成了100ms。性能测试可以保证随着时间推移系统性能不会下
不会在没人知道的情况下逐渐变慢（在发布到最终用户之前）。例如，一个程序可能
应时间和资源要求可能在开发过程中大量改变，该系统必须接受某些测试以确保它
统测试的变形来保证整个系统的性能自始至终保持在可接受范围内。因为系统的响
一旦冒烟测试通过，系统基本的正确性已经得到了保障。下一步通常是通过某个系
昂贵的测试可以不用运行了。
系统测试形式。冒烟测试有时也被称为理性测试，如果该测试不通过，那么其他更
工程师在冒烟测试中可检测非常简单但是非常重要的系统行为。这是最简单的一种
升的重要因素，同时也鼓励程序员更有效地利用我们的测试资源。
时——一般还需要专属的运算资源。时刻关注这些测试的成本，是软件开发效率提
系统（或者是mock），然后运行相关的测试可能会需要很长时间—几分钟到几小
而在另一个极限上，将一个完整的软件服务器设立起来，同时包括它所有的依赖
测试非常便宜，通常可以在毫秒级和很少的资源上（例如一个笔记本电脑上）完成
很重要的是，每个测试都有成本，时间成本和计算资源成本。在一个极限上，单元
者集成测试，重构代码的工程师可以保证他们不会偶然间将他们曾经辛苦调查和修
的，导致系统故障或产生错误信息的Bug列表。通过将这些Bug记录为系统测试或
降，或者资源要求不会升高。
随着改变开始需要32GB内存，而以前只需要8GB。或者该程序的响应时间由10ms
第17章测试可靠性
---
## Page 203
试是非常简单的。在这种情况下，测试代码发送一个查询，同时将返回结果与配置文件
当生产环境使用配置文件的实际文件内容，同时提供一个实时查询接口时，进行配置测
发现有匹配的，则会产生报警以便停止目前的变更发布过程，并采取修复措施。
尝试将实际用户的请求处理路径（从跟踪日志中获取）与一系列黑名单进行对比。如果
的在生产环境中的通过／失败状况可以揭示整个系统中配置组合错误的部分。监控系统
这些非密闭性的配置测试作为分布式监控系统的一部分是尤其有价值的，因为这些测试
自动化系统的目标版本可以暗示我们生产环境目前与实际工作相差多远。
配置测试是针对某一个已经提交的配置文件构建和运行的。比较目前测试通过的版本和
运行。
任何不一致的情况。这个测试自然不是密闭性的，因为它们需要在测试系统的沙盒之外
有一个单独的配置测试检查生产系统，以确保该服务的配置和配置文件一致，同时汇报
在Googic内部，Web服务的配置信息保存在代码仓库中的文件中。针对每个配置文件，
配置测试
下的测试，却没有在生产环境下通过。这样的结果是很不好的。
该测试的配置测试（下一节提到）却没有通过，那么这项测试只通过了密闭环境
同样的，系统测试也可以使用配置文件在测试前组装模块。如果测试通过，但是
复的Bug。
二进制文件。或者测试可能使用的是旧版文件，结果发现了一个已经被新版本修
测试可能在使用代码仓库中的最新版本的某个配置文件与生产系统中的老版本的
待发布配置文件。这个场景下针对生产环境测试有可能会导致问题。例如，这项
有可能在源代码版本控制系统中同时存在多个版本的二进制文件，以及它对应的
统的版本来代表。
任何未知的问题。所以，整个生产环境通常并不能用任何一个源代码版本控制系
机制逐渐将用户切换到新系统上。同时，监控每个新阶段以保证新环境没有遇到
们被加入源代码版本控制系统的顺序发布。发布过程经常按阶段进行，使用某种
为了更好地控制不可预知性，同时避免最终用户受到影响，变更可能没有按照它
为有节奏的变更发布过程在进行小范围的、已知的生产系统改变。
[Nar12])，这句话暗示了生产环境是非密闭的。当然生产环境通常不是密闭的，因
人们经常宣称测试是在（或者应该在）密闭的测试环境下进行的（参见文献
变更发布与测试
软件测试的类型
161
188
---
## Page 204
增长172%（呈自然对数e倍率增长）所需的时间。
总的累积公式为CU=RK（R是错误发生的速率，U是错误等级，见后文，K是用户流量
生问题。因此，这种测试是不完美的，有的时候会漏掉某些Bug。
的。这种测试将代码置于比较难以预测的生产环境的实时用户流量之下，看代码是否产
还原到已知的正常状态下。我们经常用“烘烤这个二进制文件（baking the binary）”来
矿中的金丝雀”这样一个说法，指代利用一只鸟来检测有毒气体以避免人类中毒的做法。
金丝雀测试
试来找到Web服务的性能边界。压力测试能够回答以下问题：
的组件在超过某个临界值时并不能优雅地降级，而是灾难性地失败。工程师使用压力测
为了安全地操作某个系统，SRE需要理解系统和组件的性能边界。在很多案例中，单独
压力测试
进行对比。
162
注5
注4
1台，然后部属2台，然后4台等）下，一个对用户流量影响不大的Bug情况。我们预计，
为了提供一个现实的金丝雀测试案例，我们来考虑在一个指数型升级部署流程（先部属
力测试可以测试在某种特定情况下的服务的特殊表现，而金丝雀测试更多的是比较随意
金丝雀测试并不真的是一个测试，而是一种结构化的最终用户验收测试。配置测试和压
指代这个过程。
会被逐渐升级到新版本。
定的孵化期。如果没有任何未预料的问题发生，发布流程会继续，其他的软件服务器也
要进行一次金丝雀测试，一小部分服务器被升级到一个新版本或者新配置，随后保持一
·向某应用每秒发送多少个请求，将导致应用过载并导致请求处理失败。
·数据库容量满到什么程度，才会导致写请求失败。
·根据共享的运行时的某个特殊行为（使得测试还要取决于该运行时的版本）。
·隐式地加入二进制文件中包含的默认值（这样查询返回的结果就和提交的版本不一
小时25分钟。
从距离上来说，假设24小时内在1%~10%区间持续部属，K=86400/Ln0.1/0.01）=37523秒，即10
倍推进。
。
一个常见标准是，
预处理器的结果)。
配置文件作为一个预处理器（例如Bash）的命令行参数使用（导致结果取决于
致）。
第17章测试可靠性
：当配置代码做以下事情的时候，测试就变得复杂起来：
与此同时，
，变更部属应该以影响0.1%的用户流量的服务容量开始，
。注4如果发生了问题，这个单独修改过的软件服务器可以很快被
注5
同时按每24小时增长10
---
## Page 205
困难的工作。然而，我们可以将测试的重点集中在用最小力气得到最大收益的地方。
果目前基本没有测试，那么针对每个关键函数和类编写单元测试可能看起来是一项非常
完整的测试还没有写出来，甚至没有设计出来。在这种情况下，从哪里开始测试呢？如
甚至可能这时仅仅是所有的UIMock刚刚被批准。这时的项目代码仅仅停留在原型阶段，
刚刚验证了他们的研究模型，也可能刚刚验证了他们的算法是可以扩展到更大规模的，
上SRE经常在一个项目已经开工一段时间之后才加入团队。这时，这个团队的项目可能
虽然在项目开工第一天就开始考虑测试的类型以及各种失败场景是很美好的愿望，实际
创造一个构建和测试环境
（这当然最好是1了）。
略可以有效降低最终用户遇到的问题累计值C，同时仍然可以尽早提供一个U的预估值
够触发这个Bug。顺序地使用多个流量区分方式可以提供一些余，使K减小。这种策
时间内增长同样的倍数，U的估计值就将是有效的。哪怕你不知道哪种区分方式真正能
有的时候发布流程不需要绝对公平地区分用户流量，只要这种区分方式能够在同样的K
当采取指数型发布策略的时候，一定要将前述的低阶Bug和高阶Bug的区别记在心中
不再失败了。在发布过程中，能够找到这种Bug非常重要，否则，我们的运维压力会增
所有前序请求按顺序执行过之后某一个不停失败的请求，可能在打乱前续请求的环境里
免它们未来重现。但是对高阶Bug来说，这样的策略就没用了：在高阶Bug作用下，在
献[Per07])。我们一般可以通过查看日志将一些异常的请求回应变成新的回归测试来避
大部分的Bug 都是U=1级别的：这些Bug的出现频率与用户流量成线性正比（参见文
将这些值除以K可以得出一个估计值U，也就是错误等级准6。
长得非常快。
速率R代表。
间内，有可能产生了一些额外的错误报告。所有这些错误报告可以用之前的累计值C和
置。在部署开始后到自动化系统收集到相应的异常信号并且做出回滚响应之前的一段时
为了避免对用户造成影响，部署流程一旦遇到不可接受的问题需要快速回滚到之前的配
●U=3：随机损坏的数据也包括前序请求需要使用的数据（意味着该问题不可重现）
notationo
●U=1：用户请求只是触发了某段逻辑错误的代码。
U=2：用户的请求可能会随机损坏到未来该用户可能会访问的数据（意味着该问<190
题必须严格按顺序访问才能重现）。
创造一个构建和测试环境
163
---
## Page 206
注7有关这个主题的更多讨论，我们推荐参考文献[Blal4]，作者是我们以前的合作者MikeBland。
候敏捷性需要靠稳定性来驱动。如果每次代码构建的结果都坚如磐石非常可靠时，开发
稳定性和敏捷性通常在SRE的世界中是互相矛盾的。但是上面最后一点反而证明了有时
的工程师时，他们应该放下手中的一切其他任务，优先处理该问题。这样做的原因在于：
建立良好测试的软件的另外一项关键任务是建立起一套良好的测试基础设施。测试基础
师修复好Bug，测试用例也一个一个通过，这样用不了多久你就会有一套完善的回归测
变成了一个测试用例，每个测试用例都应该在问题修复好之前处于失败状态。随着工程
一种建立强测试文化的方式注7是将所有遇到的问题都进行测试案例化。如果每个Bug都
更全面测试过的软件。
住大部分的明显问题。这种低成本、高收益的行为应该作为第一步，从而建立起更可靠、
发布明显的故障代码是开发者最备受指责的行为。在发布前建立一系列冒烟测试可以抓
可以先从如下的问题开始：
164
程师，随时保持最新版本的代码处于正常工作状态非常重要。当构建系统通知搞坏代码
进行一次构建。我们发现最有效的方式就是，构建系统可以实时通知提交这个改变的工
一旦这套体系建立起来之后，我们就可以增加一套持续构建系统，将每一次代码改变都
设施的基础是一套版本化源代码控制体系，可以追踪源代码的每一个改变。
试体系了。
·哪些API是其他团队需要集成使用的？有时最终用户级别的测试能够找到的问题
·是否能够将源代码按重要程度分出优先级？用研发管理和项目管理的行话来说，
团队响应紧急发布的能力将会受到严重影响，甚者非常复杂和困难（例如，发现
如果问题引入系统之后，又有新的变动，修复会更难。