Lemma VI.2, I
Corollary VI.1. For any (cid:10)P, μ(cid:11), SMEL((cid:10)P, μ(cid:11)) is ITSNI.
2|l and O1|l = O2|l.
(cid:2)
From Corollary VI.1, SMEL is sound w.r.t. ITSNI. Unfortu-
nately, SMEL is not precise w.r.t. ITSNI. The reason is that the
high execution may starve and hence, there is no input events
consumed or no output events generated on high channels. An
example illustrating this case is described in Example VI.3
Example VI.3 (SMEL not precise w.r.t. ITSNI). Suppose that
the lattice has two levels: L (cid:3) H and the level of chH is H.
We consider the following program.
1: output 1 to chH
2: while 1 do skip
This program only sends a ﬁxed output event to the high
channel and it does not generate any visible output at L. This
program is ITSNI. When we run this program with SMEL, the
execution at L is scheduled to run ﬁrst and its output event to
chH is suppressed by SMEL. Since the execution at L runs
forever, the execution at H starves and hence, there is no
output event sent to chH by SMEL. In other words, SMEL is
not precise w.r.t. ITSNI.
B. Fair scheduler
SME with a fair scheduler [15] is denoted by SMEF. W.r.t.
a fair scheduler, no local execution starves. Thus, we have the
following property for SMEF. Notice that here we abuse the
notation and use (cid:2)S for the transition relation of SMEF. We
write (cid:2)S
for the transitive and reﬂexive closure of (cid:2)S.
∗
Property VI.2. For any lecs of SMEF and l,
lecs(l) = (cid:10)P, μ, W(cid:11)l ∧ P (cid:6)= skip =⇒
(cid:2)(cid:2)
lecs
(cid:2)(cid:2)) = l ∧ lecs
, lecs
select(lecs
(cid:2) : lecs (cid:2)S
∃lecs
(cid:2)(cid:2)
∗
(cid:2) ∧
(cid:2)S lecs
(cid:2)(cid:2)(l) = (cid:10)P, μ, W
(cid:2)(cid:11)l.
(cid:2)
(cid:2)
, O(cid:11). Intuitively, if (cid:10)(cid:10)lecs, I(cid:11)(cid:11)(l) = (cid:10)I
We next establish the relation between the input consumed
and the output generated by SMEF and the corresponding ones
by local executions. In order to do so, given lecs and I, we
deﬁne (cid:10)(cid:10)lecs, I(cid:11)(cid:11) that constructs a function from levels to tuples
, O(cid:11), then
of the form (cid:10)I
(cid:2) and generates
the local execution lecs(l) consumes the input I
the output O. Since the local execution can only consume
directly input events at level l, and can only generate output
event at l, for (cid:10)(cid:10)lecs, I(cid:11)(cid:11)(l) = (cid:10)I
(cid:2) and O
have only events at l.
In order to deﬁne (cid:10)(cid:10)lecs, I(cid:11)(cid:11), we deﬁne some auxiliary
notations. We deﬁne I (cid:23)l that returns the input with streams
on channels at l, i.e. dom(I (cid:23)l) = {ch ∈ dom(I)|Γ(ch) = l}
and for any ch ∈ dom(I (cid:23)l), I (cid:23)l (ch) = I(ch). Similarly, we
have O(cid:23)l.
, O(cid:11), we have that I
(cid:2)
To reason about the behavior of a local execution, we need
to know which input events are consumed by executions at
lower levels. Since a local execution may consume an inﬁnite
number of input events and the waiting input of a local
execution can only accept ﬁnite queues, we deﬁne lecx, an
extended version of state of local execution. An extended state
of a local execution is also of the form (cid:10)P, μ, W(cid:11)l. Different
from the (normal) state of a local execution, W in a lecx is
a mapping from channels to streams. The semantics for lecx
at level l is the same as the one of local execution (e.g. if it
needs an input event on a channel at l, it will consume one
(cid:2) (cid:3) l, it either consumes one from its waiting input or it
from the environment, if it needs an input event on a channel
at l
we can write lecx(I)(cid:2) (cid:10)I
has to wait). We have that lecx satisﬁes Deﬁnition III.1, hence,
The inductive deﬁnition of (cid:10)(cid:10)lecs, I(cid:11)(cid:11) is as below, where ⊥
is the smallest level of the lattice, lecs(l).P , lecs(l).μ, and
lecs(l).W are respectively the program, the memory, and the
waiting input in lecs(l), and [[l,(cid:10)(cid:10)lecs, I(cid:11)(cid:11)]] constructs a waiting
input for the local execution lecx at l by combining the current
waiting input with the inputs consumed by lower executions.
Here, to simplify the presentation, we abuse “:” and use it to
concatenate a ﬁnite queue to a stream.
, O(cid:11), where lecx = lecs(⊥), then
(cid:2)
, O(cid:11),
(cid:2)
, O(cid:11), then (cid:10)(cid:10)lecs, I(cid:11)(cid:11)(l) = (cid:10)I
, O(cid:11), where
• if lecx(I (cid:23)⊥) (cid:2) (cid:10)I
(cid:10)(cid:10)lecs, I(cid:11)(cid:11)(⊥) = (cid:10)I
• if lecx(I (cid:23)l)(cid:2)(cid:10)I
(cid:2)
lecx = (cid:10)lecs(l).P, lecs(l).μ, [[l,(cid:10)(cid:10)lecs, I(cid:11)(cid:11)]](cid:11)l, and
, O(cid:11).
(cid:2)
(cid:2)
⎧⎪⎨
[[l,(cid:10)(cid:10)lecs, I(cid:11)(cid:11)]](ch) (cid:2)
⎪⎩lecs(l).W (ch) : I
lecs(l).W (ch)
(cid:2)(ch)
if Γ(ch) (cid:3) l,
where (cid:10)(cid:10)lecs, I(cid:11)(cid:11)(Γ(ch)) = (cid:10)I
if Γ(ch) (cid:6)(cid:3) l.
(cid:2)
, O(cid:11),
505
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:28:58 UTC from IEEE Xplore.  Restrictions apply. 
Next we prove that
input events consumed and output
events generated by SMEF at level l are the same as the
corresponding ones by the local execution at l.
Lemma VI.3. For any lecs and I, suppose that lecs(I) (cid:2)
(cid:10)I
, O(cid:11), and for any l, (cid:10)(cid:10)lecs, I(cid:11)(cid:11)(l) = (cid:10)I
(cid:2)(cid:11). For any l, it
follows that I
Proof. The proof is in Appendix.
(cid:2)(cid:23)l and O
(cid:2) = O(cid:23)l.
(cid:2)(cid:2) = I
, O
(cid:2)(cid:2)
(cid:2)
We now can prove that SMEF is ITSNI.
Theorem VI.2 (Soundness). For any lecs, lecs is ITSNI.
Proof. The proof is in Appendix.
Corollary VI.2. For any (cid:10)P, μ(cid:11), SMEF((cid:10)P, μ(cid:11)) is ITSNI.
(cid:2)
We now prove that SMEF is a precise enforcement mecha-
nism of ITSNI.
Theorem VI.3 (Precision). SMEF is precise w.r.t. ITSNI.
Proof. Let Q be the state that is ITSNI, Q(I)(cid:2) (cid:10)I
, O(cid:11) and
SMEF(Q)(I)(cid:2) (cid:10)I
We deﬁne (cid:25)I(cid:26)l that returns an input where for any ch, if ch
(cid:2) (cid:6)(cid:15) l, it is mapped to Dch, a stream of default input
is at levels l
events for ch (that is any input event in Dch is ch(def(ch))).
(cid:2)(cid:11).
, O
(cid:2)(cid:2)
(cid:2)
(cid:2)(cid:2)
O
I(ch)
Dch
(cid:25)I(cid:26)l(ch) =
⊥, and O1⊥(cid:23)⊥= O⊥.
(cid:2)
We write lecs for SMEF(Q). For any l, we have that
(cid:2)
if Γ(ch) (cid:15) l,
if Γ(ch) (cid:6)(cid:15) l.
(cid:2)(cid:11) and for any l, Q((cid:25)I(cid:26)l)(cid:2)
lecs(l) = Q. Let lecs(I)(cid:2) (cid:10)I
1l, O1l(cid:11), and lecxl(I (cid:23)l)(cid:2) (cid:10)I
, O
l , Ol(cid:11).
(cid:10)I
(cid:2)
(cid:2)|l = I
(cid:2)(cid:2)|l and O|l =
1l(cid:23)l= I
l and O1l(cid:23)l= Ol, I
(cid:2)
(cid:2)
We prove I
(cid:2)(cid:2)|l by induction on l.
lecx⊥(I (cid:23)⊥) (cid:2) (cid:10)I
l = ⊥. Let
⊥, O⊥(cid:11) and
(cid:2)
Q((cid:25)I(cid:26)⊥)(cid:2)(cid:10)I
Base case:
1⊥, O1⊥(cid:11). We have that lecx = lecs(⊥) = Q. We
(cid:2)
also have that (cid:25)I(cid:26)⊥(cid:23)⊥= I (cid:23)⊥. From the semantics of original
program and the semantics of local execution, we have that
1⊥(cid:23)⊥= I
(cid:2)
I
Since Q is ITSNI, and I|⊥ = (cid:25)I(cid:26)⊥|⊥, we have that I
(cid:2)|⊥ =
, O(cid:11) and Q((cid:25)I(cid:26)⊥)(cid:2)
1|⊥ and O|⊥ = O1|⊥ (where Q(I)(cid:2)(cid:10)I
(cid:2)
(cid:2)
I
(cid:10)I
(cid:2)(cid:23)⊥= O⊥.
1, O1(cid:11)). From Lemma VI.3, I
(cid:2)(cid:2)(cid:23)⊥= I
(cid:2)
(cid:2)
⊥ and O
1⊥ (cid:23)⊥= I
(cid:2)(cid:2) (cid:23)⊥= I
(cid:2)
(cid:2)
(cid:2)
Therefore, we have that I
⊥, I
⊥, and
(cid:2)(cid:2)(cid:23)⊥
(cid:2)(cid:23)⊥= I
1⊥(cid:23)⊥. Thus, I
(cid:2)|⊥ = I
(cid:2)
I
(cid:2)(cid:2)|⊥. Similarly, O|⊥ = O
(cid:2)|⊥.
(cid:2) (cid:3) l
and hence, I
(IH). We now consider l. From the semantics of SME, the
is I1 = I (cid:23)l. The
input provided to the execution at l
waiting input for this execution is W = [[l,(cid:10)(cid:10)lecs, I(cid:11)(cid:11)]]. Let
lecxl(I1)(cid:2) (cid:10)I
1l, O1l(cid:11). We now prove
(cid:2)
1(cid:23)l= I
(cid:2)
l , Ol(cid:11), and Q((cid:25)I(cid:26)l)(cid:2) (cid:10)I
(cid:2)
l and O1(cid:23)l= Ol.
(cid:2)
that I
1 (cid:23)l(cid:6)= I
(cid:2)
(cid:2)
l or
1 (cid:23)l(cid:6)= I
O1 (cid:23)l(cid:6)= Ol. We consider the case where I
(cid:2)
(cid:2)
l (the
1 (cid:23)l(cid:6)= I
(cid:2)
(cid:2)
l,
proof for the remaining case is similar). Since I
there exists I0 (which has only input events at l) and Ia
s.t. Ia (cid:23)l = I0, Q
(cid:2) and
Ia→ Q
lecx(cid:2)
(cid:2)
consume different input events at l, where Q
For the sake of contradiction, suppose that I
the two statements holds for all
1⊥|⊥ and hence, I
(cid:2)
(cid:2) and lecxl
I0→E lecx(cid:2)
Suppose that
(cid:2)(cid:23)⊥= I
(cid:2)|⊥ = I
l, and Q
Ia→ Q
l
(cid:2)
(cid:2)
(cid:2)
(cid:2)
.μ, where Q
.μ = lecx(cid:2)
(cid:2). We claim that
mean that Q consumes Ia and goes to Q
.P = lecx(cid:2)
.P is the
.P and Q
Q
(cid:2). Suppose that
(cid:2)
(cid:2) and Q
.μ is the memory in Q
program in Q
.P (cid:6)= lecx(cid:2)
.μ (cid:6)= lecx(cid:2)
(cid:2)
.μ. Since the programs and
.P or Q
Q
(cid:2) (cid:3) l. Thus, we have that Il(cid:2) (cid:6)= I1l(cid:23)l(cid:2).
memories in Q and lecx are the same, they must consume a
different input event at l
Since Q is ITSNI, we have that Il(cid:2) (cid:6)= I1l(cid:2) (cid:23)l(cid:2). Contradiction.
(cid:2) and lecx(cid:2)
s.t. Q
.P and
Therefore, we consider Q
(cid:2) and lecx(cid:2)
.μ = lecx(cid:2)
(cid:2)
must consume the same
.μ. Hence, Q
Q
input event at l. Contradiction.
Since Q is ITSNI, and I|l = (cid:25)I(cid:26)l|l, we have that I
(cid:2)|l =
, O(cid:11) and Q((cid:25)I(cid:26)l) (cid:2)
1l|l and O|l = O1l|l, where Q(I) (cid:2) (cid:10)I
(cid:2)
(cid:2)
I
1l, O1l(cid:11). From Lemma VI.3, I
(cid:2)(cid:23)l= Ol(cid:2).
(cid:2)(cid:2)(cid:23)l= I
(cid:10)I
(cid:2)
(cid:2)
l(cid:2) and O
1l (cid:23)l= I
(cid:2)|l =
(cid:2)
(cid:2)
(cid:2)
Therefore, we have that I
l, and I
l, I
1l|l and hence I
(cid:2)(cid:2)(cid:23)l. From IH, for
(cid:2)(cid:23)l= I
(cid:2)
(cid:2) (cid:3) l, I
I
(cid:2)(cid:2)|l.
(cid:2)|l = I
any l
Similarly, O|l = O
(cid:2)(cid:2) (cid:23)l= I
1l(cid:23)l. Thus, I
(cid:2)
(cid:2)(cid:2)|l(cid:2). Hence, it follows that I