title:Cryptographic Security for Mobile Code
author:Joy Algesheimer and
Christian Cachin and
Jan Camenisch and
G&quot;unter Karjoth
Cryptographic Security for Mobile Code 
Joy Algesheimer 
Christian Cachin 
Jan Camenisch 
Gun ter Karj 0th 
IBM Research 
{jmu,cca, jca,gka}@zurich.ibm.com 
Zurich Research Laboratory 
CH-8803 Ruschlikon, Switzerland 
Abstract 
This paper addresses the protection of mobile code against 
cheating and potentially malicious hosts.  We point out that 
the recent approach based on computing with  “encrypted 
functions” is limited to the case where onlj the code origi- 
nator learns the result of the computation and the host run- 
ning  the code  must not notice anjthing  at all.  We argue 
that if  the host is to receive some output of the computation, 
then securing  mobile code requires minimal trust in a third 
party.  Tamper-proof hardware installed  on each host has 
been proposed for this purpose.  In this paper we introduce 
a new approach for securely  executing  (fragments of)  mo- 
bile code that relies on a minimally trusted third party.  This 
party is a generic independent entity, called the secure com- 
putation service, which pelforms some operations on behalf 
of the mobile application, but does not learn anything about 
the encrypted  computation. Because it is universal, the se- 
cure computation service needs to be only minimally trusted 
and  can serve  many diflerent  applications.  We present a 
protocol based on tools from theoretical  cpptography that 
is quite practical for computing small functions. 
1  Introduction 
Mobile code is an important programming paradigm for 
our  increasingly  networked  world.  It  provides  a  flexible 
way to structure cooperative computation in distributed sys- 
tems.  Already  today,  the  Internet  is  full  of  mobile  code 
fragments, such as Java applets, which  represent  only  the 
simplest form of mobile code. 
Mobile  agents are mobile  code that  acts  autonomously 
on behalf  of a user for continuous collecting, filtering, and 
processing  of  information.  They  combine the  benefits  of 
the agent paradigm, such as reacting to a changing environ- 
ment and autonomous operation, with the features of remote 
code execution; they operate in computer networks and are 
capable  of  moving  from  server  to  server  as  necessary  to 
fulfill  their  goals.  Important  applications  include  mobile 
computing,  where  bandwidth  is  limited  or  users  are  dis- 
connected, data retrieval  from large repositories, and  con- 
figuration management of software and networks.  Today’s 
vision  of mobile agents roaming the Internet may soon be- 
come reality  as the paradigm is incorporated in  large-scale 
applications. 
Although sound  definitions  of mobile computations are 
still  under debate (e.g., [ 13]),  we  assume here  that mobile 
code is a program that is produced by one entity, called the 
originator, and is subsequently transferred  to a second en- 
tity, the host, immediately before it is executed by the host. 
In other words, no manual intervention (such as performing 
an installation or running a setup routine) is required on be- 
half of the host; mobile code comes ready to run. Moreover, 
mobile agents are capable of continued, autonomous oper- 
ation  disconnected from the  originator and  migrate  freely 
to other hosts  during their  lifetime.  Such agents have also 
been called itinerant agents. 
Mobile  Code  Security.  Two security  problems  arise  in 
the area of mobile code:  (1) protecting the  host  from ma- 
licious  code  and  (2)  protecting  the  code  from  malicious 
hosts.  The first  problem  has received considerable atten- 
tion because of the imminent threat of computer viruses and 
Trojan horses-nothing 
but prominent members of the mo- 
bile agent family.  Current solutions are to run mobile code 
in  a sandbox with fine-grained access control and to apply 
code  signing for exploiting a  trust  relation  with  the  code 
producer. We address the second problem in this paper: pro- 
tecting the mobile application. Solutions for this are far less 
developed, but this problem needs to be solved for making 
the mobile agent metaphor useful  in many contexts. 
Mobile code is exposed to various security threats:  a ma- 
licious host may  examine the code, try  to learn  the secrets 
carried by an agent, and exploit this knowledge in its inter- 
action  with  the  agent to gain an  unfair advantage.  A  host 
1081-6011/01 $10.0002001 IEEE 
2 
might also try  to manipulate the  result  of  a  computation. 
We  do not  address denial-of-service attacks here, such as 
killing the agent.  Our goal is to achieve secrecy for mobile 
applications and integrity for their outputs in the traditional 
sense of information security. 
Protecting mobile code was deemed impossible by some 
mobile code researchers until Sander and Tschudin [22] re- 
alized  that  protocols from  theoretical  cryptography could 
be  useful  to execute mobile code in  an  encrypted form on 
an  untrusted  host.  However,  most  such  protocols for  so- 
called secure computation [ 16, l ]  require several rounds of 
interaction  and are therefore  not applicable in  our context. 
Sander and Tschudin  concluded that  only  functions repre- 
sentable as polynomials  can be computed securely  in  this 
manner. Subsequent work of Sander et al. extends this to all 
functions computable by circuits of logarithmic depth [23]. 
Recently  some of  us together  with  Kilian  have  found a 
protocol  for  computing all  polynomial-time functions ef- 
ficiently  [7], which  solves the  mobile code privacy  prob- 
lem  in  this  form.  In  particular,  this  protocol  allows  any 
polynomial-size  circuit to be evaluated securely in polyno- 
mial time using only one round of interaction. 
However, this  approach  has a serious drawback:  no  in- 
formation about the encrypted computation must leak to the 
host and  only the originator may  receive any output.  This 
rules out any active mobile code that performs some imme- 
diate action  on the host (like a mobile agent in a shopping 
scenario that accepts or rejects an offer of its host based  on 
a secret strategy  [27]).  The impossibility  of protecting  ac- 
tive mobile code is  demonstrated in  Section  2  below;  the 
basic problem  is that a malicious host can observe the out- 
put of the computation and simply run the code again with 
a different input. 
The only existing defense for active mobile code against 
a malicious host uses trusted  hardware.  This has been  pro- 
posed  by  Yee  [27] and  by  Wilhelm  et al. [2S] and entails 
running mobile code exclusively  inside tamper-proof  hard- 
ware, encrypting it as soon as it leaves the trusted environ- 
ment.  The implicit assumption  one must make here is that 
all users  trust  the  manufacturer of  the hardware.  Such an 
assumption seems very strong and it is unclear whether the 
benefits of  the  mobile code software  paradigm justify  the 
deployment of  an  expensive  hardware  infrastructure  (un- 
like the example of a DVD player using tamper-proof hard- 
ware, which primarily provides the functionality of playing 
video). 
Our Contribution.  In  this paper,  we introduce an archi- 
tecture  for  secure  execution  of  active  mobile  code  frag- 
ments  that  needs  no  additional  client  hardware.  Instead, 
we propose  a generic  secure  computation service  that per- 
forms some cryptographic operations on behalf of the mo- 
bile  code; it guarantees privacy  as  well  as  integrity  of  the 
computation to the code originator and its host.  Moreover, 
the computation service itself does not learn anything about 
the computation; it must only be trusted  not to collude with 
the originator or the host. 
Our architecture builds on tools for secure computation 
from  cryptology  and  applies them  in  new  ways.  In  par- 
ticular,  we  employ  Yao’s “encrypted circuit  construction” 
for  scrambling  a  circuit  that  computes  the  desired  func- 
tion  [26]. Such methods had been thought of theoretical  in- 
terest only, but current technology makes them appear prac- 
tical for small tasks where maintaining privacy justifies  this 
overhead. 
The generic nature of the proposed computation service 
has several benefits: 
Its  cost  can  be  shared  across many  applications be- 
cause  it  is  generic;  nothing about  its  usage  must  be 
known before deploying it. 
The trust  placed  in  its  integrity  is  universal  and  not 
bound to a particular service or to an application  con- 
text; secure computation servers may be set up and op- 
erated by independent entities. 
It is based on software and commodity hardware only 
and therefore much cheaper to build  and operate than 
any solution involving specialized hardware. 
In many respects, the secure computation service resembles 
other generic security  services like a public-key  infrastruc- 
ture (PKI) or an anonymous re-mailer.  These services also 
enhance security and privacy where needed. 
Organization of the  Paper.  Section 2  introduces a  lor- 
mal model  for mobile computations, formulates the desired 
security  properties, and  reviews  prior  work  for protecting 
mobile code.  It is shown why the approach based on “one- 
round secure computation” is not  suitable for securing ac- 
tive  mobile  code.  Our  architecture is  introduced  in  Sec- 
tion  3, and  Section 4  illustrates  two  applications:  a  com- 
parison  shopping agent and a generalized auction  scheme. 
Conclusions are drawn in Section S. 
2  Protecting Mobile Agents 
This section  formalizes mobile agent computations and 
states our  desired security  conditions.  The formal model 
is  then  used  to  argue why  protecting  active  mobile agents 
purely  by  software is  impossible without  further assump- 
tions. 
2.1  Model 
The defining  element of  a  mobile  code computation is 
that  it  proceeds  autonomously  and  independently  of  the 
3 
originator. We model mobile agent computation as follows. 
Participants: There  are  an  originator  0  and  e  hosts 
HI,. . . ,He, on which the mobile agent runs. 
Non-interactive communication:  Each  participant  sends 
and receives only a single message. We denote by mo 
the message that 0 sends to HI  and by m,  the mes- 
sage that H,  sends to H3+1 for j = 1,. . . , 1 - 1, and 
by me  the message that the last host He  returns to 0. 
Computation:  Let the state of the mobile agent be an el- 
ement of a set X. Its initial  state zo  is determined by 
0. Let the input by  H:, be an element of a set y  and 
the  output to  H3 an  element  of  2 (input and  output 
domains are the same at all hosts for simplicity). The 
agent computation on  host H:, is  represented by  two 
functions 
gj  : X x y -+  X  and  hj : X x y -+ 2 
that determine the new state xj = g j ( z j - 1 ,  y3) of the 
agent and the output zj  = hj(xj-1, yj). 0 obtains the 
final state E  = xe E  X of the agent. The functions gi 
and hi are known to all parties. 
A  (non-interactive)  secure  mobile  computing  scheme 
consists of 21 + 2  algorithms do, AI,. . . ,de, &,. . . ,Be, 
and V such that for all j  = 1,. . . ,  and 50 E X, yj E Y ,  
and with 
mo  = A o ( ~ o )  
m3 = dJ(m:,-lr 9,) f o r j  = 1,. . . , e  
z3 =B3(m3-l,y3)forj=1,...r! 
= D(me) 
the following two conditions hold 
Correctness:  = ge(ze-1, ye)  and zj  = hj(zj-1,yj) for 
j  = 1,. . . ,e, using 
X y   = gjs (. ‘ ’ (92 (91 ( 2 0 1  YI), Y2) . ’ .), Yjt 
forj‘ = 1,. . . , e  - 1. 
Privacy:  The inputs, outputs, and the computations of  all 
hosts  remain  hidderi  from the originator and from all 
other hosts, except for what follows from their outputs: 
0 learns only 6 but nothing else about any y j  than what 
follows from xo and e, and similarly,  H j   learns only 
z j  but  nothing about z o  and y j ~  for j’ < j  than  what 
follows from z j  and yj. 
These  requirements can  be  defined  formally  using  the 
simulation approach from cryptography [3, 18, 14, 81. Note 