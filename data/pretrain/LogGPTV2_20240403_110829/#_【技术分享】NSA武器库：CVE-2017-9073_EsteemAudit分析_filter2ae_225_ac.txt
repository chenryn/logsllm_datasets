这里pExtraBytes长度为2，接下来的两个额外字节分别是90 00在服务器上会被智能卡模块处理。
    len
    0178cf98  0000003c
pExtraBytes长度为0，是一个结束的响应包。这个数据包完成了EsteemAudit与客户端的交互，接着我们看看服务器端如何处理这些数据。
**RDP 服务器端**
在看完EsteemAudit和RDP服务器端交互的数据包各个字段的具体含义后，接下来我们关注服务器端如何处理这些数据、漏洞是如何被触发的和如何完成漏洞利用。
**内核态**
下面列出的两个调用栈信息直接展示了DEVICE_IO的处理流程。termdd是一个核心分发器(dispatcher)，RDPWD负责MSC协议栈，我们可以通过函数RDPWD!MCSIcaRawInput获取从客户端发送的原始数据。接下来的一些函数会将前面提到的RDP协议一层一层的解析。
    kd> k
    # ChildEBP RetAddr
    00 baf3b32c f6e134ef rdpdr!DrExchangeManager::RecognizePacket+0x8
    01 baf3b350 f6e12e34 rdpdr!DrSession::ReadCompletion+0x95
    02 baf3b368 8081d741 rdpdr!DrSession::ReadCompletionRoutine+0x38
    03 baf3b398 f76895d8 nt!IopfCompleteRequest+0xcd
    04 baf3b3d4 f768a0d2 termdd!IcaChannelInputInternal+0x1f0
    05 baf3b3fc ba1a26e1 termdd!IcaChannelInput+0x3c
    06 baf3b430 ba19c3c1 RDPWD!WDW_OnDataReceived+0x181
    07 baf3b458 ba19c1b9 RDPWD!SM_MCSSendDataCallback+0x159
    08 baf3b4c0 ba19bfe0 RDPWD!HandleAllSendDataPDUs+0x155
    09 baf3b4dc ba1b9ba4 RDPWD!RecognizeMCSFrame+0x32
    0a baf3b504 ba19b06b RDPWD!MCSIcaRawInputWorker+0x346
    0b baf3b52c f768d194 RDPWD!MCSIcaRawInput+0x65
    0c baf3b550 baa92fcb termdd!IcaRawInput+0x58
    0d baf3bd90 f768c265 TDTCP!TdInputThread+0x371
    0e baf3bdac 809418f4 termdd!_IcaDriverThread+0x4d
    0f baf3bddc 80887f4a nt!PspSystemThreadStartup+0x2e
    10 00000000 00000000 nt!KiThreadStartup+0x16
    kd> k
    # ChildEBP RetAddr
    00 f5a8b254 f6e14f22 rdpdr!RxLowIoCompletion+0x3a
    01 f5a8b260 f6e15291 rdpdr!DrDevice::CompleteRxContext+0x2a
    02 f5a8b284 f6e158b0 rdpdr!DrDevice::CompleteBusyExchange+0x4d
    03 f5a8b2cc f6e164b2 rdpdr!DrDevice::OnDeviceControlCompletion+0x116
    04 f5a8b2f0 f6e1269d rdpdr!DrDevice::OnDeviceIoCompletion+0x1ee
    05 f5a8b310 f6e1285a rdpdr!DrExchangeManager::OnDeviceIoCompletion+0x55
    06 f5a8b324 f6e1351f rdpdr!DrExchangeManager::HandlePacket+0x26
    07 f5a8b350 f6e12e34 rdpdr!DrSession::ReadCompletion+0xc5
    08 f5a8b368 8081d741 rdpdr!DrSession::ReadCompletionRoutine+0x38
    09 f5a8b398 f76c95d8 nt!IopfCompleteRequest+0xcd
    0a f5a8b3d4 f76ca0d2 termdd!IcaChannelInputInternal+0x1f0
    0b f5a8b3fc f53856e1 termdd!IcaChannelInput+0x3c
    0c f5a8b430 f537f3c1 RDPWD!WDW_OnDataReceived+0x181
    0d f5a8b458 f537f1b9 RDPWD!SM_MCSSendDataCallback+0x159
    0e f5a8b4c0 f537efe0 RDPWD!HandleAllSendDataPDUs+0x155
    0f f5a8b4dc f539cba4 RDPWD!RecognizeMCSFrame+0x32
    10 f5a8b504 f537e06b RDPWD!MCSIcaRawInputWorker+0x346
    11 f5a8b52c f76cd194 RDPWD!MCSIcaRawInput+0x65
    12 f5a8b550 f55b2fcb termdd!IcaRawInput+0x58
    13 f5a8bd90 f76cc265 TDTCP!TdInputThread+0x371
    14 f5a8bdac 809418f4 termdd!_IcaDriverThread+0x4d
    15 f5a8bddc 80887f4a nt!PspSystemThreadStartup+0x2e
    16 00000000 00000000 nt!KiThreadStartup+0x16
我们可以从IDA
pro中的注释看到RDPWD!MCSIcaRawInputWorker调用RDPWD!RecognizeMCSFrame时srcBuf的内容。
我们还可以看到RDPWD!RecognizeMCSFrame如何解析PER
当MCS协议栈解析完成后，RDPWD会解析TS_DATA_INFO。TS_DATA_INFO中被加密的数据会被SM_MCSSendDataCallback调用SMDecryptPacket->DecryptData->rc4进行解密。
我们在可以在RDPWD!rc4下断点来看服务端解密前和解密后的数据，类似之前的libeay32。
接着SM_MCSSendDataCallback函数会调用WDW_OnDataReceived来处理被解密的数据。
随后，函数会调用termdd!IcaChannelInput来向不同的channel派发被解密的数据。这个例子中，EsteemAudit发送的缓冲区溢出数据包是DEVICE_IO类型的，且属于File
System Virtual Channel Extension。将会被RDPDR模块解析。
我们在缓冲区溢出数据包中可以找到DR_DEVICE_IOCOMPLETION [MS-RDPEFS.pdf]头部
    000000f4 ->CodePage
    00000003 ->Flags
    Device Control Response (DR_CONTROL_RSP)
    ->DeviceIoReply (16 bytes): DR_DEVICE_IOCOMPLETION
    4472 ->RDPDR_CTYP_CORE 0x4472
    4943 ->PAKID_CORE_DEVICE_IOCOMPLETION 0x4943
在RDPDR模块中，我们可以看到虚表虚表中的函数被用来识别和处理数据包
如果服务器端收到了被标记为RDPDR_HEADER的数据包，对应的类会调用RecognizePacket函数
EsteemAudit发送的缓冲区溢出数据包和漏洞利用数据包设置了0x49434472的标志位。0x4472被设备重定向核心组件(Device
redirector core component)使用，0x4943用来做Device I/O响应。
在识别数据包类型后，rdpdr!DrSession::ReadCompletion会调用HandlePacket来解析数据包。我们可以看到OnDeviceControlCompletion函数处理数据包头部。
在处理完数据包后，我们可以看到rdpdr!DrDevice::CompleteRxContext通过IO通知已经处理完成相关的数据包。其他模块被通知继续处理剩下的数据包，在这里是pbExtraBytes。
**用户态**
在用户态中，winlogon.exe调用了智能卡模块，类似gpkcsp，scredir和winscard来和客户端进行交互。
首先，我们看看函数调用栈。这个调用栈是从内核态向用户态拷贝用户发送的数据pbExtraBytes时的。我们可以看到客户端发送到服务器端的数据从内核态进入用户态的流程。
    0:003> k
    ChildEBP RetAddr
    00fce058 5cd45619 scredir!_CopyReturnToCallerBuffer
    00fce104 723642b0 scredir!SCardTransmit+0x194
    00fce180 08005c32 WinSCard!SCardTransmit+0x76
    00fce1b0 0800921d gpkcsp!DoSCardTransmit+0x3d
    00fce41c 0800e2dd gpkcsp!WriteTimestamps+0x679
    00fcf39c 08004acb gpkcsp!MyCPAcquireContext+0x817
    00fcf708 77f50909 gpkcsp!CPAcquireContext+0x26e
    00fcf7cc 77f50a5f ADVAPI32!CryptAcquireContextA+0x55f
    00fcf834 0103fd78 ADVAPI32!CryptAcquireContextW+0xa4
    00fcf864 0104086c winlogon!CSCLogonInit::CryptCtx+0x75
    00fcf874 010408c1 winlogon!CSCLogonInit::RelinquishCryptCtx+0x10
    00fcf898 0103a8f5 winlogon!ScHelperGetCertFromLogonInfo+0x22
    00fcf8bc 77c50193 winlogon!s_RPC_ScHelperGetCertFromLogonInfo+0x3f
    00fcf8e0 77cb33e1 RPCRT4!Invoke+0x30
    00fcfce0 77cb35c4 RPCRT4!NdrStubCall2+0x299
    00fcfcfc 77c4ff7a RPCRT4!NdrServerCall2+0x19
    00fcfd30 77c7e732 RPCRT4!DispatchToStubInCNoAvrf+0x38
    00fcfd48 77c5042d RPCRT4!DispatchToStubInCAvrf+0x14
    00fcfd9c 77c50353 RPCRT4!RPC_INTERFACE::DispatchToStubWorker+0x11f
    00fcfdc0 77c511dc RPCRT4!RPC_INTERFACE::DispatchToStub+0xa3
    00fcfdfc 77c512f0 RPCRT4!LRPC_SCALL::DealWithRequestMessage+0x42c
    00fcfe20 77c58678 RPCRT4!LRPC_ADDRESS::DealWithLRPCRequest+0x127
    00fcff84 77c58792 RPCRT4!LRPC_ADDRESS::ReceiveLotsaCalls+0x430
    00fcff8c 77c5872d RPCRT4!RecvLotsaCallsWrapper+0xd
    00fcffac 77c4b110 RPCRT4!BaseCachedThreadRoutine+0x9d
    00fcffb8 7c824829 RPCRT4!ThreadStartRoutine+0x1b
    WARNING: Stack unwind information not available. Following frames may be wrong.
    00fcffec 00000000 kernel32!GetModuleHandleA+0xdf
gpkcsp!MyCPAcquireContext这个函数是负责发送，接受和处理智能卡数据包的，且与EsteemAudit中的函数RecvProcessSendPackets是相关的。
在介绍这个函数前，我们先看看scredir!SCardTransmit。这个函数被函数gpkcsp!DoSCardTransmit调用，是发送和接受智能卡数据的基础函数。
函数_SendSCardIOCTL的第一个参数为0x900d0代表SCARD_IOCTL_TRANSMIT。发送数据的和接受数据的数据结构_Transmit_Call和_Transmit_Return之前已经介绍过了。随后Transmit_Return_Decode会解码并处理从内核中得到的数据。scredir!_CopyReturnToCallerBuffe这个函数拷贝的数据来自于客户端发送的数据，且为保存在地址0x080190d8中的全局变量。这意味这缓冲区溢出数据包和漏洞利用数据包的数据将会被拷贝到地址0x080190d8中。这就是为什么在缓冲区溢出数据包和漏洞利用数据包中有这个地址被硬编码地址的原因。
接下来我们介绍gpkcsp!MyCPAcquireContext函数和整个的利用过程。函数SCardEstablishContext和ConnectToCard的细节不在此阐述，不过我们会介绍程序处理缓冲区溢出包的流程。
这是一个名为ProvCont的全局变量，被存储在大小是0x24a8的堆中
    0:003> dc gpkcsp!ProvCont (08176dd8)
    08176dd8  02cdcb58                             X…