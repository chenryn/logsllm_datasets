41270936
Stack
5
当遍历到数字4时，发现栈顶5>4，栈顶5出栈，数字4入栈。
---
## Page 381
原整数
5
127
0936
Stack
当遍历到数字1时，发现栈顶4>1，栈顶4出栈，数字1入栈。
原整数
1
93
Stack
1
然后继续遍历数字2、数字7，并依次入栈。
原整数
5
7
09
Stack
2
最后，遍历数字0，发现栈顶7>0，栈顶7出栈，数字0入栈。
---
## Page 382
原整数
1270936
Stack
1
2
Q
此时k的次数已经用完，无须再比较，让剩下的数字一起入栈即可。
原整数
Stack
120936
此时栈中的元素就是最终的结果。
上面的方法只对所有数字遍历了一次，遍历的时间复杂度是O(n)，把栈
转化为字符串的时间复杂度也是0(n)，所以最终的时间复杂度是0(m)。
同时，程序中利用栈来回溯遍历过的数字及删除数字，所以程序的空间
复杂度是0(n)。
哇，这段代码好巧妙啊！
---
## Page 383
这段代码其实仍然有优化空间，各位
读者可以思考一下。好了，关于这道题目我们就介绍到这里，感谢
大家！
5.10
如何实现大整数相加
5.10.1
加法，你会不会
小灰，你为什么只面
试我们一家公司啊？
因为我看好你
公司哦：
---
## Page 384
好吧，下面考你一道算法题，给你两个
很大很大的整数，如何求出它们的和？
题目
给出两个很大的整数，要求实现程序求出两个整数之和。
这还不简单？直接用long类型存储，
在程序里相加不就行了？
如果这两个整数大得连long类型都装不
下呢，如两个100位的整数？
---
## Page 385
啊，那怎么可能算得出来呢？是不是题
目出错了呀？
呵呵，题目没出错，回家等通知去吧！
啊这么快就挂掉
5.10.2
解题思路
---
## Page 386
小灰，你刚刚去面试了？结果怎么
样？
埃
大黄，你能不能给我讲讲，怎么
实现大整数的相加呀？
好啊，在讲解大整数相加之前，我们
---
## Page 387
先来回顾一下小学数学课。小灰，你在上小学时，如何计算两个较
大数目的加、减、乘、除？
让我想想啊......读小学的时候，老师好
像教我们列竖式进行计算，就像下面这样。
426709752318
+95481253129
522191005447
那么，我们为什么需要列出竖式来运
算呢？
---
## Page 388
因为对于这么大的整数，我们无
法一步到位直接算出结果，所以不得不把计算过程拆解成一个一个
子步骤。
说得没错。其实不仅仅是人脑，对于
计算机来说同样如此。
程序不可能通过一条指令计算出两个
大整数之和，但我们却可以把大运算拆解成若干小运算，像小学生
列竖式一样进行按位计算。
---
## Page 389
可是，如果大整数超出了long类
型的范围，我们如何来存储这样的整数呢？
这很好解决，用数组存储即可。数组
的每一个元素，对应着大整数的每一个数位。
在程序中列出的“竖式"究竞是什么样子呢？我们以426709752318+95
481253129为例，来看看大整数相加的详细步骤。
第1步，创建两个整型数组，数组长度是较大整数的位数+1。把每一个
整数倒序存储到数组中，整数的个位存于数组下标为0的位置，最高位
存于数组的尾部。之所以倒序存储，是因为这样更符合从左到右访问数
组的习惯。
腔歌A
8132579076240
X
9213521845900
第2步，创建结果数组，结果数组的长度同样是较大整数的位数+1，+1
的目的很明显，是给最高位进位预留的。
---
## Page 390
+
resuit
0000000000000
第3步，遍历两个数组，从左到右按照对应下标把元素两两相加，就像
小学生计算竖式一样。
在本示例中，最先相加的是数组A的第1个元素8和数组B的第1个元素
9，结果是7，进位1。把7填充到result数组的对应下标位置，进位的1填
充到下一个位置。
+
result
0000000000012
第2组相加的是数组A的第2个元素1和数组B的第2个元素2，结果是3，
再加上刚才的进位1，把4填充到result数组的对应下标位置。
result
00000000000+2
第3组相加的是数组A的第3个元素3和数组B的第3个元素1，结果是4，
把4填充到result数组的对应下标位置。
---
## Page 391
整豹A
8132579076240
9213521845900
result
0000000000+2
第4组相加的是数组A的第4个元素2和数组B的第4个元素3，结果是5，
把5填充到result数组的对应下标位置，
整豹A
+
Result
000000000S2
以此类推......一直把数组的所有元素都相加完毕。
+
result
第4步，
把result数组的全部元素再次逆序，去掉首位的o，就是最终结
果。
结果=522191005447
需要说明的是，为两个大整数建立临时数组，是一种直观的解决方案。
若想节省内存空间，也可以不创建这两个临时数组。
---
## Page 392
明白了，真是个好方法！那么，怎么
用代码来实现呢？
代码很简单，我们一起来看看。
1. /**
2.*大整数求和
3.*@param bigNumberA
大整数A
4.*@param bigNumberB
大整数B
6. public static String bigNumberSum(String bigNumberA,
String bigNumberB) {
7.
//1.把两个大整数用数组逆序存储，数组长度等于较大整数位数+1
8.
int maxLength = bigNumberA.length() > bigNumberB.length(
?bigNumberA.length():bigNumberB.lengt
9.
int[] arrayA = new int[maxLength+1];
10.
for(int i=0; i= 10){
26.
temp = temp-10;
27.
result[i+1] = 1;
28.
29.
result[i] = temp;
30.
31.
//4.把result数组再次逆序并转成String
32.
StringBuilder sb = new StringBuilder();
33.
//是否找到大整数的最高有效位
---
## Page 394
34.
boolean findFirst = false;
35.
for （int i=result.length-1;i >=0;i--）{
36.
if(!findFirst){
37.
if(result[i] == 0){
38.
continue;
39.
}
40.
findFirst = true;
41.
}
42.
sb.append(result[i]);
43.
44.
return sb.toString(）;
45.}
46.
47. public static void main(String[] args) {
48.
System.out.println(bigNumberSum("426709752318","954812
49.}
小灰，你说说这个算法的时间复杂度
是多少？
---
## Page 395
如果给出的大整数的最长位数是
n，那么创建数组、按位计算、结果逆序的时间复杂度各自都是
O(n)，整体的时间复杂度也是0(n)。
说的没错，不过当前的思路其实还存
在一个可优化的地方。
如何优化呢？
我们之前是把大整数按照数位来拆分的，即如果较大整数有50位，那么
我们就需要创建一个长度为51的数组，数组中的每个元素存储其中一位
数字。
50位大整数
长度为51的数组，每个元素存储1位数字
那么我们真的有必要把原整数拆分得这么细吗？显然不需要，只需要拆
分到可以被直接计算的程度就够了。
---
## Page 396
int类型的取值范围是-2147483648~2147483647，最多可以有10位整
数。为了防止溢出，我们可以把大整数的每9位作为数组的一个元素，
进行加法运算。（这里也可以使用long类型来拆分，按照int类型拆分仅
仅是提供一个思路。）
50位大整数
9位数
9位数
9位数
9位数
9位数
9位数
长度为6的数组，每个元素存储9位数字
如此一来，内存占用空间和运算次数，都压缩到了原来的1/9。
在Java中，工具类BigInteger和
BigDecimal的底层实现同样是把大整数拆分成数组进行运算的，和
这个思路大体类似。
有兴趣的话，可以看看这两个类的源
代码。好了，关于大整数加法，就介绍到这里，咱们下一节再见！
---
## Page 397
5.11
如何求解金矿问题
5.11.1
一个关于财富自由的问题
小灰，你今天面试挂掉
以后走楼梯下去，我们
的电梯正在维修。
好的，多谢
提醒：
下面考你一道算法题，这个算法题目和
钱有关系。
题目
很久很久以前，有一位国王拥有5座金矿，每座金矿的黄金储量不同，
---
## Page 398
需要参与挖掘的工人人数也不同。例如有的金矿储量是500kg黄金，需
要5个工人来挖掘；有的金矿储量是200kg黄金，需要3个工人来挖
掘......
如果参与挖矿的工人的总数是10。每座金矿要么全挖，要么不挖，不能
派出一半人挖取一半的金矿。要求用程序求出，要想得到尽可能多的黄
金，应该选择挖取哪几座金矿？
总共10名工人
200kg黄金/3人
300kg黄金/4人
350kg黄金/3人
400kg黄金/5人
500kg黄金/5人
哇，要是我家也有5座金矿，我就财富自
由了，也用不着来你这里面试了！
说正经的！关于这道题你有什么思路
吗？
---
## Page 399
题目好复杂啊，让我想想..
我想到了一个办法！我们可以按照金
矿的性价比从高到低进行排序，优先选择性价比最高的金矿来挖
掘，然后是性价比第2的..
按照小灰的思路，金矿按照性价比从高到低进行排序，排名结果如下。
第1名，350kg黄金/3人的金矿，人均产值约为116.6kg黄金。
第2名，500kg黄金/5人的金矿，人均产值为100kg黄金。
第3名，400kg黄金/5人的金矿，人均产值为80kg黄金。
第4名，300kg黄金/4人的金矿，人均产值为75kg黄金。
第5名，200kg黄金/3人的金矿，人均产值约为66.6kg黄金。
由于工人数量是10人，小灰优先挖掘性价比排名为第1名和第2名的金矿
之后，工人还剩下2人，不够再挖掘其他金矿了。
所以，小灰得出的最佳金矿收益是350+500即850kg黄金。
---
## Page 400
怎么样？我这个方案妥妥的吧？
你的解决思路是使用贪心算法。这种思
路在局部情况下是最优解，但是在整体上却未必是最优的。
给你举个例子吧，如果我放弃性价比最
高的350kg黄金/3人的金矿，选择500kg黄金/5人和400kg黄金/5人的
金矿，加起来收益是900kg黄金，是不是大于你得到的850kg黄金？
---
## Page 401
啊，还真是呢！
呵呵，没关系，回家等通知去吧！
唤，看来我一时半会儿是
实现不了财富自由了
5.11.2
解题思路
小灰，你刚刚去面试了？结果怎么
---
## Page 402
样？
喉
大黄，你能不能给我讲讲，怎么
来求解金矿问题呀？
好啊，这是一个典型的动态规划题
目，和著名的"背包问题"类似。
---
## Page 403
动态规划？好“高大上"的概念
呀！
其实也没有那么高深啦。所谓动态规
划，就是把复杂的问题简化成规模较小的子问题，再从简单的子问
题自底向上一步一步递推，最终得到复杂问题的最优解。
哦，说了半天还是没听明白...
---
## Page 404
没关系，让我们具体分析一下这个金
矿问题，你就能明白动态规划的核心思想了。
首先，对于问题中的金矿来说，每一个金矿都存在着“挖"和“不挖"两种