#BHUSA @BlackHatEvents
Devils Are in the File Descriptors: 
It Is Time To Catch Them All
Le Wu from Baidu Security
Le Wu(@NVamous)
•
Focus on Android/Linux bug hunting and exploit 
•
Found 200+ vulnerabilities in the last two years
•
Blackhat Asia 2022 speaker
About me
2
Outline
 Background
 Diving into issues in the fd export operations
 Diving into issues in the fd import operations
 Conclusion & Future work
3
Introduction to file descriptor—— An integer in a process
Process A
fd:0
file ojbect0
file object_n
file ojbect1
fd:1
fd:n
…
read(fd, …), write(fd, …), ioctl(fd, …), mmap(fd, …), close(fd) …
Thread1
…
Thread_M
Background
…
User Space
Kernel Space
4
Process A
User Space
fd:0
file ojbect0
Kernel Space
file object_n
file ojbect1
fd:1
fd:n
…
…
read(fd, …), write(fd, …), ioctl(fd, …), mmap(fd, …), close(fd) …
Thread1
…
Thread_M
Background
fd_array
[0]
[1]
[n]
…
NULL
…
Introduction to file descriptor—— An integer in a process
5
User Space
Kernel space
export operation
Introduction to file descriptor——fd export operation and import operation in kernel
import operation
Background
fd
file
fd
file
6
Process A
User Space
fd:0
file ojbect0
Kernel Space
file object_n
file ojbect1
fd:1
fd:n
…
…
read(fd, …), write(fd, …), ioctl(fd, …), mmap(fd, …), close(fd) …
Thread1
…
Thread_M
Background
fd_array
[0]
[1]
[n]
…
…
Introduction to file descriptor—— fd export operation in kernel
[x]
file object_x
fd:x
Step1: get an unused fd
Step2: fd_array[fd]=file
Step3: pass fd to user space
7
Process A
User Space
fd:0
file ojbect0
Kernel Space
file object_n
file ojbect1
fd:1
fd:n
…
…
read(fd, …), write(fd, …), ioctl(fd, …), mmap(fd, …), close(fd) …
Thread1
…
Thread_M
Background
fd_array
[0]
[1]
[n]
…
…
Introduction to file descriptor—— fd import operation in kernel
fd:x
[x]
file object_x
Step1: file=fd_array[x]
Step2: acquire file reference
8
User Space
Kernel space
file
fd
Step1:get an unused fd
Step2:fd_array[fd]=file
Step3:pass the fd to user space
Introduction to file descriptor——fd export operation and fd import operation
Step1:file=fd_array[fd]
Step2:acquire file reference
import operation
file
fd
export operation
Background
9
Process A
User Space
fd:0
file ojbect0
Kernel Space
file object_n
file ojbect1
fd:1
fd:n
…
…
read(fd, …), write(fd, …), ioctl(fd, …), mmap(fd, …), close(fd) …
Thread1
…
Thread_M
Background
fd_array
[0]
[1]
[n]
…
…
fd:x
[x]
file object_x
Introduction to file descriptor—— User process close(fd)
10
Process A
User Space
fd:0
file ojbect0
Kernel Space
file ojbect1
fd:1
fd:n
…
…
read(fd, …), write(fd, …), ioctl(fd, …), mmap(fd, …), close(fd) …
Thread1
…
Thread_M
Background
fd_array
[0]
[1]
[n]
…
NULL
…
fd:x
[x]
Introduction to file descriptor—— User process close(fd)
Step1: fd_array[fd]=NULL
Step2: drop file reference, set fd unused
file object_n
file object_x
11
Why file descriptor——Inspired by CVE-2021-0929
Import dma-buf fd to get a dma_buf file object
Map the memory buffer represented by the  ion_handle into kernel space:
kernel_vaddr= ion_map_kernel(ion_client, ion_handle);
Reference the kernel_vaddr;
UAF
Thread A
Kernel space
Create a dma-buf fd with ION
sync.flag = DMA_BUF_SYNC_END;
ioctl(dma-buf fd, DMA_BUF_IOCTL_SYNC, &sync);
Thread B
User space
dma-buf fd
trigger the unmap
of kernel_vaddr
Background
Create an ion_handle related to the dma_buf file object;
Operations on fd and file 
object or related objects
Operations on fd
12
A file descriptor can be shared between kernel space and user space, race condition can happen between kernel and 
user operations：
Background
Thread A
Thread B
User Space
Kernel space
Operations on 
file object
Operations on fd
Race condition 1
Thread A
Thread B
User Space
Kernel space
Operations on fd
Operations on fd
Race condition 2
Maybe there are issues in these 
race conditions? Let’s try to 
construct such race conditions in 
the fd export and import 
operations!
Why file descriptor——Inspired by CVE-2021-0929
13
User Space
Kernel space
file
fd
Step1:get an unused fd
Step2:fd_array[fd]=file
Step3:pass the fd to user space
Step1:file=fd_array[fd]
Step2:acquire file reference
import operation
file
fd
export operation
Diving into issues in the fd export operation
14
 Scenario of fd export operation
 UAF caused by race condition
 Find the issues
 Fixes
Diving into issues in the fd export operation
15
User Space
Kernel space
file
Operations on fd:
read(fd, …);
write(fd, …);
ioctl(fd, …);
close(fd);
…
Request a resource
Thread A
Step1:get an unused fd
Step2:fd_array[fd]=file
Step3:pass the fd to user space
Scenario of fd export operation
fd
16
SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)
{
…
return do_sys_open(AT_FDCWD, filename, flags, mode);
}
static long do_sys_openat2(int dfd, const char __user *filename,
struct open_how *how)
{
…
fd = get_unused_fd_flags(how->flags);
if (fd >= 0) {
struct file *f = do_filp_open(dfd, tmp, &op);
…
fd_install(fd, f);
…
}
…
return fd;
}
Example:
Step1:get an unused fd
get_unused_fd_flags()
Step2.fd_array[fd]=file:
fd_install(fd, file)
Step3.pass the fd to user space:
fd as return value
Scenario of fd export operation
…
17
But this regular fd export operation is executed sequentially, which is still far from the race conditions we want to see:  
Thread A
Thread B
User Space
Kernel space
Operations on 
file object
Operations on fd
Race condition 1
Thread A
Thread B
User Space
Kernel space
Operations on fd
Operations on fd
Race condition 2
Scenario of fd export operation
18
User Space
Kernel space
file
Request a resource
Thread A
Step1:get an unused fd
Step2:fd_array[fd]=file
Step3:pass the fd to user space
fd
After step2, we already can 
perform the operations on 
fd, but we only know the 
value of fd after step3!
UAF caused by race condition
Operations on fd:
read(fd, …);
write(fd, …);
ioctl(fd, …);
close(fd);
…
19
Hold on! Do we have to wait for fd to be passed from kernel to know the value of it ?
Fd is predictable:
int fd = open(file_path, …);
close(fd);
int fd2 = open(file_path2,…);
For a new process, fd 0，1，2 are usually occupied, 3 will be the next fd exported from kernel, 
and then 4, 5, 6……
• Assigned in ascending order
• Reused after close(fd)
fd2=fd
UAF caused by race condition
20
User Space
Kernel space
file
Thread A
Step1:get an unused fd
Step2:fd_array[fd]=file
Step3:pass the fd to user space
Thread B
We already know the value of fd !
time window
Operations on fd:
read(fd, …);
write(fd, …);
ioctl(fd, …);
close(fd);
…
UAF caused by race condition
21
User Space
Kernel space
file
Thread A
Step1:get an unused fd
Step2:fd_array[fd]=file
Step3:return to user space
Thread B
More assumption:
time window Operations on file object
Operations on fd:
read(fd, …);
write(fd, …);
ioctl(fd, …);
close(fd);
…
We succeed in 
constructing the case 
of race condition 1
UAF caused by race condition
Thread A
Thread B
User Space
Kernel space
Operations on 
file object
Operations on fd
Race condition 1
22
User Space
Kernel space
file
Thread A
Step1:get an unused fd
Step2:fd_array[fd]=file
Step3:return to user space
Thread B
A potential UAF scenario:
Operations on file object
close(fd);
file
file->private_data
file->private_data->…
release
UAF
drop file 
reference
UAF caused by race condition
23
Looking for all kinds of kernel APIs which perform the “step2”:
Step2:fd_array[fd]=file
• fd_install(fd, file)
• anon_inode_getfd()
• dma_buf_fd()
• sync_fence_install()
• ion_share_dma_buf_fd()
• …
They all wrap fd_install(fd, file)
UAF caused by race condition
24
Try to search for the bug pattern: “reference file or related objects after the step2”
From Vendor Q:
static int get_fd(uint32_t handle, int64_t *fd)
{
int unused_fd = -1, ret = -1;
struct file *f = NULL;
struct context *cxt = NULL;
…
cxt = kzalloc(sizeof(*cxt), GFP_KERNEL);
…
unused_fd = get_unused_fd_flags(O_RDWR);
…
f = anon_inode_getfile(INVOKE_FILE, &invoke_fops, cxt, O_RDWR);
…
*fd = unused_fd;
fd_install(*fd, f);
((struct context *)(f->private_data))->handle = handle;
return 0;
…
}
From Vendor M:
int ged_ge_alloc(int region_num, uint32_t *region_sizes)
{
unsigned long flags;
int i;
struct GEEntry *entry =
(struct GEEntry *)kmem_cache_zalloc(gPoolCache, …);
…
entry->alloc_fd = get_unused_fd_flags(O_CLOEXEC);
…
entry->file = anon_inode_getfile("gralloc_extra",
&GEEntry_fops, entry, 0);
…
fd_install(entry->alloc_fd, entry->file);
return entry->alloc_fd;
…
}
UAF caused by race condition
My assumption is correct! 
let’s try to search for more!
25
From
CVE-id/issue
fd exported by function
Feature
Vendor M
CVE-2022-21771
fd_install()
GPU related driver
CVE-2022-21773
dma_buf_fd()
dma-buf related
Duplicated issue#1
dma_buf_fd()
dma-buf related
Vendor Q
CVE-2022-33225
fd_install()
Vendor S
Issue#1
fd_install()
sync_file related
Issue#2
dma_buf_fd()
dma-buf related
Linux Mainstream
Issue#1
anon_inode_getfd()
Amd GPU driver
Issue#2
dma_buf_fd()
dma-buf related
I found since the end of 2021:
ARM Mali GPU driver
CVE-2022-28349
anon_inode_getfd()
can be triggered from 
untrusted apps
CVE-2022-28350
fd_install()
sync_file related, can 
be triggered from 
untrusted apps
Maybe I should 
pay more 
attention to the 
GPU drivers?
UAF caused by race condition
26
CVE-2022-28349—— A Nday in ARM Mali GPU driver
Affect:
•Midgard GPU Kernel Driver: All versions from r28p0 – r29p0
•Bifrost GPU Kernel Driver: All versions from r17p0 – r23p0
•Valhall GPU Kernel Driver: All versions from r19p0 – r23p0
int kbase_vinstr_hwcnt_reader_setup(
struct kbase_vinstr_context *vctx,
struct kbase_ioctl_hwcnt_reader_setup *setup)
{
int errcode;
int fd;
struct kbase_vinstr_client *vcli = NULL;
…
errcode = kbasep_vinstr_client_create(vctx, setup, &vcli);
…