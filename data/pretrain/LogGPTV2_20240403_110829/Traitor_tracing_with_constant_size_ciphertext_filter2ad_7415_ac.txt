all adversaries A, all n > t, all  ∈ (0, 1), and all subsets
C ⊆ {1, . . . , n} of size at most t, we have
CR Adv[(G(n, , δ), T, C),A]  0 then the adversary A must possess
sk [j, 0], since otherwise E is not semantically secure (E
allows decryption of content without the key).
• Second, if pj and qj are “far apart” then A must possess
sk [j, 1], since, again, otherwise E is not semantically se-
cure (E distinguishes encryptions of 0 from encryptions
of m).
Observe also that qj is computed by running the pirate de-
coder on valid ciphertexts and therefore qj is an estimate for
the decoder’s error rate for ciphertexts that use coordinate j.
These observations motivate deﬁning the following code-
word: for j = 1, . . . , (cid:3) let wj ∈ {0, 1} be
0
1
if pj > 0
if pj = 0 and qj > 1√
λ
‘?’ otherwise
(A knows sk [j, 0])
(A knows sk [j, 1])
(pj = 0 and qj ≤ 1√
)
λ
and set ¯w∗
:= w1 . . . w(cid:2). The symbol ‘?’ at position j in-
dicates that PD refuses to decrypt most valid ciphertexts
created for coordinate j. We know nothing about A’s knowl-
edge of keys at this position.
satisﬁes two important properties: First,
with high probability (i.e. probability at least 1 − f (λ) for
some negligible function f ), the fraction of ‘?’ symbols in
¯w∗
The codeword ¯w∗
is at most
√
:= δ/(1 − 2/
δ(cid:4)
λ).
(6)
The proof is via a standard probabilistic argument show-
ing that otherwise PD will incorrectly decrypt more than
a δ fraction of well-formed ciphertexts: qj is a good ap-
proximation to the actual probability ˆqj that when the jth
coordinate is used PD decrypts correctly. If ˆqj ≥ 2√
λ then
the probability that qj ≤ 1√
λ is negligible. Now, if δ(cid:4)
is the
fraction of locations where ˆqj  0 when the adversary does not possess sk[j, 1],
which is negligible, and the probability the adversary has of
making pj = 0 but qj > 1√
λ when not possessing sk[j, 1].
If we replace in the ﬁrst step of RobustTRj the encryption
of 0 with m, then the adversary’s chance of success is ex-
If now for the original RobustTRj the
ponentially small.
probability of this event is not negligible, then we have a
distinguisher for encryptions of a collection of random mes-
sages from encryptions of the all 0 collection, violating the
semantic security of E .
These two facts show that if the underlying ﬁngerprinting
code is δ(cid:4)
-robust then applying the ﬁngerprinting tracing al-
gorithm to the codeword ¯w∗
will identify a non-empty subset
of keys in the adversary’s possession, with high probability.
In summary, the modiﬁed tracing algorithm works as fol-
1. For each j in {1, . . . , (cid:3)} run experiment RobustTRj and
lows:
deﬁne the word ¯w∗
2. Output Ttt ( ¯w∗, tk ).
as above.
-robust.
We argued that tracing succeeds as long as the underlying
ﬁngerprinting code is δ(cid:4)
4.3 Constructing robust ﬁngerprinting codes
It remains to construct a δ-robust code to be used in the
traitor tracing system of Section 3. We extend the Boneh-
Shaw ﬁngerprinting code [5] to make it δ-robust for any ﬁxed
repeat the following steps λ2 ln (cid:3) times:
pk [j, 0], m
,
R← Eenc
c1
let pj be the fraction of times that m = ˆm
repeat the following steps λ2 ln (cid:3) times:
pk [j, 0], m
,
R← Eenc
c1
`
m R← M
R← Eenc
c0
c∗ ← (j, c0, c1)
ˆm ← PD(c∗
)
`
m R← M
R← Eenc
c0
c ← (j, c0, c1)
ˆm ← PD(c)
´
´
let qj be the fraction of times that m = ˆm
`
pk [j, 1], 0
´
`
pk [j, 1], m
´
Figure 3: Experiment RobustTRj for 1 ≤ j ≤ (cid:3).
δ ∈ [0, 1). We note that Sirvent [32] recently presented a re-
lated construction. Constructing these codes is purely com-
binatorial and does not depend on complexity assumptions.
The Boneh-Shaw codes
We begin with a brief review of the Boneh-Shaw code. The
fully collusion resistant code for n users is built from the
following set of n words Γ0, where each word consists of
n + 1 blocks and each block is d-wide:
block 0
0000
0000
0000
...
0000
···
1111 1111
0000 1111 ···
0000 0000
...
0000 0000 ···
block n
1111
1111
1111
1111
1111
1111
1111
...
0000
word 1:
word 2:
word 3:
...
word n:
(7)
The total codeword length is (cid:3) = d(n + 1). The code gen-
erator G picks a random permutation π on (1, . . . , (cid:3)) and
permutes the columns of Γ0 according to π.
It outputs
the resulting n codewords as the code Γ with tracing-key
tk := π.
For notational convenience we will occasionally ignore the
permutation π and use the term “block i of Γ” or “block i of a
codeword w” to mean the set of coordinates that correspond
(via π−1) to block number i in Γ0.
Let W be a subset of codewords in Γ that does not include
codeword number i. Observe that an adversary A who is
given W , cannot distinguish columns from block number
i − 1 from columns belonging to block number i. Therefore,
generated by A contains
one expects that the codeword ¯w∗
roughly the same number of ‘1’s in block i − 1 as in block i.
In fact, if block i in ¯w∗
contains many more ‘1’s than block
i − 1, then we can conclude that A can distinguish block
i from i − 1 and therefore A is in possession of codeword
number i.
Suppose A is given words W ⊂ Γ and let ¯w∗ ∈ F (W ) be
a codeword generated by A. For i = 0, . . . , n let ai be the
weight of the ith block of ¯w∗
, namely the number of 1s in
block i. Computing the quantities a0, . . . , an requires the
tracing-key tk to undo the random permutation π. Boneh
and Shaw show that if there is a gap between block i and
p
i − 1, namely
ai − ai−1 > Δ
d · log2(2n/)
Δ :=
where
(8)
then A is in possession of codeword number i with prob-
ability at least 1 − (/n) (they actually prove a stronger
statement, but that is not needed for our discussion).
Equation (8) gives a tracing algorithm that accuses an
innocent i with probability at most : output all 1 ≤ i ≤ n
such that ai − ai−1 > Δ. However, we must ensure that
there is always some i that satisﬁes (8). Since ¯w∗ ∈ F (W )
we know that a0 = 0 and an = d and therefore there is
some 1 ≤ i ≤ n for which ai − ai−1 > d/n. If we ensure
that d/n > Δ then equation (8) will be satisﬁed for some
1 ≤ i ≤ n, as required. To ensure d/n > Δ we solve for d
and obtain:
d ≥ dmin := 2n2
implying that the code length is
log2(2n/)
(cid:3) = dmin · (n + 1) = O(n3
log(n/)).
Overall, we trace ¯w∗
our tracing algorithm never outputs an empty set.
to some codeword used to create it and
dmin :=
A δ-robust variant of Boneh-Shaw
We show that to make the code δ-robust it suﬃces to in-
crease the block width dmin to
4n2
(1 − δ)2
· log2(2n/)
Suppose A is given words W ⊂ Γ and let ¯w∗ ∈ F?(W ) be a
codeword generated by A that contains at most δ· (cid:3) symbols
‘?’. For i = 0, . . . , n let bi be the number of ‘?’ symbols in
block i of ¯w∗
. Let ai be the number of ‘1’s in block i of ¯w∗
.
We modify the original Boneh-Shaw tracing algorithm as
follows.
Step 1: use the tracing-key tk to compute ai and bi for all
i = 0, . . . , n;
Step 2: output all 1 ≤ i ≤ n such that
ai+1 − ai > Δ or
bi+1 − bi > Δ.
The same logic as in the original algorithm shows that this
tracing algorithm accuses an innocent party with probability
at most 2. To see why, we re-iterate that without codeword
number i the adversary cannot distinguish columns in block
i from columns in block i − 1 and therefore cannot create
a large gap between ai and ai−1 or between bi and bi−1.
Therefore, the existence of a gap indicates that codeword i
was used to create ¯w∗
.
More precisely, we argue that if user i is not a member of
W then
Pr[ai+1 − ai > Δ or
bi+1 − bi > Δ]  Δ]  Δ]  Δ] using the following balls and
bins experiment: the adversary throws A blue balls (corre-
sponding to ’1’ symbols) and B red balls (corresponding to
‘?’ symbols) at random into 2d bins, with one ball per bin.
Let xi be the random variable indicating the number of blue
balls in the left d bins and xi+1 be the number of blue balls
in the right d bins. For any 0 ≤ k ≤ d we have
´ ·`
`
`
´ ·`
Pr[xi = k and xi+1 = A − k] =
´ ·`
´
2d−A
´ ·`
`
2d−A
A−k
A−k
`
d
´
´
B
=
d
k
d
´
d