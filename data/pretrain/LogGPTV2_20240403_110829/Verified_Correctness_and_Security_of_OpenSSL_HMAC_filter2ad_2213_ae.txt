the SHA-256 block shufﬂe, but not the SHA-256 man-
agement code or HMAC. The Cryptol synthesizer is not
foundational because its semantics is not formally speci-
ﬁed, let alone proved.
CAO is a domain speciﬁc language for crypto appli-
cations, which is compiled into C [11], and equipped
with veriﬁcation technology based on the FRAMA-C
tool suite [4].
Libraries of arbitrary-precision arithmetic functions
have been veriﬁed by Fischer [39] and Berghofer [17]
using Isabelle/HOL. Bertot et al. [20] verify GMP’s com-
putation of square roots in Coq, based on Filliatre’s COR-
RECTNESS tool for ML-style programs with imperative
features [26]. Neither of these formalizations is foun-
datationally connected to a veriﬁed compiler.
Veriﬁed assembly implementations of arithmetic func-
tions have been developed by Myreen and Curello [36]
and Affeldt [1], who use, respectively, proof-producing
(de)compilation and simulation to link assembly code
and memory layout
to functional speciﬁcations at
(roughly) the level of our FIPS speciﬁcations. Chen et
al. [24] verify the Montgomery step in Bernstein’s high-
speed implementation of elliptic curve 25519 [18], using
a combination of SMT solving and Coq to implement a
Hoare logic for Bernstein’s portable assembly represen-
tation qhasm.
The abstraction techniques and representation predi-
cates in these works are compatible with our memory
layout predicates. One important future step is to con-
dense commonalities of these libraries into an ontology
for crypto-related reasoning principles, reusable across
multiple language levels and realised in multiple proof
assistants. Doing this is crucial for scaling our work to
larger fragments of cryptographic libraries.
Formal veriﬁcation of protocols is an established re-
search area, and efforts to link abstract protocol veriﬁca-
tions to implementations are emerging using automated
techniques like model extraction or code generation [8],
or interactive proof [2].
Toma and Borrione [41] use ACL2 to prove correct-
ness of a VHDL implementation of the SHA-1 block-
shufﬂe algorithm. There is no connection to (for exam-
ple) a veriﬁed compiler for VHDL.
Backes et al. [10] verify mechanically (in EasyCrypt)
that Merkle-Damg˚ard constructions have certain security
properties.
EasyCrypt. Almeida et al. [3] describe the use of their
EasyCrypt tool to verify the security of an implemen-
tation of the RSA-OAEP encryption scheme. A func-
tional speciﬁcation of RSA-OAEP is written in Easy-
Crypt, which then veriﬁes its security properties. An
unveriﬁed Python script translates the EasyCrypt spec-
iﬁcation to (an extension of) C, then an extension of
CompCert compiles it to assembly language. Finally, a
leakage tool veriﬁes that the assembly language program
has no more program counter leakage than the source
code, i.e.
that the compiled program’s trace of condi-
tional branches is no more informative to the adversary
than the source code’s.
The EasyCrypt veriﬁer is not foundational; it is an
OCaml program whose correctness is not proved. The
translation from C to assembly language is foundational,
using CompCert. However, EasyCrypt’s C code relies on
bignum library functions, but provides no mechanism by
which these functions can be proved correct.
CertiCrypt [13] is a system for reasoning about cryp-
tographic algorithms in Coq; it is foundational, but (like
EasyCrypt) has no foundational connection to a C se-
mantics. ZKCrypt[9] is a synthesizer that generates C
code for zero-knowledge proofs, implemented in Cer-
tiCrypt, also with no foundational connection to a C se-
mantics.
Bhargavan et al.
[21] “implement TLS with veri-
ﬁed cryptographic security” in F# using the F7 type-
checker. F7 is not capable of reasoning about all of
the required cryptographic/probabilistic relationships re-
quired to complete the proof. So parts of the proof are
completed using EasyCrypt, and there is no formal rela-
tionship between the EasyCrypt proofs and the F7 proof;
one must inspect the code to ensure that the things ad-
mitted in F7 are the same things that are proved in Easy-
USENIX Association  
24th USENIX Security Symposium  219
Crypt. F7 is also not foundational, because the type
checker has a large amount of trusted code and because
it depends on the Z3 SMT solver. Another difference
between this work and ours is that the code provides a
reference implementation in F#, not an efﬁcient imple-
mentation in C.
CryptoVerif
[22] is a prover (implemented in OCaml)
for security protocols in which one can, for example, ex-
tract a OCaml program from a CryptoVerif model [23].
CryptoVerif is not foundational, the extraction is not
foundational, and the compiler for OCaml is not foun-
dationally veriﬁed.
C program veriﬁcation. There are many program
analysis tools for C. Most of them do not address func-
tional speciﬁcation or functional correctness, and most
are unsound and incomplete. They are useful in practice,
but cannot be used for an end-to-end veriﬁcation of the
kind we have done.
Foundational formal veriﬁcation of C programs has
only recently been possible. The most signiﬁcant such
works are both operating-system kernels: seL4 [32] and
CertiKOS [29]. Both proofs are reﬁnement proofs be-
tween functional speciﬁcations and operational seman-
tics. Both proofs are done in higher-order logics: seL4
in Isabelle/HOL and CertiKOS in Coq.
Neither of those proof frameworks uses separation
logic, and neither can accommodate the use of address-
able local variables in C. This means that OpenSSL’s
HMAC/SHA could not be proved in these frameworks,
because it uses addressable local variables.
Additionally, neither of those proof frameworks can
handle function pointers. OpenSSL uses function point-
ers in its “engines” mechanism, an object-oriented style
of programming that dynamically connects components
together, such as HMAC and SHA. The Veriﬁable C pro-
gram logic is capable of reasoning about such object-
oriented patterns in C [6, Chapter 29], although we have
not done so in the work described in this paper.
9 Conclusion
Widely used open-source cryptographic libraries such as
OpenSSL, operating systems kernels, and the C compil-
ers that build them, form the backbone of the public’s
communication security. Since 2013 or so, it has be-
come clear that hackers and nation-states (is there a dif-
ference anymore?) are willing to invest enormous re-
sources in searching for vulnerabilities and exploiting
them. Other authors have demonstrated that compilers
[34] and OS kernels [32, 29] can be built to a prov-
able zero-functional-correctness-defect standard. Here
we have demonstrated the same, in a modular way, for
key components of our common cryptographic infras-
tructure.
Functional correctness implies zero buffer-overrun de-
fects as well. But there are side channels we have not ad-
dressed here, such as timing, fault-injection, and leaks
through dead memory. Our approach does not solve
these problems; but it makes them no worse. Because we
can reason about standard C code, other authors’ tech-
niques for side channel analysis are applicable without
obstruction.
Functional correctness (with respect to a speciﬁcation)
does not always guarantee that a program has abstract
security properties. Here, by linking a proof of crypto-
graphic security to a proof of program correctness, we
provide that guarantee.
Acknowledgments. Funded in part by DARPA award
FA8750-12-2-029 and by a grant from Google ATAP.
References
[1] AFFELDT, R. On construction of a library of formally veriﬁed
low-level arithmetic functions. Innovations in Systems and Soft-
ware Engineering (ISSE) 9, 2 (2013), 59–77.
[2] AFFELDT, R., AND SAKAGUCHI, K. An intrinsic encoding of a
subset of C and its application to TLS network packet processing.
Journal of Formalized Reasoning 7, 1 (2014), 63–104.
[3] ALMEIDA, J. B., BARBOSA, M., BARTHE, G., AND DUPRES-
SOIR, F. Certiﬁed computer-aided cryptography: efﬁcient prov-
ably secure machine code from high-level implementations. In
Proceedings of the 2013 ACM SIGSAC Conference on Computer
and Communications security (2013), ACM, pp. 1217–1230.
[4] ALMEIDA, J. B., BARBOSA, M., FILLI ˆATRE, J., PINTO, J. S.,
AND VIEIRA, B. CAOVerif: An open-source deductive veriﬁca-
tion platform for cryptographic software implementations. Sci.
Comput. Program. 91 (2014), 216–233.
[5] APPEL, A. W. Veriﬁcation of a cryptographic primitive: SHA-
256. ACM Trans. on Programming Languages and Systems 37, 2
(Apr. 2015), 7:1–7:31.
[6] APPEL, A. W., DOCKINS, R., HOBOR, A., BERINGER, L.,
DODDS, J., STEWART, G., BLAZY, S., AND LEROY, X. Pro-
gram Logics for Certiﬁed Compilers. Cambridge, 2014.
[7] APPEL, A. W., MICHAEL, N. G., STUMP, A., AND VIRGA, R.
A trustworthy proof checker. J. Automated Reasoning 31 (2003),
231–260.
[8] AVALLE, M., PIRONTI, A., AND SISTO, R. Formal veriﬁca-
tion of security protocol implementations: a survey. Formal Asp.
Comput. 26, 1 (2014), 99–123.
[9] BACELAR ALMEIDA, J., BARBOSA, M., BANGERTER, E.,
BARTHE, G., KRENN, S., AND ZANELLA B ´EGUELIN, S. Full
proof cryptography: veriﬁable compilation of efﬁcient zero-
knowledge protocols. In Proceedings of the 2012 ACM confer-
ence on Computer and communications security (2012), ACM,
pp. 488–500.
[10] BACKES, M., BARTHE, G., BERG, M., GR ´EGOIRE, B., KUNZ,
C., SKORUPPA, M., AND B ´EGUELIN, S. Z. Veriﬁed security of
Merkle-Damg˚ard. In Computer Security Foundations Symposium
(CSF), 2012 IEEE 25th (2012), IEEE, pp. 354–368.
220  24th USENIX Security Symposium 
USENIX Association
[27] Keyed-hash message authentication code. Tech. Rep. FIPS PUB
198-1, Information Technology Laboratory, National Institute of
Standards and Technology, Gaithersburg, MD, July 2008.
[28] Secure hash standard (SHS). Tech. Rep. FIPS PUB 180-4, Infor-
mation Technology Laboratory, National Institute of Standards
and Technology, Gaithersburg, MD, Mar. 2012.
[29] GU, L., VAYNBERG, A., FORD, B., SHAO, Z., AND
COSTANZO, D. CertiKOS: A certiﬁed kernel for secure cloud
computing. In Proceedings of the Second Asia-Paciﬁc Workshop
on Systems (2011), APSys’11, ACM, pp. 3:1–3:5.
[30] HALEVI, S. A plausible approach to computer-aided crypto-
graphic proofs. http://eprint.iacr.org/2005/181, 2005.
[31] HOARE, C. A. R. An axiomatic basis for computer program-
ming. Commun. ACM 12, 10 (October 1969), 578–580.
[32] KLEIN, G., ELPHINSTONE, K., HEISER, G., ANDRONICK, J.,
COCK, D., DERRIN, P., ELKADUWE, D., ENGELHARDT, K.,
KOLANSKI, R., NORRISH, M., ET AL.
seL4: Formal veriﬁ-
cation of an OS kernel.
In Proceedings of the ACM SIGOPS
22nd symposium on Operating systems principles (2009), ACM,
pp. 207–220.
[33] KOBLITZ, N., AND MENEZES, A. Another look at HMAC.
Journal of Mathematical Cryptology 7, 3 (2013), 225–251.
[34] LEROY, X. Formal certiﬁcation of a compiler back-end, or: pro-
gramming a compiler with a proof assistant. In POPL’06 (2006),
pp. 42–54.
[35] LEROY, X. Formal veriﬁcation of a realistic compiler. Commu-
nications of the ACM 52, 7 (2009), 107–115.
[36] MYREEN, M. O., AND CURELLO, G. Proof pearl: A veri-
In Cer-
ﬁed bignum implementation in x86-64 machine code.
tiﬁed Programs and Proofs - Third International Conference,
CPP 2013, Proceedings (2013), G. Gonthier and M. Norrish,
Eds., vol. 8307 of Lecture Notes in Computer Science, Springer,
pp. 66–81.
[37] O’HEARN, P., REYNOLDS, J., AND YANG, H. Local reasoning
about programs that alter data structures.
In CSL’01: Annual
Conference of the European Association for Computer Science
Logic (Sept. 2001), pp. 1–19. LNCS 2142.
[38] PETCHER, A., AND MORRISETT, G. The foundational cryptog-
raphy framework. In Principles of Security and Trust - 4th In-
ternational Conference, POST 2015, Proceedings (2015), R. Fo-
cardi and A. C. Myers, Eds., vol. 9036 of Lecture Notes in Com-
puter Science, Springer, pp. 53–72.
[39] SCHMALTZ, S. F. F. Formal veriﬁcation of a big integer library
including division. Master’s thesis, Saarland University, 2007.
busserver.cs.uni-sb.de/publikationen/Fi08DATE.pdf.
[40] SMITH, E. W., AND DILL, D. L. Automatic formal veriﬁca-
In Formal Methods in
tion of block cipher implementations.
Computer-Aided Design (FMCAD’08) (2008), IEEE, pp. 1–7.
[41] TOMA, D., AND BORRIONE, D. Formal veriﬁcation of a SHA-1
circuit core using ACL2. In Theorem Proving in Higher Order
Logics. Springer, 2005, pp. 326–341.
[11] BARBOSA, M., CASTRO, D., AND SILVA, P. F. Compiling
CAO: from cryptographic speciﬁcations to C implementations.
In Principles of Security and Trust - Third International Confer-
ence, POST 2014, Proceedings (2014), M. Abadi and S. Kremer,
Eds., vol. 8414 of Lecture Notes in Computer Science, Springer,
pp. 240–244.
[12] BARTHE, G., DUPRESSOIR, F., GR ´EGOIRE, B., KUNZ, C.,
SCHMIDT, B., AND STRUB, P.-Y. EasyCrypt: A tutorial.
In
Foundations of Security Analysis and Design VII. Springer, 2014,
pp. 146–166.
[13] BARTHE, G., GR ´EGOIRE, B., AND ZANELLA B ´EGUELIN, S.
Formal certiﬁcation of code-based cryptographic proofs. In Pro-
ceedings of the 36th Annual ACM SIGPLAN-SIGACT Symposium
on Principles of Programming Languages (New York, NY, USA,
2009), POPL ’09, ACM, pp. 90–101.
[14] BELLARE, M. New proofs for NMAC and HMAC: Secu-
In Advances in Cryptology-
rity without collision-resistance.
CRYPTO 2006. Springer, 2006, pp. 602–619.
[15] BELLARE, M., CANETTI, R., AND KRAWCZYK, H. Keying
hash functions for message authentication. In Advances in Cryp-
tologyCRYPTO96 (1996), Springer, pp. 1–15.
[16] BELLARE, M., AND ROGAWAY, P. Code-based game-playing
IACR Cryptology
proofs and the security of triple encryption.
ePrint Archive 2004 (2004), 331.
[17] BERGHOFER, S. Veriﬁcation of dependable software using
SPARK and Isabelle. In 6th International Workshop on Systems
Software Veriﬁcation, SSV 2011 (2011), J. Brauer, M. Roveri, and
H. Tews, Eds., vol. 24 of OASICS, Schloss Dagstuhl - Leibniz-
Zentrum fuer Informatik, pp. 15–31.
[18] BERNSTEIN, D. J. Curve25519: New Difﬁe-Hellman speed
records. In Public Key Cryptography - PKC 2006, 9th Interna-
tional Conference on Theory and Practice of Public-Key Cryp-
tography, Proceedings (2006), M. Yung, Y. Dodis, A. Kiayias,
and T. Malkin, Eds., vol. 3958 of Lecture Notes in Computer Sci-
ence, Springer, pp. 207–228.
[19] BERNSTEIN,
D.
J.
cr.yp.to/talks/2012.03.20/slides.pdf, Mar. 2012.
The
HMAC
brawl.
[20] BERTOT, Y., MAGAUD, N., AND ZIMMERMANN, P. A proof of
GMP square root. J. Autom. Reasoning 29, 3-4 (2002), 225–252.
[21] BHARGAVAN, K., FOURNET, C., KOHLWEISS, M., PIRONTI,
A., AND STRUB, P.
Implementing TLS with veriﬁed crypto-
graphic security. In Security and Privacy (SP), 2013 IEEE Sym-
posium on (2013), IEEE, pp. 445–459.
[22] BLANCHET, B. A computationally sound mechanized prover
for security protocols. Dependable and Secure Computing, IEEE
Transactions on 5, 4 (2008), 193–207.
[23] CAD ´E, D., AND BLANCHET, B. Proved generation of imple-
mentations from computationally secure protocol speciﬁcations.
In Principles of Security and Trust. Springer, 2013, pp. 63–82.
[24] CHEN, Y., HSU, C., LIN, H., SCHWABE, P., TSAI, M., WANG,
B., YANG, B., AND YANG, S. Verifying curve25519 software.
In Proceedings of the 2014 ACM SIGSAC Conference on Com-
puter and Communications Security (2014), G. Ahn, M. Yung,
and N. Li, Eds., ACM, pp. 299–309.
[25] ERKOK, L., CARLSSON, M., AND WICK, A. Hardware/-
software co-veriﬁcation of cryptographic algorithms using Cryp-
tol. In Formal Methods in Computer-Aided Design, 2009 (FM-
CAD’09) (2009), IEEE, pp. 188–191.
[26] FILLI ˆATRE, J. Veriﬁcation of non-functional programs using in-
terpretations in type theory. J. Funct. Program. 13, 4 (2003),
709–745.
USENIX Association  
24th USENIX Security Symposium  221