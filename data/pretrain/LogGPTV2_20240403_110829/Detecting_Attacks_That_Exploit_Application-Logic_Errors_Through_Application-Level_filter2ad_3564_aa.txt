title:Detecting Attacks That Exploit Application-Logic Errors Through Application-Level
Auditing
author:Jingyu Zhou and
Giovanni Vigna
Detecting Attacks That Exploit Application-Logic Errors
Through Application-Level Auditing
Jingyu Zhou and Giovanni Vigna
Department of Computer Science
{jzhou, vigna}@cs.ucsb.edu
University of California, Santa Barbara
Abstract
Host security is achieved by securing both the operat-
ing system kernel and the privileged applications that run
on top of it. Application-level bugs are more frequent than
kernel-level bugs, and, therefore, applications are often the
means to compromise the security of a system. Detecting
these attacks can be difﬁcult, especially in the case of at-
tacks that exploit application-logic errors. These attacks
seldom exhibit characterizing patterns as in the case of buf-
fer overﬂows and format string attacks. In addition, the data
used by intrusion detection systems is either too low-level,
as in the case of system calls, or incomplete, as in the case
of syslog entries. This paper presents a technique to enforce
non-bypassable, application-level auditing that does not re-
quire the recompilation of legacy systems. The technique is
implemented as a kernel-level component, a privileged dae-
mon, and an off-line language tool. The technique uses bi-
nary rewriting to instrument applications so that meaning-
ful and complete audit information can be extracted. This
information is then matched against application-speciﬁc
signatures to detect attacks that exploit application-logic
errors. The technique has been successfully applied to de-
tect attacks against widely-deployed applications, including
the Apache web server and the OpenSSH server.
1. Introduction
The security of a host depends on both the operating sys-
tem and the privileged applications that run on top of it.
However, application-level vulnerabilities account for the
majority of the vulnerabilities that are found and made pub-
lic through mailing lists and advisories. A large number of
the vulnerabilities in applications are caused by the lack of
dynamic checks on input data, which makes it possible to
perform buffer overﬂow and format string attacks.
Another type of attacks are those exploiting application-
logic errors. Application-logic errors happen when an ap-
plication performs actions that were not originally consid-
ered in the application design. For example, suppose that a
privileged application is designed to read and print a spe-
ciﬁc ﬁle, such as “/etc/services”. An application-logic error
would allow an attacker to exploit an unexpected interac-
tion with the shell environment to force the application to
access (and print) a different ﬁle, such as “/etc/shadow”, re-
sulting in a security compromise.
The goal of Intrusion Detection Systems (IDSs) is to de-
tect attacks against networks, operating systems, and appli-
cations. The mainstream approaches to intrusion detection
use attack signatures to identify evidence of malicious ac-
tivity in an event stream. The two most common types of
intrusion detection systems are network-based intrusion de-
tection systems (NIDSs), which use network packets as the
data source for analysis [30], and host-based intrusion de-
tection systems (HIDSs), which use operating system audit
data as input [22, 14].
Unfortunately, both types of systems are unsuitable to
detect attacks that exploit application-logic errors. These
systems rarely have access to the semantically-rich audit
data needed to identify this type of attacks. In fact, to de-
tect these attacks, NIDSs need to reconstruct the data stream
and parse application-level protocols, which are two expen-
sive procedures. In addition, attackers can “desynchronize”
the view of a NIDS with respect to the view of the attacked
application, to evade detection or produce false alarms [27].
In some cases, NIDSs cannot even access the payload of the
packets because encryption is used.
HIDSs may seem more suitable to detect application-
level attacks because they have direct access to the system
calls invoked by the application [18, 38]. Unfortunately, at-
tacks exploiting application-logic errors rarely change the
execution ﬂow of the application. Therefore, approaches
based on the analysis of system call sequences will not de-
tect these attacks [10, 37]. Another problem is that the in-
formation needed to detect application-level attacks may be
missing or too difﬁcult to extract from the low-level infor-
mation included in system call traces and in the audit re-
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
cords produced by the operating system.
To detect attacks exploiting application-logic errors, it
is desirable to be able to perform selective, application-
speciﬁc auditing in certain points of the application’s con-
trol ﬂow. The problem is that few applications provide
hooks for instrumenting their control ﬂows, and, even if
these hooks are available, they may not be in the right
places. In addition, the instrumentation technique would be
application-speciﬁc and not easily portable to different ap-
plications.
This paper presents an instrumentation technique based
on dynamic binary rewriting. The technique is application-
independent and supports the collection of auditing infor-
mation at any point within the application control ﬂow. This
technique is used in conjunction with application-speciﬁc
signatures to detect attacks that exploit application-logic er-
rors.
The approach has been validated through several case
studies of attacks against real-world applications, namely
Apache and OpenSSH. In both cases, auditing routines to
collect data at critical points of the application’s control
ﬂow have been developed. In addition, signatures to detect
the attacks have been deﬁned. Some of these attacks were
not detectable by analyzing the network trafﬁc or the data
produced by existing OS-level auditing mechanisms.
The overhead introduced by the instrumentation techni-
que has been evaluated quantitatively and compared to the
overhead introduced by other types of auditing. The results
are promising and show a low run-time overhead.
The rest of the paper is organized as follows. Section 2
discusses related work. Section 3 presents the approach
used to instrument applications and detect attacks. Section 4
discusses several case studies. Section 5 evaluates the over-
head introduced by the technique. Section 6 discusses some
limitations of the approach. Finally, Section 7 draws con-
clusions and outlines future work.
2. Related Work
The work presented hereinafter is mostly related to au-
diting and program binary instrumentation.
2.1. Auditing
Auditing is a mechanism to collect information regard-
ing the activity of users and applications. The Trusted Com-
puter System Evaluation Criteria (TCSEC) requires that all
computer systems evaluated at division C and higher pro-
duce audit data, and that audit mechanisms be both tamper-
resistant and non-bypassable. Since the operating system is
usually regarded as a trusted entity because it controls ac-
cess to resources (e.g., memory and ﬁles), most existing au-
dit mechanisms are implemented within the operating sys-
tem.
Operating system audit data is not designed speciﬁcally
for intrusion detection. Therefore, in many cases the audit
records produced by OS-level auditing facilities contain ir-
relevant information, and sometimes lack useful data. As a
result, IDSs often have to access the operating system di-
rectly for relevant information.
Lunt [23] suggested that specialized audit trails with
only those data relevant to intrusion detection are needed.
Daniels et al. identiﬁed the audit data that operating systems
need to provide to support the detection of attacks against
the TCP/IP stack [8]. Then, Kuperman et al. extended that
work and developed a dynamic library interposition for ap-
plication auditing [20]. However, their technique does not
ensure non-bypassability because it cannot intercept func-
tion calls of statically-linked programs.
Almgren and Lindqvist proposed an extension to the
Apache web server to collect application-speciﬁc au-
dit data [1]. However, their work is speciﬁc to the Apache
web server, which has a well-deﬁned set of hooks to ex-
tend and instrument the server process. The problem with
this technique is that it is not directly applicable to other ap-
plications that may provide a different set of hooks, or even
no possibility of instrumentation at all.
The technique described in this paper overcomes the lim-
itations of the approaches described above. The approach is
based on binary rewriting, but, different from Kuperman’s
approach, the technique described here can be used to col-
lect information about both the application and the library
functions used by the application, even if an application has
been linked statically. Therefore, it is independent of any
particular application-speciﬁc interface to application ex-
tensions (e.g., the Apache module interface). The approach
includes a language that allows one to specify the location
in the application control ﬂow where auditing must be per-
formed. The language is independent of a particular appli-
cation and allows a programmer to specify which format
should be used for the audit records (e.g., [2]).
2.2. Binary Rewriting
Binary rewriting is a post-compilation technique that di-
rectly changes the binary code of executables. Different
from dynamic library interposition, binary rewriting works
for both statically-linked and dynamically-linked programs.
Binary rewriting also provides more access to the appli-
cation internals, because, in addition to library functions,
static functions of the application can also be instrumented.
There are two types of binary rewriting techniques: static
rewriting and dynamic rewriting. Static rewriting tech-
niques modify the ﬁle-system image of program binaries,
while dynamic rewriting techniques change the mem-
ory image of a process. ATOM [34], EEL [21], Purify [12],
and Etch [31] are examples of tools based on static re-
writing techniques. Dyninst [3] and Detours [13] are exam-
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
ples of dynamic rewriting tools. The Dyninst tool is used in
this paper for dynamic rewriting.
Compared to the static techniques, dynamic rewriting
techniques have the advantage of keeping the executables
intact. In addition, by using dynamic rewriting it is possible
to modify an application binary image in different ways, de-
pending on the context of the invocation of the application.
Dynamic rewriting also allows instrumentation code to be
kept in memory after a fork() call, so that the child pro-
cess is also instrumented.
Broadly speaking, dynamic binary rewriting is an in-
terposition approach. Interposition is generally performed
at the system call interface, the library interface, and the
application interface for various purposes: Curry uses dy-
namic library interposition for proﬁling and tracing library
calls [6]; Detours is a debugging and proﬁling tool that
uses dynamic binary rewriting for intercepting Win32 func-
tions [13]; Bypass extends the functionality of existing soft-
ware systems for distributed computing using shared library
interposition techniques [35]; Interposition Agents is a tool-
kit for interposing user code between a program and the op-
erating system kernel [15].
System call interposition has been used for performance
proﬁling and debugging of software systems. Interposition
is also widely used for security purposes. SLIC [7], Gene-
ric Software Wrappers [11], and Systrace [26] enhance op-
erating system security by interposing code at the kernel in-
terface. The TIS ﬁrewall toolkit [29] and the TCP Wrap-
pers [36] interpose code at the application level, but they
only provide very limited application audit data. The tech-
nique described here uses interposition at the application
and library interfaces to gather a complete set of security-
relevant information.
3. Design and Implementation
An application-level auditing facility should be designed
to meet a number of requirements.
1. Non-bypassability. This is a requirement of all au-
diting systems. For application-level auditing, non-
bypassability essentially means that the auditing code
has to be effective since the beginning of the applica-
tion’s execution.
2. Compatibility. The auditing mechanism should be
compatible with legacy applications and operating sys-
tems. The changes to the applications and operat-
ing systems required by the mechanism should be
minimal, in order to reduce the cost of deployment
and administration. In addition, if the auditing mecha-
nism does not modify the application binary, integrity
checkers, such as Tripwire [17], will not be affected.
3. Programming support. The auditing facility should
provide a simple mechanism for programmers to de-
velop application-level audit routines.
4. Performance. The
auditing capabil-
ity should not exact much performance penalty on
applications.
additional
There are several possible alternatives for the implemen-
tation of application-level auditing. In the following, we re-
view the advantages and disadvantages of three possible ap-
proaches.
Source modiﬁcation. This approach directly modiﬁes the
source code of applications. Both the internal sensors
approach for intrusion detection described in [16] and
the DoS-resistant software approach described in [28]
are examples of this approach. While achieving most
of the design objectives, this approach requires recom-
pilation of the applications. In addition, the conﬁgura-
tion of the auditing system (i.e., what functions are in-
strumented, and what information is logged) is deter-
mined at compile time, once for all. This is a limitation
to the ﬂexibility of the system.
Virtual machine modiﬁcation.
it
Interpreted langu-
ages such as Java or Perl use virtual machines or in-
terpreters to execute programs. Therefore,
is
possible to extend a virtual machine or the inter-
preted code to add auditing functionalities [33].
Approaches like [4, 25] apply different access con-
trol policies by using Java bytecode rewriting tech-
niques. Approaches that operate at the virtual machine
level may impose notable overhead to the interpre-
tation of the application’s code. In this paper, we
focused on high-performance, privileged applica-
tions written in C/C++.
Dynamic binary rewriting. This approach separates the
audit routines from the original application. Thus, a
new audit module can be added without re-compilation
of the application binary. Audit module selection is
postponed until the application is actually invoked, al-
lowing for ﬂexible selection of the auditing conﬁgura-
tion. In addition, the audit routines run in the same ad-
dress space as the application, with performance com-
parable to the source modiﬁcation approach.
We implemented an application-level auditing tool by
using a dynamic binary rewriting approach. The tool lever-
ages an existing dynamic rewriting mechanism for inserting
audit routines into applications at runtime. We implemented
a loadable kernel module and a user-space daemon that al-
low for non-bypassable monitoring of applications. We also
developed a language to support the development of both
the instrumentation code and the detection procedures. The
language hides the details of instrumentation from the pro-
grammers.
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
The tool has been implemented for the Linux 2.4 ker-
nel. The dynamic rewriting mechanism is implemented by
using an extended version of the Dyninst API [3]. The de-
sign and implementation of the tool’s components are de-
tailed in the following sections.
3.1. Runtime Environment
The tool uses a kernel module and a user-space dae-
mon to perform application instrumentation. The purpose
of these components is to monitor the operating system for
events that represent the invocation of a monitored appli-
cation and to inject the appropriate audit routines into the
memory of the application at startup time.
The loadable kernel module allows for a custom appli-
cation invocation procedure. Without support from the ker-
nel, the use of dynamic binary rewriting would either cause
incompatibility with legacy systems or fail to achieve the
non-bypassability goal. On systems supporting ptrace, ap-
plication instrumentation could be implemented using the
PTRACE TRACEME semantics. This mechanism allows a
parent process to instrument its child after the child calls the
execve() system call. Unfortunately, this solution would
violate the compatibility requirement because the applica-
tion’s ﬁrst invocation would have to be performed by some
special “parent” program. In addition, ptrace’s attach opera-
tion does not meet the non-bypassability goal, because there
is a time window between the creation of a process and the
beginning of the instrumentation procedure. Therefore, we
implemented a kernel module that ensures non-bypassable
instrumentation by intercepting the execve() system call.
By doing this, the application is stopped before its ﬁrst in-
struction is executed and the audit routines can be inserted
into the application before its execution starts.
Monitoring
Daemon
4
instrument
3
Application
Patch
Libraries
1
execve()
3
Audit
Libraries
notify
2
Kernel Module