title:Static Enforcement of Web Application Integrity Through Strong Typing
author:William K. Robertson and
Giovanni Vigna
Static Enforcement of Web Application Integrity Through Strong Typing
William Robertson
PI:EMAIL
Computer Security Group
UC Santa Barbara
Giovanni Vigna
PI:EMAIL
Computer Security Group
UC Santa Barbara
Abstract
Security vulnerabilities continue to plague web appli-
cations, allowing attackers to access sensitive data and
co-opt legitimate web sites as a hosting ground for mal-
ware. Accordingly, researchers have focused on various
approaches to detecting and preventing common classes
of security vulnerabilities in web applications, includ-
ing anomaly-based detection mechanisms, static and dy-
namic analyses of server-side web application code, and
client-side security policy enforcement.
This paper presents a different approach to web appli-
cation security.
In this work, we present a web appli-
cation framework that leverages existing work on strong
type systems to statically enforce a separation between
the structure and content of both web documents and
database queries generated by a web application, and
show how this approach can automatically prevent the
introduction of both server-side cross-site scripting and
SQL injection vulnerabilities. We present an evaluation
of the framework, and demonstrate both the coverage and
correctness of our sanitization functions. Finally, exper-
imental results suggest that web applications developed
using this framework perform competitively with appli-
cations developed using traditional frameworks.
Keywords: Web applications, strongly typed languages,
functional languages, cross-site scripting, SQL in-
jection.
1
Introduction
In the last decade, web applications have become an
extremely popular means of providing services to large
numbers of users. Web applications are relatively easy to
develop, the potential audience of a web application is a
signiﬁcant proportion of the planet’s population [36, 10],
and development frameworks have evolved to the point
that web applications are approaching traditional thick-
client applications in functionality and usability.
By far,
Unfortunately, web applications have also been found
to contain many security vulnerabilities [40]. Web ap-
plications are also widely accessible and often serve as
an interface to large amounts of sensitive data stored in
back-end databases. Due to these factors, web applica-
tions have attracted much attention from cyber-criminals.
Attackers commonly exploit web application vulnerabil-
ities to steal conﬁdential information [41] or to host mal-
ware in order to build botnets, both of which can be sold
to the highest bidder in the underground economy [46].
the most prevalent security vulnerabilities
present in web applications are cross-site scripting (XSS)
and SQL injection vulnerabilities [42]. Cross-site script-
ing vulnerabilities are introduced when an attacker is
able to inject malicious scripts into web content to be
served to other clients. These scripts then execute with
the privileges of the web application delivering the con-
tent, and can be used to steal authentication credentials
or to install malware, among other nefarious objectives.
SQL injections occur when malicious input to a web ap-
plication is allowed to modify the structure of queries
issued to a back-end database. If successful, an attacker
can typically bypass authentication procedures, elevate
privileges, or steal conﬁdential information.
Accordingly, much research has focused on detecting
and preventing security vulnerabilities in web applica-
tions. One approach is to deploy web application ﬁre-
walls (WAFs), usually incorporating some combination
of misuse and anomaly detection techniques, in order to
protect web applications from attack [6, 14, 8, 29, 45].
Anomaly detection approaches are attractive due to their
black-box approach; they typically require no a priori
knowledge of the structure or implementation of a web
application in order to provide effective detection.
Another signiﬁcant focus of research has been on ap-
plying various static and dynamic analyses to the source
code of web applications in order to identify and miti-
gate security vulnerabilities [21, 33, 25, 2, 7, 50]. These
approaches have the advantage that developers can con-
tinue to create web applications using traditional lan-
guages and frameworks, and periodically apply a vulner-
ability analysis tool to provide a level of assurance that
no security-relevant ﬂaws are present. Analyzing web
applications is a complex task, however, as is the inter-
pretation of the results of such security tools. Addition-
ally, several approaches require developers to specify se-
curity policies to be enforced in a specialized language.
A more recent line of research has focused on provid-
ing client-side protection by enforcing security policies
within the web browser [43, 22, 13]. These approaches
show promise in detecting and preventing client-side at-
tacks against newer web applications that aggregate con-
tent from multiple third parties, but the speciﬁcation of
policies to enforce is generally left to the developer.
In this paper, we propose a different approach to web
application security. We observe that cross-site script-
ing and SQL injection vulnerabilities can be viewed as
a failure on the part of the web application to enforce a
separation of the structure and the content of documents
and database queries, respectively, and that this is a result
of treating documents and queries as untyped sequences
of bytes. Therefore, instead of protecting or analyzing
existing web applications, we describe a framework that
strongly types both documents and database queries. The
framework is then responsible for automatically enforc-
ing a separation between structure and content, as op-
posed to the ad hoc sanitization checks that developers
currently must implement. Consequently, the integrity
of documents and queries generated by web applications
developed using our framework are automatically pro-
tected, and thus, by construction, such web applications
are not vulnerable to server-side cross-site scripting and
SQL injection attacks.
To illustrate the problem at hand, consider that HTML
or XHTML documents to be presented to a client are typ-
ically constructed by concatenating strings. Without ad-
ditional type information, a web application framework
has no means of determining that the following opera-
tions could lead to the introduction of a cross-site script-
ing vulnerability:
String result = "" + userInput + "";
The key intuition behind our work is that because
both documents and database queries are strongly typed
in our framework, the framework can distinguish be-
tween the structure ( and ) and the content
(userInput) of these critical objects, and enforce their
integrity automatically.
In this work, we leverage the advanced type system
of Haskell, since it offers a natural means of expressing
the typing rules we wish to impose. In principle, how-
ever, a similar framework could be implemented in any
language with a strong type system that allows for some
form of multiple inheritance (e.g., Java or C#).
In summary, the main contributions of this paper are
the following:
• We identify the lack of typing of web documents
and database queries as the underlying cause of
cross-site scripting and SQL injection vulnerabili-
ties.
• We present the design of a web application develop-
ment framework that automatically prevents the in-
troduction of cross-site scripting and SQL injection
vulnerabilities by strongly typing both web docu-
ments and database queries.
• We evaluate our prototype web application frame-
work, demonstrate the coverage and correctness of
its sanitization functions, and show that applications
under our framework perform competitively with
those using existing frameworks.
The remainder of this paper is structured as follows.
Section 2 presents the design of a strongly typed web
application framework. The speciﬁcation of documents
under the framework and how their integrity is enforced
is discussed in Section 3, and similarly for SQL queries
in Section 4. Section 5 evaluates the design of the frame-
work, and demonstrates that web applications developed
under this framework are free from certain classes of vul-
nerabilities. Related work is discussed in Section 6. Fi-
nally, Section 7 concludes and presents avenues for fur-
ther research.
2 Framework design
At a high level, the web application framework is com-
posed of several familiar components. A web server
component processes HTTP requests from web clients
and forwards these requests in an intermediate form to
the application server based on one of several conﬁgura-
tion parameters (e.g., URL path preﬁx). These requests
are directed to one of the web applications hosted by
the application server. The web application examines
any parameters to the request, performs some process-
ing during which queries to a back-end database may be
executed, and generates a document. Note that in the fol-
lowing, the terms “document” or “web document” shall
generically refer to any text formatted according to the
HTML or XHTML standards. This document is then
returned down the component stack to the web server,
which sends the document as part of an HTTP response
to the web client that originated the request. A graphical
depiction of this architecture is given in Figure 1.
Figure 1: Architectural overview of the web application framework.
Web applications developed for our framework are
structured as a set of functions with access to a com-
bination of conﬁguration data and application state.
More precisely, web applications execute inside the App
monad. Monads are a category theoretic construction
that have found wide application in Haskell to sequence
actions or isolate code that can produce side effects.1 For
the purposes of our framework, we use the App monad to
thread implicit state through the functions comprising a
web application, and to provide a controlled interface to
potentially dangerous functions.
In particular, the App
monad itself is structured as a stack of monad transform-
ers that provide a functional interface to a read-only con-
ﬁguration type AppConfig, a read-write application state
type AppState, and ﬁltered access to the IO monad. The
deﬁnitions for AppConfig and AppState are given in
Figures 2 and 3.
data AppConfig = AppConfig {
appCfgPort :: Int,
appCfgPrefix :: String,
appCfgRoutes :: RouteMap,
appCfgFileRoot :: FilePath,
appCfgDBConn :: Connection,
appCfgDBStmts :: StmtMap
}
Figure 2: Deﬁnition for the AppConfig type.
The AppConfig type holds static information relating
to the conﬁguration of the application, including the port
on which to listen for HTTP requests and the root direc-
tory of static ﬁles to serve from the ﬁlesystem. Of partic-
ular interest, however, are the RouteMap and StmtMap
ﬁelds. The RouteMap type describes how URL paths
are mapped to values of type DocumentGen, which are
simply functions that generate documents within the App
monad. In addition, the RouteMap type contains a de-
fault DocumentGen type that speciﬁes an error page.
Given an incoming HTTP request destined for a partic-
1For further information on monads, please refer to [37, 48].
ular web application, the application server uses that ap-
plication’s RouteMap type to determine the proper func-
tion to call in order to generate the document to be re-
turned to the client.2 Finally, the StmtMap type asso-
ciates unique database query identiﬁers to prepared state-
ments that can be executed by a document generator.
data AppState = AppState {
appStClient :: Maybe SockAddr,
appStUrl :: Maybe Url
}
Figure 3: Deﬁnition for the AppState type.
The AppState type contains mutable state that is spe-
ciﬁc to each request for a document. In particular, one
ﬁeld records information indicating the source of the re-
quest. Additionally, another ﬁeld records the URL that
was requested, including any parameters that were spec-
iﬁed by the client. More complex state types that hold
additional information (e.g., cached database queries or
documents) are possible, however.
3 Document structure
In this section, we introduce the means by which doc-
uments are speciﬁed under the framework. Then, we
discuss how these speciﬁcations allow the framework to
automatically contain the potentially harmful effects of
dynamic data.
3.1 Document speciﬁcation
Once an appropriate route from the RouteMap structure
has been selected by the application server, the asso-
ciated document generator function is executed within
the context of the App monad (i.e., with access to the
2This construction is similar to the “routes” packages present in
popular web development frameworks such as Rails [18] and Py-
lons [4].
DatabaseHTTPrequestHTTPresponseHTTPserverApplicationserverWebapplicationdata Document Document {
docType :: DocumentType,
docHead :: DocumentHead,
docBody :: DocumentBody
}
data DocumentType = DOC TYPE HTML 4 01 STRICT
| DOC TYPE HTML 4 01 TRANS
| ...
| DOC TYPE XHTML 1 1
data DocumentHead = DocumentHead {
docTitle :: String,
docLinks :: [Node],
docScripts :: [Node],
docBaseUrl :: Maybe Url,
docBaseTarget :: Maybe Target,
docProfile :: [Url]
}
data DocumentBody = DocumentBody {
}
docBodyNode :: Node
Figure 4: Deﬁnition for the Document type.
conﬁguration and current state of the application). The
document generator function processes the request from
the application server and returns a variable of type
Document. The deﬁnition of the Document type and its
constituent types are shown in Figure 4.
As is evident, documents in our framework are not
represented as an unstructured stream of bytes. Rather,
the structure of the Document type closely mirrors
that of parsed HTML or XHTML documents. The
DocumentType ﬁeld indicates the document’s type, such
as “HTML 4.01 Transitional” or “XHTML 1.1”. The
DocumentHead type contains information such as the ti-
tle and client-side code to execute. The DocumentBody
type contains a single ﬁeld that represents the root of a
tree of nodes that represent the body of the document.
Each node in this tree is an instantiation of the
Node type. Each Node instantiation maps to a distinct
(X)HTML element, and records the set of possible prop-
erties of that element. For instance, the TextNode data
constructor creates a Node that holds a text string to be
displayed as part of a document. The AnchorNode data
constructor, on the other hand, creates a Node that holds
information such as the href attribute, rel attribute, and
a list of child nodes corresponding to the text or other el-
ements that comprise the “body” of the link. A partial
deﬁnition of the Node type is presented in Figure 5.
With this construction, the entire document produced
by a web application in our framework is strongly typed.
Instead of generating a document as a byte stream, doc-
data Node = TextNode {
nodeText :: String
}
| AnchorNode {
anchorAttrs :: NodeAttrs,
anchorHref :: Maybe Url,
anchorRel :: Maybe Relationship,
anchorRev :: Maybe Relationship,
anchorTarget :: Maybe Target,
anchorType :: Maybe MimeType,
anchorCharset :: Maybe CharSet,
anchorLang :: Maybe Language,
anchorName :: Maybe AttrValue,
anchorShape :: Maybe Shape,
anchorCoords :: Maybe Coordinates,
anchorNodes :: [Node]
| DivNode {
divAttrs :: NodeAttrs,
divNodes :: [Node]
}
} ...
Figure 5: Sample Node deﬁnitions.
ument structure is explicitly encoded as a tree of nodes.
Furthermore, each element and element attribute has an
associated type that constrains, to one degree or another,