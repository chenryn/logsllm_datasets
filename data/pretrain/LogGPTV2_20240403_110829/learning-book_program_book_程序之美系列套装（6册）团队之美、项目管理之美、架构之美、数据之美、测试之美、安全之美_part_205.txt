小结
1158
---
## Page 1160
本节概要介绍了JikesRVM的优化编译器的许多高级组件。用Java编
写这些组件已经给这些系统带来了许多内在的好处。线程是有用
的，允许系统的所有组件都支持多线程。系统设计成线程安全，例
如，容许多个编译器线程并行运行。另一个优点来自Java通用的集
合，它提供了易于理解的库，简化了开发，并容许系统的组件集中
在它们的角色上，而不是底层的数据结构管理。
10.5.4异常模式
异常是例外情况吗？虽然许多程序员对这个问题都抱着肯定的观
点，但是，虚拟机必须对基准测试中常见的用例进行优化。有问题
的用例是读取一个输入流并当一个预期的模式出现时抛出一个异
常。这种模式既出现在SPECjvm98!ljack基准测试中又出现在
DaCapo2006I=1-lusearch基准测试中。
首先让我们考虑一个异常需要什么。每个异常必须创建在抛出异常
）
这个异常的catch块。通过允许出现内存保护失败，空指针异常（例
如，读或写不存在的内存页）就有效地处理了。当产生一个错误
时，错误指针的地址会提供给一个处理器。正是因为如此，栈跟踪
和处理器信息必须确定下来。
用C语言编写的虚拟机会设法使用C的调用方式来调用Java的即时编
译代码。其中的一个问题是C的调用方式不记录正在运行的代码，
为了解决这个问题，C的虚拟机可以设法使用返回地址来计算正在
运行的方法。必须搜索虚拟机内的每个方法来了解它对应的编译后
代码是否包含特定的返回地址。对于当前栈中的每个方法都必须进
行重复搜索。由于JfikesRVM控制了它的内存配置，栈配置成包含额
外的信息来快速地处理异常。JikesRVM特别在栈上放置了一个标识
符，以便不用提供方法信息就能进行简单地查找。为了确定字节码
出现异常的地方和处理器的位置，需要利用返回地址或错误指针地
址进行计算。这意味着处理一个异常的速度与栈的深度成比例，而
不由虚拟机中方法的数量来决定。
和其他虚拟机一样，JikesRVM尽可能优化地远离异常，最好把异常
压缩到分支。它还把许多方法内联到一个方法中，因此，在栈上放
置一个标识符的情况很少发生，只有当处理未内联的方法时才这样
处理。
1159
---
## Page 1161
[1]http://www.spec.org/jvm98/.
[2]_http://dacapobench.org/
10.5.5Magic、annotation，使事情流畅地进行
由编译器生成的代码有直接存取内存的指令。有时候需要直接存取
内存一例如，为了实现垃圾收集程序或为了锁住对象而访问对象
头。为了容许强类型地内存存取，JikesRVM利用一个名为VM
Magic的库，它已经作为一个标准接口并用于其他的JVM项目中。
VMMagic定义了这两种类：编译器pragmaannotation（扩展了Java语
言）或未封装类型（描绘对底层内存系统的存取）。未封装类型的
地址用于直接存取内存。
JikesRVM的编译器内特别处理了VMMagic的未封装类型。对未封
装类型的所有方法调用都作为直接操作一个宽度为一个字的值来对
待。例如，“plus"这个方法会作为累加机器底层一个字的宽度来对
待，从而直接影响通常是这个对象的指针的内容。由于操作的这个
值不是一个对象的引用，编译器会标明，垃圾收集器对保存未封装
类型的位置和保存基础字段（例如一个int）的内存地址同样感兴
趣。
拥有强类型存取内存还不足于完全容许JikesRVM完好地运行。还需
要一些专门的方法向编译器指明内在的事情正在发生或它们应该简
化部分的Java强类型语法。这些专门的方法存在于
orgjikesrvm.runtime.Magic中。一个内在操作的例子是平方根方法，
对于这个方法，Java没有提供字节码，但许多计算机架构都有直接
获得结果的一条指令或一个程序。绕过Java的强语义的一个例子是
在线程调度的过程中避免转换，因为在某些关键时刻运行时异常是
不允许的。
所有的神奇操作都采用不同于常规方法的方式编译，而且它们不能
作为单独的方法进行编译。方法确实在那儿，但如果一旦执行它
们，就会抛出一个异常。编译器根据方法来确定哪个神奇运算正在
执行，然后寻找编译器必须为它提供哪些运算。在启动映像的创建
期间，提供了一些未封装的神奇类型和方法的替换。例如，对象在
配置好之前在启动映像中的地址是未知的。启动映像的未封装类型
知道标识符和它们映射的对象。在启动映像的创建期间，这些标识
符链接到它们引用的对象。
1160
---
## Page 1162
虽然神奇运算和未封装类型允许JikesRVM中的Java代码像C或
C++中的指针一样有权访问内存，但是，指针是强类型，不能用来
代替引用。强类型使程序员的错误在编译期就能发觉，优秀的集成
IDE和对查找缺陷的工具的支持，所有这些都帮助了JikesRVM的开
发。
10.5.6线程模式
Java有完整的线程支持。在1998年，操作系统对线程的支持还不能
很好地适合许多Java应用程序。尤其是，典型的操作系统线程实现
方式不适合支持单个进程中有好几百个线程，锁操作（实现Java的
同步方法所必需的）的开销非常昂贵。为了避免这个开销，一些
JVM自己实现线程，利用一个名为绿色线程（greenthreading）的操
作模式。在绿色线程中，线程是通过让JIVM自已管理这个过程（把
多个Java线程复合到较少的操作系统线程上，通常是复合到一个操
作系统线程，或在多处理器系统中每个处理器一个线程）来实现
的。绿色线程的主要优点在于实现了Java语义中特有的锁和线程调
度并使它非常容易扩展。主要缺点是操作系统不知道JVM正在做什
么，这会导致许多性能反常，尤其当Java应用程序与本机代码频繁
交互的时候（它自身对线程模式进行了假定）。然而，实现绿色线
程的IVM已经为许多Java操作系统项目（能够避免绿色线程在标准
操作系统上的性能反常）提供了基础。
随着处理器性能和操作系统实现的改进，在IVM中管理线程的优势
势。
利用Java，一个清楚的线程API已经创建以允许JikesRVM拥有不同
的底层线程模式，就像由不同的操作系统提供的那些模式一样。将
来，在语言和操作系统之间拥有一个灵活的接口可以容许JikesRVM
适合新的程序员行为（例如，支持数千个线程）。
10.5.7本机接口
很不幸，JikesRVM不能全部使用Java代码。访问操作系统程序必须
分配内存页。JikesRVM的类库把Java代码与现有的库（例如用于窗
口化的库）结合起来。JikesRVM提供了两种方式来访问本机码：
Java本机接口（Java Native Interface,JNI）
1161
---
## Page 1163
INI是容许Java应用程序与通常用C编写的本机应用程序结合的一个
标准。JNI的一个特性是可以处理Java对象，也可以调用Java方法。
为了防止本机代码访问的对象被当作垃圾收集掉，这些对象必须记
录下来。当使用NI调用本机方法时，这会产生一些开销。
系统调用
在系统调用的声明中，它们与本机方法相似，只是它们有一个额外
的annotation。由于限制了本机代码不能通过INI接口回调入虚拟
机，系统调用容许更有效地与本机代码进行传人和传出。JikesRVM
利用默认的操作系统调用惯例把系统调用实现为对一个本机方法的
简单的进程调用。
10.5.8类加载器和反射
类加载器负责把类载入JikesRVM并把这个过程与对象模式连接起
来。反射允许一个应用程序查询对象的类型，甚至对在静态编译期
还不知道其类型的对象进行方法调用。反射是通过应用程序使用像
java.lang.Class这样的对象或像java.lang.reflect包中那些对象（它们
是在JikesRVM的运行时执行的API封装器）来进行的。
由于一些优化依赖类的层次结构，重要的运行时钩子存在于类加载
器中，如果先前保存的假定不再正确时它们可以触发重新编译。关
于这些内容，我们已经在前面的10.5.3节详细地讨论过。
10.5.9垃圾收集
内存管理工具包（MemoryManagementToolkit,MMTk）是构建高性
能内存管理实现的一个框架（Blackburn等，2004年5月）。经过5年
时间，MIMTk已经成为垃圾收集研究团体密集使用的核心基础。它
的高便捷和可配置架构是它取得成功的关键。除用作JikesRVM的内
存管理系统之外，它也移植到了其他语言的运行时，例如Rotor。本
节将略微讨论一些MIMTk的关键设计概念。关于垃圾收集算法和概
念的完整信息，最好的参考是《GarbageCollection：Algorithmsfor
Automatic Dynamic Memory Management（Jones和Lins 1996）》。
MMTk的一个底层元法则完全用在了JikesRVM中：通过依赖一个激
进的优化编译器，可以以高层次、可扩展和面向对象的风格编写出
高性能的代码。这个法则在MIMTk中得到最大的发展，即使对性能
而言非常关键的操作（例如快速的对象分配路径和写障碍）也完全
1162
---
## Page 1164
表示成结构良好的、面向对象的Java代码。表面上，这种风格与高
性能（分配单个对象，有许多代码级的虚拟调用和相当多复杂的数
值计算）完全不相容。然而，当分配序列由优化编译器递归内联和
优化后，它会产生紧密内联的代码序列（类似于分配一个对象并初
始化该对象头的10个机器指令），这些代码序列等同于那些通过在
汇编代码中手写的快速路径序列或把它硬写入编译器而获得的代码
序列。
MMTk把内存组织成空间（Space），这是（可能不连续的）虚拟内
存区域。MIMTk提供了空间的许多不同的实现，每个实现都体现了
一个分配和回收由空间管理的虚拟内存块的特殊基础机制。例如，
CopySpace利用碰（bump）指针分配并通过把所有活的对象复制到
另一个空间来回收；MarkSweepSpace通过这种方式组织内存：利用
空闲列表把空闲的内存块链在一起，通过“清扫"无记号的（死的）
对象并把它们重新链接到适当的空闲列表来支持分配。
计划（Plan）是MMTk关于一个垃圾收集算法的典型构想的术语。
计划是通过把一个或多个空间实例以不同的方式组合在一起来定义
的。例如，MMTk的GenMS计划实现了相当标准的按代的标记来清
除的算法，组合了一个CopySpace和一个MarkSweep空间来分别实现
新生代和壮年代的空间。除了用于管理用户级Java堆的空间之外，
所有的MIMTk计划还包括好几个用于管理虚拟机级内存的空间。特
别地，专门的空间用于分配即时生成的代码、JikesRVM启动映像和
低级别的虚拟机实现对象（例如类型信息块）。在MMTk3.0版本中
预定义和发布了15个计划（也就是15个不同的垃圾收集算法）。此
外，许多其他的计划已经由MIMTk研究团体开发出来并发布在学术
文献中。
MIMTk和它的主机运行时环境通过两个仔细定义的、说明MMTk暴
露给主机虚拟机哪些API和MMTk希望主机提供哪些虚拟机服务的接
口来进行交互。为了保持MIMTk对于多个主机虚拟机的轻便性，构
建过程通过依靠虚拟机接口的一个存根实现单独编译MMTk来严格
控制这两个接口。或许这些接口最复杂的是用于允许MMTk和Jikes
RVM协作识别用于垃圾收集的根的那部分。大部分MIMTK的计划都
代表轨迹收集器。在一个轨迹收集器中，垃圾收集器从一组根对象
（通常是这个程序的全局变量和线程栈结构中的引用）开始并对它
们的引用域求传递闭包来找到所有可获得的对象。可获得的对象认
为是活的且不会收集掉。传递闭包中不可获得的任何对象都是死
的：这些都会由收集器安全地回收并用于满足将来的内存分配请
1163
---
## Page 1165
求。在JikesRVM中，垃圾收集的根来自寄存器、栈、Java内容表和