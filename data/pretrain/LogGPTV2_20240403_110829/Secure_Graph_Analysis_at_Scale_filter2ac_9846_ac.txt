We aim for security against malicious adversaries (namely, ad-
versaries that can behave arbitrarily and do not necessarily follow
the protocol). We follow the common design methodology of MPC,
which first designs protocols that are secure against semi-honest
adversaries and then enhances these protocols to be secure against
malicious adversaries.
The data elements are shared using replicated
Sharing method
secret sharing in the following way: Let the three servers be denoted
as S1,S2 and S3. We assume that the servers share binary strings of
length ğ‘š. For every input ğ‘¥ âˆˆ {0, 1}ğ‘š, let ğ‘, ğ‘, ğ‘ âˆˆ {0, 1}ğ‘š be chosen
at random subject to the constraint that ğ‘¥ = ğ‘ âŠ• ğ‘ âŠ• ğ‘. Server S1
has shares ğ‘, ğ‘, server S2 has shares ğ‘, ğ‘, and server S3 has ğ‘, ğ‘.
Notation Our input always consists of multiple elements of the
same length (representing (ğ‘¢, ğ‘£, ğ‘‘) tuples). It is therefore sometimes
convenient to denote each element as a â€œrowâ€, and denote an or-
dered set of elements as a â€œtableâ€. We can then discuss shuffling
and sorting rows of a table.
Protocols There exist very efficient protocols and implementations
for generic secure MPC in the three-party setting. These protocols
are based on representing the computed function as a circuit. The
primary challenge is in securely implementing functions that do
not have an efficient representation as a circuit.
We construct protocols of secure multi-party computation for
the following three tasks, which are then used to implement secure
message-passing algorithms for distributed graph analysis.
â€¢ Computing a random shuffle of the rows of a table.
â€¢ Sorting the rows of a table.
â€¢ Set equality: verifying that two sets of rows are equal.
4 SECURE SHUFFLING AND SORTING
Our sorting protocol follows the work of Hamada et al.[26], which
first randomly shuffles the data and then applies to the result a
comparison-based sorting protocol. The parties running the proto-
col decide on a key â€“ some field by which rows are ordered. The
input to the protocol is a shared table, and the output is a random
sharing of this table where the rows are sorted based on the key.
The main improvement of our work is an efficient transformation
to full security. We also optimize the implementation of the shuffle
and sorting protocols.
The sorting protocol includes two phases:
â€¢ The first phase is a secure computation of a shuffle. Namely,
the output is a random sharing of a random permutation of
rows of the input table. (This step is also used by itself in our
graph computation protocol.)
â€¢ The second phase applies a secure sorting protocol to the
output of the first phase. The output is the permutation
which maps the rows of the table that was output by
the first phase, to their location in the sorted table.
This permutation is applied to a random permutation of the
original rows, and therefore does not leak any information
about the order of the original input.
Applying the two phases enables to compute a sharing of the sorted
table. In this work we apply the two phases separately. We then
use the fact that both the initial shuffle, and the permutation to a
sorted table, can be computed once and saved, and later be applied
multiple times.
Roadmap The shuffle protocols, secure against semi-honest
adversaries, include a 3-round protocol based on Laur et al. [33],
and a new 2-round shuffle protocol. The protocols are described
in Section 5. The secure sort protocol for the semi-honest setting
is described in Section. 5.3. Section 6.1 describes a set equality
verification protocol which is the basis for our efficient trans-
formation for achieving full security. Given the set-equality ver-
ification protocol, we show how to obtain full security against
malicious behavior for the shuffle and sort protocols (Sec. 6.2). Ap-
pendices A.1 and A.2 describe implementation optimizations
and experiments of the sorting protocol.
5 SEMI-HONEST SECURE SHUFFLING
The basic method for secure shuffling is based on Laur et al. [33],
and consists of three invocations of a "shuffle-pair" protocol, in
which the shuffle is known to two parties and is hidden from the
third party. In each of these invocations a different party does not
know the corresponding shuffle, and therefore no party knows the
composition of all three shuffles. We also describe in Section 5.2 a
new shuffle protocol which runs in only two rounds, rather than
three, but we do not describe a fully secure version for that protocol.
Functionality definition The input to the shuffle operation is
a sharing of a single table ğ‘‡ . The output is a random sharing of a
table ğ‘‡ğ‘‚ with the same rows as in the first table but in a random
order. Namely, the following two properties are satisfied:
Session 2D: Secure Multiparty Computation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea615Input: A sharing of a table T.
Output: A sharing of Tğ‘‚, which is a random shuffle of T.
(1) T1 = Shuffle-pair(T,S1,S2,S3)
(2) T2 = Shuffle-pair(T1,S2,S3,S1)
(3) Tğ‘‚ = Shuffle-pair(T2,S3,S1,S2)
Figure 3: The 3-message shuffle protocol.
â€¢ The set of rows of ğ‘‡ and of ğ‘‡ğ‘‚ are equal (moreover, a row
appears â„“ times in ğ‘‡ if and only if it also appears â„“ times in
ğ‘‡ğ‘‚).4
â€¢ The order of the rows in ğ‘‡ğ‘‚ is uniformly random. The view
of any single server is independent of the order of the rows.
Notation Recall the following notation: The number of rows in ğ‘‡
is ğ‘›, the length of each row is ğ‘š, and the length of each key for the
sorting is ğ‘˜.
The basic idea of the protocol follows a protocol suggested in [33]
â€“ it compose three random shuffles of the table, where each server
does not know one of these shuffles. We describe two variants of
the protocol.
â€¢ The first protocol, described in Section. 5.1, computes the
shuffle in three rounds, where each round applies a random
shuffle protocol (â€œShuffle-pairâ€) which is known to two of
the servers and hidden from the third server.
â€¢ The second protocol, described in Section 5.2, runs in only
two rounds. It works by transforming the 2-out-of-3 sharing
of the table to a series of 2-out-of-2 sharings, running three
shuffles with the different pairs of parties while merging
communication rounds which do not depend on each other.
5.1 A 3-round, 6-message, shuffle protocol
The protocol uses a sub-protocol denoted as Shuffle-pair, which
is run between three ordered servers. The input to Shuffle-pair
is a shared table. The output is a sharing of a shuffled version of the
table. The two first servers know the shuffle that was applied to the
table, but the shares of the third server are distributed independently
of the original input and of the shuffle.
The notation Tâ€™=Shuffle-pair(T,S1,S2,S3) refers to running
the Shuffle-pair protocol on shares of a table T, with the servers
ordered S1,S2,S3. The output Tâ€™ is shared between the servers.
The 3-round shuffle protocol is described in Figure 3. Given the
properties of the Shuffle-pair sub-protocol, at the end of the first
Shuffle-pair, server S3 does not know the relation between T
and T1, and at the end of the third step none of the servers knows
the relation between T and ğ‘‡ğ‘‚.
Implementing Shuffle-pair
An invocation of Shuffle-pair(T,S1,S2,S3) works in the fol-
lowing way. As input to the protocol, server S1 has shares A,B,
server S2 has shares B,C, and server S3 has shares C,A. Each of
these shares is a table of ğ‘› Ã— ğ‘š bits, and it holds that ğ‘‡ = ğ´ âŠ• ğµ âŠ• ğ¶.
At the end of the protocol the parties will have share ğ´ğ‘‚, ğµğ‘‚, ğ¶ğ‘‚
4The sorting protocol requires all keys to be different, and therefore no two rows can
be equal. The shuffle protocol can also handle the case of equal rows.
Input: A sharing of a table T = A âŠ• B âŠ• C.
Output: A sharing of Tğ‘‚ = Ağ‘‚âŠ• Bğ‘‚âŠ• Cğ‘‚ = ğœ‹(ğ‘‡), which is a
random shuffle of T. Servers S1 and S2 learn ğœ‹.
S2
ğµ, ğ¶
ğ‘ 12, ğ‘ 23
S3
ğ¶, ğ´
ğ‘ 31, ğ‘ 23
S1
ğ´, ğµ
ğ‘ 12, ğ‘ 31
ğœ‹(ğ´), ğœ‹(ğµ)
ğ´ğ‘‚ = ğ‘“ (ğ‘ 31)
Computation and messages
ğœ‹(ğµ), ğœ‹(ğ¶)
ğ¶ğ‘‚ = ğ‘“ (ğ‘ 23) ğ¶ğ‘‚ = ğ‘“ (ğ‘ 23)
ğ´ğ‘‚ = ğ‘“ (ğ‘ 31)
ğœ‹(ğ´) âŠ• ğ´ğ‘‚ â†’
â† ğœ‹(ğ¶) âŠ• ğ¶ğ‘‚
ğµğ‘‚ = ğœ‹(ğµ) âŠ• (ğœ‹(ğ´) âŠ• ğ´ğ‘‚) âŠ• (ğœ‹(ğ¶) âŠ• ğ¶ğ‘‚)
AO, BO
BO, CO
CO, AO
Outputs
Figure 4: Shuffle-pair protocol
such that ğ‘‡ğ‘‚ = ğ´ğ‘‚ âŠ• ğµğ‘‚ âŠ• ğ¶ğ‘‚. The protocol is implemented in the
following way, and is depicted in Figure 4:
(1) The parties are sharing some random seeds beforehand in
the following way. S1 and S2 share a seed ğ‘ 12. S2 and S3
share ğ‘ 23. S3 and S3 share ğ‘ 31.
(2) Servers S1 and S2 use the seed ğ‘ 12 to generate a permutation
ğœ‹ of the ğ‘› rows.
(3) S1 and S2 each apply ğœ‹ to the rows of their shares, computing
intermediate shares ğ´â€² = ğœ‹(ğ´), ğµâ€² = ğœ‹(ğµ) for S1, and the
shares ğµâ€² = ğœ‹(ğµ), ğ¶â€² = ğœ‹(ğ¶) for S2.
(4) S3 computes two new shares ğ´ğ‘‚, ğ¶ğ‘‚, each of which is a
table of random ğ‘› Ã— ğ‘š bits. The share ğ´ğ‘‚ is computed as a
function of the seed ğ‘ 31 and a disclosed nonce, and the share
ğ¶ğ‘‚ is computed as a function of the seed ğ‘ 23 and the same
disclosed nonce.
ğ‘ 31 and the nonce. It sends the table ğ´â€² âŠ• ğ´ğ‘‚ to S2.
ğ‘ 23 and the nonce. It sends the table ğ¶â€² âŠ• ğ¶ğ‘‚ to S1.
ğ´ğ‘‚) âŠ• (ğ¶â€² âŠ• ğ¶ğ‘‚).
for S3.
(6) S2 similarly computes the table ğ¶ğ‘‚ as a function of the seed
(7) Both S1 and S2 set their other share to be ğµğ‘‚ = ğµâ€² âŠ• (ğ´â€² âŠ•
(8) The new shares are ğ´ğ‘‚, ğµğ‘‚ for S1, ğµğ‘‚, ğ¶ğ‘‚ for S2, and ğ¶ğ‘‚, ğ´ğ‘‚
(5) S1 similarly computes the table ğ´ğ‘‚ as a function of the seed
Correctness holds since the sum of the new shares is equal to
the permuted table: ğ´ğ‘‚ âŠ• ğµğ‘‚ âŠ• ğ¶ğ‘‚ = ğ´ğ‘‚ âŠ• (ğµâ€² âŠ• (ğ´â€² âŠ• ğ´ğ‘‚) âŠ• (ğ¶â€² âŠ•
ğ¶ğ‘‚)) âŠ• ğ¶ğ‘‚ = ğ´â€² âŠ• ğµâ€² âŠ• ğ¶â€² = ğœ‹(ğ´) âŠ• ğœ‹(ğµ) âŠ• ğœ‹(ğ¶) = ğœ‹(ğ‘‡).
The preprocessing communication involves sending short seeds
before the protocol. The online communication includes bi-directional
(duplex) communication between these S1 and S2, where each party
sends a table to the other one. (The bi-directional communication
is important for performance, since the messages between S1 and
S2 can be sent in parallel.)
Session 2D: Secure Multiparty Computation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea616S1
ğ´, ğµ
ğœ‹12, ğ‘12, Ëœğµ
ğœ‹31, ğ‘31, Ëœğ´
S2
ğµ, ğ¶
ğœ‹12, ğ‘12, Ëœğµ
ğœ‹23, ğ‘23
ğ‘‹1 = ğœ‹12(ğ´ âŠ• ğµ âŠ• ğ‘12)
ğ‘‹2 = ğœ‹31(ğ‘‹1 âŠ• ğ‘31)
ğ‘‹2 â†’
Computation and messages
ğ‘Œ1 = ğœ‹12(ğ¶ âŠ• ğ‘12)
ğ‘‹3 = ğœ‹23(ğ‘‹2 âŠ• ğ‘23)
Ëœğ¶1 = ğ‘‹3 âŠ• Ëœğµ
Ëœğ¶ = Ëœğ¶1 âŠ• Ëœğ¶2
Outputs
ËœB, ËœC
ËœA, ËœB
S3
ğ¶, ğ´
ğœ‹23, ğ‘23
ğœ‹31, ğ‘31, Ëœğ´
ğ‘Œ1 â†’
Ëœğ¶1 â†â†’ Ëœğ¶2
ğ‘Œ2 = ğœ‹31(ğ‘Œ1 âŠ• ğ‘31)
ğ‘Œ3 = ğœ‹23(ğ‘Œ2 âŠ• ğ‘23)
Ëœğ¶2 = ğ‘Œ3 âŠ• Ëœğ´
Ëœğ¶ = Ëœğ¶1 âŠ• Ëœğ¶2
ËœC, ËœA
Figure 5: 2-round 4-message Shuffle protocol
Claim 1. The Shuffle-pair protocol of Figure 4 is secure against
semi-honest adversaries. Furthermore, privacy is preserved even against
a malicious server.
Proof: The third server does not receive or send any messages,
except for random seeds in the preprocessing phase, and therefore
its view can be easily simulated given its input and output. The
view of the first server can be simulated using its input ğ´, ğµ, ğ‘ 12, ğ‘ 13,
and output ğ´ğ‘‚, ğµğ‘‚ (note that ğœ‹ is a function of ğ‘ 12): the message
that it receives, ğœ‹(ğ¶) âŠ• ğ¶ğ‘‚, is equal to ğµğ‘‚ âŠ• ğœ‹(ğµ) âŠ• (ğœ‹(ğ´) âŠ• ğ´ğ‘‚).
A similar argument holds for the second server.
Claim 2. The 3-round protocol of Figure 3 is secure against semi-
honest adversaries. Furthermore, privacy is preserved even against a
malicious server.
Proof: The security of the complete shuffle protocol follows from
the fact that for each server there is an instance of the Shuffle-pair
protocol in which this server serves as the third party and does
not learn the permutation that was applied to the table. More for-
mally, consider, for instance, S1, for which the simulator needs to
assign inputs and outputs for all Shuffle-pair invocations. Its
inputs and output in the protocol are random shares of ğ‘‡ and ğ‘‡ğ‘‚.
In the simulation, it sets its input to the first Shuffle-pair to be
its shares of ğ‘‡ , its output from the third Shuffle-pair to be its
shares of ğ‘‡ğ‘‚, and its input and output to the second Shuffle-pair
to be random shares (these also correspond to its output of the
first Shuffle-pair and its input to the third Shuffle-pair). It
assigns random permutations ğœ‹1, ğœ‹3 to its output from the first and
third Shuffle-pair. The distribution of this view is identical to
the distribution of these values in the real execution of the protocol.
A note on malicious adversaries With regards to malicious ad-
versaries, note that the only change to the protocol that a malicious
ğ‘†1 can do is to replace the message ğœ‹(ğ´) âŠ• ğ´ğ‘‚ with a different
message ğ·. We can write ğ· as ğ· = (ğœ‹(ğ´) âŠ• ğ´ğ‘‚) âŠ• Î”. The effect
of this behavior is to change the output share from ğµğ‘‚ to ğµğ‘‚ âŠ• Î”
and thus change the shared output to ğ‘‡ğ‘‚ âŠ• Î”. A similar argument
applies with respect to the other two servers. As a result, we can
conclude that the only change to the functionality that a malicious
server can cause is to add a constant of its choice to the shared
output of the protocol.
5.2 A 2-round, 4-message, shuffle protocol
The following protocol, depicted in Figure 5. is more efficient than
composing three shuffle-pair protocols. On the other hand, it is
easier to convert the shuffle-pair solution to be secure against ma-
licious behavior, and therefore we will use that approach in our
work.
The protocol keeps the invariant that for ğ‘– = 1, 2, 3, it holds that
ğ‘‹ğ‘– âŠ• ğ‘Œğ‘– is a shuffle of ğ‘‡ . The parties begin by sharing some seeds of
randomness, such that S1 and S2 share a seed ğ‘ 12, S2 and S3 share
ğ‘ 23, and S3 and S1 share ğ‘ 31.
S1 and S2 use ğ‘ 12 to generate a pseudo-random permutation
ğœ‹12 and generate pseudo-random tables ğ‘12 and Ëœğµ of the size of
ğ‘‡ . S2 and S3 use ğ‘ 23 to generate a pseudorandom permutation ğœ‹23
and a pseudo-random table ğ‘23. S3 and S1 use ğ‘ 31 to generate a
permutation ğœ‹31 and pseudo-random tables ğ‘31 and Ëœğ´.