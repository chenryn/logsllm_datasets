The teas application consists of about 140 lines of
C code, which is compiled to 913 lines of MIPS as(cid:173)
sembly code, which in tum is translated to 800 lines of
SymPLFIED's assembly code (by our custom transla(cid:173)
tor). teas takes as input a set of 12 parameters indicat(cid:173)
ing the positions of the two aircrafts and prints a single
number as its output. The output can be one of the
following values: 0, 1, or 2, where 0 indicates that the
condition is unresolved, 1 indicates an upward advi(cid:173)
sory, and 2 indicates a downward advisory. Based on
these advisories, the aircraft operator can choose to
increase or decrease the aircraft's altitude.
In the later part of this section, we describe how
we apply SymPLFIED on the replace program of the
Siemens suite [18] in order to understand the effects of
scaling to larger programs.
6.1
Experimental Setup
under
error-free
Our goal is to find whether a transient error in the
register file during the execution of teas can lead to
the program's producing an incorrect output (in this
case, an advisory). We chose an input for teas in
which the upward advisory (value of 1) would be pro(cid:173)
duced
directed
SymPLFIED to search for runs in which the program
did not throw an exception and produced a value other
than 1 under the assumption of a single register error
in each execution. The search space constitutes about
(800 x 32) possible injections, since there are 32 regis(cid:173)
ters in the machine, and each instruction in the pro-
execution. We
1-4244-2398-9/08/$20.00 ©2008 IEEE
479
DSN 2008: Pattabiraman et al.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:30:25 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems & Networks: Anchorage, Alaska, June 24-27 2008
gram is chosen as a breakpoint. To reduce the search
space, at each breakpoint, only the register(s) used by
the instruction was injected.
The injections were started on a cluster of 150
dual-processor AMD Opteron machines in order to
ensure quick tum-around. The search command is split
into multiple smaller searches, each of which sweeps a
particular section of the program code looking for er(cid:173)
rors that satisfy the search conditions. The smaller
searches can be performed independently by each
node in the cluster and the results pooled together to
find the overall set of errors. The maximum number of
errors found by each search task was capped at 10, and
a maximum time of 30 minutes was allotted for task
completion (after which the task was killed).
To validate the results from SymPLFIED, we
augmented the SimpleScalar simulator [1 7] with the
capability to inject errors into the source and destina(cid:173)
tion registers of all instructions, one at a time. For
each register, we injected three extreme values in the
integer range as well as three random values, so that a
representative sample of the errors in each value can
be considered by the injections.
6.2
SymPLFIED Results
Running Time: Of the 150 search tasks started
on the cluster, 85 tasks completed within the allotted
time of 30 minutes. The remaining 65 tasks did not
complete in the allotted time. We report results only
from the tasks that completed. Of the 85 tasks that
completed, 70 tasks did not find any errors that satisfy
the conditions in the search command (as either the
error was benign or the program crashed due to the
error). These 70 tasks completed within at most 1
minute. The time taken by the 15 completed tasks that
found errors satisfying the search condition was less
than 4 minutes, and the average time for task comple(cid:173)
tion was 64 seconds. Even without considering the
incomplete tasks, we were able to find the catastrophic
outcome for tcas, shown below.
Outcomes: For the tcas application, we found on(cid:173)
ly one case where an output of 1 is converted to an
output of 2 by the fault injections. This can potentially
be catastrophic, as it is hard to distinguish from the
correct outcome of tcas. None of the other injections
found any other such case. We also found cases where
(1) tcas printed an output of 0 (unresolved) in place of
1, (2) the output was outside the range of the allowed
values printed by tcas, or (3) the program crashed
(numerous cases). We do not report these cases, as
tcas is only an advisory tool, and the operator can ig(cid:173)
nore the advisory if he or she determines that the out(cid:173)
put produced by tcas is incorrect. We also found viola(cid:173)
tions in which the value is computed correctly but
printed incorrectly. We do not report these errors, as
the output method may be different in the real system.
int alt_sep_testO
{
enabled = High_Confidence && (Own_Traeked_Alt_Rate  MAXALTDIFF);
teas_equipped = Other_Capability == TCAS_TA;
intent_not_known
Two_of_Three_Reports_Valid
&&
(Other_RAC == NO_INTENT);
alt_sep = UNRESOLVED;
if
(enabled && «teas_equipped && intent_not_known)
II
!teas_equipped)) {
Own_Below_ThreatO;
need_upward_RA = Non_Crossing_Biased_Climb0 &&
need_downward_RA
Non_Crossing_Biased_DescendO && Own_Above_Threato;
if (need_upward_RA && need_downward_RA)
alt_sep = UNRESOLVED;
else if (need_upward_RA)
alt_sep = UPWARD_RA;
else if (need_downward_RA)
alt_sep = DOWNWARD_RA;
else
alt_sep = UNRESOLVED;
}
return alt_sep;
}
Figure 4: teas code excerpt corresponding to error
Catastrophic Outcome Found by SymPLFIED:
Figure 4 shows an excerpt from the tcas code. The
code corresponds to the function alt_sep_test, which
tests the minimum vertical separation between two
aircrafts and returns an advisory. This function in tum
calls the function Non_Crossing_Biased_ClimbO and
the function Own_Above_ThreatO to decide if an up(cid:173)
ward advisory is needed for the aircraft. It then checks
if a downward advisory is needed by calling the func(cid:173)
tion Non_Crossing_Biased_DescendO and the func(cid:173)
tion Own_Below_ThreatO. If neither or both adviso(cid:173)
ries are needed, it returns the value 0 (unresolved).
Otherwise, it returns the advisory computed.
The error under consideration occurs in the body
of the called function Non_Crossing_Biased_Climb0
and corrupts the value of register $31, which holds the
function return address. Therefore, instead of control
being transferred to the instruction following the call
to the function Non_Crossing_Biased_Climb0 in
the control gets transferred to the
altyep_testO,
statement alt_sep = DOWNWARD_RAin the function.
This causes the function to return the value 2 instead
of the value 1, which is printed by the program. Note
that the above error occurs in the function call/return
mechanism, which is added by the compiler. Hence,
only a technique like SymPLFIED that reasons at the
assembly language level can discover the error.
6.3
SimpleScalar Results
We performed over 6000 fault-injection runs on
the tcas application using the modified SimpleScalar
simulator to see if we could find any instances of the
catastrophic outcome outlined in Section 6.1. In these
experiments, we ensure that SimpleScalar is run for
1-4244-2398-9/08/$20.00 ©2008 IEEE
480
DSN 2008: Pattabiraman et al.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:30:25 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems & Networks: Anchorage, Alaska, June 24-27 2008
as
time
same
SymPLFIED. Recall
that
the
SymPLFIED was run with 150 tasks, and each com(cid:173)
pleted task took a maximum time of 4 minutes. This
constitutes 10 hours in total, during which time we
were able to perform 6000 automated fault-injection
experiments using the SimpleScalar simulator. The
results are summarized in column 2 of Table 2.
Imp e ca ar au t-In.lectlon resu ts
I S I
f:
·
I ·
Percenta2e
a e :
T bl 2 S·
Program Out-
come
o(Undecided)
1 (Upward)
2 (Downward)
Other
Crash
Hang
#faults = 6253
(117)
(3364)
(0)
(29)
(2718)
(25)
1.86%
53.7%
0%
0.5%
43.4%
0.4%
# faults = 41082
(960)
2.33%
56.33% (23143)
0%
1.0%
40.43% (16208)
0.8%
(0)
(404)
(327)
Even though we injected exhaustively into regis(cid:173)
ters of all instructions in the program, SimpleScalar
was unable to uncover even a single scenario with the
catastrophic outcome of '2', whereas the symbolic
error injection performed by SymPLFIED was able to
uncover these scenarios with relative ease. This is be(cid:173)
cause, in order to find an error scenario using random
fault injections, not only must the error be injected at
the right place in the program (for example, register
$31 in the Non_Crossing_Biased_Climb function), but
also the right value must be chosen during the injec(cid:173)
tion (for example,
the address of the assignment
statement must be chosen in Figure 4).
We also extended the SimpleScalar-based fault
injection campaign to inject 41000 register faults in
the tcas application. The injection campaign com(cid:173)
pleted in 35 hours but was still unable to find such an
error. The results of this extended set of injections is
shown in column 3 of Table 2.
6.4 Application to Larger Programs
the
We
replace
analyzed
program using
SymPLFIED. replace is the largest of the Siemens
benchmarks [18] and is used extensively in software
testing. The replace program matches a given string
pattern in the input string and replaces it with another
given string. The program translates to about 1550
lines of assembly code. Using the same experimental
setup as described in Section 6.1, we ran SymPLFIED
on the replace program to find all single register errors
(one per execution) that lead to an incorrect outcome
of the program. The overall search was decomposed
into 312 search tasks. Of these, 202 completed execu(cid:173)
tion within the allotted time of 30 minutes. In 148 of
the completed search tasks, either the error was benign
or the program crashed due to the error. Only 54 of the
search tasks found error(s) leading to incorrect out(cid:173)
comes. The analysis completed in an average of 4 mi(cid:173)
nutes where no erroneous solutions where found. Runs
that found error(s) took 10 minutes on average.
7 Conclusions
This paper presented SymPLFIED, a modular,
flexible framework for performing symbolic fault(cid:173)
injection and evaluating error detectors in programs.
We have implemented the SymPLFIED framework for
a MIPS-like processor using the Maude rewriting logic
engine. We demonstrated the SymPLFIED framework
on a widely deployed application, tcas, and found a
non-trivial case of a hardware transient error that can
lead to catastrophic consequences for the tcas system.
Acknowledgments: This research was funded in part
by NSF grant CNS-05-51665 and CNS-04-6351. We
would also like to thank the Gigascale System Re(cid:173)
search Consortium (GSRC) and the Motorola Center
for Communications at UIVC for their support.
References
[1] Hiller, M., A. Jhumka, and N. Suri. On the placement of soft(cid:173)
ware mechanisms for detection of data errors. Proc. Int'l Con! on
Dependable Systems and Networks (DSN), pp. 135-144,2002.
[2] Arlat, 1., et al. Fault injection for dependability validation: A
methodology and some applications.
IEEE Trans. Softw. Eng.,
16(2), pp. 166-182, February 1990.
[3] Cyrluk, D. Microprocessor verification in PVS: A methodolo(cid:173)
gy and simple example. Tech Report SRI-CSL-93-12, 1993.
[4] Boyer, R. S., and 1. S. Moore. Program verification. Journal of
Automated Reasoning, 1(1), pp. 17-23, 1985.
[5] Krautz, U., et al. Evaluating coverage of error detection logic
for soft errors using formal methods. Proc. of the Con! on Design,
Automation and Test in Europe (DATE), 2006.
[6]
Seshia, S. A., W. Li, and S. Mitra. Verification-guided soft
error resilience. Proc. ofthe Con! on Design, Automation and Test
in Europe (DATE), 2007.
[7] Nicolescu, B., et al. On the use of model checking for the
verification of a dynamic signature monitoring approach.
IEEE
Trans. on Nuclear Science, 52(5), pp. 1555-1561, October 2005.
[8]
Con! on Prog. Lang. Design and Implementation (PLDI), 2007.
[9] King, 1. C. Symbolic execution and program testing. Commu(cid:173)
nications ofACM, 19(7), pp. 385-394, July 1976.
[10] Bush, W., et al. A static analyzer for finding dynamic pro(cid:173)
gramming errors. Software: Practice and Experience, 30(7),2000.
[11] Larrson, D., and R. Hahnle. Symbolic fault injection. Interna(cid:173)
tional Verification Workshop (VERIFY), vol. 259, pp. 85-103, 2007.
[12] Clavel, M., S. Eker, P. Lincoln, and 1. Meseguer. Principles of
Maude. Proc. First Int'l Workshop on Rewriting Logic and Its Ap(cid:173)
plications, 1996.
[13] Clarke, E., et al. Bounded model-checking using satisfiability
solving. Formal Methods in System Design, July 2001.
[14] Pattabiraman, K., et al. SymPLFIED: Symbolic program-level
fault Injection and error detection framework. Technical Report
UILU-ENG-08-2205, University of Illinois at Urbana-Champaign,
March 2008.
[15] Federal Aviation Administration. TCAS II Collision Avoid(cid:173)
ance System (CAS) System Requirements Spec, 1993.
[16] Lygeros, 1., and N.A. Lynch. On the formal verification of the
TCAS conflict resolution algorithms. Proc. 36th IEEE Con! on
Decision and Control, pp. 1829--1834, 1997.
[17] Burger, D., and T. M. Austin. The SimpleScalar tool set, ver(cid:173)
sion 2.0. Computer Architecture News, 25(3), 1997.
[18] Hutchins, M., et al. Experiments on the effectiveness of dataf(cid:173)
low- and control flow-based test adequacy criteria. Int'/ Con! on
Software Engineering (ICSE), pp. 191-200, 1994.
Perry, F., et al. Fault-tolerant Typed Assembly Language, Int'l
1-4244-2398-9/08/$20.00 ©2008 IEEE
481
DSN 2008: Pattabiraman et al.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:30:25 UTC from IEEE Xplore.  Restrictions apply.