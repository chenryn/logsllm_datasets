#### 程式码生成和动态型别的语言
Thrift 和 Protobuf 依赖于程式码生成：在定义了模式之后，可以使用你选择的程式语言生成实现此模式的程式码。这在 Java、C++ 或 C# 等静态型别语言中很有用，因为它允许将高效的记忆体中的资料结构用于解码的资料，并且在编写访问资料结构的程式时允许在 IDE 中进行型别检查和自动补全。
在动态型别程式语言（如 JavaScript、Ruby 或 Python）中，生成程式码没有太多意义，因为没有编译时型别检查器来满足。程式码生成在这些语言中经常被忽视，因为它们避免了显式的编译步骤。而且，对于动态生成的模式（例如从资料库表生成的 Avro 模式），程式码生成对获取资料是一个不必要的障碍。
Avro 为静态型别程式语言提供了可选的程式码生成功能，但是它也可以在不生成任何程式码的情况下使用。如果你有一个物件容器档案（它嵌入了 Writer 模式），你可以简单地使用 Avro 库开启它，并以与检视 JSON 档案相同的方式检视资料。该档案是自描述的，因为它包含所有必要的元资料。
这个属性特别适用于动态型别的资料处理语言如 Apache Pig 【26】。在 Pig 中，你可以开启一些 Avro 档案，开始分析它们，并编写派生资料集以 Avro 格式输出档案，而无需考虑模式。
### 模式的优点
正如我们所看到的，Protocol Buffers、Thrift 和 Avro 都使用模式来描述二进位制编码格式。他们的模式语言比 XML 模式或者 JSON 模式简单得多，而后者支援更详细的验证规则（例如，“该栏位的字串值必须与该正则表示式匹配” 或 “该栏位的整数值必须在 0 和 100 之间” ）。由于 Protocol Buffers，Thrift 和 Avro 实现起来更简单，使用起来也更简单，所以它们已经发展到支援相当广泛的程式语言。
这些编码所基于的想法绝不是新的。例如，它们与 ASN.1 有很多相似之处，它是 1984 年首次被标准化的模式定义语言【27】。它被用来定义各种网路协议，例如其二进位制编码（DER）仍然被用于编码 SSL 证书（X.509）【28】。ASN.1 支援使用标签号码的模式演进，类似于 Protocol Buffers 和 Thrift 【29】。然而，它也非常复杂，而且没有好的配套文件，所以 ASN.1 可能不是新应用程式的好选择。
许多资料系统也为其资料实现了某种专有的二进位制编码。例如，大多数关系资料库都有一个网路协议，你可以透过该协议向资料库传送查询并获取响应。这些协议通常特定于特定的资料库，并且资料库供应商提供将来自资料库的网路协议的响应解码为记忆体资料结构的驱动程式（例如使用 ODBC 或 JDBC API）。
所以，我们可以看到，尽管 JSON、XML 和 CSV 等文字资料格式非常普遍，但基于模式的二进位制编码也是一个可行的选择。他们有一些很好的属性：
* 它们可以比各种 “二进位制 JSON” 变体更紧凑，因为它们可以省略编码资料中的栏位名称。
* 模式是一种有价值的文件形式，因为模式是解码所必需的，所以可以确定它是最新的（而手动维护的文件可能很容易偏离现实）。
* 维护一个模式的资料库允许你在部署任何内容之前检查模式更改的向前和向后相容性。
* 对于静态型别程式语言的使用者来说，从模式生成程式码的能力是有用的，因为它可以在编译时进行型别检查。
总而言之，模式演化保持了与 JSON 资料库提供的无模式 / 读时模式相同的灵活性（请参阅 “[文件模型中的模式灵活性](ch2.md#文件模型中的模式灵活性)”），同时还可以更好地保证你的资料并提供更好的工具。
## 资料流的型别
在本章的开始部分，我们曾经说过，无论何时你想要将某些资料传送到不共享记忆体的另一个程序，例如，只要你想透过网路传送资料或将其写入档案，就需要将它编码为一个位元组序列。然后我们讨论了做这个的各种不同的编码。
我们讨论了向前和向后的相容性，这对于可演化性来说非常重要（透过允许你独立升级系统的不同部分，而不必一次改变所有内容，可以轻松地进行更改）。相容性是编码资料的一个程序和解码它的另一个程序之间的一种关系。
这是一个相当抽象的概念 - 资料可以透过多种方式从一个流程流向另一个流程。谁编码资料，谁解码？在本章的其余部分中，我们将探讨资料如何在流程之间流动的一些最常见的方式：
* 透过资料库（请参阅 “[资料库中的资料流](#资料库中的资料流)”）
* 透过服务呼叫（请参阅 “[服务中的资料流：REST 与 RPC](#服务中的资料流：REST与RPC)”）
* 透过非同步讯息传递（请参阅 “[讯息传递中的资料流](#讯息传递中的资料流)”）
### 资料库中的资料流
在资料库中，写入资料库的过程对资料进行编码，从资料库读取的过程对资料进行解码。可能只有一个程序访问资料库，在这种情况下，读者只是相同程序的后续版本 - 在这种情况下，你可以考虑将资料库中的内容储存为向未来的自我传送讯息。
向后相容性显然是必要的。否则你未来的自己将无法解码你以前写的东西。
一般来说，几个不同的程序同时访问资料库是很常见的。这些程序可能是几个不同的应用程式或服务，或者它们可能只是几个相同服务的例项（为了可伸缩性或容错性而并行执行）。无论哪种方式，在应用程式发生变化的环境中，访问资料库的某些程序可能会执行较新的程式码，有些程序可能会执行较旧的程式码，例如，因为新版本当前正在部署滚动升级，所以有些例项已经更新，而其他例项尚未更新。
这意味著资料库中的一个值可能会被更新版本的程式码写入，然后被仍旧执行的旧版本的程式码读取。因此，资料库也经常需要向前相容。
但是，还有一个额外的障碍。假设你将一个栏位新增到记录模式，并且较新的程式码将该新栏位的值写入资料库。随后，旧版本的程式码（尚不知道新栏位）将读取记录，更新记录并将其写回。在这种情况下，理想的行为通常是旧程式码保持新的栏位不变，即使它不能被解释。
前面讨论的编码格式支援未知栏位的储存，但是有时候需要在应用程式层面保持谨慎，如图 4-7 所示。例如，如果将资料库值解码为应用程式中的模型物件，稍后重新编码这些模型物件，那么未知栏位可能会在该翻译过程中丢失。解决这个问题不是一个难题，你只需要意识到它。
![](../img/fig4-7.png)
**图 4-7 当较旧版本的应用程式更新以前由较新版本的应用程式编写的资料时，如果不小心，资料可能会丢失。**
#### 在不同的时间写入不同的值
资料库通常允许任何时候更新任何值。这意味著在一个单一的资料库中，可能有一些值是五毫秒前写的，而一些值是五年前写的。
在部署应用程式的新版本时，也许用不了几分钟就可以将所有的旧版本替换为新版本（至少伺服器端应用程式是这样的）。但资料库内容并非如此：对于五年前的资料来说，除非对其进行显式重写，否则它仍然会以原始编码形式存在。这种现象有时被概括为：资料的生命周期超出程式码的生命周期。
将资料重写（迁移）到一个新的模式当然是可能的，但是在一个大资料集上执行是一个昂贵的事情，所以大多数资料库如果可能的话就避免它。大多数关系资料库都允许简单的模式更改，例如新增一个预设值为空的新列，而不重写现有资料 [^v]。读取旧行时，对于磁碟上的编码资料缺少的任何列，资料库将填充空值。LinkedIn 的文件资料库 Espresso 使用 Avro 储存，允许它使用 Avro 的模式演变规则【23】。
因此，模式演变允许整个资料库看起来好像是用单个模式编码的，即使底层储存可能包含用各种历史版本的模式编码的记录。
[^v]: 除了 MySQL，即使并非真的必要，它也经常会重写整个表，正如 “[文件模型中的模式灵活性](ch2.md#文件模型中的模式灵活性)” 中所提到的。