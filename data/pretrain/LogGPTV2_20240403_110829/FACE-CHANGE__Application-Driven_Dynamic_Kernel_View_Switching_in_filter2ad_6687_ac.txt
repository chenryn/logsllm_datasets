instructions. For do sys poll this is not a problem because
the return address (0xc021a526) is an even number. Exe-
cution will return to the “0xf 0xb” opcode (UD2), causing
an invalid opcode trap, and we can recover do sys poll as
normal. We call this as a lazy recovery. But for sys poll,
the return address (0xc021a759) is an odd number, and the
opcode starting at address 0xc021a759 is “0xb 0xf.” This
Recover 0xc0211370  for kernel[top]
|--Backtrace: 0xc021a526 
   0xf 0xb 0xf 0xb 0xf 0xb 0xf 0xb 0xf 0xb 0xf 0xb 0xf 0xb 0xf 0xb 0xf 0xb 0xf 0xb
'0xf 0xb' can trap => Lazy recovery
1
|--Backtrace: 0xc021a759 
   0xb 0xf 0xb 0xf 0xb 0xf 0xb 0xf 0xb 0xf 0xb 0xf 0xb 0xf 0xb 0xf 0xb 0xf 0xb 0xf
'0xb 0xf' cannot trap  => Instant recovery
2
|--Backtrace: 0xc01033ec 
   0x89 0x44 0x24 0x18 0xfa 0x8d 0xb6 0x0 0x0 0x0
do_sys_poll:
...
c021a521: e8 4a f4 ff ff       
c021a526: 89 85 8c fc ff ff    
sys_poll:
...
c021a754: e8 97 fc ff ff       
c021a759: 83 f8 fc             
call   0xc0219970 
mov    %eax,-0x374(%ebp)
call   0xc021a3f0 
cmp    $0xfffffffc,%eax
syscall_call:
...
c01033e5: ff 14 85 50 81 59 c0 
c01033ec: 89 44 24 18          
    call   *-0x3fa67eb0(,%eax,4)
    mov    %eax,0x18(%esp)
Figure 3: Cross-View Kernel Code Recovery
opcode will be misinterpreted by the processor and not cause
a trap. Our solution is, during code recovery, to backtrack
the stack and recover any caller whose return-target opcode
starts with “0xb 0xf ” in the new kernel view. We call this
instant recovery. In this example, when we recover the code
for pipe poll, we recover sys poll instantly.
4) Disable Customized Kernel View: We can load/unload
customized kernel views dynamically at runtime to satisfy
our ﬂexibility goal. When we disable a kernel view, FACE-
CHANGE de-allocates all memory pages for that kernel view
and switches the EPT back to a full kernel view without
interrupting the running application. This enables us to adapt
to an altered environment smoothly by “hot-plugging” kernel
views.
IV. EVALUATION
In this section, we present the evaluation of our system
in two aspects: security and performance. For the security
496
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:20:50 UTC from IEEE Xplore.  Restrictions apply. 
evaluation, we ﬁrst use the similarity index to measure
the similarities of kernel views among applications. Then
we demonstrate the effectiveness of our system to track
attack provenance of both user-level malware and kernel-
level rootkits. For the performance evaluation, we measure
the overall system performance with FACE-CHANGE en-
abled and the I/O performance for an Apache web server
with a minimized kernel view. The hardware conﬁguration
of our testing platform is a Lenovo Ideapad U410 with
Intel R(cid:4) CoreTM i7 3.10GHz and 8GB memory. We run
FACE-CHANGE on Linux Mint 13 x86 64 (Linux kernel
version 3.5.0). We test our prototype with a guest VM
using Ubuntu 10.04 (Linux kernel version 2.6.32) i386
LTS release3, further since FACE-CHANGE requires minimal
domain knowledge,
to extend our
current system to support more Linux kernel versions with
only minor changes to the implementation. The guest VM’s
memory is 2GB and it uses bridged networking.
it will be convenient
A. Security Evaluation
1) Kernel View Variation among Applications: We use
the similarity index deﬁned in Section II to measure the
difference of kernel views among 12 well-known Linux
applications from different categories. For example, Apache
and vsftpd are server applications that handle network re-
quests. Firefox and gvim are interactive applications that
respond to user input. We present the proﬁling results as
a square matrix in Table I. The main diagonal((cid:5)) of the
matrix is marked with gray cells. Each cell on the main
diagonal presents the size of the kernel view for this speciﬁc
application (e.g., vsftpd executes 341KB kernel code in
the proﬁling phase). We compare the kernel code address
ranges between every two applications to get the overlapping
size. All entries above the main diagonal represent
the
overlapping size between two applications’ kernel views
(e.g., tcpdump and Firefox have 218KB overlapping kernel
code). Entries below the main diagonal represent the simi-
larity index calculated using Equation (1) in Section II. The
similarity index demonstrates the similarity of kernel attack
surface between different applications. For applications of
different types, lower percentages are better as this ensures
a distinct minimized kernel in both cases, and for similar
applications high percentages are expected since both require
similar kernel services. As Table I shows, the similarity
indices range from 33.6% for dissimilar applications to
86.5% for applications with common kernel requirements.
This proves our intuition that if two applications are from
different categories they have relatively low similarity index
and leverage different parts of the kernel.
2) Attack Detection and Provenance: Because the kernel
attack surface for each individual application is reduced
3We use Ubuntu 10.04 because the kernel rootkit samples we use in the
evaluation do not support newer Linux kernel yet.
    // create socket
   sock = socket(AF_INET, SOCK_DGRAM, 0);
socket:
0xc051c950  
   ...
   // bind to the specified port
   server.sin_family = AF_INET;
   server.sin_addr.s_addr = htonl(INADDR_ANY);
   server.sin_port = htons(port); 
   err = bind(sock, (struct sockaddr *) &server, sizeof(server));
   ...
bind:
   // receive data loop
   while (1) {   
       memset(buffer, 0, BUFF_LEN);
       // receive data
       err = recvfrom(sock, buffer, BUFF_LEN, 0, NULL, 0);
       ...     
   }
recvfrom:
0xc04b80c0  
0xc02f8900  
0xc0324470  
0xc051c6a0  
0xc0522460  
0xc04ba450  
0xc05148c0  
0xc0514680  
0xc0512890  
0xc04ba3a0  
0xc04b86d0  
0xc04b8560  
0xc02f89a0 
0xc03243d0 
0xc04b9be0 
0xc0514b50 
0xc04c1d80 
0xc0168830 
A. UDP server payload code snippet
B. Kernel code recovery log
Figure 4: Attack Pattern of Injectso’s Payload
according to the proﬁling results, we can reveal malicious
attack patterns whenever a process goes beyond the bound-
ary of its kernel view. Further, we backtrack the requested
kernel code to identify the exact attack provenance.
This result
is a step further than traditional system-
wide kernel minimization techniques [1]–[4] because FACE-
CHANGE is able to detect anomalous execution based on
an individual application’s kernel view. To demonstrate that
FACE-CHANGE can reveal attack evidences that may go
unnoticed under traditional system-wide minimization tech-
niques, we also create a “union” kernel view (the union of all
kernel views from the applications we have proﬁled) as the
system-wide minimized kernel. System-wide minimization
may fail to detect an attack if the attack utilizes kernel code
required by any application in the system. FACE-CHANGE
greatly reduces this “blind spot” because it is able to detect
kernel execution anomalies speciﬁc to a single application.
In this paper, we evaluate the effectiveness of attack
detection with 13 user-level malware (8 of them use online
runtime infection and 5 use ofﬂine binary infection) and 3
kernel-level rootkits. This data is presented in Table II. We
highlight four of these attack case studies in detail.
Case Study I – Injectso:
Injectso [10] is a well-
known hot-patching tool used to modify the behavior of a
running process by injecting a dynamic shared object into
its address space. It detours the current instruction pointer
libc dlopen mode and builds a fake stack to invoke
to
the shared object’s code. The shellcode’s payload is a UDP
server, and the target program is top. Obviously, the kernel
view for top does not contain any kernel code needed to run
a UDP server (even if the kernel views of other co-existing
applications do), and thus Injectso’s payload triggered the
kernel code recovery mechanism.
From the kernel code recovery log, we can precisely iden-
tify the anomalous execution caused by Injectso in the top
process. In Figure 4, we present the UDP server payload’s
code and the corresponding kernel code recovery log. The
UDP server will create a socket, bind to an address/port,
and receive data using the C library calls socket, bind
and recvfrom respectively. It is straightforward to identify
which library functions correspond to the recovered kernel
497
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:20:50 UTC from IEEE Xplore.  Restrictions apply. 
ﬁrefox
totem
gvim
apache
vsftpd
top
tcpdump
mysqld
bash
sshd
gzip
eog
ﬁrefox
totem
443KB
275KB
62.1% 286KB
56.7%
68.2%
67.9%
33.6%
49.2%
68.7%
50.0%
71.3%
48.1%
64.6%
gvim
251KB
239KB
83.6% 262KB
62.7%
63.6%
49.2%
58.0%
68.1%
68.7%
58.4%
60.9%
86.5%
vsftpd
284KB
217KB
206KB
284KB
83.5% 341KB
42.2%
62.6%
78.9%
60.6%
77.5%
59.6%
64.2%
sshd
bash
apache
316KB
221KB
302KB
220KB
196KB
210KB
211KB
190KB
206KB
292KB
203KB
61.5% 335KB
293KB
205KB
60.5%
153KB
147KB
54.2%
216KB
165KB
61.1%
260KB
186KB
65.4%
242KB
223KB
72.6%
59.0% 378KB
55.9%
64.6%
63.4%
72.4%
83.2%
Table I: Similarity Matrix for Applications’ Kernel Views
tcpdump mysqld
218KB
305KB
228KB
166KB
220KB
160KB
265KB
210KB
272KB
208KB
135KB
138KB
203KB
234KB
336KB
60.5%
55.5%
68.3%
68.9%
57.3%
63.2%
69.0%
56.5%
68.7%
149KB
140KB