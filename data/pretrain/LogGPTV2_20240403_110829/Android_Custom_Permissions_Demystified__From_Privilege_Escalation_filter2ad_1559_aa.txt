title:Android Custom Permissions Demystified: From Privilege Escalation
to Design Shortcomings
author:Rui Li and
Wenrui Diao and
Zhou Li and
Jianqi Du and
Shanqing Guo
0
7
0
0
0
.
1
2
0
2
.
1
0
0
0
4
P
S
/
9
0
1
1
.
0
1
:
I
O
D
|
E
E
E
I
1
2
0
2
©
0
0
.
1
3
$
/
1
2
/
5
-
4
3
9
8
-
1
8
2
7
-
1
-
8
7
9
|
)
P
S
(
y
c
a
v
i
r
P
d
n
a
y
t
i
r
u
c
e
S
n
o
m
u
i
s
o
p
m
y
S
E
E
E
I
1
2
0
2
2021 IEEE Symposium on Security and Privacy (SP)
Android Custom Permissions Demystiﬁed:
From Privilege Escalation to Design Shortcomings
Rui Li∗†, Wenrui Diao∗†((cid:66)), Zhou Li‡, Jianqi Du∗†, and Shanqing Guo∗†
∗School of Cyber Science and Technology, Shandong University
PI:EMAIL, PI:EMAIL, PI:EMAIL, PI:EMAIL
†Key Laboratory of Cryptologic Technology and Information Security, Ministry of Education, Shandong University
‡University of California, Irvine, PI:EMAIL
Abstract—Permission is the fundamental security mechanism
for protecting user data and privacy on Android. Given its
importance, security researchers have studied the design and
usage of permissions from various aspects. However, most of
the previous research focused on the security issues of system
permissions. Overlooked by many researchers, an app can use
custom permissions to share its resources and capabilities with
other apps. However, the security implications of using custom
permissions have not been fully understood.
In this paper, we systematically evaluate the design and
implementation of Android custom permissions. Notably, we built
an automatic fuzzing tool, called CUPERFUZZER, to detect custom
permissions related vulnerabilities existing in the Android OS.
CUPERFUZZER treats the operations of the permission mecha-
nism as a black-box and executes massive targeted test cases to
trigger privilege escalation. In the experiments, CUPERFUZZER
discovered 2,384 effective cases with 30 critical paths successfully.
Through investigating these vulnerable cases and analyzing the
source code of Android OS, we further identiﬁed a series of severe
design shortcomings lying in the Android permission framework,
including dangling custom permission,
inconsistent permission-
group mapping, custom permission elevating, and inconsistent
permission deﬁnition. Exploiting any of these shortcomings, a
malicious app can obtain dangerous system permissions without
user consent and further access unauthorized platform resources.
On top of these observations, we propose some general design
guidelines to secure custom permissions. Our ﬁndings have been
acknowledged by the Android security team and rated as High
severity.
I. INTRODUCTION
As the most popular mobile platform, Android provides
rich APIs and features to support third-party apps develop-
ments. For security concerns, Android also designs a series
of mechanisms to prevent malicious behaviors. Among these
mechanisms, permission is the fundamental one of Android
OS: any app must request speciﬁc permissions to access the
corresponding sensitive user data and system resources.
On account of the importance of the permission mechanism,
its design and usage have been studied by lots of previous
research from many aspects, such as permission models [49],
[25], [31], permission usage [33], [46], [32], and malware
detection [35], [48], [23]. Along with the continuous upgrade
of Android OS, the underlying architecture of the permission
mechanism becomes more and more complicated. Its current
design and implementation are seemingly complete enough.
However, overlooked by most of the previous research,
Android allows apps to deﬁne their own permissions, say
custom permissions [7], and use them to regulate the sharing of
their resources and capabilities with other apps. Since custom
permission is not related to system capabilities by design,
its range of action is supposed to be conﬁned by the app
deﬁning it. Therefore, in theory, dangerous operations cannot
be executed through custom permissions, which may be the
reason that custom permissions are overlooked by the security
community.
To the best of our knowledge,
the study of Tuncay et
al. [41] is the only work focusing on the security of custom
permissions. They manually discovered two privilege escala-
tion attacks that exploit the permission upgrade and naming
convention ﬂaws, respectively. Currently, according to the
Android Security Bulletins,
their discovered vulnerabilities
have been ﬁxed. Unfortunately, we ﬁnd that, though both
attacks have been blocked, custom permission based attacks
can still be achieved with alternative execution paths bypassing
the ﬁx (more details are given in Section III). This preliminary
investigation motivates us to explore whether the design of
Android custom permissions still has other ﬂaws and how to
ﬁnd these ﬂaws automatically.
Our Work. In this work, we systematically evaluate the design
and implementation of Android custom permissions. Notably,
we explored the design philosophy of custom permissions
and measured their usage status based on a large-scale APK
dataset. We also built an automatic light-weight fuzzing tool
called CUPERFUZZER to discover custom permission related
privilege escalation vulnerabilities. Different from the previous
approaches of permission system modeling [36], [26], CU-
PERFUZZER treats the operations of the Android permission
mechanism as a black-box and dynamically generates massive
test cases for fuzzing. In other words, it does not rely on prior
knowledge of the internal permission mechanism and avoids
missing inconspicuous system components. After solving a
series of technical challenges, CUPERFUZZER achieves fully
automated seed generation,
test case construction, parallel
execution, and result veriﬁcation. Running on four Pixel 2
phones equipped with Android 9 / 10, ﬁnally, CUPERFUZZER
discovered 2,384 successful exploit cases after executing
40,195 fuzzing tests.
These effective cases were further converted to 30 critical
paths, say the least necessary operations triggering a privilege
© 2021, Rui Li. Under license to IEEE.
DOI 10.1109/SP40001.2021.00070
70
escalation issue. Combined with the analysis on the source
code of Android OS, we identiﬁed four severe design short-
comings1 in the Android permission framework.
• DS#1: Dangling custom permission: causing granting
apps nonexistent custom permissions.
• DS#2: Inconsistent permission-group mapping: causing
obtaining incorrect permission-group members list.
• DS#3: Custom permission elevating: causing elevating a
custom permission to a dangerous system permission.
• DS#4: Inconsistent permission deﬁnition: causing break-
ing the integrity of custom permission deﬁnitions.
A malicious app can exploit any of the above design short-
comings to obtain dangerous system permissions without
user consent. As showcases, we present four concrete attacks
to demonstrate their fatal consequences. Attack demos are
available at https://sites.google.com/view/custom-permission.
Responsible Disclosure. We reported our ﬁndings to the
Android security team, and all reported issues have been
conﬁrmed with positive severity rating [19], as shown below.
• DS#1: rated as High severity, assigned CVE-2021-0307.
• DS#2: rated as High severity, assigned CVE-2020-0418.
• DS#3: rated as High severity, assigned CVE-2021-0306.
• DS#4: rated as High severity, assigned CVE-2021-0317.
To mitigate the current security risks, we propose some im-
mediate improvements and discuss general design guidelines
to secure custom permissions on Android.
Contributions. The main contributions of this paper are:
• Tool Design and Implementation. We designed and im-
plemented an automatic black-box fuzzing tool, CUPER-
FUZZER, to discover custom permission related privilege
escalation vulnerabilities in Android.
• Real-world Experiments. We deployed CUPERFUZZER
under the real-world settings and conducted massive
fuzzing analysis. In the end, it discovered 2,384 privilege
escalation cases with 30 critical paths.
• New Design Shortcomings. We identiﬁed four severe
design shortcomings lying in the Android permission
framework. Malicious apps can exploit these ﬂaws to ob-
tain dangerous system permissions without user consent.
• Systematic Study. We explored the design philosophy of
custom permissions and measured their usage in the wild.
After digging into the essence of discovered design ﬂaws,
we discussed the general guidelines to secure Android
custom permissions.
Roadmap. The rest of this paper is organized as follows.
Section II provides the necessary background of Android
custom permissions. Section III gives a motivation case and
threat model used in this paper. Section IV introduces the
detailed design of CUPERFUZZER, and Section V presents the
experiment results. The design ﬂaws of custom permissions are
analyzed in Section VI. In Section VII, we propose the mitiga-
tion solutions and general design guidelines. In Section VIII,
1In the following sections, we use DS#1, DS#2, DS#3, and DS#4 for short.
71
we discuss some limitations of our work. Section IX reviews
related work, and Section X concludes this paper.
II. ANDROID CUSTOM PERMISSIONS
In this section, we provide the necessary background of
Android custom permissions and further discuss their usage
in the wild based on a large-scale measurement.
A. Android Permission Mechanism
In Android, sensitive APIs and system resources are pro-
tected by the permission mechanism. To access them, apps
must declare the corresponding permissions in their manifest
ﬁles and ask users to authorize. In Android 10 (API level 29),
the permission control functionalities are mainly implemented
in PackageManager [11] and PermissionController [13].
Permissions are mainly divided into three protection levels:
normal, signature, and dangerous. The system grants apps
normal and signature permissions at the install time. The
difference is that signature permissions can only be used
by the apps signed by the same certiﬁcate as the app that
deﬁnes the permission [16]. On the other hand, users can
choose to grant or deny dangerous permissions at runtime.
Therefore, dangerous permissions are also called runtime per-
missions, and accordingly, normal and signature permissions
are called install-time permissions. Install-time permissions
cannot be revoked by users once they are granted, on the
contrary, runtime permissions can be revoked at any time.
All dangerous permissions belong to permission groups.
For example, both READ_SMS and RECEIVE_SMS belong to
the SMS group. Also, dangerous permissions are granted on
a group basis. If an app requests dangerous permissions
belonging to the same permission group, once the user grants
one, the others will be granted automatically without user