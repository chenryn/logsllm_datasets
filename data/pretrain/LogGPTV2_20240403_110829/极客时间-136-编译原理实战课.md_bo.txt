# 程序的话，也会进行类型检查。还有很重要的一点，就是 **C#的泛型能够支持值类型**，比如基础的整型、浮点型数据；再比如，针对`List`和`List`，C#的泛型能够真的生成一份完全不同的可运行的代码。它也不需要把值类型转换成对象，从而导致额外的内存开销和性能开销。**把参数化类型变成实际的类型的过程，是在运行时通过 JIT技术实现的。这就是具体化（Reification）的含义。**把一个参数化的类型，变成一个运行时真实存在的类型，它可以跟非参数化的类型起到完全相同的作用。不过，为了支持泛型，其实.NET 扩展了 C
# 生成的 IL，以便在 IL里能够记录参数化类型信息。而 JVM则没有改变它的字节码，从而完全是靠编译器来处理泛型。好了，现在我们已经见识到了两种不同的泛型实现机制。还有一种泛型实现机制，也是经常被拿来比较的，这就是C++的泛型机制，它的泛型机制依托的是**模板元编程技术**。基于元编程技术来支持泛型在上一讲，我们介绍过 C++的模板元编程技术。模板元编程很强大，程序里的很多要素都可以模板化，那么类型其实也可以被模板化。你已经知道，元编程技术是把程序本身作为处理对象的。采用 C++的模板元编程技术，我们实际上是为每一种类型参数都生成了新的程序，编译后生成的目标代码也是不同的。所以， **C++的模板技术也能做到 Java的类型擦除技术所做不到的事情**，比如提供对基础数据类型的支持。在 C++的标准模板库（STL）中，提供了很多容器类型。它们能像保存对象一样保存像整型、浮点型这样的基础数据类型。不过使用模板技术来实现泛型也有一些**缺点**。因为本质上，模板技术有点像宏，它是把程序中某些部分进行替换，来生成新的程序。在这个过程中，**它并不会检查针对参数类型执行的某些操作是否是合法的**。编译器只会针对生成后的程序做检查，并报错。这个时候，错误信息往往是比较模糊的，不太容易定位。这也是模板元编程技术固有的短板。究其原因，是模板技术不是单单为了泛型的目的而实现的。不过，如果了解了泛型机制的原理，你会发现，其实可以通过增强C++编译器，来提升它的类型检查能力。甚至，对类型参数指定上界和下界等约束条件，也是可以的。不过这要看C++ 标准委员会的决定了。总的来说，**C++ 的泛型技术像 Java的一样，都是在运行期之前就完成了所有的工作，而不像.NET那样，在运行期针对某个参数化的类型产生具体的本地代码。**好了，了解了泛型的几种实现策略以后，接下来，我们接着讨论一个更深入的话题：**把类型参数化以后，对于计算机语言的类型系统有什么挑战？**这个问题很重要，因为在语义分析阶段，我们已经知道如何做普通类型的分析和处理。而要处理参数化的类型，我们还必须更加清楚支持参数化以后，类型体系会有什么变化。泛型对类型系统的增强在现代语言中，通常会建立一个层次化的类型系统，其中一些类型是另一些类型的子类型。什么是子类型呢？就是在任何一个用到父类型的地方，都可以用其子类型进行替换。比如，Cat是 Animal 的子类型，在任何用到 Animal 的地方，都可以用 Cat来代替。 不过，当类型可以带有参数之后，类型之间的关系就变得复杂了。比如说：1.  `Collection`和        `List`是什么关系呢？        2.  `List`和        `List`之间又是什么关系呢？        对于第一种情况，其实它们的类型参数是一样的，都是 Cat。而 List 本来是Collection 的子类型，那么`List`也是`Collection`的子类型，我们永远可以用`List`来替换`Collection`。这种情况比较简单。但是对于第二种情况，`List`是否是`List`的子类型呢？这个问题就比较难了。不同语言的实现是不一样的。在Java、Julia 等语言中，`List`和`List`之间没有任何的关系。在由多个类型复合而形成的类型中（比如泛型），复合类型之间的关系随其中的成员类型的关系而变化的方式，分为**不变（Invariance）、协变（Covariance）和逆变（Contravariance）**三种情况。理解清楚这三种变化，对于我们理解引入泛型后的类型体系非常重要，这也是编译器进行正确的类型计算的基础。**首先说说****[不变 slate-object="mark"}****。**在 Java 语言中，`List`和`List`之间并没有什么关系，在下面的示例代码中，如果我们把`List`赋值给`List`，编译器会报错。因此，我们说`List`基于 T是不变的。     List catList = new ArrayList<>();    List animalList = catList;  //报错，不是子类型**那么****[协变 slate-object="mark"}****是什么呢？**就是复合类型的变化方向，跟成员类型是相同的。我给你举两个在Java 语言中关于协变的例子。第一个例子。假设 Animal 有个 reproduce() 方法，也就是繁殖。而 Cat覆盖（Override）了这个方法，但这个方法的返回值是 Cat 而不是Animal。因为猫肯定繁殖出的是小猫，而不是其他动物。这样，当我们调用Cat.reproduce() 方法的时候，就不用对其返回值做强制转换。这个时候，我们说reproduce()方法的返回值与它所在类的类型，是协变的，也就是**一起变化**。    class Animal{        public abstract Animal reproduce();    }    class Cat extends Animal{        @Override        public Cat reproduce() {  //方法的返回值可以是Animal的子类型            ...        }    }第二个例子。在 Java语言中，数组是协变的。也就是`Cat[]`其实是`Animal[]`的子类型，在下面的示例代码中，一个猫的数组可以赋值给一个动物数组。    Cat[] cats = {new Cat(), new Cat()}; //创建Cat数组    Animal[] animals = cats;             //赋值给Animal数组    animals[0] = new Dog();              //修改第一个元素的值    Cat aCat = cats[0];                  //运行时错误但你接下来会看到，Animal 数组中的值可以被修改为 Dog，这会导致 Cat数组中的元素类型错误。至于为什么 Java语言要把数组设计为协变的，以及由此导致的一些问题，我们暂且不管它。我们要问的是，`List`**这样的泛型可以变成协变关系吗？**答案是可以的。我前面也提过，我们可以在类型参数中指定上界。`List`是`List`的子类型，`List`的意思，是任何以 Animal为祖先的子类。我们可以把一个`List`赋值给`List`。你可以看一下示例代码：    List catList = new ArrayList<>();    List animalList = catList;  //子类型    catList.add(new Cat());    Animal animal = animalList.get(0);实际上，不仅仅`List`是`List`的子类型，连`List`也是`List`的子类型。你可以自己测试一下。**我们再来说说****[逆变 slate-object="mark"}****。**逆变的意思是：虽然 Cat 是 Animal 的子类型，但包含了 Cat的复合类型，竟然是包含了 Animal的复合类型的父类型！它们颠倒过来了？这有点违反直觉。在真实世界里有这样的例子吗？当然有。比如，假设有两个函数，`getWeight()`函数是返回 Cat的重量，`getWeight()`函数是返回 Animal的重量。你知道，从函数式编程的观点，每个函数也都是有类型的。那么这两个函数，谁是谁的子类型呢？实际上，求 Animal 重量的函数，其实是求 Cat重量的函数的子类型。怎么说呢？来假设一下。如果你想用一个 getTotalWeight() 函数，求一群 Cat的总重量，你会怎么办呢？你可以把求 Cat重量的函数作为参数传进去，这肯定没问题。但是，你也可以把求 Animal重量的函数传进去。因为既然它能返回普通动物的重量，那么也一定能返回猫的重量。    //伪代码，求Cat的总重量    getTotalWeight(List cats, function fun)而根据类型理论，**如果类型 B 能顶替类型 A 的位置，那么 B 就是 A的子类型**。所以，`getWeigh()`反倒是`getWeight()`的子类型，这种情况就叫做逆变。总的来说，加入泛型以后，计算机语言的类型体系变得更加复杂了。我们在编写编译器的时候，一定要弄清楚这些变化关系，这样才能执行正确的类型计算。那么，在了解了加入泛型以后对类型体系的影响后，我们接着借助 Julia语言，来进一步验证一下如何进行正确的类型计算。Julia 中的泛型和类型计算Julia 设计了一个精巧的类型体系。这个类型体系有着共同的根，也就是Any。在这个类型层次中，橙色的类型是叶子节点，它们是具体的类型，也就是可以创建具体的实例。而中间层次的节点（蓝色），都是抽象的，主要是用于类型的计算。![](Images/6a32de1110b3257690557cb610b6b6ce.png)savepage-src="https://static001.geekbang.org/resource/image/4b/38/4b88f681a305ecf5010606e3b3a68c38.jpg"}Julia的类型体系你在 [第 22讲  slate-object="inline"中，已经了解到了 Julia做函数编译的特点。在编写函数的时候，你可以根本不用指定参数的类型，编译器会根据传入的参数的实际类型，来编译成相应版本的机器码。另外，你也可以为函数编写多个版本的方法，每个版本的参数采用不同的类型。编译器会根据实际参数的类型，动态分派到不同的版本。而**这个动态分派机制，就需要用到类型的计算**。比如说，有一个函数foo()，定义了三个版本的方法，其参数分别是没有指定类型（也就是Any）、Real 类型和 Float64 类型。如果参数是 Float64类型，那它当然会被分派到第三个方法。如果是 Float32类型，那么就会被分派到第二个方法。如果是一个字符串类型呢，则会被分派到第一个方法。    julia> function foo(x)          #方法1               ...           end               julia> function foo(x::Real)    #方法2                 ...           end               julia> function foo(x::Float64) #方法3                 ...           end再进一步，**Julia还支持在定义结构体和函数的时候使用泛型。**比如，下面的一个 Point 结构中，坐标 x 和 y的类型是参数化的。    julia> struct Point{T}               x::T               y::T           end    julia> Point{Float64}    Point{Float64}    julia> Point{Float64}  Point{Float64}  p1 = Point(1.0,2.3)   #创建一个Point实例    Point{Float64}(1.0, 2.3)     #自动推断出类型如果我们再为 foo() 函数添加几个方法，其参数类型分别是 Point类型、Point{Real}类型和Point{Float64}类型，那动态分派的算法也必须能够做正确的分派。所以，在这里，我们就必须能够识别出带有参数的类型之间的关系。    julia> function foo(x::Point)          #方法4               ...           end               julia> function foo(x::Point{Real})    #方法5                 ...           end               julia> function foo(x::Point{Float64}) #方法6                 ...           end通过以上的示例代码你可以看到，Point{Float64} \item*item);通过这个简单的例子，我们可以体会出函数式编程的几个特点：1. 函数作为一等公民也就是说，函数可以像一个数值一样，被赋给变量，也可以作为函数参数。如果一个函数能够接受其他函数作为参数，或者能够把一个函数作为返回值，那么它就是**高阶函数**。像示例程序中的 map就是高阶函数。那函数式编程语言的优势来自于哪里呢？就在于它可以像数学那样使用函数和变量，这会让软件的结构变得特别简单、清晰，运行结果可预测，不容易出错。根据这个特点，我们先来看看函数式编程语言中的函数，跟其他编程语言中的函数有什么不同。2. 纯函数（Pure Function）在函数式编程里面，有一个概念叫做纯函数。纯函数是这样一种函数，即**相同的输入，永远会得到相同的输出**。其实你对纯函数应该并不陌生。你在中学时学到的函数，就是纯函数。比如对于f(x)=ax+b，对于同样的x，所得到的函数值肯定是一样的。所以说，纯函数不应该算是个新概念，而是可以回归到你在学习计算机语言之前的那个旧概念。在 C 语言、Java等语言当中，由于函数或方法里面可以引用外面的变量，比如全局变量、对象的成员变量，使得其返回值与这些变量有关。因此，如果有其他软件模块修改了这些变量的值，那么该函数或方法的返回值也会受到影响。这就会让多个模块之间基于共享的变量耦合在一起，这种耦合也使得软件模块的依赖关系变得复杂、隐秘，容易出错，牵一发而动全身。这也是像面向对象语言这些命令式编程语言最令人诟病的一点。而对于纯函数来说，它不依赖外部的变量，这个叫做**引用透明（ReferenceTransparency）**。纯函数的这种"靠谱"、可预测的特征，就给我们的编程工作带来了很多的好处。举个例子。既然函数的值只依赖输入，那么就跟调用时间无关了。假设有一个函数式g(f(x))，如果按照传统的求值习惯，我们应该先把 f(x) 的值求出来，再传递给g()。但如果 f(x)是纯函数，那么早求值和晚求值其实是无所谓的，所以我们可以**延迟求值（LazyEvaluation）**。延迟求值有很大的好处。比如，在下面的伪代码中，unless 是一个函数，f(x)是传给它的一个参数。在函数式编程语言中，只有当 condition为真时，才去实际对 f(x)求值。这实际上就降低了工作量。    //在满足条件时，执行f(x)    unless(condition, f(x));    //伪代码    int unless(bool condition, f(x)){      if (condition)        return f(x);    }再回到纯函数。我说纯函数的输出仅依赖输入，有一点需要说明，就是函数只有返回值这一种输出，没有其他的输出。换句话说，**纯函数没有副作用（SideEffect）**。什么是副作用呢？简单地说，就是函数在运行过程中影响了外界环境。比如，修改了一个全局变量或者是对象的属性、往文件里写入内容、往屏幕上打印一行字、往数据库插入一条记录、做了一次网络请求，等等。也就是说，纯函数要求程序除了计算，其他的事情都不要做。如果函数有副作用的话，那么我们前面说的时间无关性就被破坏了。比如说，原来a 函数是在屏幕上打印"欢迎："，b函数是屏幕输出你的名字，最后形成"欢迎：XXX"。那么 a 和 b的前后顺序就不能颠倒。你可能会说，一个有用的程序，哪能没有副作用呀。你说得对。在函数式编程里，程序会尽量把产生副作用的函数放在调用的外层，而完成内部功能的大部分函数，都保持是纯函数。比如，最外层的函数接受网络请求，并对客户端返回结果，它是有副作用的。而程序所使用的其他函数，都没有副作用。纯函数的功能是如此地简单纯粹，以至于它还能继续带来一些好处。比如说，像Erlang这样的语言，可以在运行时给某些函数升级，而不用重启整个系统。为什么呢？因为这些升级后的函数，针对相同的输入，程序得到的结果是一样的，那么对这个函数的使用者来说，就没有任何影响。这也是用Erlang写的系统会具有很高的可靠性的原因之一。不过，函数式编程语言里使用的也不全都是纯函数，比如有的函数要做一些 IO操作。另外，闭包，是函数引用了词法作用域中的自由变量而引起的，所以也不是纯函数。总结起来，在函数式编程中，会希望函数像数学中的函数那样纯粹，即**不依赖外部（引用透明），也不改变外部（无副作用），从而带来计算时间、运行时替换等灵活性的优势**。好，说完了函数的不同，我们再来看看函数式编程语言里使用变量跟其他语言的不同。3. 不变性（Immutability）我们都知道，在数学里面，当我们用到 x 和 y这样的变量的时候，它所代表的值在计算过程中是不变的。没错，这也是函数式编程的一个重要原则，**不变性**。它的意思是，程序会根据需要来创建对象并使用它们，但不会去修改对象的状态。如果有需要修改对象状态的情况，那么去创建一个新对象就好了。在前面的示例程序中，map函数返回了一个新的数组，而原来的数组保持不变。这就体现了不变性的特点。不变性也会带来巨大的好处。比如说，由于函数不会修改对象的状态，所以就不存在并发程序中的竞争情况，进而也就不需要采用锁的机制。所以说，**函数式编程更适合编写并发程序**。这个优势，也是导致这几年函数式编程复兴的重要原因。好，那么最后，我们再来注意一下函数式编程语言在编程风格上的不同。4. 声明式（Declarative）的编程风格在计算机语言中，实现编程的方式主要有几种。第一种实现方式，我们会一步步告诉计算机该去怎么做计算：循环访问 a的元素，计算元素的平方值，并加到 b中。这种编程风格叫做**命令式（Imperative）编程**，即命令计算机按照你要求的步骤去做。命令式编程风格植根于现代计算机的结构，因为机器指令本质上就是命令式的。这也是图灵机模型的特点。而第二种实现方式叫做**声明式（Declarative）编程**。这种编程风格，会要求计算机给出你想要的结果，而不关心过程。比如在前面的示例程序中，你关心的是对数组中的每个元素计算出平方值。至于具体的处理步骤，是对数组a的元素顺序计算，还是倒序计算，你并不关心。声明式编程风格的另一个体现，是递归函数的大量使用。这是因为我们描述一个计算逻辑的时候，用递归的方式表达通常会更简洁。举个例子。你可能知道，斐波纳契（Fibonacci）数列中的每个数，是前两个数字的和。这个表达方式就是递归式的。写成公式就是：Fibonacci(n)=Fibonacci(n-1)+Fibonacci(n-2)。这个公式与我们用自然语言的表达完全同构，也更容易理解。我把计算斐波纳契数列的程序用 Erlang这种函数式语言来写一下，你可以进一步体会到声明式编程的那种简洁和直观的特点：    %% 计算斐波那契的第N个元素    fibo(1) -> 1;                      %%第一个元素是1    fibo(2) -> 1;                      %%第二个元素也是1    fibo(N) -> fibo(N-1) + fibo(N-2).  %%递归好了，现在我们已经了解了函数式编程的一些关键特征。它的总体思想呢，就是像数学那样去使用函数和值，使可变动部分最小化，让软件的结构变得简单、可预测，从而获得支持并发、更简洁的表达等优势。那么下面，我们就一起来看看如何结合编译原理的相关知识点，来实现函数式编程的这些特征。函数式编程语言的编译和实现为了实现函数式语言，我们在编译期和运行时都要做很多工作。比如，要在编译器前端做分析和各种语义的检查；要以合适的方式在程序内部表示一个函数；要针对函数式编程的特点做特别的优化，等等。接下来我们就从编译器的前端工作开始学起。编译器前端的工作函数式编程语言，在编译器的前端也一样要做很多的语法分析和语义分析工作。你应该知道，语言的设计者，需要设计出**如何声明一个函数**。像是 JavaScript 语言会用 function 关键字，Go 语言用 func关键字，Rust 语言用的是 fn 关键字，而 C语言根本不需要一个关键字来标识一个函数的定义；另外，如何声明函数的参数和返回值也会使用不同的语法。编译器都要能够正确地识别出来。语义分析的工作则更多，包括：1.       **符号表和引用消解**        ：当声明一个函数时，要把它加入到符号表。而当程序中用到某个函数的时候，要找到该函数的声明。        2.       **类型检查和推导**        ：既然函数可以被当做一个值使用，那么它一定也是有类型的，也要进行类型检查和推导。比如，在程序的某个地方只能接受返回值为    int，有一个参数为 String    的函数，那么就需要被使用的函数是否满足这个要求。关于函数的类型，一会儿我还会展开讲解。        3.       **语法糖处理**        ：在函数式编程中经常会使用一些语法糖。最常见的语法糖就是    Lambda 表达式，Lambda 表达式可以简化匿名函数的书写。比如，前面    JavaScript 的示例代码中，对数组元素求平方的函数可以写成一个 Lambda    表达式，从而把原来的代码简化成了一行：        ```{=html}```    var d = a.map(item=>item*item);   //括号中是一个lambda表达式在这个示例程序中，=\>左边的是匿名函数的参数，右边的是一个表达式，这个表达式的计算结果就是匿名函数的返回值。你看，通过一个Lambda表达式，代替了传统的函数声明，代码也变得更简洁了。OK，因为在编译器前端还要对函数做类型分析，所以我们再来探究一下函数的类型是怎么一回事。把函数纳入类型系统这里我要先提一个问题，就是在函数式编程语言里，既然它能够把函数当做一个值一样去看待，那么也应该有相应的类型吧？这就要求语言的类型系统能够把函数包含进来。因此函数式编程语言在编译的时候，也要进行**类型检查和类型推断**。不过，我们在谈论类型时，比较熟悉的是值类型（如整型、浮点型、字符型），以及用户自定义的类型（如结构、类这些），如果函数也是一种类型，那跟它们是什么关系呢？如果由你来设计，那么你会怎么设计这个类型体系呢？在不同的语言里，设计者们是以不同的方式来解决这个问题的。拿 Python来说，Python 中一切都是对象，函数也不例外。函数对象的 ob_type字段也被设置了合适的类型对象。这里，你可以再次回味一下，Python的类型系统  slate-object="inline"设计得是如何精巧。我们再看看 Scala 的类型系统。上一讲我提出过，Scala实现了一个很漂亮的类型系统，把值类型和引用类型（也就是自定义类）做了统一。它们都有一个共同的根，就是Any。由于 Scala 是基于 JVM 的，所以这些类型最后都是以 Java的类来实现的。那么函数也不例外。因为 Scala 的函数最多支持 22 个参数，所以 Scala里有内置的 Function1、Function2...Function22这些类，作为函数的类型，它们也都是 Any 的子类型。每个 Scala函数实际上是这些类的实例。另外，Swift 语言的文档对类型的定义也比较清楚。它以产生式的方式列出了type的语法定义。根据该语法，类型可以是函数类型、数组类型、字典类型、元组类型等等，这些都是类型。![](Images/ac259eedc2a201673ebfb619cf471885.png)savepage-src="https://static001.geekbang.org/resource/image/59/2a/59422fb82f57e8a877d66c6947cab22a.jpg"}Swift语言中对类型的语法定义并且，它还把所有类型分成了两个大类别：命名类型（NamedType）和复合类型（CompoundType）。 1.  **命名类型**        包括类、结构体、枚举等，它们都有一个名称，比如自定义类的类名就是类型名称。        2.  **复合类型**        则没有名称，它是由多个其他类型组合而成的。函数和元组都属于复合类型。函数的类型是由参数的类型和返回值的类型组合而成的，它们都是编译器对函数类型进行计算的依据。        举例来说，假设一个函数有两个参数，分别是类型 A 和 B，而返回值的类型是C，那么这个函数的类型可以计为 (A,B)-\>C。这就是对函数的类型的形式化的表达。那么进一步，我们**如何在编译期里针对函数的类型做类型分析呢**？它跟非复合的类型还真不太一样，因为编译器需要检查复合类型中的多个元素。举个例子。在一个高阶函数 g() 里，能够接收一个函数类型的参数f(A,B)，要求其类型是 (A, B)-\>C，而实际提供的函数 f2 的类型是 (A1,B1)-\>C1，那么你在编译器里如何判断函数的类型是否合法呢？这里的算法要做多步的检查：1.  第一，f2    也必须有两个参数，这点是符合的。        2.  第二，检查参数的类型。A1 和 B1 必须是跟 A 和 B    相同的类型，或者是它们的父类型，这样 f1 才能正确地给 f2    传递参数。        3.  第三，检查返回值的类型。C1，则必须是 C 的子类型，这样 f1 才能接收    f2 的返回值。        好，说完了编译器的前端工作，我们再来看看函数在语言内部的实现。函数的内部实现在函数式编程里，所有一切都围绕着函数。但是在编译完毕以后，函数在运行时中是怎么表示的呢？就像不同的面向对象的语言，在运行时是以不同的方式表示一个对象的，不同的函数式编程语言，在运行时中去实现一个函数的机制也是不太一样的。1.  在 Python 中，一切都是对象，所以函数也是一种对象，它是实现了    Callable    协议的对象，能够在后面加上一对括号去调用它。        2.  在 Scala 和 Java 这种基于 JVM 的语言中，函数在 JVM    这个层次没有获得原生支持，因此函数被编译完毕以后，其实会变成 JVM    中的类。        3.  在 Julia、Swift、Go、Rust    这样编译成机器码的语言中，函数基本上就是内存中代码段（或文本段）的一个地址。这个地址在编译后做链接的时候，会变成一个确定的地址值。在运行时，跳转到这个地址就可以执行函数的功能。        补充：再具体一点的话，slate-object="mark"}**编译成机器码的函数有什么特点呢？**slate-object="mark"}我们再来回顾一下。slate-object="mark"}首先，函数的调用者要根据调用约定，通过栈或者寄存器设置函数的参数，保护好自己负责保护的寄存器以及返回地址，然后调用函数。slate-object="mark"}在被调用者的函数体内，通常会分为三个部分。头尾两个部分叫做slate-object="mark"}**序曲（prelude）**slate-object="mark"}**和**slate-object="mark"}**尾声（epilogue）**slate-object="mark"}，分别做一些初始化工作和收尾工作。在序曲里会保存原来的栈指针，以及把自己应该保护的寄存器存到栈里、设置新的栈指针等，接着执行函数的主体逻辑。最后，到尾声部分，要根据调用约定把返回值设置到寄存器或栈，恢复所保护的寄存器的值和栈顶指针，接着跳转到返回地址。slate-object="mark"}返回到调用者以后，会有一些代码恢复被保护起来的寄存器，获取返回值，然后继续执行后面的代码。slate-object="mark"}这样，把上述整个过程的细节弄清楚了，你就知道如何为函数生成代码了。slate-object="mark"}最后，我们必须提到一种特殊情况，就是**闭包**。闭包是纯函数的对立面，它引用了上级作用域中的一些自由变量。闭包在运行时不仅是代码段中的一个函数地址，还必须保存自由变量的值。为了实现闭包的运行时功能，编译器需要生成相应的代码，以便在生成闭包的时候，可以在堆里申请内存来保存自由变量的值。而当该闭包不再被引用了，那么就会像不再被引用的对象一样，成为了内存垃圾，要被垃圾回收机制回收。好了，到这里你可能会觉得，看上去函数的实现似乎跟命令式语言也没有什么不同。不过，接下来你就会看到不同点了，这就是延迟求值的实现。延迟求值（Lazy Evaluation）在命令式语言里，我们对表达式求值，是严格按照顺序对 AST求值。但对于纯函数来说，由于在任何时候求值结果都是一样的，因此可以进行一定的优化，比如延迟求值（LazyEvaluation），从而有可能减少计算工作量，或者实现像 unless()那样的特别的控制结构。那么针对这种情况，编译器需要做什么处理呢？我举个例子，对于下面的示例程序（伪代码）：    g(condition, x){      if (condition)        return x;      else return 0;    }如果我们调用的时候，在 x 参数的位置传入的是另一个函数调用f(y)，也就是 g(condition, f(y))，那么编译器就会把 g() 的函数体内用到 x的地方，都转换成对 f(y)的调用：       if (condition)        return f(y);      else return 0;这种把对参数的引用替换成对函数调用的技术，叫做**换名调用**。不过换名调用有一个缺点，就是 f(y)有可能会被多次调用，而且每次调用的结果都是一样的。这就产生了浪费。那么这时，编译器就要更聪明一点。怎么办呢？那就是在第一次调用的时候，记录下它的值。如果下次再调用，则使用第一次调用的结果。这种方式叫做**按需调用**。总而言之，纯函数的特征就导致了延迟求值在编译上的不同。而函数式编程另一个重要的特征，不变性，也会对编译和运行过程造成影响。不变性对编译和运行时的影响在遵守不变性原则的情况下，对程序的编译也会有很大的不同。第一，由于函数不会修改对象的状态，所以就不存在并发程序中的竞争情况，进而也就不需要采用锁的机制，编译器也不需要生成与锁有关的代码。Java、JavaScript等语言中关于参数逃逸的分析，也变得不必要了，因为反正别的线程获得了某个对象或结构体，也不会去修改它的状态。第二，不变性就意味着，只可能是新的对象引用老的对象，老的对象不可能引用新的对象。这对于垃圾收集算法的意义很大。在分代收集的算法中，如果老对象被新对象引用，那必须等到新对象回收之后老对象才可能被回收，所以函数式编程的程序现在可以更容易做出决定，把老对象放到老一代的区域，从而节省垃圾收集算法的计算量；另外，由于对象不会被改变，因此更容易实现增量收集和并行收集；由于不可能存在循环引用，因此如果采用的是引用计数法的话，就没有必要进行循环引用的检测了。第三，不变性还意味着，在程序运行过程中可能要产生更多的新对象。在命令式语言中，程序需要对原来的对象修改状态。而函数式编程，只能每次创建一个新对象。所以，垃圾收集算法需要能够尽快地收集掉新对象。OK，了解了不变性，我们再来看看，针对函数式编程语言的优化算法。其中最重要的就是对递归函数的优化。对递归函数的优化虽然命令式的编程语言也会用到递归函数，但函数式编程里对递归函数的使用更加普遍，比如通常会用递归来代替循环。如果要对一个整型数组求和，命令式编程语言会做一个循环，而函数式编程语言则更习惯于用递归的方式表达：sum(a,i) = a\[i\] + sum(a, i-1)。按照传统的函数调用的运行方式，对于每一次函数调用，程序都要增加一个栈桢。递归调用一千次，就要增加一千个栈桢。这样的话，程序的栈空间很快就会被耗尽。并且，函数调用的时候，每次都要有一些额外的开销，比如保护寄存器的值、保存返回地址、传递参数等等。我在 [第 7讲  slate-object="inline"的优化算法里，提到过**尾调用优化**，也就是执行完递归函数后，马上用 return语句返回的情况。    f(x){      ....      return g(...);   //尾调用    }在尾调用的场景下，上一级函数的栈桢已经没什么用了，程序可以直接复用。函数调用的过程，可以被优化成指令的跳转，不需要那些函数调用的开销。不过对于递归调用的情况，往往还需要对递归函数返回值做进一步的计算。比如在下面的求阶乘的函数示例中，返回值是x\*fact(x-1)。    //fact.c 求阶乘    int fact(int x){        if (x == 1)            return 1;        else            return x*fact(x-1);   //对递归值要做进一步的计算    }对于编译器来说，它可以经过分析，把这种情况转换成一个单纯的尾调用。具体地说，就是它相当于引入了一个临时的递归函数fact2()，并且用第一个参数 acc来记录累计值：    int fact(x){        if (x == 1)            return 1;        else            return fact2(x, x-1);       //调用一个临时的递归函数    }    int fact2(int acc, int x){          //参数acc用来保存累计值        if (x == 1){            return acc;        }        else{            return fact2(acc * x, x-1); //一个单纯的尾调用        }    } 如果我们调用 fact(5)，其实际执行过程就会在 acc参数中连续地做乘法，从而实现阶乘：    ->fact(5)    ->fact2(5,4)    ->fact2(5*4,3)    ->fact2(5*4*3,2)    ->fact2(5*4*3*2,1)    ->5*4*3*2你可以观察一下编译器实际生成的汇编程序，看看优化后的成果。如果用"clang-O1 -S -o fact.s fact.c"来编译 fact函数，就会得到一个汇编代码文件。我对这段代码做了注释，你可以理解下它的逻辑。你可以发现，优化后的函数没有做任何一次递归调用。    _fact:                                  