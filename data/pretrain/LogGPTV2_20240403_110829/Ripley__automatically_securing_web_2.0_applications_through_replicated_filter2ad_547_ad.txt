GZip compression reduces the size of a single event on the wire
to just 3–4 bytes on average, as shown in columns 8–9. The ef-
fectiveness of compression is most noticeable in highly interactive
benchmarks such as Speed typing, reducing the number of needed
network packets to just a single one in most cases. Unfortunately,
the current generation of browsers do not support automatic com-
pression of HTTP requests, only HTTP responses, requiring it to
make compression part of Volta tier splitting, which is part of fu-
ture work.
4.1.2 Memory Overhead in the Emulator
In the presence of multiple replicas running alongside the server
it is possible for the replicas to use up quite a bit of extra memory.
Of course, the emulator is signiﬁcantly less memory-consuming
than running a full-ﬂedged version of the browser.
To experimentally demonstrate this point we ﬁrst considered a
version of the Shopping cart application running without RIPLEY
and then with RIPLEY enabled, with both Internet Explorer and
Firefox running on the client. A summary of information about
this experiment is shown in Figure 9. The table shows the range
of memory utilization, in megabytes, to support a single client for
each version with and without RIPLEY; in most cases, more mem-
ory was allocated as the application progressed. We used Internet
Explorer version 7.0.6001 and Firefox version 2.0.0.16 on Win-
dows Vista to perform these measurements. The server memory
utilization goes up by about 5 MB by adding the RIPLEY emu-
Figure 10: Memory footprint, in MB, as a function of the num-
ber of replicas.
Figure 11: CPU overhead in ms after applying RIPLEY.
lator. The experiment was conducted thrice to verify that the in-
crease is always about 5 MB. This is an order of magnitude cheaper
than adding a full-ﬂedged browser with a memory footprint of
over 50 MB.
Furthermore, we modiﬁed the server to create more client repli-
cas to simulate the process of a multitude of clients that are simulta-
neously connected to the server. Figure 10 shows the server mem-
ory size as we increase the number of replicas to 100. Because of
DLL sharing across the different APPDOMAINs, the marginal cost
of an additional replica is only about 1.3 MB compared to 5 MB.
To put this into perspective, we have consulted recent capac-
ity planning guidelines for Microsoft Sharepoint, a sophisticated
Web 2.0 application providing wiki and document sharing func-
tionality. In many ways, Sharepoint is a good application to con-
sider: unlike search, which is server-bound, it performs a reason-
able amount of computation on the client, but the reason to have
client-side computation is responsiveness, not to unload computa-
tion from the server. Capacity planning guidelines suggest 100–
190 concurrent users per machine [1, 47]. At 1.3 MB per user, this
requires 130–247 MB of extra memory per server, which is a rea-
sonable overhead.
4.1.3 CPU Overhead
RIPLEY introduces CPU overhead on both the server and the
client. Clearly, running the replica on the server also consumes
CPU resources, despite the fact that running within the emulator
described in Section 3.4 makes things considerably faster.
RIPLEY checking on the server introduces some latency for reg-
ular requests, as shown in columns 2–4 in Figure 11. The server
runs an ASP.NET application server on a dual-core 3-GHz ma-
chine with 4 GB of RAM running Microsoft Vista. We run each
application with the same input as for the network overhead exper-
iments and measure the time that each client-side request spends
waiting for the replica to generate the corresponding request and
to compare the two to verify its integrity. In most cases, the for-
mer component forms the bulk of the overhead, since the replica
receives the event information in batches and needs time to catch
up with the actual client.
The maximum overhead of the Shopping Cart and Sudoku is due
to this effect, since the events are sent to the replica right before the
checkout and finishgame RPCs are sent to the server. The max-
imum overhead for the other applications is observed during the
application initialization phase and typically involves application-
speciﬁc IO on the server. For instance, in the Blog application,
it involves fetching the blog data and in the Quiz application, it
involves initializing the database of questions. Despite this, this
overhead is mostly negligible for all benchmarks. The minimum
times were fractions of milliseconds, since for these requests, the
replica is already in sync when the requests arrive. The overhead is
only due to the string comparison of messages.
Client-side instrumentation for capturing and serializing event
information to the server adds execution overhead in the browser.
The overhead is low as shown in columns 5–8 in Figure 11, typi-
0501001502001265176101180cally about a couple of milliseconds on average. The extremes of
minimum and maximum are shown to indicate the spread. The high
extremes are believed to be statistical anomalies since the median
overhead is 1 ms for all applications, which is not noticeable for
interactive GUI applications. This is the typical overhead we might
expect, since the events are sent asynchronously to the server. Mov-
ing event capture to the browser as discussed in Section 5 is likely
to reduce the client-side CPU overhead even further.
4.2 Hotmail Experiments:
Overhead Macro-measurements
The experimental evaluation thus far has focused on studying
several relatively small Volta applications in much detail. To pro-
vide an estimate of how RIPLEY ideas might extend to an existing
large scale Web 2.0 AJAX application, we have devised a series of
experiments focusing on replicating the client-side Hotmail state
“by hand”, without automatic deployment provided by RIPLEY for
Volta applications.
4.2.1 Hotmail Experimental Setup
The Hotmail mailbox in our setup consisted of 32 email mes-
sages, about half of which were HTML-heavy. The entire appli-
cation download with a clean browser cache consists of 793 KB
of both code and data, uncompressed. Much of that — 703 KB
total — is JavaScript. When pretty-printed,
the downloaded
JavaScript adds up to 31,178 lines.
Pretty-printing is necessary, because often,
to save space,
JavaScript is shipped as a long line of code. Note that the DOM
representing the mail application UI is partially downloaded from
the server and partially created on the client, through JavaScript
client-side logic and XmlHttpRequest calls.
4.2.2 Network Overhead
To measure the network overhead of event capture, we loaded
a Hotmail inbox window and waited for network activity to qui-
esce. For this run, the mailbox contained a total of 8 unread email
messages and several dozen read ones. We used Hotmail for a to-
tal of 5 minutes, starting by reading the messages, replying to mail,
deleting spam, cleaning the junk mail folder, searching the mailbox
for and removing some large HTML emails, etc.
This entire experiment produced a total of 491 keyboard and
mouse events (subsequent keyboard presses sent
to the same
HTML element were compressed into one event), captured using
a key logger. When saved to disk, the event trace was 8,673 bytes
or 2,889, when compressed with GZip (for this experiment we used
exact screen coordinates instead of element ids, leading to a slightly
more verbose representation). Next, we examined the amount of
trafﬁc that exists between Hotmail servers and the browser.
For this experiment, we ignore trafﬁc generated by viewing email
messages to other hosts: for instance, viewing a message from
Amazon.com results in numerous requests for book cover images,
etc. We also discount requests that the browser makes to exten-
sion vendor sites, etc. At the end, we end up with a total of 328
requests, some going directly to Hotmail servers, others going to
afﬁliated advertising sites.
The aggregate size of the requests is 617,297 bytes; the aggre-
gate size of responses is 3,045,249 bytes. Part of the reason HTTP
requests are generally larger than expected is because they contain
sizable tracking cookies: cookies of 1–2 KB in size are not uncom-
mon. The extra network trafﬁc because of event capture is negli-
gible in comparison: it constitutes 1.4% if we do not compress the
event stream and 0.4% otherwise.
Page
Hotmail homepage
Inbox page
HTML-heavy email
JavaScript heap
0.815 MB
1.25 MB
1.291 MB
Figure 12: JavaScript live heap sizes for Hotmail.
4.2.3 Memory Footprint
Client-side state, which is what our replica needs to keep track
of efﬁciently, consists of three major components. First, there is the
DOM displayed in the browser. The DOM is not displayed in the
RIPLEY emulator, but its representation needs to be kept in mem-
ory. Second, there are non-DOM client-side data structures main-
tained in the JavaScript heap. Third, there is the JavaScript code
maintained on the client. Our assumption is that within the replica,
this code will be represented in .NET and shared across the instan-
tiated replicas, so that the code footprint does not grow as more
concurrent clients are added. Therefore, we focus on measuring
the amount of per-client DOM and heap state.
DOM state. To estimate the DOM state within the replica’s heap,
we have taken a saved version of the DOM as HTML. We converted
this 20 KB HTML document into a DOM representation within the
emulator by recursively parsing the HTML and recreating the DOM
tree on the .NET emulator heap. The in-memory representation of
the DOM is 349 KB, if we enable frequent garbage collection in
.NET to simulate memory pressure, and 434 KB otherwise.
Client-side heap. Unfortunately, translating the existing 700 KB
or so of JavaScript into .NET is not a tractable approach, so instead
we have chosen to instrument the runtime execution of Hotmail
within a real browser to put an upper bound on the amount of heap
storage likely to be required within the replica.
For this experiment, we instrumented the JavaScript engine in
Mozilla Firefox to report the aggregate size of live heap objects
after each garbage collection cycle.
(Again, we forced frequent
garbage collection to simulate memory pressure in a multi-user en-
vironment. As with any garbage collection environment, while a
lot of objects are allocated, a high fraction of them die young; we
focus on the aggregate size of live heap objects on the heap.) Note
that this is an upper bound because .NET, being a strongly-typed
runtime environment, generally uses the heap more efﬁciently than
JavaScript.
We have discovered that even an empty browser allocates a fair
bit of state — 3.1 MB in total — in the JavaScript heap, which in-
cludes browser plugin state, JavaScript built-in functions, etc., all
reﬂected into JavaScript. None of this needs to be represented in
the replica, so this heap size constitutes the baseline for our exper-
iments. In other words, we focus on heap size increase seen when
we run Hotmail within Firefox.
Memory footprint numbers measured in megabytes for differ-
ent Hotmail pages in our experiment are shown in Figure 12. For
none of the frequent actions, does the JavaScript heap size ex-
ceed 1.3 MB. When considered together with the DOM state, this
is still under 1.75 MB per connected client.
4.2.4 CPU Overhead
The CPU overhead for replicating the client-side of Hotmail is
quite difﬁcult to measure accurately, given that the browser is busy
with so many activities at once. Just as with memory, we would
have to translate the existing Hotmail code into .NET and run it.
However, it has often been observed that JavaScript execution is
not the dominant part of client-side application execution, in terms
181of the fraction of time it takes. For instance, a study of 100 top
sites suggests that JavaScript execution is responsible for about 3%
of overall time. For a JavaScript-heavy site such as Hotmail, the re-
ported JavaScript time is only about 14%, when run within Internet
Explorer. On the other hand, CSS, layout, rendering, DOM ma-
nipulation, and data marshalling take a total of 75% [48]. Luckily,
the emulator is “headless”: it does not need to worry about these
issues. As such, we do not expect that replicating the client-side of
Hotmail will dramatically add to the CPU load on the server.
To support our belief, we used a proxy-based JavaScript instru-
menter to parse and add time-stamps in the beginning and end
of event handlers found in JavaScript for Hotmail. The major-
ity of event handlers in our experiment take a very small span
of time, below the 15 ms granularity of the JavaScript built-in
timer. Drilling into the execution of a single action — clicking
on a large, HTML email message and waiting for it to show up in
the email viewing pane — reveals the following. Event handlers
themselves are very fast; heavy-weight network-bound operations
execute asynchronously. For instance, an inbox message open op-
eration is processed asynchronously. The event handler itself takes
only 15 ms. Email message processing callback takes 125 ms,
much of which is HTML screen repainting. Again, the headless
emulator does not suffer this rendering performance hit.
While it is difﬁcult to precisely estimate the effect of replicating
Hotmail onto the server, replication is not entirely unprecedented
in the AJAX world. Replication is often used in mobile browsers to
achieve compatibility. Early success of projects that use server-side
rendering include the Deepﬁsh mobile browser project [35] and a
recent SkyFire browser [45], both of which rely at least partially
on server-side rendering, is encouraging for the feasibility of the
RIPLEY approach on a large scale.
4.2.5 Summary
In summary, while at over 31,000 lines of code Hotmail is a con-
siderably larger and more complex AJAX application than the ﬁve
Volta applications studied in the previous section, the overhead im-
posed by replication seems acceptable. The network overhead ap-
pears to be just 0.4%. The memory overhead is around 1.75 MB per
concurrently connected client, which is manageable given typical
capacity planning requirements of supporting 100–200 concurrent
users. While is it difﬁcult to precisely ascertain the CPU overhead
of replication, is is clear that a headless browser results in a consid-
erable overhead reduction.
5. DISCUSSION
This section considers implementation and deployment issues
that arise in the design and implementation of RIPLEY. Section 5.1
discusses difﬁculties of faithful replication. Section 5.2 addresses
scalability issues.
5.1 Difﬁculties of Faithful Replication
As was pointed out earlier, the fact that Volta provides a nar-
row browser-independent interface to the DOM makes replicating
it faithfully relatively easy. Disallowing HTML injection through
direct innerHTML assignments allows us to fully mediate access to
the DOM by the application, at the cost of the code being slightly
more verbose.
The most pronounced issue that makes replication hard is the
presence of various forms of non-determinism. Isolating them all is
a tricky problem. Below we discuss ways to introduce deterministic
replay [6, 39] into replica execution with the help of additional in-
strumentation. The following sources of non-determinism are most
common in web applications.
Using the Random family of functions. JavaScript exposes a ran-
dom number generator through function Math.Random. Clearly,
unless additional measures are taken, the value returned by calls to
this function on the client and the replica will disagree. A uniform
approach to treating randomness is to perform the computation on
one, “canonical” tier. In this case, we can instrument the client-side
code to block on Math.Random in the same way it would block on
an RPC. Then the client would request the random number from
the server and we would return the same value to both the client
and the replica. Note that this value needs to originate on the server
tier to be unguessable by a malicious client. In environments where
random numbers need to be generated frequently on the client, the
quality of the random number could be traded off for reduced net-
work usage by only asking for the randomizing seed occasionaly.
Reading and measuring time. Access to time is provided through
the Date object in JavaScript. Similarly to the approach described
above, access to time routines can be instrumented and the replica