第1遍
第2遍
第3遍
第4遍
yalue1
value1
value1
valuel
value2
value2
value2
value2
value2
velue2
yalue3
value3
value3
value3
value2
yalue3
value?
valuel
value2
value2
1个匹配/替换
2个匹配/替换
1个匹配/替换
没有找到重复
参见
实例2.10详细讨论了关于向后引用的内容。
实例5.8讲解了如何匹配重复单词。
5.10
匹配包含某个单词的整行内容
问题描述
你想要匹配在其中任何地方包含单词ninja的所有文本行。
解决方案
.*\bninja\b.*$
正则选项：不区分大小写、和$匹配换行处（“点号匹配换行符”必须关闭）
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
讨论
常常会有需要匹配整行内容，从而可以收集或者删除它们。如果要想匹配包含单词ninja
的任意行，我们首先构造-一个正则表达式\bninja\b>。在两端的单词边界会确保只能以
整个单词的形式匹配“ninja”。更多细节，请参考实例2.6。
要把这个正则式进行扩展来匹配整行内容，就需要在两端都添加.*。点号加星号的序
列会在当前行匹配0个或多个字符。星号量词是贪心的，所以它们会尽量匹配更多的
文本。第一个“点号-星号”会一直匹配到在该行中最后一次出现“ninja”的位置，而
第二个“点号-星号”则会匹配在其后的任意非换行符的字符。
298
第5章
www.TopSage.com
---
## Page 315
最后，我们把脱字符和美元符号分别放到正则表达式的开始和结尾，以确保它只会匹
配一整行的内容。严格来讲，结尾处的定位符美元符号是究余的，因为点号和贪心的
星号总是会匹配到-行的结尾。然而，添加它总不会带来什么坏处，而且会使该正则
表达式看起来更加易读。在正则式中添加合适的行定位符或字符串定位符，有时候会
帮助你避免意想不到的问题，因此形成这样的习惯是有益的。注意，与美元符号不一
样，在正则表达式开始处的脱字符则不一定是余的，因为它确保正则式只会匹配到
整行，因为也许由于某种原因，匹配查找有可能会从一行的中间开始。
需要记住用来把匹配限制到一行的3个关键元字符（定位符、$）以及点号）的含义
并不固定。要想让它们都是面向行来处理的，你就必须打并让和S>匹配换行处的
选项，同时确保没有打开让点号匹配换行符的选项。实例3.4中讲解了如何在代码中应
用这些选项。如果你使用的是JavaScript或者Ruby，那么就可以少担心一个选项，因
为JavaScript中没有让点号匹配换行符的选项，而Ruby中的脱字符和美元符号则总是
会匹配换行处。
变体
要搜索包含多个单词之一的文本行，可以使用多选结构：
.*\b(one|twolthree)\b.*$
正则选项：不区分大小写、和$匹配换行处（“点号匹配换行符”必须关闭）
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
一中，，，
个的任意一行内容。单词两边的圆括号有两个自的。首先，它们会限制多选操作的作
用范围；其次，它们会把实际出现在该行中的单词捕获到向后引用#1中。如果该行包
含超过一个这些单词，那么向后引用会包含最靠右边的那个单词。这是因为出现在圆
括号之前的星号量词是贪心的，从而会把点号扩展为匹配尽可能多的文本。如果你把
星号变成懒情的，比如使用会被用来实际
上匹配该文本行。
参见
实例5.11讲解了如何匹配不包含某个特定单词的整行内容。
单词、文本行和特殊字符
299
www.TopSage.com
---
## Page 316
5.11匹配不包含某个单词的整行
问题描述
你想要匹配不包含单词ninja的整行内容。
解决方案
(？:(?!\bninja\b).)*$
正则选项：不区分大小写、和S匹配换行处（“点号匹配换行符”必须关闭）
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
讨论
为了匹配不包含某些内容的一行，需要使用否定型的顺序环视（参考实例2.16中的
讲解）。注意在这个正则表达式中，使用一个非捕获分组来重复了一个否定型顺序
环视和一个点号。这样就可以确保正则式会在该行的每个位置都匹配失
败。定位符被放到正则表达式的两端，用来保证你所匹配到的内容是一
整行。
应用这个正则表达式的选项决定了它是否会尝试匹配整个目标字符串，还是每次只
匹配一行。如果使用了让（和匹配换行处的选项，而关闭了让点号匹配换行符
的选项，那么这个正则表达式就会按照前面的说明执行，并且会逐行进行匹配。
如果你把这两个选项都反过来，那幺正则表达式就会匹配不包含单词“ninja”的任
意字符串。
警告
在一行或者一个字符串中的每个位置检查否定型顺序环视的效率是相
当低的。这个解决方案只打算被应用于只能使用一个正则表达式的情
形，例如你在使用的应用程序不支持对它进行编程。如果可以使用编
程实现，那么实例3.21中会讲解一种效率高很多的解决方案。
参见
实例5.10会讲解如何匹配包含某个特定单词的整行内容。
5.12删除前导和拖尾的空格
问题描述
你想要删除一个字符串中的前导和拖尾空格。
300第5章
www.TopSage.com
---
## Page 317
解决方案
为了简单快速起见，最好用的万能解答是使用两次替换一一一次删除前导空格，另外
一次删除拖尾空格：
^\s+
正则选项：无（“^和$匹配换行处”必须关闭）
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
\s+$
正则选项：无（“^和$匹配换行处”必须关闭）
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
只需要把使用这两个正则表达式找到的所有匹配都替换为空串即可。实例3.14中会讲
解如何这样做。有了这两个正则表达式，你只需要替换它们找到的第一个匹配，因为
它们会一次就匹配到所有的前导或拖尾空格。
讨论
删除前导和拖尾空格是一个简单但是很常见的任务。前面刚刚给出的2个正则表达式
都包含了三个部分：一个定位符来判断字符串的起始位置或结束位置（分别使用的是
(和$>），用来匹配任意空格字符的简写字符类（心s>），以及把该字符类重复一次或
多次的量词((+))。
许多编程语言都会提供一个函数，通常被命名为trim或者strip，可以用来去掉前导和
拖尾空格。表5-2中给出了在各种编程语言中如何使用这种内置的函数或方法。
表5-2删除前导和拖尾空格的标准函数
编程语言
用法示例
C#、VB.NET
String.Trim([chars])
Java
string.trim)
PHP
trim(Sstring)
Python、Ruby
string.stripO
JavaScript和Perl在它们的标准函数库中不存在等价的函数，但是你可以很容易地创建
自己的函数来完成同样的任务。
在Perl中：
sub trim {
my $string = shift;
$string =~s/^\s+//;
$string =~ s/\s+$//;
return $string;
单词、文本行和特殊字符
301
www.TopSage.com
---
## Page 318
在JavaScript中：
functiontrim (string)(
return string.replace(/^\s+/,'').replace(/\s+$/,'');
{
// Alternatively, use this to make trim a method of all strings:
String.prototype.trim = function （){
return this.replace(/^\s+/，**).replace(/\s+$/,*');
提示
在Perl和JavaScript中，除了通常被当作是空白的空格、制表符、换行和
回车字符之外，《ls)会匹配根据Unicode标准被定义为空白的任意字符。
变体
构造一个正则表达式来帮助你修整（trim）一个字符串中的空格实际上可以有多种方式。
然而，在处理较长的字符串时（也就是当性能最为重要的时候），它们的速度无一例外
地都比不上采用两个简单的替换操作。下面会给出一些你可能会遇到的常见的解决方
案。它们都是用JavaScript写的，因为JavaScript中没有“点号匹配换行符”的选项，
所以这些正则表达式中使用来匹配任意单个字符，其中包括了换行符。在其他
编程语言中，你可以使用一个点号来替代，并且要打开“点号匹配换行符”的选项。
string.replace(/^\s+|\s+$/g,*');
这个很可能是最为常见的解决方案。它通过多选结构（参见实例2.8）组合了两个简单
正则式，并且使用了/g（全局）选项来替换所有的匹配，而不是只替换第一个匹配（如
果在字符串中同时包含前导和拖尾空格，它会匹配两次）。这并不是一个很差的解决方
法，但是在处理长字符串的时候，它的速度会比使用两个简单替换要慢一些。
这个正则表达式的工作原理是：匹配整个字符串，并且捕获从第一个到最后一个非空
白字符（如果存在），把它放到向后引用#1中。通过把整个字符串替换为向后引用#1，
你就得到了一个修整好的字符串。
这个方法在概念上是很简单的，但是在捕获分组中使用的懒情量词会让正则引擎不
得不做许多额外工作，因此也会造成这种方法在处理长的目标字符串时速度较慢。
在匹配过程中，当正则引擎进人捕获分组之后，懒情量词要求字符类sIS]被重复
的次数尽量少。因此，正则引擎会每次匹配一个字符，在每个字符之后都要停顿来
尝试匹配剩余的模式（s*$>）。如果因为在字符事的当前位置之后依然含有非空白
字符而匹配失败，那幺正则引擎会再多匹配一个字符，然后接着尝试匹配模式的剩
余部分。
string.replace(/~\s*([\s\s] *\S)?\s*$/,*$1′)
302第5章
www.TopSage.com
---
## Page 319
这个正则表达式与上一个比较类似，但是基于性能的考虑，它把懒情量词替换成了贪
心量词。为了确保捕获分组依然只会匹配到最后一个非空白字符，我们使用了一个必
需的拖尾S）。然而，因为这个正则式必须能够匹配只包含空白的字符串，所以整个
捕获分组被添加了一个拖尾的问号量词，从而变成了可选的。
我们再来退一步看一下它是如何工作的。这里，[sIS]*中的贪心星号量词会重复模式
“任意字符”直到字符串的结束。正则引擎随后会从字符事结尾开始一次一个字符回溯，
直到它能匹配后面的S>，或者直到它回溯到了在捕获分组中匹配到的第一个字符。
除非是后面的空白字符个数比到它为止的所有文本中的字符还多，这个正则式通常会
比上一个使用懒情量词的解决方案速度要快。当然，它还是无法与使用两个简单替换
的性能相比。
string.replace(/^\s*(\S*(?:\s+\S+) *)\s*$/,'$1')
这是一个相对比较常见的方法，因此我们也把它包含进来作为一个对比。其实并不
存在好的理由需要使用这个正则式，因为它比前面给的解决方案的速度都要慢。它