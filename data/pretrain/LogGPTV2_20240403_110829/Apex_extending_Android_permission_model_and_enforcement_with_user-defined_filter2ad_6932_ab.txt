a component using android:permission attribute of , ,  or  tag [6]. Note that
these are the permissions required by the target component,
not those granted to the calling component.
Definition 4
(Permissions). A permission declares
the requirements posed by a component for accessing it. A
permission association function Ap : C → P associates each
component to a single1 permission where P is the set of per-
missions. If a component c ∈ C requires that a calling com-
ponent have a permission p ∈ P , then we write p = Ap(c).
Applications are granted speciﬁc permissions by the An-
droid framework at install-time. The manifest ﬁle includes
one or more  tags that specify the per-
missions required by the application to function properly.
During installation of the application, the user is presented
with an interface listing the requested permissions. If the
user chooses to grant these permissions, the application is
installed and thus granted the requested permissions. For-
mally:
1“A feature can be protected by at most one permission”. [5]
Since we base our formalization on the concept of compo-
nents, we deﬁne a second permission function ρ that deﬁnes
the permission of one component to call another with a spe-
ciﬁc intent. The permission function is deﬁned as follows:
Definition 6
(Permission Function). The permis-
sion function ρ deﬁnes the complete set of conditions under
which a component c1 is allowed to call another component
c2. c1 can communicate with c2 if and only if either 1) there
is no permission associated with the second component or
2) the application to which c1 belongs has been granted the
permission required by c2. Formally:
ρ(c1, c2, i) ⇐⇒ Ap(c2) = null ∨
∃p ∈ P, a ∈ A · a = ς(c1)
∧ p = Ap(c2) ∧ p ∈ µ(a1)
∧ i ∈ Af (c2)
Example 2. The facebook service component declares
the permission edu.apex.android.permission.fbs_start in its
android:permission attribute. In order to be able to raise the
intent for starting the facebook service, the Ringlet activity
needs to have this permission granted to it.
This example concludes our formalization of the existing
security mechanism provided by Android. It is evident that
in this mechanism, there is no way of specifying complex or
ﬁne-grained runtime constraints for permissions. Below, we
describe how we have enhanced this mechanism to include
dynamic constraints on permissions.
3.1 Dynamic Constraints
For associating dynamic constraints with permissions, we
introduce the concept of application attributes. Each appli-
cation in Android is associated with a ﬁnite set of attributes.
The application state is a function that maps the attributes
of an application to their values. The application state is
a persistent structure that maintains its values between dif-
ferent system sessions.
Definition 7
(Application State). An application
state is a function τ : η(A) → dom(η(A)), where A is the set
of applications, η is the function that maps an application
to a set of attribute names, and dom(x) is the value domain
of attribute set x of an application a ∈ A.
Example 3. The Ringlet application has several at-
tributes associated with it such as sentMms, which captures
the number of mms that have been sent by the application.
Each application can have a diﬀerent set of attributes. Exist-
ing Android applications for which no attributes are deﬁned
can be considered as having an empty set of attribute names
associated with them.
Constraints for permissions are deﬁned in terms of predi-
cates – functions that map the set of application attributes,
system attributes and constants to boolean values. A pred-
icate returns true if and only if the attribute values in the
current application state satisfy the conditions of the pred-
icates. We denote the set of predicates as Q.
An application transitions from one state to another as a
result of a change in the value of the application’s attributes.
This change is captured by an attribute update action.
Definition 8
(Attribute Update Action). An at-
tribute update action u(a.x, v(cid:48)) : τ → τ(cid:48) is a function that
maps the value of an attribute x ∈ η(a) of an application
a ∈ A to a new value v(cid:48) ∈ dom(η(a)).
Attribute updates play a key role in our policy framework.
Predicates based on these attributes are used for two pur-
poses. First, they are used to specify the conditions under
which a permission may be granted. Second, they can cause
an update action to be triggered, which may modify the val-
ues of attributes. Conditions and updates are both speciﬁed
in a policy.
Definition 9
(Policy). A policy deﬁnes the condi-
tions under which an application is granted a permission.
It consists of two input parameters – an application and
a permission – on which it is applicable, an authorization
rule composed of predicates that specify the conditions under
which the permission is granted/denied and a set of attribute
update actions, which are to be performed if the conditions
in the authorization rule are satisﬁed. Speciﬁcally:
l(a, p):
q1 ∧ q2 ∧ q3 ∧ . . . ∧ qn → {permit, deny}
u1; u2; u3; . . . ; un
where a ∈ A, p ∈ P , qi ∈ Q, ui are attribute update
actions, l ∈ Λ and Λ is the set of policies in the system. The
right-hand-side of the authorization rule deﬁnes the value
returned by the policy.
Note that if the predicates in an authorization rule are
satisﬁed, updates speciﬁed in the policy are performed re-
gardless of the return value of the authorization rule.
A policy is applied to a speciﬁc application state. At-
tribute values in the particular state determine the truth
value of the predicates. If the predicates are satisﬁed, the
permission is either granted or denied (depending on the re-
turn value of the authorization rule) and the updates speci-
ﬁed in the policy are executed resulting in a new state. This
may render predicates in other policies true, thus allowing
for the dynamic nature of the policy-based constraints on
permissions.
We incorporate these policies in the existing security
model of Android by redeﬁning the permission function ρ.
Definition 10
(Dynamic Permission Function).
The dynamic permission function speciﬁes the conditions
under which a component c1 is granted permission to call
another component c2 using intent i.
It incorporates the
static checks as well as the dynamic runtime constraints in
its evaluation. For a permission to be granted, Android’s
permission checks must grant the permission and there must
not be a policy that denies the permission. Formally:
ρ(c1, c2, i) ⇐⇒ Ap(c2) = null ∨
∃p ∈ P, a ∈ A · a = ς(c1)
∧ p = Ap(c2) ∧ p ∈ µ(a1)
∧ i ∈ Af (c2)
∧ ¬∃l ∈ Λ · l(a, p) = deny
Example 4. The Ringlet activity is able to include the
location of the user in the messages posted. Similar to the
weather update example given in Section 1, the user may
wish to restrict access to gps for protecting her privacy.
Using dynamic constraints, she may deﬁne a policy that
denies access to gps at all times. The constraint in the
policy is set to true and the authorization rule to deny with
no updates. Using this policy, she may install Ringlet and
use it for all other functionality while still protecting the
privacy of her location. Similarly, she may deﬁne a policy
that imposes a limit on Ringlet’s ability to send updates
through mms messages, say 5 each day, thereby controlling
the carrier costs at a ﬁne-grained level.
For the implementation of Apex, we have deﬁned a policy
language that allows the user to deﬁne her policies including
dynamic constraints. Figure 1 shows how both of the above
example policies can be depicted in our language. We have
incorporated the policy model in the existing android secu-
rity mechanism and inter-component communication mech-
anism. This includes changes to the activity manager, the
package manager and the permission checking mechanisms
associated with these components. However, we are unable
to include the details of this implementation here due to
space limitations.
4. POLY ANDROID INSTALLER
Writing usage policies is a complex procedure, even for
system administrators. Android is targeted at the consumer
market and the end users are, in general, unable to write
mms_count_allow ("edu.apex.ringlet.Ringlet" as Ringlet,
"android.permission.SEND_SMS" as MMS):
Ringlet.sentMms  5 ∧
Ringlet.lastUsedDay = System.CurrentDay
→ deny(Ringlet, MMS);
reset_mms_count ("edu.apex.ringlet.Ringlet" as Ringlet,
"android.permission.SEND_SMS" as MMS):
→ permit(Ringlet, MMS);
Ringlet.lastUsedDay ! = System.CurrentDay
Ringlet.lastUsedDay’ = System.CurrentDay;
Ringlet.sentMms’ = 1;
deny_gps ("edu.apex.ringlet.Ringlet" as Ringlet,
"android.permission.ACCESS_FINE_LOCATION" as GPS):
System.CurrentTime > 1700 ∨ System.CurrentTime < 0900
→ deny(Ringlet, GPS);
restrict_internet ("edu.ringlet.Ringlet" as Ringlet,
true → deny(Ringlet, Net);
"android.permission.INTERNET" as Net):
Figure 1: Example Apex Policies
complex usage policies. One of the most important aspects
of our new policy enforcement framework is the usability of
the architecture. To this end, we have created Poly – an
advanced Android application installer. Poly augments the
existing package installer by allowing users to specify their
constraints for each permission at install time using a simple
and usable interface. In the existing Android framework, the
user is presented with an interface that lists the permissions
required by an application. We have extended the installer
to allow the user to click on individual permissions and spec-
ify their constraints. When a user clicks on a permission she
is presented with an interface that allows her to pick one of
a few options.
1. For the novice user, the default setting is to allow. The
default behavior of Android installer is also to allow
all permissions, if the user agrees to install an appli-
cation. This is a major usability feature that makes
the behavior of the existing Android installer a subset
of Poly and will hopefully allow for easier adoption of
our constrained policy enforcement framework.
2. The deny option allows a user to selectively deny a
permission as opposed to the all-or-nothing approach
of the existing security mechanism. For example, Alice
downloads an application that asks for several permis-
sions including the one associated with sending sms.
Alice may wish to stop the application from sending
sms while still being able to install the application and
use all other features. In Poly, Alice can simply tap on
the ‘send sms’ permission and set it to ‘deny’.
3. The third option is the constrained permission. This
is the main concern of this contribution and has been
discussed at length in the previous sections. An im-
portant point to note here is that currently, we have
incorporated only simple constraints such as restrict-
ing the number of times used and the time of the day
in which to grant a permission. This simpliﬁcation
is for the sake of usability. We aim to develop a fully
functional desktop application, which will allow expert
users to write very ﬁne-grained policies.
For the implementation of Poly we have extended the
Figure 2: Poly Installation Interface: By clicking
on a permission, the user can deny or impose con-
straints on that permission while still granting all
others.
PackageInstallerActivity.
Figure 2 shows the screens
as presented to the user during installation. Moreover,
we also allow users to modify their constraints even af-
ter install-time.
For this purpose, we have provided
the same interface in the settings application of Android
(com.android.settings.ManageApplications class) so that the
constraints may be modiﬁed as the user’s trust on an appli-
cation increases or decreases over time.
We believe that our comprehensive constrained policy
mechanism coupled with the usable and ﬂexible user in-
terface of Poly provides a secure, yet user-friendly security
mechanism for the Android platform.
5. CONCLUSION AND FUTURE WORK
In this paper, we have described Apex – an extension to
the Android permission framework. Apex allows users to
specify detailed runtime constraints to restrict the use of
sensitive resources by applications. The framework achieves
this with a minimal trade-oﬀ between security and perfor-
mance. The user can specify her constraints through a sim-
ple interface of the extended Android installer called Poly.
The extensions are incorporated in the Android framework
with a minimal change in the codebase and the user interface
of existing security architecture.
Our model is signiﬁcantly diﬀerent from related eﬀorts [7,
1, 2] in that not only does it deﬁne an easy-to-use policy
language, it is also user-centric.
It allows users to make
decisions about permissions on their device rather than au-
tomating the decisions based on the policies of remote own-
ers. Secondly, it allows ﬁner-granular control over usage
through constructs such as attribute updates.
6. REFERENCES
[1] William Enck, Machigar Ongtang, and Patrick
McDaniel. On lightweight mobile phone application
certiﬁcation. In CCS ’09: Proceedings of the 16th ACM
conference on Computer and communications security,
pages 235–245, New York, NY, USA, 2009. ACM.
[2] Adam P. Fuchs, Avik Chaudhuri, and Jeﬀrey S. Foster.
SCanDroid: Automated Security Certiﬁcation of
Android Applications. In Submitted to IEEE S&P’10:
Proceedings of the 31st IEEE Symposium on Security
and Privacy, 2010.
[3] Google. Android Home Page, 2009. Available at:
http://www.android.com.
[4] Google. Android Reference: Intent, 2009. Available at:
http://developer.android.com/reference/android/
content/Intent.html.
[5] Google. Android Reference: Manifest File -
Permissions, 2009. Available at:
http://developer.android.com/guide/topics/
manifest/manifest-intro.html\#perms.
[6] Google. Android Reference: Security and Permissions,
2009. Available at: http://developer.android.com/
guide/topics/security/security.html.
[7] M. Ongtang, S. McLaughlin, W. Enck, and
P. McDaniel. Semantically Rich Application-Centric
Security in Android. In Proceedings of the Annual
Computer Security Applications Conference, 2009.