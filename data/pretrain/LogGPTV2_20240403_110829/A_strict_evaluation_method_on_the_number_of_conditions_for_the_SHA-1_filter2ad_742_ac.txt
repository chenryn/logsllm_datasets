### 优化后的文本

#### II. 差分路径扩展
我们从压缩的差分变量（DV）中导出差分路径（DP），以在第2到第4轮中更精确地计算每一步的条件变量计数（#CVC），比Wang等人提出的特殊计数规则2更为准确。通过使用DV和线性约束（LCs），我们可以构建一个DP。例如，我们从x23 = 0x40000000扩展出DP，如表4所示。

**表4：技术效果示例**
| DP | 效果 |
| --- | --- |
| x23 = 0x40000000 | 使用该技术，#CVC 计数为6；而Wang等人的技术则计数为8。 |

该技术结合了技术III，解决了Wang等人在第5节中描述的技术问题5。接下来一段将解释基于DP的#CVC计数方法。

#### III. 每一步的精确计数规则
在我们的技术中，我们根据技术II导出的DP在每一步中计算#CVC，而Wang等人则是通过每个DV位来计数。我们制定了新的计数规则，以在每一步中计算#CVC。这些规则如表5所示。通过参考每个f函数的表格，可以解决Wang等人技术中的问题3和问题4（详见第5节）。每一步的#CVC是i和ii的结果之和。

1. **统计链变量a中的“1”位数量**。（此结果给出了消除链变量a的差分后剩余条件的数量。）
2. **通过参考表5，获得对应于链变量b、c、d（DP的元素）差分的每一步f函数的#CVC**。

**表5：XOR和MAJ函数的计数表**

| 差分 | 条件 | #CVC |
| --- | --- | --- |
| j ≠ 31 | XOR(∆bi,j, ∆ci,j, ∆di,j) | 见详细条目 |
| j = 31 | MAJ(∆bi,j, ∆ci,j, ∆di,j) | 见详细条目 |

- **XOR(1, 0, 0), XOR(0, 1, 0), XOR(0, 0, 1)**: #CVC = 1
- **XOR(1, 1, 0), XOR(0, 1, 1), XOR(1, 0, 1), XOR(1, 1, 1)**: #CVC = 0
- **MAJ(1, 0, 0), MAJ(0, 1, 0), MAJ(0, 0, 1)**: #CVC = 1
- **MAJ(1, 1, 0), MAJ(0, 1, 1), MAJ(1, 0, 1), MAJ(1, 1, 1)**: #CVC = 0

注意：在下标j上省略了(mod 32)。虽然符号不包含在差分中，但这不是问题，因为输入到f函数的差分符号不会影响#CVC。

#### IV. 第2至4轮差分路径确认
在我们的计数方法中，DVs通过第一节中描述的差分位压缩进行压缩。在某些DVs中，无法通过压缩的DV和LCs构造第2至4轮的差分路径。为了排除这些DVs，我们需要通过简单的程序（见算法3）确认每一步中差分值的矛盾。这项技术还解决了第7节中提到的问题。

#### 7. 计算机实验
本节展示了使用我们在第6节中提出的新算法进行的计算机实验。

**7.1 实现**
我们在PC上实现了我们的算法。使用SUSE Linux 10.0上的AMD Opteron(tm) Processor 16处理器，通过4个线程运行，获取所有DVs的#CVC所需时间约为8小时。

**表6：适用于各种消息可修改步骤的有效DV**

| i | xi-1 | #CVC |
| --- | --- | --- |
| 1 | 40000003 | 2 |
| 2 | 00000002 | 2 |
| ... | ... | ... |
| 80 | 00000000 | 0 |

（表中列出了部分数据，完整数据请参见原文）

希望这些改进能使您的文档更加清晰、连贯和专业。如果需要进一步调整或有其他问题，请随时告知。