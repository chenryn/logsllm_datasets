2
2
2
1
0
8
1
2
0
2
1
0
6
28
28
Total
ei
di
28
26
28
26
Total
for eliminating carry
for f function
for f function
for f function
Comment
for eliminating carry
for f function (see Table 5)
and eliminating carry
for f function
for f function
II. DV expansion.
We derive a diﬀerential path (DP) from a compressed DV
in rounds 2 to 4 in order to count #CVC in each step more
precisely than Wang et al.’s special counting rule 2. We can
construct a DP by using DV and LCs. For example, we
expand DP from x23 = 0x40000000 as shown in Table 4.
Table 4 shows an example of the eﬀect of this technique.
This technique, combined with technique III, counts #CVC
as 6, while Wang et al.’s technique counts #CVC as 8. We
explain the counting method of #CVC based on DPs in the
next paragraph. This technique solves Problem 5 of Wang
et al.’s technique described in Section 5.
III. Precise Counting Rules in Every Step.
In our technique, we count #CVC from the DP derived
by technique II in each step, while Wang et al. count #CVC
by each DV bit. We constructed new counting rules to count
#CVC in each step. The rules are shown in Tables 5. Prob-
lem 3 and Problem 4 with Wang et al.’s technique shown
in Section 5 are solved by counting in each step by referring
the table for each f function. #CVC in each step is the sum
of the result of i and ii.
i Count the number of “1” bits in chaining variable a.
(This result gives us the number of conditions after
eliminating the carry of diﬀerentials of chaining vari-
able a.)
ii Obtain #CVC for f in each step corresponding to the
diﬀerential of chaining variables b, c, d, which are ele-
ments of DP, by referring to Tables 5.
Table 5: Counting Table for XOR and MAJ func-
tions
Diﬀerential
Condition
#CVC
j (cid:54)= 31
(XOR(∆bi,j, ∆ci,j, ∆di,j))
XOR(1, 0, 0)
XOR(0, 1, 0)
XOR(0, 0, 1)
XOR(1, 1, 0)
XOR(0, 1, 1)
XOR(1, 0, 1)
XOR(1, 1, 1)
Diﬀerential
(MAJ(∆bi,j, ∆ci,j, ∆di,j))
MAJ(1, 0, 0)
MAJ(0, 1, 0)
MAJ(0, 0, 1)
MAJ(1, 1, 0)
MAJ(0, 1, 1)
MAJ(1, 0, 1)
MAJ(1, 1, 1)
j = 31
0
0
0
bit
ai−2,j+2
ai−1,j
ai−1,j
none
none
none
none
1
1
1
0
0
0
0
Condition
#CVC
bit
ai−2,j+2
ai−1,j
ai−1,j
none
none
none
none
1
1
1
0
0
0
0
We omit (mod 32) on the subscription j of a.
Sign is not included in the diﬀerential but this is not a
problem because the sign of the diﬀerential of inputs to the
f function doesn’t inﬂuence #CVC.
Problem 1.
IV. Differential Path Conﬁrmation for Rounds 2 to 4.
In our counting method, DVs are compressed by using
the Diﬀerential Bit Compression described in I. In some of
these DVs, the diﬀerential path in rounds 2 to 4 cannot be
constructed by using the compressed DV and LCs. In order
to exclude such DVs, we have to conﬁrm the contradiction
of diﬀerential values in each step by using a simple proce-
dure described in Algorithm 3. This technique also solves
7. COMPUTER EXPERIMENT
In this section, we show a computer experiment using our
new algorithm proposed in Section6.
7.1
Implementation
We implemented our algorithm on a PC. The running time
to obtain #CVCs of all DVs is about 8 hours by using 4
threads in SUSE Linux 10.0 on AMD Opteron(tm) Processor
16
Table 6: An Eﬀective DV for Various Message Modiﬁable Steps
i
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
xi−1 #CVC
40000003
00000002
80000003
80000002
40000000
00000002
80000003
80000000
40000003
00000002
80000003
80000002
40000000
00000002
80000003
80000000
00000003
00000002
80000001
00000002
i
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
xi−1 #CVC
4
3
4
3
3
2
4
3
3
2
3
2
1
0
0
0
0
1
1
2
00000003
00000002
80000002
00000002
80000003
00000000
80000000
00000002
80000001
00000000
00000000
00000002
00000002
00000000
00000000
00000000
00000000
00000000
00000002
00000000
i
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
xi−1 #CVC
2
2
2
2
2
1
2
1
1
1
0
1
1
1
1
0
0
1
1
1
00000002
00000000
00000002
00000000
00000003
00000000
00000000
00000002
00000000
00000000
00000000
00000000
00000002
00000000
00000000
00000000
00000000
00000000
00000002
00000000
i
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
xi−1 #CVC
1
0
0
0
0
0
0
0
0
0
0
1
1
1
2
2
2
(2)
0
0
00000002
00000000
00000000
00000000
00000000