显示每个节点中系统范围内的内存使用信息，类似 /proc/meminfo 中的信息。
-n
显示与原始 numastat 命令类似的信息（numa_hit, numa_miss, numa_foreign, interleave_hit,
local_node, and other_node），采用更新的格式，使用 MB 作为测量单位。
29
红帽企业版 Linux 6 性能调节指南
-p pattern
为指定的模式显示每个节点的内存信息。如果 pattern 值由数字组成，numastat 假设它是一个
数字进程识别符。否则 numastat 会为指定的模式搜索进程命令行。
假设在 -p 选项值后输入的命令行参数是过滤器的附加模式。附加模式要扩大而不是缩小过滤范
围。
-s
以降序模式排列显示的数据以便让最大内存消耗者（根据 total 栏）列在首位。
您也可以指定 node，并根据 node 栏排列表格。当使用这个选项时，node 值后必须立即跟上一个
-s 选项，如下所示：
numastat -s2
不要在该选项及其数值之间有空格。
-v
显示更详细的信息。就是说多进程的进程信息会为每个进程显示详细的信息。
-V
显示 numastat 版本信息。
-z
省略表格显示的信息中数值为 0 的行和列。注：有些接近 0 的值都四舍五入为 0 以方便显示，这
些数值不会在显示的输出结果中省略。
4.1.4. NUMA 亲亲和和性性管管理理守守护护进进程程（（numad））
numad 是一个自动 NUMA 亲和性管理守护进程，它监控系统中的 NUMA 拓扑以及资源使用以便动态提高
NUMA 资源分配和管理（以及系统性能）。
根据系统负载，numad 可对基准性能有 50% 的提高。要达到此性能优势，numad 会周期性访问 /proc
文件系统中的信息以便监控每个节点中的可用系统资源。该守护进程然后会尝试在有足够内存和 CPU 资源
的 NUMA 节点中放置大量进程已优化 NUMA 性能。目前进程管理阈为至少是一个 CPU 的 50%，且至少有
300 MB 内存。numad 会尝试维护资源使用水平，并在需要时通过在 NUMA 节点间移动进程平衡分配。
numad 还提供预布置建议服务，您可以通过各种任务管理系统进行查询以便提供 CPU 起始捆绑以及进程内
存资源的支持。这个预布置建议服务无论系统中是否运行 numad 都可以使用。有关为预布置建议使用 -w
选项的详情请参考 man page：man numad。
4.1.4.1. numad 的的优优点点
numad 主要可让长期运行消耗大量资源的系统受益，特别是当这些进程是包含在总系统资源子集中时尤为
突出。
numad 还可以让消耗相当于多个 NUMA 节点资源的程序受益，但 numad 提供的优势可被由于系统增长而
消耗的资源比例抵消。
numad 不太可能在进程只运行几分钟或者不会消耗很多资源时改进性能。有连续不可预测内存访问的系
30
第 4 章 CPU
统，比如大型内存中的数据库也不大可能从 numad 使用中受益。
4.1.4.2. 操操作作模模式式
注注意意
内核内存审核统计数据之间可能会在大规模整合后产生冲突。如果是这样则可能会在 KSM 数据库处
整合大量内存时让 numad 困惑。将来的 KSM 守护进程版本可能会更好地识别 NUMA。但目前，如
果您的系统有大量剩余内存，则可能需要您关闭并禁用 KSM 守护进程方可获得较高的性能。
numad 有两种使用方法：
作为服务使用
作为可执行文件使用
4.1.4.2.1. 将将 numad 作作为为服服务务使使用用
在 numad 服务运行时，它将会尝试根据其负载动态调节系统。
要启动该服务，请运行：
# service numad start
要让该服务在重启后仍保留，请运行：
# chkconfig numad on
4.1.4.2.2. 将将 numad 作作为为可可执执行行文文件件使使用用
要将 numad 作为可执行文件使用，请运行：
# numad
numad 将运行直到将其停止。在它运行时，其活动将被记录到 /var/log/numad.log 文件中。
要将 numad 限制为管理具体进程，请使用以下选项启动它。
# numad -S 0 -p pid
-p pid
在明确包含列表中添加指定的 pid。numad 进程将管理这个指定的进程直到达到其重要阈值。
-S mode
-S 参数指定扫描的进程类型。如示将其设定为 0 则将 numad 管理明确规定到所包含的进程。
要停止 numad，请运行：
# numad -i 0
停止 numad 不会删除它对改进 NUMA 亲和性所做的更改。如果系统使用大量更改，再次运行 numad 将调
整清河性以便在新条件下提高性能。
31
红帽企业版 Linux 6 性能调节指南
有关 numad 可用选项的详情请参考 numad man page：man numad。
4.2. CPU 调调度度
调度程序负责保证系统中的 CPU 处于忙碌状态。Linux 调度程序采用调度策略，它可以决定合适以及在具体
CPU 核中线程运行的时间。
调度策略有两个主要分类：
1. 实时策略
SCHED_FIFO
SCHED_RR
2. 一般策略
SCHED_OTHER
SCHED_BATCH
SCHED_IDLE
4.2.1. 实实时时调调度度策策略略
首先调度实时线程，所有实时线程调度完成后会调度一般线程。
实时策略用于必须无间断完成的关键时间任务。
SCHED_FIFO
这个策略也称作静态优先调度，因为它为每个线程规定固定的优先权（在 1 到 99 之间）。该调度
程序根据优先权顺序扫描 SCHED_FIFO 线程列表，并调度准备好运行的最高优先权线程。这个线
程会运行到它阻断、推出或者被更高的线程抢占准备运行的时候。
即使是最低优先权的实时线程也会比非实时策略线程提前被调度。如果只有一个实时线程，则
SCHED_FIFO 优先权值就无所谓了。
SCHED_RR
SCHED_FIFO 策略的轮循变体。也会为 SCHED_RR 线程提供 1-99 之间的固定优先权。但有相同
优先权的线程使用特定仲裁或者时间片以轮循方式进行调度。sched_rr_get_interval(2) 系
统调用所有时间片返回的数值，但用户无法设定时间片持续时间。这个策略在您需要以相同的优先
权运行多个线程是很有帮助。
有关实时调度策略的规定的语义详情请参考系统界面 — 实时中的《IEEE 1003.1 POSIX 标准》，地址为
http://pubs.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_08.html。
定义线程优先权的最佳实践是从低开始，并只在识别了合法延迟时才增加优先权。实时线程不象一般线程那
样是时间片。SCHED_FIFO 线程只有在他们阻断、退出或者由更高优先权线程占先时才停止。因此不建议
将优先权设定为 99。因为这样会将您的进程放到与迁移和 watchdog 线程相同的优先权等级。如果这些线程
因为您的线程进入计算池而被阻断，则他们将无法运行。单处理机系统会在这种情况下平均分配锁定。
在 Linux 内核中，SCHED_FIFO 策略包括一个带宽封顶机制。这样可以保护实时应用程序程序员不会受可
能独占 CPU 的任务影响。这个机制可通过 /proc 文件系统参数进行调整：
/proc/sys/kernel/sched_rt_period_us
以毫秒为单位定义视为 100% CPU 带宽的时间段（‘us'是明文中与 'µs' 最接近的表示）。默认值为
32
第 4 章 CPU
1000000µs 或者 1 秒。
/proc/sys/kernel/sched_rt_runtime_us
以毫秒为单位定义用于运行实时线程的时间段（‘us'是明文中与 'µs' 最接近的表示）。默认值为
950000µs 或者 0.95 秒。
4.2.2. 一一般般调调度度策策略略
有三个一般调度策略：SCHED_OTHER、SCHED_BATCH 和 SCHED_IDLE。但 SCHED_BATCH 和
SCHED_IDLE 策略主要用于低优先权任务，因此性能调整指南对其不多做论述。
SCHED_OTHER 或或者者 SCHED_NORMAL
默认调度策略。该策略使用完全公平调度程序（CFS）提供对所有使用此策略线程的公平访问时间
段。CFS 建立了动态优先权列表，部分是根据每个进程线程的 niceness 值。（有关此参数以及
/proc 文件系统的详情请参考《部署指南》。）这样可为用户提供一些间接控制进程优先权的权
利，但这个动态优先权列表只能由 CFS 直接更改。
4.2.3. 策策略略选选择择
为程序线程选择正确的调度程序策略不总是那么直截了当的任务。通常应在关键时间或者需要迅速调度且不
能延长运行时间的重要任务中使用实时策略。一般策略通常可已产生比实时策略好的数据流量结果，因为它
们让调度进程更有效地运行（即他们不需要经常重新调度占先的进程。
如果您要管理大量进程，且担心数据流量（每秒网络数据包，写入磁盘等等），那么请使用
SCHED_OTHER，并让系统为您管理 CPU 使用。
如果您担心事件响应时间（延迟），则请使用 SCHED_FIFO。如果您只有少量线程，则可以考虑隔离 CPU
插槽，并将线程移动到那个插槽的核中以便没有其他线程与之竞争。
4.3. 中中断断和和 IRQ 调调节节
中断请求（IRQ）是用于服务的请求，在硬件层发出。可使用专用硬件线路或者跨硬件总线的信息数据包
（消息信号中断，MSI）发出中断。
启用中断后，接收 IRQ 后会提示切换到中断上下文。内核中断调度代码会搜索 IRQ 号码机器关联的注册中
断服务路由（ISR）列表，并按顺序调用 ISR。ISR 会确认中断并忽略来自同一 IRQ 的多余中断，然后在延
迟的句柄中排队完成中断处理，并忽略以后的中断来结束 ISR。
/proc/interrupts 文件列出每个 I/O 设备中每个 CPU 的中断数，每个 CPU 核处理的中断数，中断类
型，以及用逗号分开的注册为接收中断的驱动程序列表。（详情请参考 proc(5) man page：man 5
proc）
IRQ 有一个关联的“类似”属性 smp_affinity，该参数可以定义允许为 IRQ 执行 ISR 的 CPU 核。这个属性