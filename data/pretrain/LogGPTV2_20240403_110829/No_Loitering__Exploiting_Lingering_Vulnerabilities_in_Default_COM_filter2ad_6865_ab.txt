tains the CLSID of every COM object that should never
be loaded and interacted with from the IE scripting en-
gines. Microsoft Ofﬁce will prompt the user if the con-
tent being loaded attempts to instantiate a control that
is listed in the IE killbit list. The user can accept the
prompt and allow the Ofﬁce application to load the un-
trusted content, but the default is to disable the control.
Figure 2 shows an attempt to load a killbit-listed COM
object and the corresponding interception of that request
by the operating system.
Blacklisting can be effective at stopping an applica-
tion from loading a known bad object, but has no impact
on the instantiation of objects with an unknown security
level. Additionally, it is only effective for applications
that choose to implement the policy; it is not enforced
across the system as a whole.
3.3 Complexity of COM Management
One may think that as vulnerabilities are disclosed in
COM objects, the simple answer would be to remove
the object from the Windows registry, or even delete the
library containing the object. This approach is not al-
ways possible as it relates to COM for several reasons.
First, many libraries containing COM objects store more
than one object. While there may be one undesirable
object in the library, it must remain on the system to
support the other objects it contains. Second, many vul-
nerable COM objects are critical to the operation of re-
quired applications and the operating system itself. It is
very common for a COM object to misbehave in appli-
cations including Internet Explorer or Word, but perform
entirely as expected in other applications. Since there is
no system-wide mechanism to determine which applica-
tions can load which COM objects, the object must re-
main registered, and theoretically available to all. Third,
COM is massive. As was previously mentioned, there
can be tens of thousands of COM objects installed on an
average Windows machine. Not surprisingly, the current
killbit list is approximately 600 CLSIDs. It is therefore
extremely difﬁcult for any user, regardless of skill level,
to maintain these lists properly for each application that
they run.
4 Vulnerability Characterization
With an understanding of the COM architecture, we
now describe the extent to which a class of problems
actually extend throughout the all versions of Windows
operating system.
4.1 Architectural Weakness
Once a COM object is installed on a system, it is
available for instantiation by any application. There is
no central policy governing which applications can load
which COM objects. As vulnerabilities are disclosed
in individual COM objects, there is nothing preventing
an unknowing application from loading that potentially
harmful control. Given that vulnerabilities in COM ob-
jects are most often left unpatched, any application that
loads COM objects is a potential target an adversary.
Speciﬁcally, an adversary can force an application to
load one of the previously installed and known ﬂawed
controls allowing for exploitation. This allows adver-
saries to take advantage of controls that already exist on
a system rather than attempting to trick their victim into
installing an intentionally malicious object. Because
many of the vulnerabilities that have gone unpatched al-
low for the execution of arbitrary code, an adversary can
exploit these loitering ﬂaws as an initial infection vec-
tor to install malware. Once they have installed their
malware, they can gain complete control over the sys-
tem. Given this exposure, many applications have im-
plemented their own discrete policies dictating which
controls they deem to be safe or unsafe. The Internet
Explorer killbit list is an example of one such policy.
These policies are only useful for determining which
COM objects will be directly loaded by an application.
They cannot guarantee or enforce the behavior of an ob-
ject once it is instantiated. An application must there-
fore trust the behavior of a COM object once it is loaded.
If that COM object then loads other COM objects, this
trust is transitively extended. As shown in Figure 3,
this trust transitivity exposes a critical security weakness
with regard to COM. If an application loads a COM ob-
ject that is within its security policy, it trusts that object
to only load other objects that are also in the security
Figure 3. Transitive trust between COM
Objects allows normally unauthorized ob-
jects to be loaded and executed.
policy. There is no programmatic way for the applica-
tion to ensure that an object it loads extends its security
policy to other objects. It is therefore theoretically pos-
sible to exploit this transitive trust relationship in any
application that loads COM objects.
To complete an attack exploiting this transitive trust,
an adversary requires the following:
1. An application that will
controlled content.
render
adversary-
2. An application that will load COM objects.
3. A COM object that will in turn load other COM
objects.
4. A vulnerable object that can be exploited.
Each of these requirements is easily achievable under
normal circumstances with an average Windows instal-
lation. The following subsections address them in order.
4.1.1 Supplying Adversary-Controlled Content
The ﬁrst requirement for accomplishing this sort of at-
tack is that an adversary must persuade a target to render
content under their control. This is easily accomplished
through applications like Internet Explorer and the Mi-
crosoft Ofﬁce suite. End users can be tricked into view-
ing malicious web pages through a number of means in-
cluding phishing, cross-site scripting, and content injec-
tion. Additionally, users can be emailed Ofﬁce and other
documents or the browser can be used to force the ren-
dering of Ofﬁce content through the use of ActiveX.
Browser Execution EnvironmentAuthorized PluginUnauthorized PluginXAuthorized PluginAuthorized Plugin Loads Other PluginsKillbit Protected4.1.2 Loading Adversary-Controlled COM Objects
COM objects can be loaded based on content in Inter-
net Explorer, the Microsoft Ofﬁce suite, as well as any
other applications and services commonly installed on
Windows that make use of this infrastructure including
Flash and Adobe Reader. To force an application such
as Internet Explorer to load a COM object, an adversary
can supply the CLSID parameter of an  tag.
In the case of the Microsoft Ofﬁce suite, COM objects
can be directly embedded in documents using the GUI.
4.1.3 Transitive Trust Amongst COM Objects
The third requirement for the attack is to load a COM
object that will in turn load other objects. While this
may seem rare, it is actually quite prevalent due to
a feature of Microsoft Visual Studio. Because of the
complexity of developing COM objects, Microsoft has
included with Visual Studio a set of C++ templates
called the Active Template Library (ATL). The ATL pro-
vides methods for the saving and loading of persistence
streams (covered in Section 3.1) so a developer does not
have to understand the low-level details. To interact with
these methods the developer simply provides a property
map, a template deﬁning the order and type of data that
is stored in the persistence stream, for the object ﬁelds
they intend to save stream. This way, as the control reads
the persistence stream it understands to which properties
it should apply the data.
One weakness of property maps is the ability to de-
ﬁne loose types. These are type speciﬁers that do not
directly map to one of the deﬁned types. In other words,
the property map can deﬁne that data exists in the per-
sistence stream, but the COM object should examine the
data itself to determine its type. This is the functional
equivalent of a void pointer in the C programming lan-
guage.
stream,
By using the ATL, a COM developer can now easily
create a COM object which implements persistence
without understanding the underlying required methods
or the COM-speciﬁc data types with which they are
dealing. The critical issue then becomes the handling
of loose-typed variants by the ATL-provided methods
for loading a persistence stream. To read a persis-
the IPersistStream::Load()
tence
provided
method
the
method
CComVariant::ReadFromStream().
code
As
for
source
be
in Ap-
CComVariant::ReadFromStream()
pendix A,
that
if encountered in the stream, will be passed to
OleLoadFromStream(). An approximation of the
source of OleLoadFromStream() obtained through
reverse engineering the binaries is provided in Appendix
the ATL will
two variant
types,
there
exist
seen
call
can
in
in
the
B. Here we can see that a CLSID is read from the data
stream and passed to CoCreateInstance(). The
remainder of the data stream is then passed to the
IPersistStream ::Load() method exposed by
the object that has just been loaded.
to
that
note
is
a
important
security policy consulted before
time
It
calling
was
OleLoadFromStream().
This code distributed
with the ATL can clearly be used to bypass the security
policy of the parent application.
no
at
4.1.4 Finding a Known Flawed Control
The ﬁnal requirement for this attack is to be able to
load a vulnerable control. Given that vulnerabilities in
COM objects are generally left unpatched, several hun-
dred known ﬂawed controls are resident on the average
Windows installation. For example, on the system used
to write this paper, the killbit list for Internet Explorer
is over 600 entries in size. Each of those entries cor-
responds to known ﬂawed control that is likely still un-
patched.
4.2 Proof of Concept Attack
To demonstrate the severity of this attack, and the
ease with which it can be accomplished on an aver-
age Windows platform, a working example was created
leveraging well-known applications and commonly in-
stalled COM objects. The attack created for this proof of
concept loads a trusted COM object in Microsoft Word,
which then loads a known ﬂawed control that is still resi-
dent on most installations of Windows. The speciﬁc vul-
nerability used in this example is a known ﬂawed control
in all Windows XP installations and results in the exe-
cution of arbitrary code when triggered. We note that
we tested different vulnerable controls on systems run-
ning Windows Vista and Windows 7 and were similarly
able to compromise those systems. In this example, the
COM object executes shellcode causing Word to listen
on a TCP socket. Upon connection to this socket, the
adversary is presented with a command prompt.
While this section only describes an attack against
Microsoft Word, the same attack was proven to be suc-
cessful against several other COM containers including
Microsoft WordPad, Microsoft Excel, Microsoft Power-
point and Adobe Reader.
To explain how the proof of concept attack was cre-
ated, the following describes how each of the require-
ments in Section 4.1 was met.
1. Microsoft Word was chosen as the parent appli-
cation for our proof of concept attack. Microsoft
Word documents can be easily emailed to users.
Figure 4. The successful exploitation of a COM Object in Microsoft Word, demonstrated by
having Word open a socket on port 4444.
Additionally, the browser can be used as an inter-
mediary in this attack by providing a link to a .doc
ﬁle or using ActiveX to force Word to open a doc-
ument of the adversary’s choosing.
2. Microsoft Word was chosen for the ease with which
COM objects can be embedded in documents. Ob-
ject insertion is something that is done regularly in
the course of authoring a document. This typically
comes in the form of inserting images, tables, etc.
In many cases these operations are actually embed-
ding COM objects. This same process can be used
to insert objects of many different types as long as
they conform to the Microsoft Word security pol-
icy.
3. The Microsoft Date and Time Picker control was
chosen because it provides the functionality to load
subsequent COM objects by providing a CLSID in
a persistence stream.
4. The ﬁnal requirement for constructing the attack is
to have the COM object loaded in the previous step
then load a known vulnerable control. We selected
Microsoft’s Helper Object for Java, which contains
a long standing, unpatched, exploitable vulnerabil-
ity reachable by instantiating the control outside the
Microsoft Java Virtual Machine.
To summarize, we create a working exploit by craft-
ing a Microsoft Word document containing the embed-
ded benign Microsoft Date and Time Picker control.
That COM object in turn loads a known ﬂawed control,
thus circumventing Word’s COM security policy. Once
the ﬂawed control is loaded, it triggers the vulnerability,
resulting in the execution of arbitrary code. This attack,
if executed in the real world, would easily enable an ad-
versary to take full control of a victim’s workstation to
install malware or use the system for other arbitrarily
malicious purposes.
The known vulnerable COM object loaded in this at-
tack is listed in the Internet Explorer killbit list. As such,
it is the policy of Microsoft Word to not load this control.
Had the attack simply tried to embed the control directly
in the Word document, the security policy would have
been effective, and the user would have been presented
with the dialog shown in Figure 2. While the effective-
ness of such warning messages is debatable, our attack
allows for the vulnerable control to be loaded without
providing the user with any indication that something is
amiss. As shown in Figure 4, by using a trusted COM
object to load the known ﬂawed control, the security pol-
icy is bypassed, and the winword.exe process is now lis-
tening on TCP port 4444. This is demonstrable evidence
that Microsoft Word has been compromised. In our spe-
ciﬁc exploit, upon connecting to the socket, the adver-
sary is presented with a command prompt. This allows
for the execution of any command in the security con-
text of the user viewing the Word document. In a real
attack scenario, an adversary would generally then go
on to install their malware – taking complete control of
the system.
4.3 Breadth of Attack
The attack described above is not unique to Microsoft
Word, the Microsoft Date and Time Picker, and the
Helper Object for Java. On the average Windows-based
system, there are a large number of applications that
would meet the ﬁrst and second criteria for exploitation.
In our testing, identiﬁed dozens of COM objects that ex-
ist on an average system that were either compiled with
the ATL or expose functionally equivalent capability.
As previously mentioned, the Windows XP-based sys-
tem used to write this paper has several hundred known
ﬂawed controls still installed. This system is not unique.
Given these numbers, the permutations of applica-
tion, trusted COM object, and untrusted COM object
quickly become unmanageably large. It is therefore un-