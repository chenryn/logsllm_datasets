 18
 21
Total number of servers
 20
 22
 23
 24
e
l
i
b
a
l
i
a
v
a
t
o
n
a
a
d
t
f
o
y
t
i
l
i
b
a
b
o
r
P
 1
 1e-005
 1e-010
 1e-015
 1e-020
 1e-025
 1e-030
 1e-035
 1e-040
 6
 7
Detection 0.9
Detection 0.99
Detection 0.999
Detection 0.9999
Detection 0.99999
Detection 0.999999
 9
 8
Number of primary servers
 10
 11
 12
 13
Figure 4: Probability that HAIL is unavailable for 8 primary servers (left) and 20 total servers (right) for b = 3 faults per epoch.
HAIL Encoding: 8 Primary Servers
HAIL Encoding: 20 Total Servers
)
c
e
s
(
e
m
T
i
 450
 400
 350
 300
 250
 200
 150
 100
 50
 0
Other
MAC
Server PRP
Server PRF
Dispersal PRF
Server Encoding
Dispersal Encoding
HAIL (15,8)
HAIL (17,8)
HAIL (19,8)
HAIL (21,8)
)
c
e
s
(
e
m
T
i
 500
 450
 400
 350
 300
 250
 200
 150
 100
 50
 0
Other
MAC
Server PRP
Server PRF
Dispersal PRF
Server Encoding
Dispersal Encoding
HAIL (20,6)
HAIL (20,8)
HAIL (20,10)
HAIL (20,12)
Figure 5: Encoding time for HAIL: on the left, 8 primary servers; on the right, 20 total servers.
bits. In order to obtain a UHF on 128 bits, we combine four blocks
of size 32 bits, construct a polynomial of degree 4(cid:4), and evaluate
that polynomial four times at different random points to obtain four
UHF outputs of size 32 bits.
To maximize the size of ﬁles that can be encoded efﬁciently us-
ing our algorithm, the ﬁle is ﬁrst dispersed across the primary and
secondary servers before application of the server code. Applying
the server code involves a logical permutation of the ﬁle fragment
using a PRP and can be done much more efﬁciently if each server’s
fragment ﬁts into main memory. For the server code, we use a (35,
32, 3) Cauchy Reed-Solomon code over GF [232] that adds 9% re-
dundancy to data stored on each server.
Disk access is expensive and comprises 50% - 60% of our encod-
ing time, depending on the parameters. In the graphs we present,
I/O time has been removed to make the other encoding functions
more visible. Figure 5 shows the encoding cost of HAIL for a 1GB
ﬁle divided into several components: Jerasure dispersal code appli-
cation, Jerasure server code application, the application of a PRF to
the parity blocks both in the dispersal and server encoding, the time
to logically rearrange the fragment on a server before application
of the server code using a PRP, the computation of a MAC over the
entire ﬁle, and additional data manipulations necessary to support
the encoding functions. Reﬂecting parameter choices from Figure
4, on the left graph in Figure 5, we present the encoding cost as the
number of primary servers remains constant at 8 and the total num-
ber of servers varies from 15 to 21. On the right graph in Figure
5 we keep the total number of servers constant at 20 and vary the
number of primary servers between 6 and 12.
We get an encoding throughput between 2MB and 4MB per sec-
ond, not including the disk I/O time. As noticed from Figure 5,
time spent performing dispersal code application using Jerasure is
the dominant factor in ﬁle encoding speed (at least 50% of the total
encoding cost, excluding I/O). For instance, for the (20,12) disper-
sal code, HAIL encoding throughput is 4MB per second, compared
to 7MB per second given by the dispersal code encoding. For the
(21,8) dispersal code, Jerasure encoding is 5MB per second, while
HAIL achieves an encoding throughput of 2.5MB per second.
As the number of secondary servers increases, the dispersal cost
increases linearly, both in terms of time spent in Jerasure, as well as
the time necessary to compute the required PRF values. The time
spent to perform server encoding, including Jerasure application
and PRP and PRF computation, increases linearly with the total
amount of data to be encoded (the size of the dispersed ﬁle), which
depends on both the number of primary and secondary servers.
9. CONCLUSION
We have proposed HAIL, a high-availability and integrity layer
that extends the basic principles of RAID into the adversarial set-
ting of the Cloud. HAIL is a remote-ﬁle integrity checking protocol
that offers efﬁciency, security, and modeling improvements over
straightforward multi-server application of POR protocols and over
previously proposed, distributed ﬁle-availability proposals. Through
a careful interleaving of different types of error-correcting layers,
and inspired by proactive cryptographic models, HAIL ensures ﬁle
availability against a strong, mobile adversary.
197There are a number of interesting HAIL variants to explore in
follow-up work. The protocols we have described above for HAIL
only provide assurance for static ﬁles. We are investigating in cur-
rent work design of similar protocols that accommodate ﬁle up-
dates. We believe that the HAIL techniques we have introduced in
this paper help pave the way for valuable approaches to distributed
ﬁle system availability.
Acknowledgements
We thank James Hendricks, Burt Kaliski and Ron Rivest for care-
fully reading the paper and providing detailed comments and sug-
gestions. We also thank Yevgeniy Dodis and Daniel Wichs for
many insights on protocol design.
10. REFERENCES
[1] Amazon.com. Amazon simple storage service (Amazon S3),
2009. Referenced 2009 at aws.amazon.com/s3.
[2] G. Ateniese, R. Burns, R. Curtmola, J. Herring, L. Kissner,
Z. Peterson, and D. Song. Provable data possession at
untrusted stores. In 14th ACM CCS, pages 598–609, 2007.
[3] G. Ateniese, R. Di Pietro, L. V. Mancini, and G. Tsudik.
Scalable and efﬁcient provable data possession, 2008. IACR
ePrint manuscript 2008/114.
[4] J. Black, S. Halevi, H. Krawczyk, T. Krovetz, and
P. Rogaway. UMAC: Fast and secure message authentication.
In CRYPTO, volume 1666 of LNCS, pages 216–233, 1999.
[5] K. D. Bowers, A. Juels, and A Oprea. HAIL: A
high-availability and integrity layer for cloud storage, 2008.
IACR ePrint manuscript 2008/489.
[6] K. D. Bowers, A. Juels, and A Oprea. Proofs of
retrievability: Theory and implementation, 2008. IACR
ePrint manuscript 2008/175.
[7] C. Cachin, K. Kursawe, A. Lysyanskaya, and R. Strobl.
Asynchronous veriﬁable secret sharing and proactive
cryptosystems. In 9th ACM CCS, pages 88–97, 2002.
[8] C. Cachin and S. Tessaro. Asynchronous veriﬁable
information dispersal. In 24th IEEE SRDS, pages 191–202,
2005.
[9] L. Carter and M. Wegman. Universal hash functions. Journal
of Computer and System Sciences, 18(3), 1979.
[10] R. Curtmola, O. Khan, and R. Burns. Robust remote data
checking. In 4th ACM StorageSS, pages 63–68, 2008.
[11] R. Curtmola, O. Khan, R. Burns, and G. Ateniese. MR-PDP:
Multiple-replica provable data possession. In 28th IEEE
ICDCS, pages 411–420, 2008.
[12] Y. Dodis, S. Vadhan, and D. Wichs. Proofs of retrievability
via hardness ampliﬁcation. In 6th IACR TCC, volume 5444
of LNCS, pages 109–127, 2009.
[13] C. Erway, A. Kupcu, C. Papamanthou, and R. Tamassia.
Dynamic provable data possession. In 16th ACM CCS, 2009.
To appear.
[14] M. Etzel, S. Patel, and Z. Ramzan. SQUARE HASH: Fast
message authentication via optimized universal hash
functions. In CRYPTO, volume 1666 of LNCS, pages
234–251, 1999.
[15] D.L.G. Filho and P.S.L.M. Barreto. Demonstrating data
possession and uncheatable data transfer, 2006. IACR
eArchive 2006/150.
[16] J. A. Garay, R. Gennaro, C. Jutla, and T. Rabin. Secure
distributed storage and retrieval. Theoretical Computer
Science, 243(1-2):363–389, 2000.
[17] G. R. Goodson, J. J. Wylie, G. R. Ganger, and M. K. Reiter.
Efﬁcient byzantine-tolerant erasure-coded storage. In 34th
IEEE DSN, pages 135–144, 2004.
[18] P. Gopalan, R.J. Lipton, and Y.Z. Ding. Error correction
against computationally bounded adversaries, 2004.
Manuscript.
[19] S. Halevi and H. Krawczyk. MMH: Software message
authentication in the Gbit/second rates. In Fast Software
Encryption, volume 1267 of LNCS, pages 172–189, 1997.
[20] J. Hendricks, G. R. Ganger, and M. K. Reiter. Verifying
distributed erasure-coded data. In 26th ACM PODC, pages
139–146, 2007.
[21] A. Herzberg, M. Jakobsson, H. Krawczyk, and M. Yung.
Proactive public key and signature systems. In 4th ACM
CCS, pages 100–110, 1997.
[22] A. Herzberg, S. Jarecki, H. Krawczyk, and M. Yung.
Proactive secret sharing, or: How to cope with perpetual
leakage. In CRYPTO, volume 1963 of LNCS, pages 339–352,
1995.
[23] A. Juels and B. Kaliski. PORs: Proofs of retrievability for
large ﬁles. In 14th ACM CCS, pages 584–597, 2007.
[24] H. Krawczyk. LFSR-based hashing and authentication. In
CRYPTO, volume 839 of LNCS, pages 129–139, 1994.
[25] M. Lillibridge, S. Elnikety, A. Birrell, M. Burrows, and
M. Isard. A cooperative Internet backup scheme. In USENIX
Annual Technical Conference, pages 29–41, 2003.
[26] S. Micali, C. Peikert, M. Sudan, and D. Wilson. Optimal
error correction against computationally bounded noise. In
TCC, pages 1–16.
[27] M. Naor and G. N. Rothblum. The complexity of online
memory checking. In 46th IEEE FOCS, pages 573–584,
2005.
[28] W. Nevelsteen and B. Preneel. Software performance of
universal hash functions. In EUROCRYPT, volume 1233 of
LNCS, pages 24–41, 1997.
[29] J. S. Plank, J. Luo, C. D. Schuman, L. Xu, and Z. W.
O’Hearn. A performance evaluation and examination of
open-source erasure coding libraries for storage. In 7th
USENIX FAST, pages 253–265, 2009.
[30] P. Rogaway. Bucket hashing and its application to fast
message authentication. In CRYPTO, volume 963 of LNCS,
pages 29–42, 1995.
[31] T. J. E. Schwarz and E. L. Miller. Store, forget, and check:
Using algebraic signatures to check remotely administered
storage. In 26th IEEE ICDCS, page 12, 2006.
[32] H. Shacham and B. Waters. Compact proofs of retrievability.
In ASIACRYPT, volume 5350 of LNCS, pages 90–107, 2008.
[33] M. A. Shah, M. Baker, J. C. Mogul, and R. Swaminathan.
Auditing to keep online storage services honest. In 11th
USENIX HotOS, pages 1–6, 2007.
[34] V. Shoup. On fast and provably secure message
authentication based on universal hashing. In CRYPTO,
volume 1109 of LNCS, pages 313–328, 1996.
[35] M. Wegman and L. Carter. New hash functions and their use
in authentication and set equality. Journal of Computer and
System Sciencies, 22(3):265–279, 1981.
198