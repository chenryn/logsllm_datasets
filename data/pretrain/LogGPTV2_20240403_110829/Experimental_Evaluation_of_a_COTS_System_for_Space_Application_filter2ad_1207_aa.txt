title:Experimental Evaluation of a COTS System for Space Application
author:Henrique Madeira and
Raphael R. Some and
Francisco Moreira and
Diamantino Costa and
David A. Rennels
Experimental evaluation of a COTS system for space applications
Henrique Madeira
Univ. of Coimbra
Pasadena, CA, USA
Coimbra, Portugal
PI:EMAIL PI:EMAIL
Jet Propulsion Laboratory
Raphael R.Some
Abstract
This paper evaluates the impact of transient errors in the
operating system of a COTS-based system (CETIA board
with two PowerPC 750 processors running LynxOS) and
quantifies their effects at both the OS and at
the
application level. The study has been conducted using a
Software-Implemented Fault Injection tool (Xception)
and both realistic programs and synthetic workloads (to
focus on specific OS features) have been used. The
results provide a comprehensive picture of the impact of
faults on LynxOS key features (process scheduling and
the most
frequent system calls), data integrity, error
propagation, application termination, and correctness of
application results.
1.
Introduction
The use of Commercial Off-The-Shelf
(COTS)
components and COTS-based systems in space missions
is particularly attractive, as the ratio of performance to
power consumption of commercial components can be an
order of magnitude greater than that of radiation hardened
components, and the price differential
is even higher.
However, COTS are not usually designed for the stringent
requirements of space applications. This means that the
actual use of COTS components in space missions must
be preceded by careful study of the impact of faults such
as the ones caused by space radiation (e.g., Single Event
Upsets (SEU)) in order to identify weak points that should
be strengthened with specific fault tolerance techniques.
for
(SCC)
is used for
One proposal of using COTS-based systems in space
applications is to use these systems for scientific data
processing and not
spacecraft control. A good
example of this approach is the Remote Exploration and
Experimentation (REE) Project
Jet
Propulsion Laboratory [1]. In this project, an external,
protected
radiation-hardened
Spacecraft Control Computer
the
overall spacecraft control, while scientific computations
are performed by COTS-based systems. In this scenario,
the use of Software Implemented Fault Tolerance (SIFT)
techniques
to tolerate
transient faults seems an interesting alternative [2].
in the COTS-based systems
from NASA’s
independently
and
This paper evaluates the impact of transient errors in a
CETIA board with two PowerPC 750 processors running
the LynxOS and quantifies their effects at both the OS
and at the application level. The emphasis of the work is
on the system behavior when errors are induced into the
F. Moreira, D. Costa
David Rennels
Critical Software Univ. Calif. Los Angeles
Coimbra, Portugal Los Angeles, CA, USA
PI:EMAIL
PI:EMAIL
operating system – looking at application termination,
data integrity, error propagation, and correctness of
application results. A fault injection tool [3] has been used
to emulate the effects of SEU through the insertion of bit-
flip errors in processor structures and memory whilst the
processor is executing OS or application code.
The structure of the paper is as follows:
the next
section presents the experimental setup used in this study.
Section 3 presents the different experiments and discusses
the results and Section 4 summarizes the contributions
and concludes the paper.
2. Experimental setup
2.1. Target system and Xception fault injector
Figure 1 shows the test bed layout used in these
experiments. The target system is a COTS CETIA board
with two PowerPC 750 processors and 128 Mbytes of
memory, running Lynx operating system version 3.0.1.
The host is a Sun UltraSparc-II with SunOS 5.5.1.
Host Computer
Target System
TCP/IP or
Dedicated link
Reset capability
Experiment Definition
Experiment Control
Result Collection and Archiving
Fault Injection
Built-in Monitoring
Results
Fault
Xception
Database
Result Analysis
Statistical Data
Figure 1 – Test bed layout
processor
architecture
The injection tool
is the Xception PowerPC705/
LynxOS, which is a port of the Xception tool [4] to the
PowerPC705
and LynxOS.
Xception uses the debugging and performance monitoring
features available in the processors to inject faults by
software and to monitor the activation of the faults and
their impact on the target system behavior. The target
applications are not modified for the injection of faults
and the applications are executed at full speed. Faults
injected by Xception can affect any process running on
the target system (including the kernel code) and can be
injected in target locations such as processor registers,
integer unit, internal processor buses, floating point unit,
cache, and memory. In the present experiments, faults
consist of single bit-flips injected in all possible units that
can be reach by Xception.
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:24:52 UTC from IEEE Xplore.  Restrictions apply. 
The definition of
the faults parameters,
injection
process, and collection of results is controlled by the host
system. Figure 2 shows the key steps of the fault injection
process. The target system is restarted after each injection
to assure independent experiments. Faults are injected
after the workload start and, depending on the type of
trigger, faults are uniformly distributed over time or are
injected during the execution of specific portions of code.
The collection of results (the actual location in the code
where the fault was injected, the processor context at that
moment, etc, which are stored in a small log in the target)
is done after resetting the system to assure that the system
is stable and can send the results to the host.
Average
execution time +
tolerance
Collect
results from
previous fault
Reset
target
Start
Injection
workload
workload
Figure 2 - Typical injection run profile
Reset
target
Start
Time
Injection
2.2. Workload
2.2.1. Synthetic workload
As one major goal of this study is the evaluation of the
impact of transient faults on key features of LynxOS, we
decided to define a synthetic workload in order
to
exercise core functions of the operating system such as
the ones related to processes (schedule, create, kill,
process wait), memory (attribute memory to a process,
free memory), and input/output (open, read, write). The
synthetic workload executes a given number of iterations
and in each iteration of the cycle it starts by doing some
buffer and matrix manipulations, to use memory resources
that will be checked for integrity later on, and then
executes a number of system calls related to the core OS
functions mention above. After each step, the program
stores a footprint in a file. For example, after each system
call
the program stores the return code; after each
checksum calculation (performed over all data structures
and application code), it stores the value of the checksum,
etc. At the end of each cycle interaction the program
executes additional tests and at the end of the program the
final result stored in the file is compared with a gold
version to check if any of the individual step outputs were
wrong. The amount of memory allocated for buffer
manipulations is 1 Mbyte and the matrices manipulations
are performed on three matrix of 250 x 250 integers
define as static variables.
Three instances of this synthetic program are used to
test the effect of the kernel error on other processes in a
multiprogramming environment. The first one (P1) is the
one that is going to be used to inject faults. That is, faults
are injected (in processor register, integer unit, etc) during
the execution of P1 code or during the execution of kernel
code. The processes P2 and P3 are used to evaluate error
propagation from P1 to P2 or P3 and the operating system
response after a fault. Figure 3 illustrates this scheme.
Faults in
application
Faults in
kernel
P1
P2
P3
Lynx OS 3.01
CETIA PowerPC 750 board
Figure 3 – Process configuration: synthetic workload
2.2.2. Realistic workloads
The use of realistic workloads is particularly relevant
to the evaluation of the effects of OS errors on application
termination and result correctness. We chose three
applications with different profiles
and
memory needs, use of I/O system calls), and size of the
results,
these
parameters on the impact of the faults. The workloads are:
  Gravity: Calculates the trajectory of a small mass
attracted by a bigger one, as modeled by Newton’s
Gravity Law.
to evaluate the influence of
(processor
in order
  PI: Computes the value of π (with a large number of
decimal digits) by numerically calculating the area
under the curve 4/(1+X 2).
  Matmult: Matrix multiplication program.
In our
experiments it multiplies two 400 x 400 integers and
two 400 x 400 floating-point matrices.
3. Results and analysis
In short, the different sets of experiments performed
have the following goals:
  Experiments using the Synthetic Applications:
- Evaluate the impact of faults injected while the
processor was executing OS code (section 3.1.1).
We have used a synthetic workload to be sure that
core OS functions are heavily used.
- Evaluate the impact of faults injected while the
processor was executing code of the synthetic
application process P1 and compare the effects of
application faults vs. OS faults (section 3.1.2).
- Evaluate the error propagation from OS to
application processes and from one process to the
others (section 3.1.3).
  Experiments using Realistic Applications:
- Evaluate the impact of
faults on application
termination and the correctness of the application
results (section 3.2). The use of realistic programs
and uniform faults distributions try to emulate as
close as possible the effects of SEU errors in real
applications.
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:24:52 UTC from IEEE Xplore.  Restrictions apply. 
faults in the OS and error
3.1. Impact of
confinement & propagation: experiments with
the synthetic workload
In this set of experiments we used the synthetic
workload in the scenario shown in Figure 3. For
simplicity, we call
the faults injected while P1 was
scheduled and when the processor was executing OS code
as OS faults (or kernel mode faults). Similarly, we call
the faults injected while the processor was executing P1
code as application faults (or user mode faults).
Table 1 shows the fault distribution by process. The
fault distribution by target unit was weighted by the
relative sizes of the silicon areas of the corresponding
processor structure. Some faults (23%) were injected in
key location of the memory to emulate faults in the
processor cache.
Distribution by processes
Inj. while P1 is scheduled
Inj. while executing OS code
Inj. while executing other proc.
Totals
All faults
User Mode Kernel Mode
# faults % # faults % # faults %
52%
2013
100%
233
33%
30
2276
56%
88% 975
0
10%
1%
20
100% 995
48% 1038
0% 233
67% 10
44% 1281
Table 1 – Fault injected with the synthetic workload.
OS level
Figure 4 shows the impact of the faults injected while
P1 was scheduled (2013 faults) from the point of view of
the process P1 only (i.e., disregarding the impact on the
other processes).
A general observation of the results on Figure 4 is that
a large percentage of faults had no effect, because the
state that was modified was unused or was soon-to-be