## Page 208
大话数据结构
6.8.5后序遍历算法
那么同样的，后序遍历也就很容易想到应该如何写代码了。
/*二叉树的后序遍历退归算法*/
void PostOrderTraverse（BiTree T)
if（T==NULL）
retuzn,
PostOrderTraverse（T->lchild）：/*先后序遍历左子树*/
PostOrderTraverse（T->rchild）;/弄后序遍历右子树/
printE（“c"，T->data）：/显示结点数据，可以更改为其他对结点操作*/
如图6-8-20所示，后序遍历是先递归左子树，由根结点A→B一D→H，结点H无
左孩子，再查看结点H的右孩子K，因为结点K无左右孩子，所以打印K，返回。
A
B
D
F
G
H
K
图 6-8-20
最终，后序遍历的结点的顺序就是：KHDEBIFJGCA。同学们可以自己按照刚才的
办法得出这个结果。
6.8.6推导遍历结果
有一种题目为了考查你对二叉树遍历的掌握程度，是这样出题的。已知一棵二叉
树的前序遍历序列为ABCDEF，中序遍历序列为CBAEDF，请问这棵二叉树的后序遍
历结果是多少？
对于这样的题目，如果真的完全理解了前中后序的原理，是不难的。
三种遍历都是从根结点开始，前序遍历是先打印再递归左和右。所以前序遍历序
列为ABCDEF，第一个字母是A被打印出来，就说明A是根结点的数据。再由中序遍
184
---
## Page 209
神惠9
历序列是CBAEDF，可以知道C和B是A的左子树的结点，E、D、F是A的右子树的
结点，如图6-8-21所示。
(A)
C、B
（E、D、F
图6-8-21
然后我们看前序中的C和B，它的顺序是ABCDEF，是先打印B后打印C，所以B
应该是A的左孩子，而C就只能是B的孩子，此时是左还是右孩子还不确定。再看中
序序列是CBAEDF，C是在B的前面打印，这就说明C是B的左孩子，否则就是右孩
子了，如图6-8-22所示。
(A)
B
E、D、F
图6-8-22
再看前序中的E、D、F，它的顺序是ABCDEF，那就意味着D是A结点的右孩
子，E和F是D的子孙，注意，它们中有一个不一定是孩子，还有可能是孙子的。再
来看中序序列是CBAEDF，由于E在D的左侧，而F在右侧，所以可以确定E是D
的左孩子，F是D的右孩子。因此最终得到的二叉树是图6-8-23所示。
A
C
（E
F
图6-8-23
为了避免推导中的失误，你最好在心中递归遍历，检查一下这棵树的前序和中序
遍历序列是否与题目中的相同。
已经复原了二叉树，要获得它的后序遍历结果就是易如反掌，结果是CBEFDA。
但其实，如果同学们足够熟练，不用面这棵二叉树，也可以得到后序的结果，因
185
---
## Page 210
大话数据结构
为刚才判断了A结点是根结点，那么它在后序序列中，一定是最后一个。刚才推导出
C是B的左孩子，而B是A的左孩子，那就意味着后序序列的前两位一定是CB。同
样的办法也可以得到EFD这样的后序顺序，最终就自然的得到CBEFDA这样的序列，
不用在草稿上画树状图了。
反过来，如果我们的题目是这样：二叉树的中序序列是ABCDEFG，后序序列是
BDCAFGE，求前序序列。
这次简单点，由后序的BDCAFGE，得到E是根结点，因此前序首字母是E。
于是根据中序序列分为两棵树ABCD和FG，由后序序列的BDCAFGE，知道A是
E的左孩子，前序序列目前分析为EA。
再由中序序列的ABCDEFG，知道BCD是A结点的右子孙，再由后序序列的
BDCAFGE知道C结点是A结点的右孩子，前序序列目前分析得到EAC。
中序序列ABCDEFG，得到B是C的左孩子，D是C的右孩子，所以前序序列目
前分析结果为EACBD。
由后序序列BDCAEGE，得到G是E的右孩子，于是F就是G的孩子。如果你是
在考试时做这道题目，时间就是分数、名次、学历，那么你根本不需关心F是G的左
还是右孩子，前序遍历序列的最终结果就是EACBDGF。
不过细细分析，根据中序序列ABCDEEG，是可以得出F是G的左孩子。
从这里我们也得到两个二叉树遍历的性质。
■已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。
■已知后序逾历序列和中序遍历序列，可以唯一确定一棵二叉树。
但要注意了，已知前序和后序遍历，是不能确定一棵二叉树的，原因也很简单，
比如前序序列是ABC，后序序列是CBA。我们可以确定A一定是根结点，但接下来，
我们无法知道，哪个结点是左子树，哪个是右子树。这棵树可能有如图6-8-24所示的
四种可能
A
A
(A)
B
B
?
B
?
?
C
图6-8-24
186
---
## Page 211
第6章树
6.9二叉树的建立
说了半天，我们如何在内存中生成一棵二叉链表的二叉树呢？树都没有，哪来遍
历。所以我们还得来谈谈关于二叉树建立的问题。
如果我们要在内存中建立一个如图6-9-1左图这样的树，为了能让每个结点确认
是否有左右孩子，我们对它进行了扩展，变成图6-9-1右图的样子，也就是将二叉树
中每个结点的空指针引出一个虚结点，其值为一特定值，比如“#”。我们称这种处理
后的二叉树为原二叉树的扩展二叉树。扩展二叉树就可以做到一个遍历序列确定一棵
二叉树了。比如图6-9-1的前序遍历序列就为AB#D##C##。
A
B
?
普通二叉树
扩展二叉树
图 6-9-1
有了这样的准备，我们就可以来看看如何生成一棵二叉树了。假设二叉树的结点
均为一个字符，我们把刚才前序遍历序列AB#D##C##用键盘挨个输入。实现的算法
如下：
/按前序输入二叉树中结点的值（一个字符）*/
/表示空树，构造二叉链表表示二叉树T。*/
void CreateBiTree(BiTree*T)
TElemType ch;
scanf（"c”,4ch）;
if（ch--)
"T-NULL:
else
*T=（BiTree）malloc（sizeof（BiTNode））;
if（I*T)
exit（OVERFLOW）;
187
---
## Page 212
大语数据结构
（*T）->data=ch;/生成根结点
CreateBiTree（6（*T）->lchild）;/·构造左子树*/
CreateBiTree（s（*T）->rchild）：/*构造右子树*/
其实建立二叉树，也是利用了递归的原理。只不过在原来应该是打印结点的地
方，改成了生成结点、给结点赋值的操作而已。所以大家理解了前面的遍历的话，对
于这段代码就不难理解了。
当然，你完全也可以用中序或后序遍历的方式实现二叉树的建立，只不过代码里
生成结点和构造左右子树的代码顺序交换一下。另外，输入的字符也要做相应的更
改。比如图6-9-1的扩展二叉树的中序遍历字符串就应该为#B#D#A#C#，而后序字符
串应该为###DB##CA。
6.10线索二叉树
6.10.1线索二叉树原理
我们现在提倡节约型社会，一切都应该节约为本。对待我们的程序当然也不例
外，能不浪费的时间或空间，都应该考虑节省。我们再来观察图6-10-1，会发现指针
域并不是都充分的利用了，有许许多多的“人”，也就是空指针域的存在，这实在不是
好现象，应该要想办法利用起来。
EFGA
图6-10-1
首先我们要来看看这空指针有多少个呢？对于一个有n个结点的二叉链表，每个
结点有指向左右孩子的两个指针域，所以一共是2n个指针域。而n个结点的二叉树
188
---
## Page 213
第6章树
一共有n-1条分支线数，也就是说，其实是存在2n-（n-1）=n+1个空指针域。
比如图6-10-1有10个结点，面带有“A”空指针域为11。这些空间不存储任何事
物，白白的浪费着内存的资源。
另一方面，我们在做遍历时，比如对图6-10-1做中序遍历时，得到了
HDIBJEAFCG这样的字符序列，遍历过后，我们可以知道，结点I的前驱是D，后继
是B，结点F的前驱是A，后继是C。也就是说，我们可以很清楚的知道任意一个结
点，它的前驱和后继是哪一个。
可是这是建立在已经遍历过的基础之上的。在二叉链表上，我们只能知道每个结
点指向其左右孩子结点的地址，而不知道某个结点的前驱是谁，后继是谁。要想知
道，必须遍历一次。以后每次需要知道时，都必须先遍历一次。为什么不考虑在创建
时就记住这些前驱和后继呢，那将是多大的时间上的节省。
综合刚才两个角度的分析后，我们可以考虑利用那些空地址，存放指向结点在某
种遍历次序下的前驱和后继结点的地址。就好像GPS导航仪一样，我们开车的时候，
哪怕我们对具体目的地的位置一无所知，但它每次都可以告诉我从当前位置的下一步
应该走向哪里。这就是我们现在要研究的问题。我们把这种指向前驱和后继的指针称
为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树
(Threaded Binary Tree) 。
请看图6-10-2，我们把这棵二叉树进行中序遍历后，将所有的空指针域中的
rchild，改为指向它的后继结点。于是我们就可以通过指针知道H的后继是D（图中
①），1的后继是B（图中②），J的后继是E（图中③），E的后继是A（图中④），F的
后继是C（图中5），G的后继因为不存在而指向NULL（图中）。此时共有6个空指
针域被利用。
B
5/
NULL
EAF
1
图 6-10-2
189
---
## Page 214
再看图6-10-3，我们将这棵二叉树的所有空指针域中的khid，改为指向当前结点
的前驱。因此H的前驱是NULL（图中①），I的前驱是D（图中②），1的前驱是B
（图中③），F的前驱是A（图中④），G的前驱是C（图中）。一共5个空指针城被利
用，正好和上面的后继加起来是11个。
F
G
H
图6-10-3
通过图6-10-4（空心箭头实线为前驱，虚线黑箭头为后继），就更容易看出，其实
线索二叉树，等于是把一棵二叉树转变成了一个双向链表，这样对我们的插入删除结
点、查找某个结点都带来了方便。所以我们对二叉树以某种次序遍历使其变为线索二
叉树的过程称做是线索化。
A)
B
图6-10-4
不过好事总是多磨的，问题并没有彻底解决。我们如何知道某一结点的khild是指
向它的左孩子还是指向前驱？rchild是指向右孩子还是指向后继？比如E结点的khil
是指向它的左孩子I，而rchild却是指向它的后继A。显然我们在决定khid是指向
左孩子还是前驱，rchild是指向右孩子还是后继上是需要一个区分标志的。因此，我
的布尔型变量，其占用的内存空间要小于像khild和rchild的指针变量。结点结构如
190
---
## Page 215
第6章树
表6-10-1所示。
表6-10-1
khildltag
data
rtag
rchild
其中：
■ltag为0时指向该结点的左孩子，为1时指向该结点的前驱。
rtag为0时指向该结点的右孩子，为1时指向该结点的后继。
■因此对于图6-10-1的二叉链表图可以修改为图6-10-5的样子。
0AO
0B0
D
图 6-10-5
6.10.2线索二叉树结构实现
由此二叉树的线索存储结构定义代码如下：
/二叉树的二叉线索存储结构定义/
typedefenum（Link，Thread）PointerTag：/*Link--0表示指向左右孩子指针*/
/Thread--1表示指向前成后继的线索*/
/二叉线索存储结点结构*/
TElenType data;
结点数据*/
PointerTag LTag;
PointerTag RTag;
左右标志/
)BiThrNode,*BiThrTree;
线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱
和后继的信息只有在遍历该二叉树时才能得到，所以线索化的过程就是在遍历的过程
191
---
## Page 216
大语数据结构
中修改空指针的过程。