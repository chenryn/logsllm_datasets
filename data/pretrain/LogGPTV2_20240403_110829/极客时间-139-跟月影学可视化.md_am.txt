# 14 \| 如何使用片元着色器进行几何造型？你好，我是月影。 在 WebGL中，片元着色器有着非常强大的能力，它能够并行处理图片上的全部像素，让数以百万计的运算同时完成。但也正因为它是并行计算的，所以它和常规代码顺序执行或者串行执行过程并不一样。因此，在使用片元着色器实现某些功能的时候，我们要采用与常规的JavaScript 代码不一样的思路。 到底哪里不一样呢？今天，我就通过颜色控制，以及线段、曲线、简单几何图形等的绘制，来讲讲片元着色器是怎么进行几何造型的，从而加深你对片元着色器绘图原理的理解。 首先，我们来说比较简单的颜色控制。 如何用片元着色器控制局部颜色？我们知道，片元着色器能够用来控制像素颜色，最简单的就是把图片绘制为纯色。比如，通过下面的代码，我们就把一张图片绘制为了纯黑色。     #ifdef GL_ES    precision highp float;    #endif    varying vec2 vUv;    void main() {      gl_FragColor = vec4(0, 0, 0, 1);    }如果想让一张图片呈现不同的颜色，我们还可以根据纹理坐标值来绘制，比如，通过下面的代码，我们就可以让某个图案的颜色，从左到右由黑向白过渡。     #ifdef GL_ES    precision highp float;    #endif    varying vec2 vUv;    void main() {      gl_FragColor.rgb = vec3(vUv.x);      gl_FragColor.a = 1.0;    }不过，这种颜色过渡还比较单一，这里我们还可以改变一下渲染方式让图形呈现的效果更复杂。比如说，我们可以使用乘法创造一个10\*10的方格，让每个格子左上角是绿色，右下角是红色，中间是过渡色。代码和显示的效果如下所示：     #ifdef GL_ES    precision highp float;    #endif    varying vec2 vUv;    void main() {      vec2 st = vUv * 10.0;      gl_FragColor.rgb = vec3(fract(st), 0.0);      gl_FragColor.a = 1.0;    }![](Images/c7061fbdb143dfd6fd3d612f0b4101c4.png)savepage-src="https://static001.geekbang.org/resource/image/9b/f6/9b33fc3c5b08343114c479574f0484f6.jpeg"}不仅如此，我们还可以在上图的基础上继续做调整。我们可以通过 idx =floor(st) 获取网格的索引，判断网格索引除以 2的余数（奇偶性），根据它来决定是否翻转网格内的 x、y坐标。这样操作后的代码和图案如下所示：     #ifdef GL_ES    precision highp float;    #endif    varying vec2 vUv;    void main() {      vec2 st = vUv * 10.0;      vec2 idx = floor(st);      vec2 grid = fract(st);      vec2 t = mod(idx, 2.0);            if(t.x == 1.0) {        grid.x = 1.0 - grid.x;      }      if(t.y == 1.0) {        grid.y = 1.0 - grid.y;      }      gl_FragColor.rgb = vec3(grid, 0.0);      gl_FragColor.a = 1.0;    }![](Images/96c92a0422a00a171e6ea49a8f2874e1.png)savepage-src="https://static001.geekbang.org/resource/image/66/a2/66b0826578525073320c14e6120a8aa2.jpeg"}事实上，再改用不同的方式，我们还可以生成更多有趣的图案。不过，这里我们就不继续了，因为上面这些做法有点像是灵机一动的小技巧。实际上，我们缺少的并不是小技巧，而是一套统一的方法论。我们希望能够利用它，在着色器里精确地绘制出我们想要的几何图形。 如何用片元着色器绘制圆、线段和几何图形那接下来，我们就通过几个例子，把片元着色器精确绘图的方法论给总结出来。 1. 绘制圆首先，我们从最简单的几何图形，也就是圆开始，来说说片元着色器的绘图过程。 一般来说，我们画圆的时候是根据点坐标到圆心的距离来生成颜色的。在片元着色器中，我们可以用distance 函数求一下 vUv 和画布中点 vec2(0.5)的距离，然后根据这个值设置颜色。代码如下：     #ifdef GL_ES    precision highp float;    #endif    varying vec2 vUv;    void main() {      float d = distance(vUv, vec2(0.5));      gl_FragColor.rgb = d * vec3(1.0);      gl_FragColor.a = 1.0;    }通过这样的方法，我们最终绘制出了一个模糊的圆，效果如下： ![](Images/a99907272785d53d240533cfba567d1b.png)savepage-src="https://static001.geekbang.org/resource/image/84/58/84239f4aaf8f54cdbe93a65e3bfd2d58.jpeg"}为什么这个圆是模糊的呢？这是因为越靠近圆心，距离 d 的值越小，gl_FragColor.rgb = d \* vec3(1.0);的颜色值也就越接近于黑色。 那如果我们要实现一个更清晰的圆应该怎么做呢？这个时候，你别忘了还有step 函数。我们用 step 函数基于 0.2 做阶梯，就能得到一个半径为 0.2的圆。实现代码和最终效果如下：     #ifdef GL_ES    precision highp float;    #endif    varying vec2 vUv;    void main() {      float d = distance(vUv, vec2(0.5));      gl_FragColor.rgb = step(d, 0.2) * vec3(1.0);      gl_FragColor.a = 1.0;    }![](Images/c5fab2e7be0c75a8af72b9bfd4d7b1cf.png)savepage-src="https://static001.geekbang.org/resource/image/8b/36/8b3acfbe004038caba9f9c1a1429ae36.jpeg"}不过，你会发现我们得到的这个圆的边缘很不光滑。这是因为浮点数计算的精度导致的锯齿现象。为了解决这个问题，我们用smoothstep 代替 step。 ![](Images/a647c5f5a0ff49c21dcb4d8fa9fb8755.png)savepage-src="https://static001.geekbang.org/resource/image/3f/c8/3f73b8cf75cf0c67cdb7815d0b7051c8.jpeg"}为什么 smoothstep 代替 step 就可以得到比较光滑的圆呢？这是因为smoothstep 和 step 类似，都是阶梯函数。但是，与 step的值是直接跳跃的不同，smoothstep 在 step-start 和 step-end之间有一个平滑过渡的区间。因此，用 smoothstep绘制的圆，边缘就会有一圈颜色过渡，就能从视觉上消除锯齿。 ![](Images/5e871fbe87e9e010b95dcce95ea77a92.png)savepage-src="https://static001.geekbang.org/resource/image/52/d7/52c7484a1e18526e2fca815c4083b5d7.jpeg"}片元着色器绘制的圆，在构建图像的粒子效果中比较常用。比如，我们可以用它来实现图片的渐显渐隐效果。下面是片元着色器中代码，以及我们最终能够实现的效果图。     #ifdef GL_ES    precision highp float;    #endif    uniform sampler2D tMap;    uniform vec2 uResolution;    uniform float uTime;    varying vec2 vUv;    float random (vec2 st) {        return fract(sin(dot(st.xy,                            vec2(12.9898,78.233)))*            43758.5453123);    }    void main() {        vec2 uv = vUv;        uv.y *= uResolution.y / uResolution.x;        vec2 st = uv * 100.0;        float d = distance(fract(st), vec2(0.5));        float p = uTime + random(floor(st));        float shading = 0.5 + 0.5 * sin(p);        d = smoothstep(d, d + 0.01, 1.0 * shading);        vec4 color = texture2D(tMap, vUv);        gl_FragColor.rgb = color.rgb * clamp(0.5, 1.3, d + 1.0 * shading);        gl_FragColor.a = color.a;    }![](Images/3e5d918bc874030338a3b9890fd8599d.png)savepage-src="https://static001.geekbang.org/resource/image/a6/9d/a6ffc10e75f217078c68c8dd6a7b4f9d.gif"}2. 绘制线利用片元着色器绘制圆的思路，就是根据点到圆心的距离来设置颜色。实际上，我们也可以用同样的原理来绘制线，只不过需要把点到点的距离换成点到直线（向量）的距离。     #ifdef GL_ES    precision highp float;    #endif    varying vec2 vUv;    void main() {      vec3 line = vec3(1, 1, 0);      float d = abs(cross(vec3(vUv,0), normalize(line)).z);       gl_FragColor.rgb = (1.0 - smoothstep(0.0, 0.01, d)) * vec3(1.0);      gl_FragColor.a = 1.0;    }比如，我们利用上面的代码，就能在画布上画出一条斜线。 ![](Images/d53ef1bc57407222ca0bed46ffb4d85e.png)savepage-src="https://static001.geekbang.org/resource/image/61/7f/618fc882f894386eccdcf4bdea233e7f.jpeg"}如果你还不能一眼看出上面的代码为什么能画出一条直线，说明你对于图形学的向量计算思维还没有完全适应。不过别着急，随着我们练习的增多，你会逐渐适应的。下面，我来解释一下这段代码。 这里，我们用一个三维向量 line 来定义一条直线。因为我们要绘制的是 2D图形，所以 z 保持 0 就行，而 x 和 y用来决定方向。 然后呢，我们求 vUv 和 line的距离。这里我们直接用向量叉乘的性质就能求得。因为两个二维向量叉积的 z轴分量的大小，就是这两个向量组成的平行四边形的面积，那当我们把 line的向量归一化之后，这个值就是 vUv 到直线的距离 d 了。因为这个 d带符号，所以我们还需要取它的绝对值。 最后，我们用这个 d 结合前面使用过的 smoothstep来控制像素颜色，就能得到一条直线了。 3. 用鼠标控制直线画出直线之后，我们改变 line还可以得到不同的直线。比如，在着色器代码中，我们再添加一个 uniform 变量uMouse，就可以根据鼠标位置来控制直线方向。     #ifdef GL_ES    precision highp float;    #endif    varying vec2 vUv;    uniform vec2 uMouse;    void main() {      vec3 line = vec3(uMouse, 0); // 用向量表示所在直线      float d = abs(cross(vec3(vUv,0), normalize(line)).z); // 叉乘表示平行四边形面积，底边为1，得到距离      gl_FragColor.rgb = (1.0 - smoothstep(0.0, 0.01, d)) * vec3(1.0);      gl_FragColor.a = 1.0;    }对应地，我们需要在 JavaScript 中将 uMouse 通过 uniforms传入，代码如下：     const canvas = document.querySelector('canvas');    const renderer = new GlRenderer(canvas);    const program = renderer.compileSync(fragment, vertex);    renderer.useProgram(program);    renderer.uniforms.uMouse = [-1, -1];    canvas.addEventListener('mousemove', (e) => {      const {x, y, width, height} = e.target.getBoundingClientRect();      renderer.uniforms.uMouse = [        (e.x - x) / width,        1.0 - (e.y - y) / height,      ];    });    renderer.setMeshData([{      positions: [        [-1, -1],        [-1, 1],        [1, 1],        [1, -1],      ],      attributes: {        uv: [          [0, 0],          [0, 1],          [1, 1],          [1, 0],        ],      },      cells: [[0, 1, 2], [2, 0, 3]],    }]);    renderer.render();![](Images/b0ceef721b1ce28964e56aeac70b497f.png)savepage-src="https://static001.geekbang.org/resource/image/aa/71/aa095666cfb32167aff86d051b929271.gif"}在上面的例子中，我们的直线是经过原点的。那如果我们想让直线经过任意的定点该怎么办？我们可以加一个uniform 变量uOrigin，来表示直线经过的固定点。代码如下：     #ifdef GL_ES    precision highp float;    #endif    varying vec2 vUv;    uniform vec2 uMouse;    uniform vec2 uOrigin;    void main() {      vec3 line = vec3(uMouse - uOrigin, 0); // 用向量表示所在直线      float d = abs(cross(vec3(vUv - uOrigin, 0), normalize(line)).z); // 叉乘表示平行四边形面积，底边为1，得到距离      gl_FragColor.rgb = (1.0 - smoothstep(0.0, 0.01, d)) * vec3(1.0);      gl_FragColor.a = 1.0;    }延续这个绘制直线的思路，我们很容易就能知道该如何绘制线段了。绘制线段与绘制直线的方法几乎一样，只不过，我们要将计算点到直线的距离修改为计算点到线段的距离。 但是因为点和线段之间有两种关系，一种是点在线段上，另一种是在线段之外。所以我们在求点到线段的距离d的时候，要分两种情况讨论：当点到线段的投影位于线段两个端点中间的时候，它就等于点到直线的距离；当点到线段的投影在两个端点之外的时候，它就等于这个点到最近一个端点的距离。 这么说还是比较抽象，我画了一个示意图。你会看到，C1] slate-object="inline"到线段 ab的距离就等于它到线段所在直线的距离，C2] slate-object="inline"到线段 ab 的距离是它到 a点的距离，C3] slate-object="inline"到线段的距离是它到 b 点的距离。那么如何判断究竟是C1] slate-object="inline"、C2] slate-object="inline"、C3] slate-object="inline"中的哪一种情况呢？答案是通过C1] slate-object="inline"到线段 ab的投影来判断。 ![](Images/f7170798267e77f74124548cc64fb119.png)savepage-src="https://static001.geekbang.org/resource/image/64/2b/64cb19cd9fabb219db3d185d3a77922b.jpeg"}所以，我们在原本片元着色器代码的基础上，抽象出一个 seg_distance函数，用来返回点到线段的距离。修改后的代码如下：     #ifdef GL_ES    precision highp float;    #endif    varying vec2 vUv;    uniform vec2 uMouse;    uniform vec2 uOrigin;    float seg_distance(in vec2 st, in vec2 a, in vec2 b) {      vec3 ab = vec3(b - a, 0);      vec3 p = vec3(st - a, 0);      float l = length(ab);      float d = abs(cross(p, normalize(ab)).z);      float proj = dot(p, ab) / l;      if(proj >= 0.0 && proj = 0.0 && proj = 0.0 && d2 >= 0.0 && d3 >= 0.0 || d1 = 0.0 && proj = 0.0 && d2 >= 0.0 && d3 >= 0.0 || d1  0.0 && c1 > 0.0 && c2 = 0.0 || c2  {      return [r * Math.cos(θ), r * Math.sin(θ)];    };    const arc = parametric(      t => 200,      t => t,      fromPolar,    );    arc(0, Math.PI).draw(ctx);此外，我们还可以添加其他的极坐标参数方程来绘制更多曲线，比如玫瑰线、心形线或者双纽线。因为这些操作都比较简单，我就直接在下面给出代码了。    const rose = parametric(      (t, a, k) => a * Math.cos(k * t),      t => t,      fromPolar,    );    rose(0, Math.PI, 100, 200, 5).draw(ctx, {strokeStyle: 'blue'});    const heart = parametric(      (t, a) => a - a * Math.sin(t),      t => t,      fromPolar,    );    heart(0, 2 * Math.PI, 100, 100).draw(ctx, {strokeStyle: 'red'});    const foliumRight = parametric(      (t, a) => Math.sqrt(2 * a ** 2 * Math.cos(2 * t)),      t => t,      fromPolar,    );    const foliumLeft = parametric(      (t, a) => -Math.sqrt(2 * a ** 2 * Math.cos(2 * t)),      t => t,      fromPolar,    );    foliumRight(-Math.PI / 4, Math.PI / 4, 100, 100).draw(ctx, {strokeStyle: 'green'});    foliumLeft(-Math.PI / 4, Math.PI / 4, 100, 100).draw(ctx, {strokeStyle: 'green'});最终，我们能够绘制出如下的效果：![](Images/734eee9ce11061994ad794201255045a.png)savepage-src="https://static001.geekbang.org/resource/image/47/fa/475905a6708e51yy234c640f292833fa.jpeg"}总的来说，我们看到，使用极坐标系中参数方程来绘制曲线的方法，其实和我们学过的直角坐标系中参数方程绘制曲线差不多，唯一的区别就是在具体实现的时候，我们需要额外增加一个坐标映射函数，将极坐标转为直角坐标才能完成最终的绘制。如何使用片元着色器与极坐标系绘制图案？在前面的例子中，我们主要还是通过参数方程来绘制曲线，用 Canvas2D进行渲染。那如果我们使用 shader来渲染，又该怎么使用极坐标系绘图呢？这里，我们还是以圆为例，来看一下用 shader渲染，再以极坐标画圆的做法。你可以先尝试自己理解下面的代码，然后再看我后面的讲解。    #ifdef GL_ES    precision highp float;    #endif    varying vec2 vUv;    vec2 polar(vec2 st) {      return vec2(length(st), atan(st.y, st.x));    }    void main() {      vec2 st = vUv - vec2(0.5);      st = polar(st);      gl_FragColor.rgb = smoothstep(st.x, st.x + 0.01, 0.2) * vec3(1.0);      gl_FragColor.a = 1.0;    }在上面的代码中，我们先通过坐标转换公式实现 polar函数。这个函数作用是将直角坐标转换为极坐标，相当于课程一开始，我们用JavaScript 写的 toPolar 函数。这里有一个细节需要注意，我们使用的是 GLSL内置的 float atan(float, float) 方法，对应的方法是 Math.atan，而在JavaScript 版本的 toPolar 函数中，对应的方法是Math.atan2。然后，我们将像素坐标转换为极坐标：st = polar(st); ，转换后的 st.x实际上是极坐标的 r 分量，而 st.y就是极坐标的θ分量。我们知道，对于极坐标下过极点的圆，实际上的 r值就是一个常量值，对应圆的半径，所以我们取 smoothstep(st.x, st.x + 0.01,0.2)，就能得到一个半径为 0.2的圆了。这一步，我们用的还是上节课的**距离场**方法。只不过，在直角坐标系下，点到圆心的距离 d 需要用 x、y平方和的开方来计算，而在极坐标下，点的极坐标 r值正好表示了点到圆心的距离d，所以计算起来就比直角坐标系简单了很多。其实，我们无论是用直角坐标还是极坐标来画图，方法都差不多。但是，一些其他的曲线用极坐标绘制会很方便。比如说，要绘制玫瑰线，我们就可以用以下代码：    void main() {      vec2 st = vUv - vec2(0.5);      st = polar(st);      float d = 0.5 * cos(st.y * 3.0) - st.x;      gl_FragColor.rgb = smoothstep(-0.01, 0.01, d) * vec3(1.0);      gl_FragColor.a = 1.0;    }这样，在画布上绘制出来的结果是三瓣玫瑰线：![](Images/450716ec339cc3e275cd12025d1f5792.png)savepage-src="https://static001.geekbang.org/resource/image/f7/8a/f73a97f5f742dd5d9c2c53b8ecf5908a.jpeg"}可能你还是会有疑问，为什么 d = 0.5 \* cos(st.y \* 3.0) - st.x;绘制出的图形就是三瓣玫瑰线的图案呢？这是因为玫瑰线的极坐标方程 r = a \* cos(k \*θ)，所以玫瑰线上的所有点都满足 0 = a \* cos(k \* θ) - r这个方程式。如果我们再把它写成距离场的形式：d = a \* cos(k \* θ) -r。这个时候就有三种情况：玫瑰线上点的 d 等于 0；玫瑰线围出的图形外的点的d 小于 0，玫瑰线围出的图形内的点的 d 大于0。 ![](Images/1fa9e9b74d3bce4a2f9a7029f6a5d587.png)savepage-src="https://static001.geekbang.org/resource/image/72/a9/7244ff9e7d36b8dd5ayy04e42430a5a9.jpeg"}因此，smoothstep(-0.01, 0.01, d) 能够将 d \>=0，也就是玫瑰线内的点选出来，这样也就绘制出了三瓣图形。那玫瑰线有什么用呢？它是一种很有趣图案，我们只要修改 u_k的值，并且保证它是正整数，就可以绘制出不同瓣数的玫瑰线图案。    uniform float u_k;    void main() {      vec2 st = vUv - vec2(0.5);      st = polar(st);      float d = 0.5 * cos(st.y * u_k) - st.x;      gl_FragColor.rgb = smoothstep(-0.01, 0.01, d) * vec3(1.0);      gl_FragColor.a = 1.0;    }    renderer.uniforms.u_k = 3;    setInterval(() => {      renderer.uniforms.u_k += 2;    }, 200);![](Images/f039b1e992b5e0b0c8ffe1f9933cbf0f.png)savepage-src="https://static001.geekbang.org/resource/image/0f/18/0fa365713c9676219e72cd55073f7318.gif"}类似的图案还有花瓣线：    void main() {      vec2 st = vUv - vec2(0.5);      st = polar(st);      float d = 0.5 * abs(cos(st.y * u_k * 0.5)) - st.x;      gl_FragColor.rgb = smoothstep(-0.01, 0.01, d) * vec3(1.0);      gl_FragColor.a = 1.0;    }在 u_k=3的时候，我们可以得到如下图案：![](Images/fabd59b1a54359bb8cc7d89c79a5c26f.png)savepage-src="https://static001.geekbang.org/resource/image/e5/47/e51fc1ca89f103b3f949477424f18047.jpeg"}有趣的是，它和玫瑰线不一样，u_k的取值不一定要是整数。这让它能绘制出来的图形更加丰富，比如说我们可以取u_k=1.3，这时得到的图案就像是一个横放的苹果。![](Images/66f5d5642d110322b9cf5aa533c20c08.png)savepage-src="https://static001.geekbang.org/resource/image/ff/96/ff98434df974b610078f76aab6c96896.jpeg"}在此基础上，我们还可以再添加几个 uniform 变量，如 u_scale、u_offset作为参数，来绘制出更多图形。代码如下：    varying vec2 vUv;    uniform float u_k;    uniform float u_scale;    uniform float u_offset;              void main() {      vec2 st = vUv - vec2(0.5);      st = polar(st);      float d = u_scale * 0.5 * abs(cos(st.y * u_k * 0.5)) - st.x + u_offset;      gl_FragColor.rgb = smoothstep(-0.01, 0.01, d) * vec3(1.0);      gl_FragColor.a = 1.0;    }当我们取 u_k=1.7，u_scale=0.5，u_offset=0.2时，就能得到一个横置的葫芦图案。![](Images/9b69f3e270adf723b20965267ff69a12.png)savepage-src="https://static001.geekbang.org/resource/image/5b/74/5b303d4e6e7afd2f2bb61f10e9717574.jpeg"}如果我们继续修改 d的计算方程，还能绘制出其他有趣的图形。    void main() {      vec2 st = vUv - vec2(0.5);      st = polar(st);      float d = smoothstep(-0.3, 1.0, u_scale * 0.5 * cos(st.y * u_k) + u_offset) - st.x;      gl_FragColor.rgb = smoothstep(-0.01, 0.01, d) * vec3(1.0);      gl_FragColor.a = 1.0;    }比如，当继续修改 d的计算方程时，我们可以绘制出花苞图案：![](Images/268ce7be3708771bcd4d9f33ba26e1b4.png)savepage-src="https://static001.geekbang.org/resource/image/8e/e9/8e87d4e5c76a06645860819474a25fe9.jpeg"}方法已经知道了，你可以在课后结合三角函数、abs、smoothstep，来尝试绘制一些更有趣的图案。如果有什么特别好玩的图案，你也可以分享出来。极坐标系如何实现角向渐变？除了绘制有趣的图案之外，极坐标的另一个应用是**角向渐变**（Conic Gradients）。那角向渐变是什么呢？如果你对 CSS比较熟悉，一定知道角向渐变就是以图形中心为轴，顺时针地实现渐变效果。而且新的 [CSS ImageValues and Replaced Content 标准 level4已经添加了角向渐变，我们可以使用它来创建一个基于极坐标的颜色渐变，代码如下：    div.conic {      width: 150px;      height: 150px;      border-radius: 50%;      background: conic-gradient(red 0%, green 45%, blue);    }![](Images/9c7de6d8cbcadcecdb6ebe415fdff71b.png)savepage-src="https://static001.geekbang.org/resource/image/6b/3e/6bdeda39bcbff4b2269d641df8f9d33e.jpeg"}我们可以通过角向渐变创建一个颜色由角度过渡的元素。在 WebGL中，我们可以通过极坐标用片元着色器实现类似的角向渐变效果，代码如下：    void main() {      vec2 st = vUv - vec2(0.5);      st = polar(st);      float d = smoothstep(st.x, st.x + 0.01, 0.2);      // 将角度范围转换到0到2pi之间      if(st.y  x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);        vec2 x1 = x0.xy + C.xx - i1;        vec2 x2 = x0.xy + C.zz;        // Do some permutations to avoid        // truncation effects in permutation        i = mod289(i);        vec3 p = permute(                permute( i.y + vec3(0.0, i1.y, 1.0))                    + i.x + vec3(0.0, i1.x, 1.0 ));        vec3 m = max(0.5 - vec3(                            dot(x0,x0),                            dot(x1,x1),                            dot(x2,x2)                            ), 0.0);        m = m*m ;        m = m*m ;        // Gradients:        //  41 pts uniformly over a line, mapped onto a diamond        //  The ring size 17*17 = 289 is close to a multiple        //      of 41 (41*7 = 287)        vec3 x = 2.0 * fract(p * C.www) - 1.0;        vec3 h = abs(x) - 0.5;        vec3 ox = floor(x + 0.5);        vec3 a0 = x - ox;        // Normalise gradients implicitly by scaling m        // Approximation of: m *= inversesqrt(a0*a0 + h*h);        m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);        // Compute final noise value at P        vec3 g = vec3(0.0);        g.x  = a0.x  * x0.x  + h.x  * x0.y;        g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);        return 130.0 * dot(m, g);    }    void main() {        vec2 st = vUv * 20.0;        gl_FragColor.rgb = vec3(0.5 * noise(st) + 0.5);        gl_FragColor.a = 1.0;    }渲染效果如下图：![](Images/f3585f7fc175352dad048108c571476f.png)savepage-src="https://static001.geekbang.org/resource/image/39/0a/3984a318acc90ccce0dcaf65aaf0a60a.jpeg"}Simplex Noise可以实现出令人惊叹的效果，在Shadertoy.comslate-object="inline"平台上经常有大神分享他们创作的神奇效果。比如，这个slate-object="inline"像某种溶洞的岩壁效果，就有一种大自然鬼斧神工的韵味在。![](Images/5fe0c0a93b39bb1621ec3245e408f63d.png)savepage-src="https://static001.geekbang.org/resource/image/bb/48/bbb7f35c9a0f4b639825074764025a48.gif"}再比如，这种像电影大片中才有的效果slate-object="inline"，你很难想象这并不是视频，甚至不是图片，只不过是我们用数学公式在Shader中计算并绘制出来的图案而已。![](Images/f88a2538750c2793cebe67ae199efb5f.png)savepage-src="https://static001.geekbang.org/resource/image/0c/cc/0c209d3f0f65d45457420f74c057d2cc.gif"}网格噪声最后，我们来讲讲网格噪声。前面我们已经使用过大量网格化的技术，我想你也应该比较熟悉了。那什么是网格噪声呢？它就是将噪声与网格结合使用的一种纹理生成技术。下面，让我们通过一个生成动态生物细胞的例子，来详细理解一下如何使用网格噪声。首先，我们用网格技术将画布分为 10\*10的网格。然后，我们构建距离场。这个距离场是在每个网格中随机一个特征点，然后计算网格内到该点的距离，最后根据距离来着色。    #ifdef GL_ES    precision highp float;    #endif    varying vec2 vUv;    uniform float uTime;    vec2 random2(vec2 st){      st = vec2( dot(st,vec2(127.1,311.7)),                dot(st,vec2(269.5,183.3)) );      return fract(sin(st) * 43758.5453123);    }    void main() {      vec2 st = vUv * 10.0;      float d = 1.0;      vec2 i_st = floor(st);      vec2 f_st = fract(st);      vec2 p = random2(i_st);      d = distance(f_st, p);      gl_FragColor.rgb = vec3(d);      gl_FragColor.a = 1.0;    }通过上面的代码，我们最终能得到如下的效果：![](Images/a4fa0b78c808c81323012a1ae1ae93df.png)savepage-src="https://static001.geekbang.org/resource/image/dc/ed/dc089df759336b3636f2a3cf7bfa71ed.jpeg"}我们可以看到，这里的每个网格是独立的，并且界限分明。那如果我们想让它们的边界过渡更圆滑该怎么办呢？我们可以在原来的代码上做改变，具体来说就是不仅计算特征点到当前网格的距离，还要计算它到周围相邻的8 个网格的距离，然后取最小值。与其他的编程语言类似，这个可以通过 for循环来实现：    void main() {      vec2 st = vUv * 10.0;      float d = 1.0;      vec2 i_st = floor(st);      vec2 f_st = fract(st);      for(int i = -1; i = 0.0 && proj = 0.0 && d2 >= 0.0 && d3 >= 0.0 || d1  0.0) {        result = pow(result, vec3(1.0 / gamma));      }      gl_FragColor.rgb = result;      gl_FragColor.a = 1.0;    }最后，我们修改 JavaScript渲染的逻辑，添加新的后期处理规则。这里，我们要使用三个 FBO对象，因为第一个 FBO对象在渲染原始图形之后，还要在混合效果时使用，后两个对象是用来交替使用完成高斯模糊的。最后，我们再将原始图形和高斯模糊的结果进行效果混合就可以了。修改后的代码如下：    // 创建三个FBO对象，fbo1和fbo2交替使用    const fbo0 = renderer.createFBO();    const fbo1 = renderer.createFBO();    const fbo2 = renderer.createFBO();    // 第一次，渲染原始图形    renderer.bindFBO(fbo0);    renderer.render();    // 第二次，对x轴高斯模糊    renderer.useProgram(blurProgram);    renderer.setMeshData(program.meshData);    renderer.bindFBO(fbo2);    renderer.uniforms.tMap = fbo0.texture;    renderer.uniforms.axis = 0;    renderer.uniforms.filter = 0.7;    renderer.render();    // 第三次，对y轴高斯模糊    renderer.useProgram(blurProgram);    renderer.bindFBO(fbo1);    renderer.uniforms.tMap = fbo2.texture;    renderer.uniforms.axis = 1;    renderer.uniforms.filter = 0;    renderer.render();    // 第四次，对x轴高斯模糊    renderer.useProgram(blurProgram);    renderer.bindFBO(fbo2);    renderer.uniforms.tMap = .texture;    renderer.uniforms.axis = 0;    renderer.uniforms.filter = 0;    renderer.render();    // 第五次，对y轴高斯模糊    renderer.useProgram(blurProgram);    renderer.bindFBO(fbo1);    renderer.uniforms.tMap = fbo2.texture;    renderer.uniforms.axis = 1;    renderer.uniforms.filter = 0;    renderer.render();    // 第六次，叠加辉光    renderer.useProgram(bloomProgram);    renderer.setMeshData(program.meshData);    renderer.bindFBO(null);    renderer.uniforms.tSource = fbo0.texture;    renderer.uniforms.tMap = fbo1.texture;    renderer.uniforms.axis = 1;    renderer.uniforms.filter = 0;    renderer.render();这样渲染之后，我就能让三角形图案中几个比较亮的三角形，产生一种微微发光的效果。渲染效果如下：![](Images/0dff5a1b1d82ec7a9afabba28f0ecafb.png)savepage-src="https://static001.geekbang.org/resource/image/69/c5/6905c7b0ff6b8b8d903e0eaeefcbfbc5.jpeg"}局部辉光效果示意图这样，我们就实现了最终的局部辉光效果。实现它的关键，就是在高斯模糊原理的基础上，将局部高斯模糊的图像与原始图像叠加。如何用后期处理通道实现烟雾效果？除了模糊和辉光效果之外，后期处理通道还经常用来实现烟雾效果。接下来，我们就实现一个小圆的烟雾效果。具体的实现过程主要分为两步：第一步和前面两个例子一样，我们通过创建一个shader，画出一个简单的圆。第二步，我们对这个圆进行后期处理，不过这次的处理方法就和实现辉光不同了。下面，我们就一起来看。首先，我们创建一个简单的shader，也就是使用距离场在画布上画一个圆。这个 shader我们非常熟悉，具体的代码如下：    #ifdef GL_ES    precision highp float;    #endif    varying vec2 vUv;    void main() {      vec2 st = vUv - vec2(0.5);      float d = length(st);      gl_FragColor.rgb = vec3(1.0 - smoothstep(0.05, 0.055, d));      gl_FragColor.a = 1.0;    }![](Images/14677868686c5e3d035fdf749a6f9466.png)savepage-src="https://static001.geekbang.org/resource/image/72/77/72d1816d29d1401636e0099016f80477.jpeg"}接着，我们修改一下 shader 代码，增加 uTime、tMap这两个变量，代码如下所示。其中，uTime 用来控制图像随时间变化，而 tMap是我们用来做后期处理的变量。    #ifdef GL_ES    precision highp float;    #endif    varying vec2 vUv;    uniform sampler2D tMap;    uniform float uTime;    void main() {      vec3 smoke = vec3(0);      if(uTime                            Document                                  ![](Images/0b19b49b30b2ec3adbe772533eaf15de.png)savepage-src="https://static001.geekbang.org/resource/image/fe/41/fe5fd08150d43ff6305042b6ea2ba041.gif"}旋转的蓝色方块在上面的例子中，我们重点关注第 22 到 26 这 5 行 JavaScript代码就行了，关键逻辑在于我们修改 rotatation 值，每次绘制的时候将它加1。这样我们就实现增量动画，是不是也很简单？确实，增量动画的优点就是实现简单。但它也有 2个缺点。首先，因为它使用增量来控制动画，从数学角度来说，也就是我们直接使用了一阶导数来定义的动画。这样的绘图方式不太好控制动画的细节，比如动画周期、变化率、轨迹等等，所以这种方法只能用来实现简单动画。其次，增量动画定义的是状态变化。如果我们要在 shader中使用动画，就只能采用后期处理通道来实现。但是后期处理通道要进行多次渲染，实现起来比较繁琐，而且性能开销也比较大。所以，更加复杂的轨迹动画，我们一般采用第三种方式，也就是通过定义时间和动画函数来实现。3. 实现时序动画还是以旋转的蓝色方块为例，我们改写一下它的 JavaScript代码。     const block = document.querySelector('.block');    const startAngle = 0;    const T = 2000;    let startTime = null;    function update() {      startTime = startTime == null ? Date.now() : startTime;      const p = (Date.now() - startTime) / T;      const angle = startAngle + p * 360;      block.style.transform = `rotate(${angle}deg)`;      requestAnimationFrame(update);    }    update();首先，我们定义 2 个变量，startAnglehe 和 T。其中，startAnglehe是起始旋转角度，T 是旋转周期。在第一次调用 update的时候，我们设置初始旋转的时间为 startTime，那么在每次调用 update的时候，当前经过的时间就是 Date.now() -startTime。 接着，我们将它除以周期 T，就能得到旋转进度 p，那么当前角度就等于startAngle + p \* 360。然后我们将当前角度设置为元素的 rotate值，就实现了同样的旋转动画。总的来说，时序动画的实现可以总结为三步：首先定义初始时间和周期，然后在update 中计算当前经过时间和进度 p，最后通过 p来更新动画元素的属性。虽然时序动画实现起来比增量动画写法更复杂，但我们可以更直观、精确地控制旋转动画的周期（速度）、起始角度等参数。也正因为如此，这种方式在动画实现中最为常用。那为了更方便使用和拓展，我们可以把实现时序动画的三个步骤抽象成标准的动画模型。具体怎么做呢？我们接着往下看。定义标准动画模型首先，我们定义一个类 Timing用来处理时间，具体代码如下：    export class Timing {      constructor({duration, iterations = 1} = {}) {        this.startTime = Date.now();        this.duration = duration;        this.iterations = iterations;      }      get time() {        return Date.now() - this.startTime;      }      get p() {        const progress = Math.min(this.time / this.duration, this.iterations);        return this.isFinished ? 1 : progress % 1;      }      get isFinished() {        return this.time / this.duration >= this.iterations;      }    }然后，我们实现一个 Animator类，用来真正控制动画过程。    import {Timing} from './timing.js';    export class Animator {      constructor({duration, iterations}) {        this.timing = {duration, iterations};      }      animate(target, update) {        let frameIndex = 0;        const timing = new Timing(this.timing);        return new Promise((resolve) => {          function next() {            if(update({target, frameIndex, timing}) !== false && !timing.isFinished) {              requestAnimationFrame(next);            } else {              resolve(timing);            }            frameIndex++;          }          next();        });      }    }Animator 构造器接受{duration, iterations}作为参数，它有一个 animate方法，会在执行时创建一个 timing 对象，然后通过执行 update({target,frameIndex, timing}) 更新动画，并且会返回一个 promise对象。这样，在动画结束时，resolve 这个promise，我们就能够很方便地实现连续动画了。接下来，你可以想一个动画效果，来试验一下这个模型的效果。比如说，我们可以用Animator 实现四个方块的轮换转动，让每个方块转动的周期是 1 秒，一共旋转1.5 个周期（即 540度）。代码和效果如下所示。                              Document                                                                        ![](Images/389434cfebbe537de84bccdd6d23f124.png)savepage-src="https://static001.geekbang.org/resource/image/d2/81/d28f5b8c8cdf8f20dc20566ab45f7181.gif"}顺序旋转的四个方块插值与缓动函数我们前面说过，时序动画的好处就在于，它能更容易地控制动画的细节。那针对我们总结出的这个标准的动画模型，它又如何控制动画细节呢？假设，我们已知元素的起始状态、结束状态和运动周期。如果想要让它进行不规则运动，我们可以使用插值的方式来控制每一帧的展现。比如说，我们可以先实现一个匀速运动的方块，再通过插值与缓动函数来实现变速运动。首先，我们用 Animator 实现一个方块，让它从 100px处**匀速运动**到 400px处。注意，在代码实现的时候，我们使用了一个线性插值方法：left = start \*(1 - p) + end \*p。线性插值可以很方便地实现属性的均匀变化，所以用它来让方块做匀速运动是非常简单的。但如果是让方块非匀速运动，比如匀加速运动，我们要怎么办呢？    import {Animator} from '../common/lib/animator/index.js';    const block = document.querySelector('.block');    const animator = new Animator({duration: 3000});    document.addEventListener('click', () => {      animator.animate({el: block, start: 100, end: 400}, ({target: {el, start, end}, timing: {p}}) => {        const left = start * (1 - p) + end * p;        el.style.left = `${left}px`;      });    });实现技巧也很简单，我们仍然可以使用线性插值，只不过要对插值参数 p做一个函数映射。比如说，如果要让方块做初速度为 0的匀加速运动，我们可以将 p 映射为p\^2。     p = p ** 2;    const left = start * (1 - p) + end * p;再比如说，如果要让它做末速度为 0 的匀减速运动，我们可以将 p 映射为 p\* (2 - p)。    p = p * (2 - p);    const left = start * (1 - p) + end * p;那为什么匀加速、匀减速的时候，p要这样映射呢？要理解这一点，我们就得先来回忆一下，匀加速和匀减速运动的物理计算公式。假设，某个物体在做初速度为 0 的匀加速运动，运动的总时间为 T，总位移为S。那么，它在 t时刻的位移和加速度的计算公式如下：![](Images/9c7900acc5d8b006ef7c0025658d207b.png)savepage-src="https://static001.geekbang.org/resource/image/fb/f3/fb1502fd6d2bca1db9921a5847409cf3.jpeg"}匀加速运动的计算公式所以我们把 p 映射为 p的平方。 还是同样的情况下，如果物体在做匀减速运动，那么，它在 t时刻的位移和加速度的计算公式如下：![](Images/a036c26a2da2a3cb1a1bb978fc3861fa.png)savepage-src="https://static001.geekbang.org/resource/image/5f/d2/5f9726b346e444775080ac98b8e93dd2.jpeg"}匀变速运动的计算公式所以我们把 p 映射为 p(2-p)。除此以外，我们还可以将 p 映射为三次曲线 p \* p \* (3.0 - 2.0 \* p)，来实现 smoothstep的插值效果等等。那为了方便使用以及实现更多的效果，我们可以抽象出一个映射函数专门处理p 的映射，这个函数叫做**缓动函数**（EasingFunction）。我们可以在前面实现过的 Timing 类中，直接增加一个缓动函数easing。这样在获取 p 值的时候，我们直接用 this.easing(progress)取代之前的progress，就可以让动画变速运动了。修改后的代码如下：    export class Timing {      constructor({duration, iterations = 1, easing = p => p} = {}) {        this.startTime = Date.now();        this.duration = duration;        this.iterations = iterations;        this.easing = easing;      }      get time() {        return Date.now() - this.startTime;      }      get p() {        const progress = Math.min(this.time / this.duration, this.iterations);        return this.isFinished ? 1 : this.easing(progress % 1);      }      get isFinished() {        return this.time / this.duration >= this.iterations;      }    }那带入到具体的例子中，我们只要多给 animator 传一个 easing参数，就可以让一开始匀速运动的小方块变成匀加速运动了。下面就是我们使用这个缓动函数的具体代码：    import {Animator} from '../common/lib/animator/index.js';    const block = document.querySelector('.block');    const animator = new Animator({duration: 3000, easing: p => p ** 2});    document.addEventListener('click', () => {      animator.animate({el: block, start: 100, end: 400}, ({target: {el, start, end}, timing: {p}}) => {        const left = start * (1 - p) + end * p;        el.style.left = `${left}px`;      });    });贝塞尔曲线缓动现在，我们已经缓动函数的应用了。缓动函数有很多种，其中比较常用的是贝塞尔曲线缓动（Bezier-easing），准确地说，是三次贝塞尔曲线缓动函数。接下来，我们就来一起来实现一个简单的贝塞尔曲线缓动。我们先来复习一下三次贝塞尔曲线的参数方程：![](Images/5bca8323a590ead52f2ee4cbc225b41f.png)savepage-src="https://static001.geekbang.org/resource/image/50/6e/50dea3d53d0d81a49b6a3cb982629e6e.jpg"}对于贝塞尔曲线图形来说，t 是参数，P是坐标。而贝塞尔曲线缓动函数，则是把 Px 作为时间参数 p，把 Py 作为 p的映射。这样，我们就知道了参数方程和缓动函数之间映射关系了。![](Images/c4238e6a26b9bebcbcdaf1d195305cf2.png)savepage-src="https://static001.geekbang.org/resource/image/f7/0b/f764285ab9554604937917e38f7c440b.jpg"}](https://react.rocks/example/bezier-easing-editor)贝塞尔缓动函数，图盘来源：React.js那要想把三次贝塞尔曲线参数方程变换成贝塞尔曲线缓动函数，我们可以使用一种数学方法，叫做**牛顿迭代法**（Newton'smethod）。因为这个方法比较复杂，所以我就不展开细说了。我们可以使用现成的 JavaScript库bezier-easingslate-object="inline"来生成贝塞尔缓动函数，例如：    import {Animator} from '../common/lib/animator/index.js';    const block = document.querySelector('.block');    const animator = new Animator({duration: 3000, easing: BezierEasing(0.5, -1.5, 0.5, 2.5)});    document.addEventListener('click', () => {      animator.animate({el: block, start: 100, end: 400}, ({target: {el, start, end}, timing: {p}}) => {        const left = start * (1 - p) + end * p;        el.style.left = `${left}px`;      });    });这样，我们能得到如下的效果：![](Images/f6bf10c55cbec5e00770af977d91e55a.png)savepage-src="https://static001.geekbang.org/resource/image/a8/18/a81289f987f354f7bdd1e983c9472418.gif"}实际上，CSS3 动画原生支持bezier-easing。所以上面的效果，我们也可以使用 CSS3动画来实现。    .container {      display: flex;      flex-wrap: wrap;      justify-content: space-between;      width: 300px;    }    .block {      width: 100px;      height: 100px;      position: absolute;      top: 100px;      left: 100px;      background: blue;      flex-shrink: 0;      transform-origin: 50% 50%;    }    .animate {      animation: mymove 3s cubic-bezier(0.5, -1.5, 0.5, 2.5) forwards;    }    @keyframes mymove {      from {left: 100px}      to {left: 400px}    }其实贝塞尔缓动函数还有很多种，你可以去easing.netslate-object="inline"这个网站里看一看，然后尝试利用里面提供的缓动函数，来修改我们例子代码中的效果，看看动画过程有什么不同。要点总结这节课，我们讲了动画的三种形式和实现它们的基本方法，并且我们重点讨论了由时序动画衍生的标准动画模型，以及在此基础上，利用线性插值和缓动函数来控制更多动画细节。首先，我们来回顾一下这三种形式的实现方法和各自的特点：1.  第一种，固定帧动画。它实现起来最简单，只需要我们为每一帧准备一张图片，然后循环播放就可以了。        2.  第二种，增量动画。虽然在实现的时候，我们需要在每帧给元素的相关属性增加一定的量，但也很好操作，就是不好精确控制动画细节。        3.  第三种是使用时间和动画函数来描述的动画，也叫做时序动画。这种方法能够非常精确地控制动画的细节，所以它能实现的动画效果更丰富，应用最广泛。        然后，为了更方便使用，我们根据时序动画定义了标准动画模型，实现了Animator类。基于此，我们就可以使用线性插值来实现动画的匀速运动，通过缓动函数来改变动画的运动速度。在动画的实现中，比较常用贝塞尔曲线缓动函数。它是通过对贝塞尔曲线方程进行牛顿迭代求出，我们可以使用bezier-easing 库来创建贝塞尔缓动函数。CSS3 动画原生支持bezier-easing，所以如果使用 HTML/CSS 方式绘制元素，我们可以尽量使用 CSS3动画。 小试牛刀最后，我希望你能利用我们今天学到的时序动画，来实现一个简单的动画效果。就是我们假设，有一个半径为10px 的弹性小球，我们让它以自由落体的方式下落 200px高度。在这个过程中，小球每次落地后弹起的高度会是之前的一半，然后它会不断重复自由下落的过程，直到静止在地面上。你能试着用标准动画模型封装好的 Animator模块，来实现这个效果吗？Animator 模块的代码你可以在 Github仓库中找到，也可以直接按照我们前面讲解内容自己实现一下。  源码本节课的完整示例代码见slate-object="mark"}GitHub 仓库slate-object="mark"}推荐阅读\[1\] 牛顿迭代法slate-object="mark"}\[2\] Bezier-easingslate-object="mark"}\[3\] Easing.netslate-object="mark"}