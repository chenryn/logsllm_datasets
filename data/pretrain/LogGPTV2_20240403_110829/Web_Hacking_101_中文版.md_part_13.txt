的标志是 。
url=
其次，不要仅限于你的第一想法。Brett 完全能够报告 XSS 载荷，但是这不太深入。通
过深入挖掘，它就能发现漏洞的真正价值。但是这样做的时候，要小心不要越界。
总结
88
十七、服务端请求伪造
服务端请求伪造在服务器可悲利用来代表攻击者执行请求时出现。但是，并不是所有请求最
终都能利用。例如，由于站点允许你提供图片的 URL，但它会复制并在自己站点上使用（就
像上面的 ESEA 示例），并不意味站点存在漏洞。发现它们只是第一步，随后你需要确认它
们的潜能。对于 ESEA，虽然站点寻找图片文件，它并不验证收到的东西，并且可以用于渲
染恶意 XSS，以及对自己的 EC2 元数据执行 HTTP 请求。
89
十八、内存
十八、内存
作者：Peter Yaworski
译者：飞龙
协议：CC BY-NC-SA 4.0
描述
缓冲区溢出是一个场景，其中程序向缓冲区或内容区域写入数据，写入的数据比实际分配的
区域要多。使用冰格来考虑的话，你可能拥有 12 个空间，但是只想要创建 10 个。在填充格
子的时候，你添加了过多的水，填充了 11 个位置而不是 10 个。你就溢出了冰格的缓存区。
缓冲区溢出在最好情况下，会导致古怪的程序行为，最坏情况下，会产生严重的安全漏洞。
这里的原因是，使用缓冲区移除，漏洞程序就开始使用非预期数据覆盖安全数据，之后会调
用它们。如果这些发生了，覆盖的代码会是和程序的预期完全不同的东西，这会产生错误。
或者，恶意用户能够使用移除来写入并执行恶意代码。
这里是来自 Apple 的一个图片：
这里第一个例子展示了可能的缓冲区溢出。 接受字符串 ，并将其写入到内
strcpy Larger
存，无论分配的可用空间（白色格子），以及将其写入非预期的内容中（红色格子）。
越界读取
除了越过分配的内容写入数据之外，另一个漏洞时越过内容边界读取数据。这是一类缓冲区
溢出，因为内容被越界读取，这是缓存区不允许的。
90
十八、内存
越界读取数据漏洞的一个著名的近期示例，是 OpenSSL Heartbleed 漏洞，在 2014 年 4 月发
现。在发现的时候，大约 17%（500K）的互联网安全服务器，由可信授权机构颁发证书，被
认为存在此漏洞。
Heartbleed 可以利用来盗取服务器的私钥，回话数据，密码，以及其他。它通过向服务器发
送“Heatbleed 请求”消息来执行，服务器会向请求者发送相同信息。消息包含长度参数。那些
漏洞服务器会基于长度参数为消息分配内存，而不验证消息的真实大小。
因此，Heartbleed 消息通过发送小型消息以及较大的长度参数来利用，存在漏洞的接受者会
读取额外数据，这超出了为消息分配的内存长度。这里是来自维基百科的图片：
虽然缓冲区溢出需要更详细的分析，读取越界和 Heartbleed 超出了本书的范围。如果你对它
们感兴趣，这里是一些不错的资源：
Apple 的文档
91
十八、内存
维基百科：缓冲区溢出词条
维基百科：NOP 垫
OWASP：缓冲区溢出
heartbleed.com
内存截断
内存截断是一种技巧，用于通过使代码执行一些不常见或者非预期的行为，来发现漏洞。它
的效果类似于缓冲区溢出，其中内容在不该暴露的时候暴露了。
一个例子是空字节注入。这发生在提供了空字节 或者十六进制的 ，并导致接收程
%00 0x00
序的非预期行为时。在 C/C++，或低级编程语言中，空字节表示字符串的末尾，或者字符串
的终止符。这可以告诉程序来立即停止字符串的处理，空字节之后的字节就被忽略了。
当代码依赖字符串长度时，它的影响力十分巨大。如果读取了空字节，并停止了处理，长度
为 10 的字符串就只剩 5 了。例如：
thisis%00mystring
这个字符串的长度应该为 15，暗示如果字符串以空字节终止，它的长度为 6。这对于管理自
己的内存的低级语言是有问题的。
现在，对于 Web 应用，当 Web 应用和库、外部 API 以及其它用 C 写成的东西交互的时候，
这就有关系了。向 URL 传入 %00 可能使攻击者操作更广泛服务器环境中的 Web 资源。尤其
是当编程语言存在问题的时候，例如 PHP，它是使用 C 语言编写的。
OWASP 链接
查看 OWASP 缓冲区溢出，OWASP 为缓冲区覆盖和溢出复查代码，OWASP 检测缓冲
区溢出，OWASP 检测堆溢出，OWASP 检测栈溢出，OWASP 嵌入空字符。
示例
1. PHP ftp_genlist()
难度：高
URL：无
报告链接：
https://bugs.php.net/bug.php?id=69545
报告日期：2015.5.12
92
十八、内存
奖金：$500
描述：
PHP 编程语言使用 C 语言写成，C 语言自己管理内存。像上面描述的那样，缓冲区溢出允许
恶意用户写入应该为不可访问的内存，并可能执行远程代码。
这里，FTP 扩展 的 ftp_genlist() 函数允许溢出，或者发送多于 ~4293MB 的数据，它们会
被写入到临时文件中。
这使得分配的缓冲区太小，而不能存放写入临时文件的数据，在将文件内容加载回内存时，
这会造成堆溢出。
重要结论
缓冲区溢出是非常古老，知名的漏洞，但是在处理自己管理内存的应用时，还是很普遍
的，特别是 C 和 C++。如果你发现，你正在处理基于 C 语言（PHP 用它编写）的 Web
应用，缓冲区溢出是一个明显的可能性。但是，如果你刚起步，可能你值得花费更多时
间，来寻找和漏洞相关的简单注入，在更有经验时，再返回到缓冲区溢出。
2. Python Hotshot 模块
难度：高
URL：无
报告链接：
http://bugs.python.org/issue24481
报告日期：2015.7.20
奖金：$500
描述：
像 PHP 一样，Python 编程语言也是用 C 编写的，它在之前提到过，自己管理内存。Python
Hotshot 模块是一个现有 profile 模块的替代品，并且几乎都是用 C 编写，比现有的 profile 模
块产生一些更微小的性能影响。但是 2015 年 7 月，该模块中发现了缓冲区溢出漏洞，和尝试
将字符串从一个内容位置复制到另一个的代码有关。
本质上，这个漏洞的代码叫做 方法，它将内容从一个地方复制到另一个地址，接受要
memcpy
复制的字节数。像这样：
memcpy(self->buffer + self->index, s, len);
这个方法接受 3 个参数， str ， str2 和 n 。 str 是目标， str2 是要复制的来源， n 是要
复制的字节数。这里，它们对应 ， 和 。
self->buffer + self->index s len
93
十八、内存
这里，漏洞实际上是， 总是固定长度的，但是 可以为任意长度。
self->buffer s
因此，在执行 copy 函数时（就像上面的 Apple 图表那样）， memcpy 函数忽视了目标区域的
真实大小，因此造成了溢出。
重要结论
我们现在查看了两个函数的例子，它们的不正确实现都收到了缓冲区溢出的影
响， memcpy 和 strcpy 。如果我们知道某个站点或者应用依赖 C 或者 C++，我们就可以
遍历还语言的源代码库（使用类似 的东西），来寻找不正确的实现。
grep
关键是寻找这样的实现，它向二者之一传递固定长度的变量作为第三个函数，对应被分
配的数据长度，在数据复制时，它实际上是变量的长度。
但是，像之前提到的那样，如果你刚刚起步，可能你需要放弃搜索这些类型的漏洞，等
你更熟悉白帽子渗透时再回来。
3. Libcurl 越界读取
难度：高
URL：无
报告链接：
http://curl.haxx.se/docs/adv_20141105.html
报告日期：2014.11.5
奖金：$1000
描述：
Libcurl 是一个免费的客户端 URL 库，并且由 CURL 命令行工具用于转送数据。libcurl
的 函数中发现了一个漏洞，它可以利用来发送本不应传输的敏感数
curl_easy_duphandle()
据。
在使用 libcurl 执行数据传输时，我们可以使用一个选项， CURLOPT_COPYPOSTFIELDS ，来为要
发送给远程服务器的数据指定内存区域。换句话说，为你的数据找一块地方。区域大小使用
单独的选项来设置。
现在，我们没必要非常技术化，内存区域和一个“句柄”相关（理解清楚“句柄”超出了本书范
围，所以没必要了解），并且应用会复制句柄来创建数据的副本。这就是漏洞所在，复制的
实现使用了 ，而数据被假设拥有空字符作为字符串末尾。
strdup
这种情况下，数据可能没有，或者在任意位置上拥有空字符。因此，复制的句柄可能过小，
过大，或者使程序崩溃。此外，在复制之后，发送数据的函数并没有考虑已经读取和复制的
数据，所以它也越过了预期的内存地址来访问和发送数据。
94
十八、内存
重要结论
这是一个非常复杂的漏洞的示例。虽然它对于这本书来说，过于技术化了，我将其包含
来展示它与我们所学的东西的相似性。当我们将其分解时，这个漏洞也与 C 语言代码实
现中的一个错误相关，而 C 语言与内存管理和复制相关。同样，如果你打算开始 C 程序
的漏洞挖掘，要寻找数据从一块区域复制到另一块区域的地方。
4. PHP 内存截断
难度：高
URL：无
报告链接：
https://bugs.php.net/bug.php?id=69453
报告日期：2015.4.14
奖金：$500
描述：
phar_parse_tarfile 函数并没有考虑以空字符开始的文件名称，空字符是值为 0 的字节，即
十六进制的 。
0x00
在该方法的执行期间，当使用文件名称时，数组会发生下溢（即尝试访问不存在的数据，并
超出了数组分配的内存）。
这是个重要漏洞，因为它向黑客提供了本该限制的内存的访问权。
重要结论
在处理自己管理内存的应用时，特别是 C 和 C++，就像缓冲区溢出那样，内存截断是个古老
但是仍旧常见的漏洞。如果你发现，你正在处理基于 C 语言的 Web 应用（PHP 使用它编
写），要留意内存操作的方式。但是同样，如果你刚刚起步，你可能值得花费更多时间来寻
找简单的注入漏洞，当你更熟练时，再回到内存截断。
总结
虽然内存相关的漏洞能搞个大新闻，但他们也非常难以处理，并需要相当大量的技巧。这些
类型的漏洞最好还是留着，除非你拥有底层编程语言的编程背景。
虽然现代的程序语言不太可能受其影响，由于它们的内存处理和垃圾收集策略，用 C 语言编
写的应用仍然易受影响。此外，当你处理用 C 语言编写的现代语言时，事情可能需要一些技
巧，就像我们在 PHP ftp_genlist() 和 Python Hotspot 模块的示例中看到的那样。
95
十八、内存
96
十九、起步
十九、起步
97
二十、漏洞报告
二十、漏洞报告
作者：Peter Yaworski
译者：飞龙
协议：CC BY-NC-SA 4.0
所以这一天终于来了，你发现了你的第一个漏洞。 首先，恭喜你！ 认真来讲，发现漏洞并不