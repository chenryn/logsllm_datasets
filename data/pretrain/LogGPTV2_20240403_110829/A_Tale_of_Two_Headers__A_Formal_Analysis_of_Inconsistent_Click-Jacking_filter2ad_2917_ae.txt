behaves as follows:
1. if multiple XFO headers are present in r, they are ﬁrst
folded into one XFO header set to a comma-separated
list of the speciﬁed directives;
2. after step 1, r is guaranteed to contain exactly one XFO
header. If the header contains a comma-separated list of
directives, it is replaced by a single directive enforcing
the same security restrictions of the conjunction of the
directives. This is always possible, thanks to the simpli-
ﬁcation rules in Table 8;
3. the proxy ﬁnally attaches to r a new CSP header enforc-
ing the same framing control restrictions of the sanitized
XFO header. This is straightforward, since CSP is more
expressive than XFO, and does not conﬂict with other
CSP headers possibly present in r, since, when multiple
CSP headers are sent, their conjunction is enforced and
no other frame-ancestors directive is present.
If r contains CSP headers with a frame-ancestors direc-
tive, the proxy instead behaves as follows:
1. all the XFO headers of r are stripped away;
2. the proxy computes the union of the source expressions
whitelisted in all the frame-ancestors directives con-
tained in the CSP headers of r;
3. if CSP denies framing, r is extended with an XFO header
containing the DENY directive. If instead CSP only al-
lows same-origin framing, r is extended with an XFO
header containing the SAMEORIGIN directive. Other-
wise, the proxy checks if the Referer header of r contains
a URL whitelisted by any of the source expressions iden-
tiﬁed at step 2: if this is the case, r is extended with an
XFO header containing an ALLOW-FROM directive set
to the origin of the Referer header; otherwise, the XFO
header is set to DENY. If r lacks the Referer header, the
proxy conservatively sets the XFO header to DENY.
Eventually, the proxy ensures the consistency of framing
control policies with respect to the set of tested browsers,
by equating the security guarantees of XFO and CSP (up to
double framing). Observe that, although Opera Mini supports
neither CSP nor ALLOW-FROM, the proxy still manages
to rectify its limitations. In particular, if the Referer of the
request is set to a whitelisted URL, the proxy sets XFO to
the corresponding ALLOW-FROM directive, which is just
ignored by Opera Mini and framing is allowed. Otherwise,
the proxy sets XFO to DENY, and the page cannot be framed.
In our design, we prioritize CSP headers over XFO head-
ers when both are present since CSP is the preferred method
to enforce framing control in modern browsers. This means
that it is occasionally possible for the proxy to relax security
restrictions beyond least privilege: for example, if a page sets
XFO to DENY and CSP allows same-origin framing, then
XFO will be relaxed to SAMEORIGIN. However, this is sen-
sible from a security perspective, because modern browsers
already allow same-origin framing, so we assume this was
694    29th USENIX Security Symposium
USENIX Association
intended by the site administrators, as modern browsers are
the primary target in the market and are also easier to test.
This is also backed up by our dataset, where we observed only
13 policies where XFO was tighter than CSP and CSP was
conﬁgured in an obviously insecure manner (see Table 7).
As a ﬁnal point, we note that the Referer header may be
stripped when controlled through the Referrer-Policy [16],
which would disable the possibility of performing Referer
snifﬁng in the proxy. However, Referrer-Policy is only sup-
ported in browsers that also support the frame-ancestors di-
rective of CSP. Since the proxy only relies on Referer snifﬁng
in the presence of frame-ancestors, the DENY directive
placed in the absence of the Referer header would be overrid-
den by CSP in all cases. After implementing our proxy, we
tested it out against the full set of test cases of Section 4.2. By
doing so, we conﬁrmed that the proxy behaves as expected
and enforces the same security restrictions in the entire pool
of browsers.
7 Related Work
In this section, we present related work, and for the work
closest to ours, we explain the main differences.
CSP and XFO for Framing Control
In their 2019 paper,
Luo et al. [14] studied the evolution of mobile browsers and
their support for client-side security mechanisms over time.
In doing so, they also documented the interplay between CSP
and XFO, reporting in particular that some mobile browsers
did not prioritize CSP over XFO in the past. Their paper
generically hints that inconsistencies between CSP and XFO
could occur based on the collected headers, yet the paper does
not go much in detail about this. The increased importance
of CSP for framing control was also documented by Roth
et al. [19], who analyzed the evolution of CSP from 2012 to
2018, indicating that CSP has become more and more pop-
ular as a protection mechanism against click-jacking. They
also evaluated the dangers coming from the inconsistent sup-
port for ALLOW-FROM and CSP in different browsers, most
notably by leveraging the well-known observation that the
ALLOW-FROM directive is not supported in Chrome.
Though both these studies have been inspiring starting
points for our work, we extend the mere analysis of the po-
tential problems by building a comprehensive framework to
reason about inconsistencies. In particular: (i) we formally de-
ﬁne the problem of inconsistencies in framing control policies
to provide a full account of this security problem, highlight-
ing different classes of inconsistencies with different security
implications; (ii) we focus on both desktop browsers and mo-
bile browsers, exposing many new and unreported dangerous
implementations of the underspeciﬁed XFO header; (iii) we
perform an in-depth analysis of several root causes of incon-
sistencies in the wild, their security import, and some possible
countermeasures, discussing the potential role of browser ven-
dors on the way forward; and (iv) we implement and release a
server-side proxy designed to retroﬁt security in existing Web
applications by enforcing consistency for the set of browsers
that we analyzed.
Click-Jacking Protection and Attacks
In 2010, Rydstedt
et al. [20] studied the usage of frame busting scripts in the
Alexa Top 500 sites, showing that the deployed mechanisms
through JavaScript were trivial to bypass. In the same year,
Balduzzi et al. [2] built a system capable of detecting click-
jacking, primarily based on the assumption that elements
should not be overlapping when clicked. In 2012, Lekies
et al. [12] highlighted additional techniques for bypassing
existing defenses and showed the shortcomings of XFO for
ﬁne-grained framing control. In the same year, Huang et al.
[7] conducted an in-depth analysis of the underlying issues
and proposed INCONTEXT, in which applications could mark
speciﬁc elements as sensitive (e.g., Like buttons), which
would, through various defensive techniques, be protected
from forced clicks at the browser. In 2014, Akhawe et al. [1]
generalized click-jacking to perceptual UI attacks and showed
how easily users could be tricked into clicking unwanted ele-
ments while seemingly playing a benign game.
Inconsistencies in Web Security
Inconsistencies in the im-
plementation of client-side security mechanisms have been
ﬁrst studied by Singh et al. [22]. Their seminal work focused
on access control policies and, in particular, on parts of the
Same Origin Policy (SOP), which proved to be inconsistently
implemented in existing Web browsers at the time. A similar
study was later performed on modern browsers by Schwenk
et al., and also exposed dangerous inconsistencies [21]. Au-
tomated testing has been proposed as an effective technique
to catch bugs in the implementation of client-side security
mechanisms by Hothersall-Thomas et al. [6]. None of these
studies focused on inconsistencies in framing control policies.
Naturally, the client is not the only software where inconsis-
tencies may occur. In particular, prior work has investigated
the handling of multiple Host headers in CDNs and origin
servers, showing that due to differences in handling multi-
ple headers, these two components end up with a different
understanding of the requested host [5]. In a recent paper,
Nguyen et al. [17] showed that inconsistencies in allowed
header lengths or control characters could allow an attacker to
force origin servers to yield error pages. This, in combination
with CDNs that cache such error pages, can lead to a cache-
poisoned Denial of Service attack. In non-academic research,
Kettle [10] showed that using multiple Content-Length head-
ers as well as conﬂicting Transfer-Encoding allows for HTTP
Desync attacks. Albeit only indirectly related to our paper,
these works clearly document the dangers of inconsistent
implementations on the Web.
USENIX Association
29th USENIX Security Symposium    695
Finally, Mendoza et al. [15] studied the inconsistent adop-
tion of security mechanisms in the mobile and the desktop
version of the same Web site. They even showed attacks where
the insecurity of a mobile site could be exploited to target the
desktop site, which sits at a higher security level.
8 Conclusion
In this paper, we presented the ﬁrst comprehensive analysis
of inconsistencies in framing control policies. We based our
investigation on a formal framework, which constituted the
basis for the implementation of a real-world policy analyzer
dubbed FRAMECHECK. Our analysis of 10,000 Web sites
from the Tranco list showed that the problem of inconsisten-
cies is widespread on the Web, since around 10% of the (dis-
tinct) framing control policies in the wild are inconsistent and
most often do not provide any form of protection to at least
one browser. Given the insights of the dangers caused through
inconsistencies, we proposed different countermeasures in
terms of recommendations for Web developers and browser
vendors, as well as the implementation of a server-side proxy
designed to retroﬁt security to existing Web applications. We
are currently in the process of responsibly disclosing the se-
curity issues found throughout our comprehensive analysis to
the affected browser vendors and site operators.
We foresee a few avenues for future work. First, we would
like to extend our current analysis to uncover inconsistencies
between the desktop version and the mobile version of the
same Web site, following the approach proposed by Mendoza
et al. [15]. Then, we plan to generalize our formal framework
to other client-side security mechanisms besides XFO and the
framing control fragment of CSP. Finally, we would like to
carry out a systematic analysis of the compatibility impact
of some of our proposed countermeasures, which we only
evaluated in terms of security so far. This might require close
collaboration with browser vendors to understand their impact
on a large scale.
Acknowledgements
We would like to thank the reviewers for their advices on
how to improve the presentation of our paper. In particular,
we thank Adam Doupé for his guidance in the shepherding
process. Furthermore, we want to thank Alexander Fink for
the helpful discussions regarding implementation details of
the proxy’s network trafﬁc interception.
References
[1] Devdatta Akhawe, Warren He, Zhiwei Li, Reza
Moazzezi, and Dawn Song. Clickjacking revisited: A
In USENIX WOOT,
perceptual view of UI security.
2014.
[2] Marco Balduzzi, Manuel Egele, Engin Kirda, Davide
Balzarotti, and Christopher Kruegel. A solution for the
automated detection of clickjacking attacks. In AsiaCCS,
2010.
[3] Michele Bugliesi, Stefano Calzavara, Riccardo Focardi,
and Wilayat Khan. Cookiext: Patching the browser
against session hijacking attacks. Journal of Computer
Security, 23(4), 2015.
[4] Stefano Calzavara, Alvise Rabitti, and Michele Bugliesi.
Semantics-based analysis of content security policy de-
ployment. TWEB, 12(2), 2018.
[5] Jianjun Chen, Jian Jiang, Haixin Duan, Nicholas Weaver,
Tao Wan, and Vern Paxson. Host of troubles: Multiple
host ambiguities in http implementations. In CCS. ACM,
2016.
[6] Charlie Hothersall-Thomas, Sergio Maffeis, and Chris
Novakovic. Browseraudit: automated testing of browser
security features. In ISSTA, 2015.
[7] Lin-Shung Huang, Alexander Moshchuk, Helen J. Wang,
Stuart Schecter, and Collin Jackson. Clickjacking: At-
tacks and defenses. In USENIX Security, 2012.
[8] Internet Engineering Task Force. Hypertext transfer
protocol (http/1.1): Message syntax and routing, . URL
https://tools.ietf.org/html/rfc7230.
[9] Internet Engineering Task Force. Http header ﬁeld
x-frame-options, . URL https://tools.ietf.org/
html/rfc7034.
[10] James Kettle.
HTTP Desync Attacks:
Reborn.
Online
Smuggling
Request
https://portswigger.net/research/
http-desync-attacks-request-smuggling-reborn.
[11] Michael Kranch and Joseph Bonneau. Upgrading
HTTPS in mid-air: An empirical study of strict transport
security and key pinning. In NDSS, 2015.
[12] Sebastian Lekies, Mario Heiderich, Dennis Appelt,
Thorsten Holz, and Martin Johns. On the fragility and
limitations of current browser-provided clickjacking pro-
tection schemes. In USENIX WOOT, 2012.
[13] Lukas Weichselbaum and Michele Spagnuolo. CSP - A
Successful Mess Between Hardening and Mitigation.
Online
https://static.sched.com/hosted_
files/locomocosec2019/db/CSP%20-%20A%
20Successful%20Mess%20Between%20Hardening%
20and%20Mitigation%20%281%29.pdf.
[14] Meng Luo, Pierre Laperdrix, Nima Honarmand, and
Nick Nikiforakis. Time does not heal all wounds: A
696    29th USENIX Security Symposium
USENIX Association
longitudinal analysis of security-mechanism support in
mobile browsers. In NDSS, 2019.
Jackson. Busting frame busting: a study of clickjacking
vulnerabilities on popular sites. In W2SP, 2010.
[15] Abner Mendoza, Phakpoom Chinprutthiwong, and
Guofei Gu. Uncovering HTTP header inconsistencies
and the impact on desktop/mobile websites. In WWW,
2018.
[16] Mozilla Developer Network. Referrer-Policy. Online
https://developer.mozilla.org/en-US/docs/
Web/HTTP/Headers/Referrer-Policy.
[17] Hoai Viet Nguyen, Luigi Lo Iacono, and Hannes Feder-
rath. Your cache has fallen: Cache-poisoned denial-of-
service attack. In CCS, 2019.
[18] Victor Le Pochat, Tom van Goethem, Samaneh Tajal-
izadehkhoob, Maciej Korczynski, and Wouter Joosen.
Tranco: A research-oriented top sites ranking hardened
against manipulation. In NDSS, 2019.
[19] Sebastian Roth, Timothy Barron, Stefano Calzavara,
Nick Nikiforakis, and Ben Stock. Complex Security
Policy? – A Longitudinal Analysis of Deployed Content
Security Policies. In NDSS, 2020.
[20] Gustav Rydstedt, Elie Bursztein, Dan Boneh, and Collin
[21] Jörg Schwenk, Marcus Niemietz, and Christian Mainka.
Same-origin policy: Evaluation in modern browsers. In
USENIX Security, 2017.
[22] Kapil Singh, Alexander Moshchuk, Helen J. Wang, and
Wenke Lee. On the incoherencies in web browser access
control policies. In IEEE S&P, 2010.
[23] Ben Stock, Martin Johns, Marius Steffens, and Michael
Backes. How the web tangled itself: Uncovering the his-
tory of client-side web (in)security. In USENIX Security,
2017.
[24] Tom Van Goethem, Ping Chen, Nick Nikiforakis, Lieven
Desmet, and Wouter Joosen. Large-scale security anal-
ysis of the web: Challenges and ﬁndings. In TRUST,
2014.
[25] Lukas Weichselbaum, Michele Spagnuolo, Sebastian
Lekies, and Artur Janc. CSP is dead, long live csp!
on the insecurity of whitelists and the future of content
security policy. In CCS, 2016.
USENIX Association
29th USENIX Security Symposium    697