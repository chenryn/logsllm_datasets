10.11 代码断点
10.11.1 陷阱指令
10.11.2 在GPU调试SDK中的使用
10.12 GPU调试模型和开发套件
10.12.1 组成
10.12.2 进程内调试模型
10.12.3 面向事件的调试接口
10.13 ROCm-GDB
10.13.1 源代码
10.13.2 安装和编译
10.13.3 常用命令
10.14 本章小结
参考资料
第11章 英特尔GPU及其调试设施
11.1 演进简史
11.1.1 i740
11.1.2 集成显卡
11.1.3 G965
11.1.4 Larabee
11.1.5 GPU
11.1.6 第三轮努力
11.1.7 公开文档
11.2 GEN微架构
11.2.1 总体架构
11.2.2 片区布局
11.2.3 子片布局
11.2.4 EU
11.2.5 经典架构图
11.3 寄存器接口
11.3.1 两大类寄存器
11.3.2 显示功能的寄存器
11.4 命令流和环形缓冲区
11.4.1 命令
11.4.2 环形缓冲区
11.4.3 环形缓冲区寄存器
11.5 逻辑环上下文和执行列表
11.5.1 LRC
11.5.2 执行链表提交端口
11.5.3 理解LRC的提交和执行过程
11.6 GuC和通过GuC提交任务
11.6.1 加载固件和启动GuC
11.6.2 以MMIO方式通信
11.6.3 基于共享内存的命令传递机制
11.6.4 提交工作任务
11.7 媒体流水线
11.7.1 G965的媒体流水线
11.7.2 MFX引擎
11.7.3 状态模型
11.7.4 多种计算方式
11.8 EU指令集
11.8.1 寄存器
11.8.2 寄存器区块
11.8.3 指令语法
11.8.4 VLIW和指令级别并行
11.9 内存管理
11.9.1 GGTT
11.9.2 PPGTT
11.9.3 I915和GMMLIB
11.10 异常
11.10.1 异常类型
11.10.2 系统过程
11.11 断点支持
11.11.1 调试控制位
11.11.2 操作码匹配断点
11.11.3 IP匹配断点
11.11.4 初始断点
11.12 单步执行
11.13 GT调试器
11.13.1 架构
11.13.2 调试事件
11.13.3 符号管理
11.13.4 主要功能
11.13.5 不足
11.14 本章小结
参考资料
第12章 Mali GPU及其调试设施
12.1 概况
12.1.1 源于挪威
12.1.2 纳入ARM
12.1.3 三代微架构
12.1.4 发货最多的图形处理器
12.1.5 精悍的团队
12.1.6 封闭的技术文档
12.1.7 单元化设计
12.2 Midgard微架构
12.2.1 逻辑结构
12.2.2 三流水线着色器核心
12.2.3 VLIW指令集
12.3 Bifrost微架构
12.3.1 逻辑结构
12.3.2 执行核心
12.3.3 标量指令集和Warp
12.4 Mali图形调试器
12.4.1 双机模式
12.4.2 面向帧调试
12.5 Gator
12.5.1 Gator内核模块（gator.ko）
12.5.2 Gator文件系统（gatorfs）
12.5.3 Gator后台服务（gatord）
12.5.4 Kbase驱动中的gator支持
12.5.5 含义
12.6 Kbase驱动的调试设施
12.6.1 GPU版本报告
12.6.2 编译选项
12.6.3 DebugFS下的虚拟文件
12.6.4 SysFS下的虚拟文件
12.6.5 基于ftrace的追踪设施
12.6.6 Kbase的追踪设施
12.7 其他调试设施
12.7.1 Caiman
12.7.2 devlib
12.7.3 Mali离线编译器
12.8 缺少的调试设施
12.8.1 GPGPU调试器
12.8.2 GPU调试SDK
12.8.3 反汇编器
12.8.4 ISA文档
12.9 本章小结
参考资料
第13章 PowerVR GPU及其调试设施
13.1 概要
13.1.1 发展简史
13.1.2 两条产品线
13.1.3 基于图块延迟渲染
13.1.4 Intel GMA
13.1.5 开放性
13.2 Rogue微架构
13.2.1 总体结构
13.2.2 USC
13.2.3 ALU流水线
13.3 参考指令集
13.3.1 寄存器
13.3.2 指令组
13.3.3 指令修饰符
13.3.4 指令类型
13.3.5 标量指令
13.3.6 并行模式
13.4 软件模型和微内核
13.4.1 软件模型
13.4.2 微内核的主要功能
13.4.3 优点
13.4.4 存在的问题
13.5 断点支持
13.5.1 bpret指令
13.5.2 数据断点
13.5.3 ISP断点
13.6 离线编译和反汇编
13.6.1 离线编译
13.6.2 反汇编
13.7 PVR-GDB
13.7.1 跟踪调试
13.7.2 寄存器访问
13.7.3 其他功能
13.7.4 全局断点和局限性
13.8 本章小结
参考资料
第14章 GPU综述
14.1 比较
14.1.1 开放性
14.1.2 工具链
14.1.3 开发者文档
14.2 主要矛盾
14.2.1 专用性和通用性
14.2.2 强硬件和弱软件
14.3 发展趋势
14.3.1 从固定功能单元到通用执行引擎
14.3.2 从向量指令到标量指令
14.3.3 从指令并行到线程并行
14.4 其他GPU
14.4.1 Adreno
14.4.2 VideoCore
14.4.3 图芯GPU
14.4.4 TI TMS34010
14.5 学习资料和工具
14.5.1 文档
14.5.2 源代码
14.5.3 工具
14.6 本章小结
参考资料
第四篇 可调试性
第15章 可调试性概览
15.1 简介
15.2 观止和未雨绸缪
15.2.1 NT 3.1的故事
15.2.2 未雨绸缪
15.3 基本原则
15.3.1 最短距离原则
15.3.2 最小范围原则
15.3.3 立刻终止原则
15.3.4 可追溯原则
15.3.5 可控制原则
15.3.6 可重复原则
15.3.7 可观察原则
15.3.8 易辨识原则
15.3.9 低海森伯效应原则
15.4 不可调试代码
15.4.1 系统的异常分发函数
15.4.2 提供调试功能的系统函数
15.4.3 对调试器敏感的函数