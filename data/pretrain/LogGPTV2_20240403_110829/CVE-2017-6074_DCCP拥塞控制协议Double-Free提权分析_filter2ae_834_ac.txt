        char            cb[48] __aligned(8);
        unsigned long        _skb_refdst;
        void            (*destructor)(struct sk_buff *skb);    // 这是析构函数，后期在skb内存销毁时会用到
        unsigned int        len,                // 表示数据区的总长度: (tail - data)与分片结构体数据区的长度之和。注意是数据的有效长度
                    data_len;                    // 只表示分片结构体数据区的长度(skb_shared_info->page指向的数据长度)，所以len = (tail - data) + data_len    
        __u16            mac_len,
                    hdr_len;
        ... ...
        __u16            inner_transport_header;    
        __u16            inner_network_header;
        __u16            inner_mac_header;
        __be16            protocol;                // 这是包的协议类型，标识是IP包还是ARP包或者其他数据包。
        __u16            transport_header;        // 指向四层帧头结构体指针
        __u16            network_header;            // 指向三层IP头结构体指针
        __u16            mac_header;                // 指向二层mac头的头
        /* private: */
        __u32            headers_end[0];
        /* public: */
        /* These elements must be at the end, see alloc_skb() for details.  */
        sk_buff_data_t        tail;                // 指向线性数据区中实际数据结束的位置
        sk_buff_data_t        end;                // 指向线性数据区中结束的位置（非实际数据区域结束位置）
        unsigned char        *head,                // 指向线性数据区中开始的位置（非实际数据区域开始位置）
                    *data;                        // 指向数据区中实际数据开始的位置
        unsigned int        truesize;            // 表示缓冲区总长度，包括sk_buff自身长度+线性数据区+分片结构体的数据区长度, truesize = len + sizeof(sk_buff) = (data - tail) + data_len + sizeof(sk_buff)
        atomic_t        users;                    // 引用计数，表明了有多少实体引用了这个skb。其作用就是在销毁skb结构体时，先查看下users是否为零，若不为零，则调用函数递减下引用计数users即可；当某一次销毁时，users为零才真正释放内存空间。有两个操作函数：atomic_inc()引用计数增加1；atomic_dec()引用计数减去1；
    };
####  3-2. sk_buff 线性数据区
**`sk_buff`线性数据区**：数据区的大小是：(skb->end – skb->head)；对于每个数据包来说这个大小都是固定的，而且在传输过程中
`skb->end` 和 `skb->head`
所指向的地址都是不变的。这块数据区是用来存放应用层发下来的数据和各层的协议信息。但在计算数据长度或者操作协议信息时，一般都要和实际的数据存放指针为准。实际数据指针为data和tail，data指向实际数据开始的地方，tail指向实际数据结束的地方。
sk_buff结构体中的指针和数据区关系：
**包构造与数据区变化** ：
  * （1）sk_buff结构数据区刚被申请好，此时head指针、data指针、tail指针都是指向同一个地方。记住前面讲过的：head指针和end指针指向的位置一直都不变，而对于数据的变化和协议信息的添加都是通过data指针和tail指针的改变来表现的。
  * （2）开始准备存储应用层下发过来的数据，通过调用函数 `skb_reserve()` 来使data指针和tail指针同时向下移动，空出一部分空间来为后期添加协议信息。
  * （3）开始存储数据了，通过调用函数 `skb_put()` 来使tail指针向下移动空出空间来添加数据，此时 `skb->data` 和 `skb->tail` 之间存放的都是数据信息，无协议信息。
  * （4）这时就开始调用函数 `skb_push()` 来使data指针向上移动，空出空间来添加各层协议信息。直到最后到达二层，添加完帧头然后就开始发包了。
####  3-3. sk_buff 非线性数据区
**[skb_shared_info](https://elixir.bootlin.com/linux/v4.9.12/source/include/linux/skbuff.h#L414)
分片结构体**：
**这个分片结构体和`sk_buff`结构的线性数据区是一体的**，`sk_buff->end`指针的下个字节就是分片结构的开始位置,所以在各种操作时都把他们两个结构看做是一个来操作。比如：为sk_buff结构的数据区申请和释放空间时，分片结构也会跟着该数据区一起分配和释放。而克隆时，sk_buff
的数据区和分片结构都由分片结构中的 `dataref` 成员字段来标识是否被引用。关系如下图所示：
    struct skb_shared_info {
        unsigned char    nr_frags;            // 表示有多少个分片结构
        __u8        tx_flags;
        unsigned short    gso_size;
        unsigned short    gso_segs;
        unsigned short  gso_type;            // 分片的类型
        struct sk_buff    *frag_list;            // 这也是一种类型的分配数据
        struct skb_shared_hwtstamps hwtstamps;
        u32        tskey;
        __be32          ip6_frag_id;
        atomic_t    dataref;                // 用于数据区的引用计数,克隆一个skb结构体时，会增加一个引用计数
        void *        destructor_arg;
        /* must be last field, see pskb_expand_head() */
        skb_frag_t    frags[MAX_SKB_FRAGS];    // 这是个比较重要的数组，到讲分片结构数据区时会细讲
    };
**分片结构的非线性数据区** ：`skb_shared_info`中有个成员字段，`skb_frag_t
frags[MAX_SKB_FRAGS]`，和分片结构的数据区有关。
    typedef struct skb_frag_struct skb_frag_t;
    struct skb_frag_struct {
        struct page *page;  // 指向分片数据区的指针，类似于sk_buff中的data指针
        __u32 page_offset;  // 偏移量，表示从page指针指向的地方，偏移page_offset
        __u32 size;          // 数据区的长度，即：sk_buff结构中的data_len
    }
有两种数据结构来存储分片数据，一种是采用`frags`数组来存储分片数据区的指针，一种是用`frag_list`双链表来存储。`frags`一般用在数据很多，且线性数据区放不下的情况，`skb_frag_t`中是一页一页的数据；对于`frag_list`，我们在分片的时候装入每个片的信息，每个片最终也被封装成一个小的skb。分别如下图所示：
####  3-4. sk_buff 指针操作函数
**`sk_buff`指针操作函数**：
  * （1）`skb_put()`：向后扩大数据区空间，headroom空间不变，tailroom空间减少，skb->data指针不变，skb->tail指针下移；
  * （2）`skb_push()`：向前扩大数据区空间，headroom空间减少，tailroom空间不变，skb->tail指针不变，skb->data指针上移；
  * （3）`skb_pull()`：缩小数据区空间，headroom空间增大，tailroom空间不变，skb->data指针下移，skb->tail指针不变；
  * （4）`skb_reserve()`：数据区不变，headroom空间增大，tailroom空间减少，skb->data和skb->tail同时下移；
    head-->        |----------|
                | headroom |
    data-->        |----------|
                |   data   |
    tail-->        |----------|
                   | tailroom |
    end -->     |----------|
####  3-5. sk_buff 分配与释放
**skb分配**
：[__alloc_skb()](https://elixir.bootlin.com/linux/v4.9.12/source/net/core/skbuff.c#L203)
，通常被三个函数所调用
[alloc_skb()](https://elixir.bootlin.com/linux/v4.9.12/source/include/linux/skbuff.h#L916)（常用）、[alloc_skb_fclone()](https://elixir.bootlin.com/linux/v4.9.12/source/include/linux/skbuff.h#L958)（分配克隆的`sk_buff`结构）、[dev_alloc_skb()](https://elixir.bootlin.com/linux/v4.9.12/source/include/linux/skbuff.h#L2450)（驱动中调用，申请时不可中断）
—— 参考[分配SKB](https://blog.csdn.net/farmwang/article/details/66978100)。
分配SKB时，需要分配两块内存，一块是SKB描述符，一块是线性数据缓存区（包括线性数据区和`skb_shared_info`结构）。
内核对于sk_buff结构的内存分配不是和一般的结构动态内存申请一样：只分配指定大小的内存空间。而是在开始的时候，在初始化函数[skb_init()](https://elixir.bootlin.com/linux/v4.9.12/source/net/core/skbuff.c#L3454)中就分配了两段内存（`skbuff_head_cache`和`skbuff_fclone_cache`）来供sk_buff后期申请时用，所以后期要为sk_buff结构动态申请内存时，都会从这两段内存中来申请（其实这不叫申请了，因为这两段内存开始就申请好了的，只是根据你要的内存大小从某个你选定的内存段中还回个指针给你罢了）。如果在这个内存段中申请失败，则再用内核中用最低层，最基本的kmalloc()来申请内存了（这才是真正的申请）。释放时也一样，并不会真正的释放，只是把数据清零，然后放回内存段中，以供下次sk_buff结构的申请。这是内核动态申请的一种策略，专门为那些经常要申请和释放的结构设计的，这种策略不仅可以提高申请和释放时的效率，而且还可以减少内存碎片的。
    struct sk_buff *__alloc_skb(unsigned int size, gfp_t gfp_mask,
                    int flags, int node)
    {
        struct kmem_cache *cache;
        struct skb_shared_info *shinfo;
        struct sk_buff *skb;
        u8 *data;
        bool pfmemalloc;
        cache = (flags & SKB_ALLOC_FCLONE)
            ? skbuff_fclone_cache : skbuff_head_cache;
        if (sk_memalloc_socks() && (flags & SKB_ALLOC_RX))
            gfp_mask |= __GFP_MEMALLOC;
        /* Get the HEAD */
        skb = kmem_cache_alloc_node(cache, gfp_mask & ~__GFP_DMA, node);    // [1] 分配SKB描述符堆块，存放sk_buff结构。从高速缓存中分配，DMA有特定用途，所以排除在DMA中分配
        if (!skb)
            goto out;
        prefetchw(skb);
        size = SKB_DATA_ALIGN(size);        // 数据对齐
        size += SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
        data = kmalloc_reserve(size, gfp_mask, node, &pfmemalloc);            // [2] 分配线性数据缓存区：线性数据区+skb_shared_info结构。这里可以从DMA内存分配
        if (!data)
            goto nodata;
        size = SKB_WITH_OVERHEAD(ksize(data));
        prefetchw(data + size);
        memset(skb, 0, offsetof(struct sk_buff, tail));
        /* Account for allocated memory : skb + skb->head */
        skb->truesize = SKB_TRUESIZE(size);                                    // [3] skb 初始化
        skb->pfmemalloc = pfmemalloc;
        atomic_set(&skb->users, 1);
        skb->head = data;
        skb->data = data;
        skb_reset_tail_pointer(skb);
        skb->end = skb->tail + size;
        skb->mac_header = (typeof(skb->mac_header))~0U;
        skb->transport_header = (typeof(skb->transport_header))~0U;
        /* make sure we initialize shinfo sequentially */
        shinfo = skb_shinfo(skb);                                            // [4] skb_shared_info 分片结构初始化
        memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
        atomic_set(&shinfo->dataref, 1);
        kmemcheck_annotate_variable(shinfo->destructor_arg);
    out:
        return skb;
    nodata:
        kmem_cache_free(cache, skb);
        skb = NULL;
        goto out;
    }
    EXPORT_SYMBOL(__alloc_skb);
**skb释放** ：
[kfree_skb()](https://elixir.bootlin.com/linux/v4.9.12/source/net/core/skbuff.c#L696)
->
[__kfree_skb()](https://elixir.bootlin.com/linux/v4.9.12/source/net/core/skbuff.c#L684)
->
[skb_release_all()](https://elixir.bootlin.com/linux/v4.9.12/source/net/core/skbuff.c#L670)
->
[skb_release_data()](https://elixir.bootlin.com/linux/v4.9.12/source/net/core/skbuff.c#L583)
如果`skb->users==1`，表明是最后一个引用该结构的，可以调用`__kfree_skb()`函数直接释放。当skb释放掉后，dst_release同样会被调用以减小相关dst_entry数据结构的引用计数。
**如果`skb->destructor`（skb的析构函数）被初始化过，相应的函数会在此时被调用**。还有分片结构体 `skb_shared_info`
也会相应的被释放掉，然后把所有内存空间全部返还到 `skbuff_head_cache` 缓存池中，这些操作都是由 `kfree_skbmem()`
函数来完成的。这里分片的释放涉及到了克隆问题：如果skb没有被克隆，数据区也没有其他skb引用，则直接释放即可；如果是克隆了skb结构，则当克隆数计数为1时，才能释放skb结构体；如果分片结构被克隆了，那么也要等到分片克隆计数为1时，才能释放掉分片数据结构。如果skb是从
`skbuff_fclone_cache`
缓存池中申请的内存时，则要仔细销毁过程了，因为从这个缓存池中申请的内存，会返还2个skb结构体和一个引用计数器。所以销毁时不仅要考虑克隆问题还要考虑2个skb的释放顺序。
    void kfree_skb(struct sk_buff *skb)
    {
        if (unlikely(!skb))
            return;
        if (likely(atomic_read(&skb->users) == 1))            // [1] 如果 skb->users 不为1，则 skb->users 只是减1，表明减少一次引用。
            smp_rmb();
        else if (likely(!atomic_dec_and_test(&skb->users)))
            return;
        trace_kfree_skb(skb, __builtin_return_address(0));
        __kfree_skb(skb);
    }
    EXPORT_SYMBOL(kfree_skb);
## 参考
[利用漏洞CVE-2017-6074获取root权限](https://zhuanlan.zhihu.com/p/25690077)
[【漏洞预警】雪藏11年：Linux kernel DCCP double-free
权限提升漏洞（CVE-2017-6074）](https://www.anquanke.com/post/id/85546)
[ftrace: trace your kernel
functions!](https://jvns.ca/blog/2017/03/19/getting-started-with-ftrace/)
[【技术分享】CVE-2016-8655内核竞争条件漏洞调试分析](https://www.anquanke.com/post/id/85162)
[What I Learnt From the CVE-2016-8655
Exploit](http://h3ysatan.blogspot.com/2016/12/what-i-learnt-from-cve-2016-8655-exploit.html)
[sk_buff
整理笔记（一、数据结构）](https://blog.csdn.net/YuZhiHui_No1/article/details/38666589)
[sk_buff整理笔记（二、操作函数）](https://blog.csdn.net/YuZhiHui_No1/article/details/38690015)
[sk_buff整理笔记（三、内存申请和释放）](https://blog.csdn.net/yuzhihui_no1/article/details/38737615)
[sk_buff整理笔记（四、克隆与复制）](https://blog.csdn.net/YuZhiHui_No1/article/details/38827603)
[sk_buff整理笔记（五、队列管理函数）](https://blog.csdn.net/YuZhiHui_No1/article/details/38965069)