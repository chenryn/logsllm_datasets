  41	
  41	
  41	
059FD060	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
059FD070	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
059FD080	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
ByteArrayBuﬀerObject	
  [managed	
  by	
  FixedMalloc]	
005A8BA0	
  f8	
  d9	
  14	
  01	
  01	
  00	
  00	
  00	
  10	
  d0	
  9f	
  05	
  00	
  10	
  00	
  00	
005A8BB0	
  80	
  00	
  00	
  00 
A  Lightweight  Page  Heap  For  FixedMalloc 
•  Change	
  all	
  of	
  Heap	
  Allocators	
  in	
  FixedMalloc	
  to	
  HeapAlloc	
  in	
ProcessHeap	
•  Turn	
  On	
  Page	
  Heap	
  on	
  Windows	
  Process	
  Heap	
Heap  Allocators  in  FixedMalloc/FixedAlloc 
AllocaTonMaros.h	
  in	
  Avmplus/MMgc	
//	
  Used	
  for	
  allocaTng/deallocaTng	
  memory	
  with	
  MMgc's	
  ﬁxed	
  allocator.	
//	
  The	
  memory	
  allocated	
  using	
  these	
  macros	
  will	
  be	
  released	
  when	
  the	
  MMgc	
  aborts	
  due	
  to	
//	
  an	
  unrecoverable	
  out	
  of	
  memory	
  situaTon.	
#deﬁne	
  mmfx_new(new_data)	
  new	
  (MMgc::kUseFixedMalloc)	
  new_data	
#deﬁne	
  mmfx_new0(new_data)	
  new	
  (MMgc::kUseFixedMalloc,	
  MMgc::kZero)	
  new_data	
#deﬁne	
  mmfx_new_array(type,	
  n)	
  ::MMgcConstructTaggedArray((type*)NULL,	
  n,	
  MMgc::kNone)	
#deﬁne	
  mmfx_new_opt(new_data,	
  opts)	
  new	
  (MMgc::kUseFixedMalloc,	
  opts)	
  new_data	
#deﬁne	
  mmfx_new_array_opt(type,	
  n,	
  opts)	
  ::MMgcConstructTaggedArray((type*)NULL,	
  n,	
  opts)	
#deﬁne	
  mmfx_delete(p)	
  ::MMgcDestructTaggedScalarChecked(p)	
#deﬁne	
  mmfx_delete_array(p)	
  ::MMgcDestructTaggedArrayChecked(p)	
#deﬁne	
  mmfx_alloc(_siz)	
  MMgc::AllocCall(_siz)	
#deﬁne	
  mmfx_alloc_opt(_siz,	
  opts)	
  MMgc::AllocCall(_siz,	
  opts)	
#deﬁne	
  mmfx_free(_ptr)	
  MMgc::DeleteCall(_ptr) 
Heap  Allocators  in  FixedMalloc 
•  Take	
  mmfx_new_array_opt	
  as	
  an	
  example 
MMgcConstructTaggedArray 
mmfx_new_array_opt(type,	
  n,	
  opts) 
MMgc::NewTaggedArray 
MMgc::TaggedAlloc 
MMgc::AllocCallInline 
MMgc::FixedMalloc::OutOfLineAlloc 
FixedMalloc::Alloc() 
REALLY_INLINE	
  void*	
  FixedMalloc::Alloc(size_t	
  size,	
  FixedMallocOpts	
  ﬂags)	
{	
  if	
  (size	
  Alloc(size,	
  ﬂags);	
  else	
  return	
  LargeAlloc(size,	
  ﬂags);	
} 
REALLY_INLINE	
  FixedAllocSafe*	
  FixedMalloc::FindAllocatorForSize(size_t	
  size)	
{	
  unsigned	
  const	
  index	
  =	
  (size	
  >3)];	
  GCAssert(size	
  m_allocs[index-­‐1].GetItemSize());	
  return	
  &m_allocs[index];	
} 
Heap  Allocators  in  FixedMalloc 
•  Take	
  mmfx_new_array_opt	
  as	
  an	
  example 
REALLY_INLINE	
  void*	
  FixedMalloc::Alloc(size_t	
  size,	
  FixedMallocOpts	
  ﬂags)	
{	
  if	
  (size	
  Alloc(size,	
  ﬂags);	
  else	
  return	
  LargeAlloc(size,	
  ﬂags);	
} 
REALLY_INLINE	
  void*	
  FixedMalloc::Alloc(size_t	
  size,	
  FixedMallocOpts	
  ﬂags)	
{	
  …	
  return	
  HeapAlloc(GetProcessHeap(),	
  0,	
  size);	
} 
Hook	
  and	
  change	
  Fixed	
Heap	
  Allocators	
  to	
HeapAlloc	
  in	
  ProcessHeap 
A  Lightweight  Page  Heap  For  FixedMalloc 
•  Find	
  Heap	
  Allocators	
  in	
  FixedMalloc(Simplest	
  Way	
  –	
  AVM.sig)	
Part	
  3	
  :	
  Detect	
  Exploit	
Find	
  *bad*	
  vector	
3  Layer  Exploit  Detec4on 
•  Check	
  the	
  length	
  of	
  vectors	
  when	
  vector	
  length/read/write	
  opera=on	
in	
  exploits	
  use	
  methods	
  in	
  ﬂash	
  module	
•  Monitor	
  the	
  length	
  of	
  vectors	
  in	
  Args	
  of	
  JIT	
  func=on	
  when	
  vector	
length/read/write	
  opera=on	
  in	
  exploits	
  use	
  JIT	
  code	
•  God	
  Mode:	
  Monitor	
  all	
  of	
  vector	
  length	
  when	
  DoABC2	
  Tag	
  is	
  parsed.	
*Bad*  Vector  Detec4on 
Exploit	
  Process	
  -­‐	
  exploit.as	
1.	
  Heap	
  Spray	
  and	
  Feng	
  Shui	
2.	
  Trigger	
  the	
  bug	
  and	
  corrupt	
  the	
  length	
  of	
  vector	
3.	
  Find	
  this	
  *bad*	
  vector	
  and	
  use	
  it	
  to	
  do	
  arbitrary	
  Read/Write	
  to	
  build	
  ROP	
  and	
  overwrite	
  v-­‐table	
4.	
  Trigger	
  controlled	
  EIP	
5.	
  Restore	
  and	
  clean 
Hook	
  vector.length	
  –	
  vectorObject::get_length	
  to	
check	
  the	
  length 
Hook	
  vector[]	
  –	
  vectorObject::Operator	
  []	
  to	
check	
  the	
  length 
Not  JIT-­‐ed  Length/Write/Read 
Take	
  vector.length	
  as	
  an	
  example:	
Exploit.as	
for(_loc1_=0;	
  _loc1_	
  orig_length)	
  break;	
}	
We	
  can	
  set	
  a	
  hookpoint	
  at	
  Vector::get_length 
JIT-­‐ed  Length/Write/Read 
Take	
  vector.length	
  as	
  an	
  example:	
Exploit.as	
for(_loc1_=0;	
  _loc1_	
  orig_length)	
  break;	
}	
03d6042c	
  mov	
  edx,dword	
  ptr	
  [ebp-­‐90h]	
  ;	
  edx	
  is	
  address	
  of	
  arg3	
03d60432	
  mov	
  eax,dword	
  ptr	
  [ebp-­‐94h]	
  ;	
  eax	
  is	
  VectorObject	
  address	
03d60438	
  and	
  eax,0FFFFFFF8h	
  ;	
  atom	
  type	
  address	
03d6043b	
  mov	
  dword	
  ptr	
  [ebp-­‐94h],eax	
03d60441	
  je	
  +0x3d60671	
  (03d60672)	
03d60447	
  mov	
  ecx,dword	
  ptr	
  [eax+18h]	
  ;	
  [eax+0x18]	
  is	
  VectorBuﬀer	
03d6044a	
  mov	
  eax,dword	
  ptr	
  [ecx]	
  ;	
  ecx	
  is	
  VectorBuﬀer	
  and	
  [ecx]	
  is	
  the	
  length	
  of	
  vector	
03d6044c	
  mov	
  dword	
  ptr	
  [ebp-­‐98h],eax	
03d60452	
  lea	
  esp,[esp]	
03d60455	
  mov	
  ecx,dword	
  ptr	
  +0xa7	
  (000000a8)[edx]	
  ds:0023:03d44158=00000072	
  ;	
  +0x1d3	
  (000001d4)[eax]	
  <-­‐	
  here	
03d60351	
  mov	
  dword	
  ptr	
  [ebp-­‐94h],esi	
03d60370	
  mov	
  eax,dword	
  ptr	
  [ebp-­‐94h]	
03d60376	
  test	
  eax,eax	
03d6037e	
  lea	
  eax,[eax+1]	
03d60387	
  push	
  eax	
  <-­‐	
  from	
  arg3	
03d60399	
  mov	
  dword	
  ptr	
  [ebp-­‐98h],eax	
  <-­‐eax	
  is	
  address	
  of	
  VectorObject	
03d603f7	
  mov	
  eax,dword	
  ptr	
  [ebp-­‐98h]	
03d6040d	
  mov	
  dword	
  ptr	
  [ebp-­‐94h],eax	
03d6042c	
  mov	
  edx,dword	
  ptr	
  [ebp-­‐90h]	
03d60432	
  mov	
  eax,dword	
  ptr	
  [ebp-­‐94h]	
  <-­‐	
  eax	
  is	
  address	
  of	