在下一次选代中，第一个步骤交换元素72和33：
33 63 34 59 28 17 29 371 72 76
第二个步骤把i递减到8，第三次选代把33移动到合适的位置：
165
63 59 34 37 28 17 29 331 72 76
下一次选代以交换63与33作为开始，选代结束时，序列变成：
59 37 34 33 28 17 291 63 72 76
当数组处于有序状态时，选代过程结束。
下面的程序对输入数据按照升序进行排列，使用的正是上面提到的过程，我们把大部分的，由单独一
条表达式组成的语句用花括号包围起来，至于这样做的原因将会在下一节讨论剖析时说明，
# heapsort
{A[NR]= $0 }
END ( hsort (A, NR)
for (i = 1; i = 1; i--)# phase 1
{heapify(A, i, n)}
for (i = n; i > 1; i--) {
phase 2
{swap(A, 1, i) }
(heapify(A, 1, i-1)}
---
## Page 171
第七章算法实验
163
function heapify(A, left,right,
P,C){
for （p = left; (c = 2*p) A[c])
{c++}
if (A[p]=）g}N）ud）
printf ("\t\t print _LBcnt[i] > \"prof.cnts\"\n}\n")
}
给定一些输入数据，运行完某个程序的剖析版之后，我们可以用printprof，把protf.cnts中
的语句计数结果附加到原始程序中：
168
# printprof - print profiling counts
usage:awk -f printprof awkprog
prints awkprog with statement counts from prof.cnts
BEGIN {while (getline  0) cnt[++i] = $1 }
/ ( /
{printf("5d",cnt[++j])}
{printf（"\ts\n"，$0）}
作为示例，考虑为7.1节末尾的程序heapaort作剖析，为了构造这个程序的剖析版，键入并执行
命令
awk -f makeprof heapsort > heapsort.p
构造出的剖析版heapsort.p看起来就像：
#heapsort
{_LBcnt[1]++;A[NR]= $0}
END ( _LBcnt[2]++;hsort(A, NR)
for (i = 1; i = 1; i--)# phase 1
{_LBcnt[5]++;heapify(A, i, n) }
for （i = n; i > 1; i--)(_LBcnt[6]++;
#phase2
---
## Page 174
第七章算法实验
166
{_LBcnt[7]++;
swap(A, 1,i)}
{_LBcnt[8]++;heapify(A,1,i-1))
function heapify(A,left,right,
P,c){_LBcnt[9]++;
++[u}(=d=>(=）=d）xg
if (c  A[c])
{_LBcnt[11]++;c++ }
if (A[p]  1; i--) {
#phase 2
66
{swap(A, 1,i)}
9 9
{heapify(A, 1, i-1) }
---
## Page 175
第七章算法实验
167
}
}
14 9
function heapify(A,left,right,p,c) {
52 6
for （p = left; (c = 2*p）  A[c])
228
{c++}
if (A[p]< A[c])
473
{swap(A,C，p)}
{
5 7 2
function swap(A,i,j，t){
t = A[i]; A[i] = A[j]; A[j] = t
}
我们实现的剖析器最重要的特点是简单，但这同时也是它最大的缺点，程序makeprof盲目地在每
一行的第一个左花括号的右边插入计数语句，一个更好的做法是忽略字符串常量，正则表达式和注释中
的左花括号，除了语句的执行次数，最好还要报告语句的执行时网，但是这里介绍的方法还无法做到这一
点.
Exercise7.7修改剖析器，使得程序不会在字符串常量，正则表达式或者注释中插入计数语句.你实现
的剖析器是否允许对自身进行剖析？
Exercise 7.8如果END动作中包含exit语句，那么剖析器就无法正常地工作，请问这是为什么？修复
这个问题
170
7.3拓扑排序
在工程建筑项目中，有些工作必须在其他工作开始前完成，为了方便说明，我们通常会把这些工作都
列出来，这样就可以很容易地看出哪些工作必须在其他工作完成后才能开始，在一个程序库中，程序a
可能会调用程序h，h也有可能会调用程序d和e，等等，我们可能希望对程序进行排序，使得程序在它
调用的所有程序之前出现（Unix命令lorder可以完成这个工作）.这些，以及其他类似的问题都是拓
扑排序（topologicalsorting）问题的实例：我到一个顺序，该暖序满足一个约束条件集合，集合中的每个
条件都具有形式“x必须在y之前出现”.由约束条件集合所表示的偏序得到该集合上的一个线序，这个
操作叫作拓扑排序.
约束条件可以用一张图来表示，图中的每个结点都用名字标记，如果结点x必须先于y出现，那么就
有一条边，从x指向y.下面这张图就是一个例子：
a
(b)
(d）
e
（h)
i
---
## Page 176
第七章算法实验
168
如果存在一条边，从x指向y，邪么x就是y的前照（predecessor)，y是x的后继（successor).假设
约束条件用前驱-后继对来表示，其中每个输入行的x和y表示一条从结点x指向y的边，上面那张图
的文本表示形式是：
a
h
b
5
C
h
d
i
e
d
6
f
5
h
h
é
1
b
如果存在一条从x指向y的边，那么在输出中x必须先于y出现.如果把上面的数据作为输入，那
么可能的一个输出是：
acfhedibg
除此之外，还有其他线序关系也包含了上图所描述的偏序，另一个可能的线序是：
cahedifbg
拓扑排序的目标是对图中的结点进行排序，使得所有前驱都在它们的后继之前出现.当且仅当图中171
不含有环（cycle，是由多条边组成的序列，当结点沿着这个序列前进时，最终会回到结点的原来位置）时，
这样的顺序才存在
广度优先拓扑排序
有多种算法可以用于图的拓扑排序，其中最简单的算法可能是一在每次选代时，从图中移除没有前
驱的结点.如果所有的结点都按照这种方式从图中移除出来，那么图的拓扑排序结果就是结点按照移除
序所组成的序列，在上面的图中，我们可以从移除结点a及以它为起点的边开始，然后移除结点c，再
接着是结点f或h，依此类推
我们的实现使用了一种先进先出的数据结构—队列（queue)—来确定不含有前驱的结点的处理项
序，以一种“广度优先”的方式进行，当所有的结点都被读取完毕后，一个循环体计算结点的数量，并把所
有的，没有前驱的结点插入到及列中，第二个循坏体移除队列的第一个结点，打印该结点的名字，然后运
减它的每一个后维结点的前驱结点个数.如米果一个后维结点的前蒸结点个数变为0,部就把这个后距
结点插入到队尾，当队列变成空，并且所有的结点都被访问过，这时候拓扑排序就完成了，但是，如果有
某些结点从未被插入到队列中，那就说明这些结点处在环中，因此无法对该图进行拓扑梅序，如果图中不
存在环，那么被打印出来的结点序列就是一个拓扑排序。
tsort的前三条语句从输入中读取前驱-后继对，并构造一个后继结点列表，就像：
---
## Page 177
第七章算法实验
169
node