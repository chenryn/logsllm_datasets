static int open_port(struct inode * inode,
struct file * filp)
{
return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
}
CARTEL SÉCURITÉ — Philippe Biondi
How ?
Taxonomy | Defence | Filtering
22
▶ Module insertion control :
asmlinkage unsigned long
sys_create_module(const char *name_user, size_t size)
{
char *name;
long namelen, error;
struct module *mod;
if (!capable(CAP_SYS_MODULE))
return -EPERM;
[...]
CARTEL SÉCURITÉ — Philippe Biondi
How ?
Taxonomy | Defence | Filtering
23
What must we protect ?
■ What is in memory
▶ Processes (memory tampering, IPC, network
communications, . . . )
▶ Kernel conﬁguration (ﬁrewall rules, etc.)
■ What is on disks or tapes
▶ Files
▶ Metadata (ﬁlesystems, partition tables, . . . ), boot loaders, . . .
■ Hardware
▶ Devices (ioctl, raw access, . . . )
▶ EPROMs, conﬁgurable hardware, . . .
CARTEL SÉCURITÉ — Philippe Biondi
How ?
Taxonomy | Defence | Filtering
24
How to protect that ?
▶ Queries are done only via the kernel
▶ System calls, sysctls and devices drivers are a place of choice
for controlling accesses
¯ We have to modify their behaviour consistently to be able to
enforce a complete security policy.
CARTEL SÉCURITÉ — Philippe Biondi
How ?
Taxonomy | Defence | Filtering
25
A good way is to use a modular architecture to control kernel calls :
there will be
■ An enforcer component
■ A decider component
▶ Lots of access control policies (DAC, MAC, ACL, RBAC,
IBAC, . . . )
syscall
app
component
decider
component
enforcer
CARTEL SÉCURITÉ — Philippe Biondi
How ?
Taxonomy | Defence | Filtering
26
■ How to add the enforcer code to the kernel calls ?
▶ kernel call interception
▶ kernel call modiﬁcation
■ ex: system call anatomy :
kill()
open()
chmod()
execve()
socketcall()
code
dispatching
app
app
user space
kernel space
user space
dispatching
code
CARTEL SÉCURITÉ — Philippe Biondi
How ?
Taxonomy | Defence | Filtering
27
Syscall interception example : Medusa DS9
linux/arch/i386/kernel/entry.S
[...]
GET_CURRENT(%ebx)
cmpl $(NR_syscalls),%eax
jae badsys
#ifdef CONFIG_MEDUSA_SYSCALL
/* cannot change: eax=syscall, ebx=current */
btl %eax,med_syscall(%ebx)
jnc 1f
pushl %ebx
pushl %eax
call SYMBOL_NAME(medusa_syscall_watch)
cmpl $1, %eax
popl %eax
popl %ebx
jc 3f
jne 2f
1:
#endif
testb $0x20,flags(%ebx)
# PF_TRACESYS
jne tracesys
[...]
CARTEL SÉCURITÉ — Philippe Biondi
How ?
Taxonomy | Defence | Filtering
28
■ Syscall interception advantages
▶ general system
▶ low cost patch
■ Drawbacks
▶ kind of duplication of every syscall
▶ need to know and interpret parameters for each different
syscall
▶ architecture dependent
CARTEL SÉCURITÉ — Philippe Biondi
How ?
Taxonomy | Defence | Filtering
29
Syscall modiﬁcation example : LIDS
linux/fs/open.c
asmlinkage long sys_utime(char * filename, struct utimbuf * times)
{
int error;
struct nameidata nd;
struct inode * inode;
struct iattr newattrs;
error = user_path_walk(filename, &nd);
if (error)
goto out;
inode = nd.dentry->d_inode;
error = -EROFS;
if (IS_RDONLY(inode))
goto dput_and_out;
#ifdef CONFIG_LIDS
if(lids_load && lids_local_load) {
if ( lids_check_base(nd.dentry,LIDS_WRITE)) {
lids_security_alert("Try to change utime of %s",filename);
goto dput_and_out;
}
}
#endif
/* Don’t worry, the checks are done in inode_change_ok() */
newattrs.ia_valid = ATTR_CTIME | ATTR_MTIME | ATTR_ATIME;
if (times) {
CARTEL SÉCURITÉ — Philippe Biondi
How ?
Taxonomy | Defence | Filtering
30
■ Syscall modiﬁcation advantages
▶ Syscall parameters already interpreted and checked
▶ Great tuning power. We can alter the part of the syscall we
want.
■ Drawbacks
▶ Lot of the 200+ syscalls must be altered
CARTEL SÉCURITÉ — Philippe Biondi
How ?
Taxonomy | Defence | Filtering
31
To be out soon in the kernel : LSM
linux/kernel/module.c
sys_create_module(const char *name_user, size_t size)
{
char *name;
long namelen, error;
struct module *mod;
unsigned long flags;
if (!capable(CAP_SYS_MODULE))
return -EPERM;
lock_kernel();
if ((namelen = get_mod_name(name_user, &name)) module_ops->create_module(name, size);
if (error)
goto err1;
CARTEL SÉCURITÉ — Philippe Biondi
Outline
Implementations
32
■ Why ?
▶ Context
▶ A new security model
▶ Conclusion
■ How ?
▶ Taxonomy of action paths
▶ Defending kernel space
▶ Filtering in kernel space
■ Implementations
▶ Existing projects
▶ LSM
CARTEL SÉCURITÉ — Philippe Biondi
Implementations
Exisiting projects | LSM
33
Existing projects :
▶ Openwall
▶ GrSecurity
▶ LIDS
▶ Medusa DS9
▶ RSBAC
▶ LoMaC
▶ SE Linux
▶ . . .
CARTEL SÉCURITÉ — Philippe Biondi
Implementations
Exisiting projects | LSM
34
Openwall : Collection of security-related features for the Linux
kernel.
▶ Non-executable user stack area
▶ Restricted links in /tmp
▶ Restricted FIFOs in /tmp
▶ Restricted /proc
▶ Special handling of fd 0, 1, and 2
▶ Enforce RLIMIT_NPROC on execve
CARTEL SÉCURITÉ — Philippe Biondi
Implementations
Exisiting projects | LSM
35
GrSecurity : General Security for Linux
▶ Kernel hardening from Openwall
▶ ACL system
CARTEL SÉCURITÉ — Philippe Biondi
Implementations
Exisiting projects | LSM
36
LIDS : Linux Intrusion Detection (Defence?) System
■ Self-protection
■ Processes protection
■ Files protection
■ Online administration
■ Special (controversial) features
▶ Dedicated mailer in the kernel
▶ Kind of portscan detector in the kernel
CARTEL SÉCURITÉ — Philippe Biondi
Implementations
Exisiting projects | LSM
37
LIDS general architecture
processes
syslog
Kernel image
Boot stuff
init, rc, daemons
enforcer 
component
Logging
stuff
Kernel
Mailer
portscan
detector
AC data
procfs stuff
init code
component
decider 
lidsadm
LIDS AC data
syscalls
CARTEL SÉCURITÉ — Philippe Biondi
Implementations
Exisiting projects | LSM
38
Medusa DS9 : Extending the standard Linux (Unix) security
architecture with a user-space authorization server.
■ layer 1
▶ Hooks in the original kernel code
■ layer 2
▶ kernel space code
▶ called from hooks.
▶ do basic permission checks
▶ check for cached permissions
▶ call the communication layer if necessary
■ layer 3
▶ communication layer
▶ communicate with a user space daemon
CARTEL SÉCURITÉ — Philippe Biondi
Implementations
Exisiting projects | LSM
39
■ User space daemon
▶ decider component
■ Miscellaneous
▶ syscall interception
▶ can force code to be executed after a syscall
CARTEL SÉCURITÉ — Philippe Biondi
Implementations
Exisiting projects | LSM
40
RSBAC : Rule Set Based Access Control
■ It is based on the Generalized Framework for Access Control
(GFAC)
■ All security relevant system calls are extended by security
enforcement code.
■ Different access control policies implemented as kernel modules
▶ MAC, ACL, RC (role control), FC (Functional Control), MS
(Malware Scan), . . .
CARTEL SÉCURITÉ — Philippe Biondi
Implementations
Exisiting projects | LSM
41
LOMAC : Low Water-Mark Integrity
■ Initialization
▶ Some speciﬁed directories (B) are high
▶ Other directories (D) and sockets (E) are low
■ Execution
▶ Processes created from B are high
▶ Processes created from D are low
■ Reading
▶ A can read B. C can read D or E
▶ C can’t read B
▶ if A reads D or E, A goes into the low level
■ . . .
High
Low
process
file
C
D
E
A
B
CARTEL SÉCURITÉ — Philippe Biondi
Implementations
Exisiting projects | LSM
42
SE Linux : NSA’s Security Enhanced Linux
■ Based on the Flask architecture
(Flexible architecture security kernel)
■ Enforcer / decider components
■ Pays a lot of attention to the change of the access control policy
(revocation)
CARTEL SÉCURITÉ — Philippe Biondi
Implementations
Exisiting projects | LSM
43
Linux Security Modules : to be included in 2.5
▶ Kernel Summit 2001 : Linus decides that linux should support
security enhancements
▶ LSM patch is a set of hooks in the kernel syscalls
¯ Linux kernel provide the enforcer component
▶ Modular enough for the decider component to become a LKM
CARTEL SÉCURITÉ — Philippe Biondi
The End
44
That’s all folks. Thanks for your attention.
You can reach me at 
These slides are available at
http://www.cartel-securite.fr/pbiondi/
CARTEL SÉCURITÉ — Philippe Biondi