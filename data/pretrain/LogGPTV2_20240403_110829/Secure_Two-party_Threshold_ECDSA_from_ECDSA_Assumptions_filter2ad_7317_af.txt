Table I indicates. Over its course, each of the n parties commits
to and then sends a single proof-of-knowledge-of-discrete-
logarithm to all other parties in broadcast and then veriﬁes the
n−1 proofs that it receives. The parties then compute and send
Lagrange coefﬁcients to one another, which requires O(n2)
(parallel) communication in total, and this pattern repeats for
veriﬁcation. Finally, each party evaluates a single KOS Setup
instance with every other party, for (n2 − n)/2 instances in
total. The entire protocol requires four broadcast rounds, plus
the messages required by the KOS Setup instances.
For ease of comparison, concrete communication costs
for our signing protocol along with the signing protocols of
Gennaro et al. [3], Boneh et al. [4], and Lindell [2] are listed
in Table II. The former pair of schemes are related: Boneh
et al. reduce the number of messages in Gennaro et al.’s
signing protocol from six to four, with the goal of reducing the
communication cost. Apart from requiring only two messages,
our signing protocol requires roughly one twentieth of the
communication incurred by either.
Lindell’s signing scheme requires four messages and excels
in terms of communication cost, only transferring a com-
mitment, two curve points, two zero-knowledge proofs, and
one Paillier ciphertext. However, the Paillier homomorphic
operations it requires are quite expensive. Lindell’s scheme
requires one encryption, one homomorphic scalar multiplica-
tion, and one homomorphic addition with a Paillier modulus
N > 2q4 + q3, or 2048 bits for a 256-bit curve, concretely.
Gennaro et al. and Boneh et al.’s schemes both require one
to three encryptions and three to ﬁve homomorphic additions
and scalar multiplications per party, with N > q8, which
likewise results in a 2048-bit concrete modulus for 256-bit
curves. In addition, Lindell’s protocol requires 12 Elliptic Curve
multiplications, while the protocols of the other two require
roughly 100. These Paillier and group operations dominate the
computation cost of the protocols.
VIII. IMPLEMENTATION
We created a proof-of-concept implementation of our 2-of-2
and 2-of-n setup and signing protocols in the Rust language.
As a prerequisite, we also created an elliptic curve library
in Rust. We use SHA-256 to instantiate the Hash function,
per the ECDSA speciﬁcation, and in addition we use it to
instantiate the PRG. As a result, our protocol relies on both
the same theoretical assumptions as ECDSA and the same
practical assumption: that SHA-256 is secure. The SHA-256
implementation used in signing is capable of parallelizing
vectors of hash operations, and the 2-of-n setup protocol
is capable of parallelizing OT-extension initializations, but
otherwise the code is strictly single-threaded. This approach has
likely resulted in reduced performance relative to an optimized
C implementation, but we believe that the safety afforded by
Rust makes the trade worthwhile.
We benchmarked our implementation on a pair of Amazon
C5.2xlarge instances from Amazon’s Virginia datacenter,
both running Ubuntu 16.04 with Linux kernel 4.4.0, and we
compiled our code using Rust 1.25 with the default level
of optimization. The bandwidth between our instances was
measured to be be 5GBits/Second, and the round-trip latency
to be 0.1ms. Our signatures were calculated over the secp256k1
curve, as standardized by NIST [7]. Thus κ = 256, and we
chose s = 80 and κOT = 128 + s, following the analysis
of KOS [34]. We performed both strictly single-threaded
benchmarks, and benchmarks allowing parallel hashing with
three threads per party, collecting 10,000 samples for setup and
100,000 for signing. Note that signatures were not batched, and
thus each sample was impacted individually by the full latency
of the network. The average wall-clock times for both signing
protocols and the 2-of-2 setup protocol are reported in Table III,
along with results from previous works for comparison.
We benchmarked our 2-of-n setup algorithm using set of 20
Amazon C5.2xlarge instances from the Virginia datacenter,
conﬁgured as before with one instance per party. For initializing
OT-extensions, each machine was allowed to use as many
992
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:37:03 UTC from IEEE Xplore.  Restrictions apply. 
Rounds
Communication (Bits)
2-of-2 Setup
2-of-2 Signing
2-of-n Signing
2-of-n Setup
5
2
2
5
κ · (5κ + 11) + 6
κ · (κOT + 8κ + 6s + 6) + 2
κ · (κOT + 10κ + 8s + 6) + 2
(n2 − n) · ( 5
2
κ2 + 8κ + 4)
EC Multiplications
Bob
Alice
3κ + 6
6
6
Max
nκ − κ + 4
2κ + 6
7
7
Min
n + 3
Hash Function Invocations
Alice
Bob
6κ + 4
2κOT + 16κ + 12s + 4
2κOT + 18κ + 14s + 4
6κ + 4
3κOT + 16κ + 10s + 4
3κOT + 18κ + 12s + 4
Max
5nκ − 5κ + 1
Min
4nκ − 4κ + 1
TABLE I: Communication and Computation Cost Equations For Our Protocol. We assume that the hash function H is used to implement
the PRG. Note that communication costs are totals for all parties over all rounds, whereas computation costs are given per party. In the
2-of-n protocol the computation cost depends upon the identity of the party; consequently we give the minimum and maximum.
κ = 256
κ = 384
κ = 521
Lindell [2]
This Work (2-of-2)
Gennaro et al. [3]
Boneh et al. [4]
This Work (2-of-n)
897 B
176.5 KiB
1043 B
769 B
85.7 KiB
309.2 KiB
∼1808 KiB ∼4054 KiB ∼7454 KiB
∼1680 KiB ∼3768 KiB ∼6924 KiB
106.7 KiB
385.7 KiB
220.0 KiB
TABLE II: Concrete Signing Communication Cost Comparison.
Assuming 2-of-n signing for Gennaro et al. and Boneh et al., and
2-of-2 signing for the protocol of Lindell. For our protocols, we use
s = 80 and κOT = 128 + s.
Fig. 2: Wall Clock Times for 2-of-n Setup over LAN. Note that
all 20 parties reside on individual machines in the same datacenter,
and latency is on the order of a few tenths of a millisecond.
This Work
(3 threads)
2-of-2 Setup
2-of-2 Signing
44.32
2.27
–
2.11
This Work
(3 threads)
2-of-n Signing
2.45
2.24
[2]
2435
36.8
[3]
∼650
[4]
∼350
TABLE III: Wall-clock Times in Milliseconds over LAN, as
compared to the prior approaches of Lindell [2], Gennaro et al. [3],
and Boneh et al. [4]. Note that hardware and networking environments
are not necessarily equivalent, but all benchmarks were performed
with a single thread except where speciﬁed.
threads as there were parties, but the code was otherwise
single-threaded. We collected 1000 samples for groups of
parties ranging in size from 3 to 20, and we report the results
in Figure 2.
Transoceanic Benchmarks: We repeated our 2-of-2 setup,
2-of-2 signing, and 2-of-n signing benchmarks with one of the
machines relocated to Amazon’s Ireland datacenter, collecting
1,000 samples for setup and 10,000 for signing, and in the latter
case allowing three threads for hashing. In this conﬁguration,
the bandwidth between our instances was measured to be
161Mbps and the round-trip latency to be 74.6ms. In addition,
we performed a 2-of-4 setup benchmark among four instances
in Amazon’s four US datacenters (Virginia, Ohio, California,
and Oregon), and we performed a 2-of-10 setup benchmark
2-of-2
Setup
2-of-4 (US)
2-of-10 (World)
2-of-2
2-of-n
Signing
342.02
376.86
1228.46
76.95
77.06
TABLE IV: Wall-clock Times in Milliseconds over WAN. All
benchmarks were performed between one party in the eastern US
and one in Ireland, except the 2-of-4 setup benchmark, which was
performed among four parties in four different US states, and the
2-of-10 setup benchmark, which was performed among ten parties in
America, Europe, Asia, and Australia.
among ten instances in ten geographically distributed data-
centers (Virginia, Ohio, California, Oregon, Mumbai, Sydney,
Canada, Ireland, London, and Paris). The round-trip latency
between the US datacenters was between 11.2ms and 79.9ms
and the bandwidth between 152Mbps and 1.10Gbps, while
round-trip latency between the most distant pair of datacenters,
Mumbai and Ireland, was 282ms, and the bandwidth was
39Mbps. Results are reported in Table IV. We note that in
contrast to our single-datacenter benchmarks, our transoceanic
benchmarks are dominated by latency costs. We expect that
our protocol’s low round count constitutes a greater advantage
in this setting than does its computational efﬁciency.
A. Comparison to Prior Work
We compare our implementation to those of Lindell [2],
Gennaro et al. [3], and Boneh et al. [4] (who also provide an
optimized version of Gennaro et al.’s scheme, against which
993
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:37:03 UTC from IEEE Xplore.  Restrictions apply. 
we make our comparison). Though Boneh et al. and Gennaro
et al. support thresholds larger than two, we consider only their
performance in the 2-of-n case. Neither Gennaro et al. nor
Boneh et al. include network costs in the timings they provide,
nor do they provide timings for the setup protocol that their
schemes share. However, Lindell observes that Gennaro et al.’s
scheme involves a distributed Paillier key generation protocol
that requires roughly 15 minutes to run in the semi-honest
setting. Unfortunately, this means we have no reliable point of
comparison for our 2-of-n setup protocol.
Lindell benchmarks his scheme using a single core on
each of two Microsoft Azure Standard_DS3_v2 instances
in the same datacenter, which can expect bandwidth of roughly
3GBits/Second. Lindell’s performance ﬁgures do include
network costs. In spite of the fact that Lindell’s protocol
requires vastly less communication, as reported in Section VII,
we nonetheless ﬁnd that, not accounting for differences in
benchmarking environment, our implementation outperforms
his for signing by a factor of roughly 16 (when only a single
thread is allowed), and for setup by a factor of roughly 55.
Given that each 2-of-2 signature requires 85.7 KiB of data
to be transferred under our scheme, but only 769 Bytes under
Lindell’s, there must be an environment in which his scheme
outperforms ours. Speciﬁcally Lindell has an advantage when
the protocol is bandwidth constrained but not computationally
constrained. Such a scenario is likely when a large number of
signatures must calculated in a batched fashion (mitigating the
effects of latency) by powerful machines with a comparatively
weak network connection.
Finally, we note that an implementation of the ordinary
(local) ECDSA signing algorithm in Rust using our own elliptic
curve library requires an average of 179 microseconds to
calculate a signature on our benchmark machines – a factor of
only 11.75 faster than our 2-of-2 signing protocol.
IX. ACKNOWLEDGMENTS
We thank Megan Chen and Emily Wang for their contribu-
tions to this project during the summer of 2017. The authors
of this work are supported by NSF grants TWC-1646671
and TWC-1664445. This work used the Extreme Science
and Engineering Discovery Environment (XSEDE) Jetstream
cluster [54] through allocation TG-CCR170010, which is
supported by NSF grant number ACI-1548562.
X. CODE AVAILABILITY
Our implementation is available under the three-clause BSD
license from https://gitlab.com/neucrypt/mpecdsa/.
¨π
REFERENCES
[1] Y. Desmedt, “Society and group oriented cryptography: A new concept,”
in CRYPTO, 1987.
[2] Y. Lindell, Fast Secure Two-Party ECDSA Signing, 2017.
[3] R. Gennaro, S. Goldfeder, and A. Narayanan, Threshold-Optimal
DSA/ECDSA Signatures and an Application to Bitcoin Wallet Security,
2016.
[4] D. Boneh, R. Gennaro, and S. Goldfeder, “Using level-1 homomorphic
encryption to improve threshold dsa signatures for bitcoin wallet security,”
http://www.cs.haifa.ac.il/~orrd/LC17/paper72.pdf, 2017.
[5] W. Difﬁe and M. Hellman, “New directions in cryptography,” IEEE
Trans. Inf. Theor., vol. 22, no. 6, Sep. 1976.
[6] S. Goldwasser, S. Micali, and R. L. Rivest, “A digital signature scheme
secure against adaptive chosen-message attacks,” SIAM J. Comput.,
vol. 17, no. 2, Apr. 1988.
[7] National Institute of Standards and Technology, “FIPS PUB 186-4:
Digital Signature Standard (DSS),” http://nvlpubs.nist.gov/nistpubs/FIPS/
NIST.FIPS.186-4.pdf, 2013.
[8] American National Standards Institute, “X9.62: Public Key Cryptography
For The Financial Services Industry: The Elliptic Curve Digital Signature
Algorithm (ECDSA),” 2005.
[9] D. R. L. Brown, “Sec 2: Recommended elliptic curve domain
parameters,” 2010. [Online]. Available: http://www.secg.org/sec2-v2.pdf
[10] D. Kravitz, “Digital signature algorithm,” jul 1993, uS Patent 5,231,668.
[11] S. Blake-Wilson, N. Bolyard, V. Gupta, C. Hawk, and B. Moeller, “Elliptic
curve digital signature algorithm (dsa) for dnssec,” https://tools.ietf.org/
html/rfc4492, 2006.
[12] P. Hoffman and W. Wijngaards, “Elliptic curve digital signature algorithm
(dsa) for dnssec,” https://tools.ietf.org/html/rfc6605, 2012.
[13] Bitcoin Wiki, “Transaction,” https://en.bitcoin.it/wiki/Transaction, 2017,
accessed Oct 22, 2017.
[14] G. Wood, “Ethereum: A secure decentralised generalised transaction
ledger,” 2017. [Online]. Available: https://ethereum.github.io/yellowpaper/
paper.pdf
[15] Y. G. Desmedt and Y. Frankel, “Threshold cryptosystems,” in CRYPTO,
1989.
[16] T. ElGamal, “A public key cryptosystem and a signature scheme based
on discrete logarithms,” in CRYPTO, 1984.
[17] A. Shamir, “How to share a secret,” Commun. ACM, vol. 22, no. 11,
Nov. 1979.
[18] T. P. Pedersen, “A threshold cryptosystem without a trusted party,” in
EUROCRYPT, 1991.
[19] Y. Desmedt and Y. Frankel, “Shared generation of authenticators and
signatures (extended abstract),” in CRYPTO, 1991.
[20] R. L. Rivest, A. Shamir, and L. Adleman, “A method for obtaining digital
signatures and public-key cryptosystems,” Commun. ACM, vol. 21, no. 2,
Feb. 1978.
[21] Y. Desmedt and Y. Frankel, “Parallel reliable threshold multisignature,”
1992.
[22] R. Gennaro, S. Jarecki, H. Krawczyk, and T. Rabin, “Robust and efﬁcient
sharing of rsa functions,” in CRYPTO, 1996.
[23] A. De Santis, Y. Desmedt, Y. Frankel, and M. Yung, “How to share a
function securely,” in STOC, 1994.
[24] V. Shoup, “Practical threshold signatures,” in EUROCRYPT, 2000.
[25] C.-P. Schnorr, “Efﬁcient identiﬁcation and signatures for smart cards,”
in CRYPTO, 1989.
[26] D. R. Stinson and R. Strobl, “Provably secure distributed schnorr
signatures and a (t, n) threshold scheme for implicit certiﬁcates,” in
ACISP, 2001.
[27] S. K. Langford, “Threshold dss signatures without a trusted party,” in
CRYPTO, 1995.
[28] R. Gennaro, S. Jarecki, H. Krawczyk, and T. Rabin, “Robust threshold
dss signatures,” in EUROCRYPT, 1996.
[29] P. MacKenzie and M. K. Reiter, Two-Party Generation of DSA Signatures,
2001.
[30] Bitcoin Wiki, “Multisignature,” https://en.bitcoin.it/wiki/Multisignature,
2017, accessed Oct 22, 2017.
[31] P. Paillier, “Public-key cryptosystems based on composite degree
residuosity classes,” in EUROCRYPT, 1999.
[32] N. Gilboa, “Two party rsa key generation,” in CRYPTO, 1999.
[33] T. Chou and C. Orlandi, “The simplest protocol for oblivious transfer,”
in LATINCRYPT, 2015.
[34] M. Keller, E. Orsini, and P. Scholl, “Actively secure OT extension with
optimal overhead,” in CRYPTO, 2015.
[35] E. Hauck and J. Loss, “Efﬁcient and universally composable protocols for
oblivious transfer from the cdh assumption,” Cryptology ePrint Archive,
Report 2017/1011, 2017, http://eprint.iacr.org/2017/1011.
[36] J. Katz and Y. Lindell, Introduction to Modern Cryptography, Second
Edition, 2015, ch. Digital Signature Schemes, pp. 443–486.
994
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:37:03 UTC from IEEE Xplore.  Restrictions apply. 
[37] D. R. L. Brown, “Generic groups, collision resistance, and ecdsa,”
Cryptology ePrint Archive, Report 2002/026, 2002, http://eprint.iacr.
org/2002/026.
[38] S. Vaudenay, “The security of dsa and ecdsa,” in PKC, 2003.
[39] N. Koblitz and A. Menezes, “Another look at generic groups,” Cryptology
ePrint Archive, Report 2006/230, 2006, https://eprint.iacr.org/2006/230.
[40] S. Even, O. Goldreich, and A. Lempel, “A randomized protocol for
signing contracts,” Commun. ACM, vol. 28, no. 6, Jun. 1985.
[41] M. O. Rabin, “How to exchange secrets with oblivious transfer,”
Cryptology ePrint Archive, Report 2005/187, 1981, http://eprint.iacr.
org/2005/187, Harvard University Technical Report 81.
[42] S. Wiesner, “Conjugate coding,” SIGACT News, 1983.
[43] M. Naor and B. Pinkas, “Computationally secure oblivious transfer,” J.
[44] D. Beaver, “Correlated pseudorandomness and the complexity of private
Cryptol., vol. 18, no. 1, Jan. 2005.
computations,” in STOC, 1996.
[45] Y. Ishai, E. Kushilevitz, R. Ostrovsky, M. Prabhakaran, and A. Sahai,
“Efﬁcient non-interactive secure computation,” in EUROCRYPT, 2011.
[46] A. Beimel, A. Gabizon, Y. Ishai, E. Kushilevitz, S. Meldgaard, and
A. Paskin-Cherniavsky, “Non-interactive secure multiparty computation,”
in CRYPTO, 2014.
[47] V. Shoup, “Lower bounds for discrete logarithms and related problems,”
in EUROCRYPT, 1997.
[48] A. Fiat and A. Shamir, “How to prove yourself: Practical solutions to