}
( names [ i ]==username )
}
}
i f
private S t r i n g [ ] names ; // P : C o n f i d e n t i a l
private S t r i n g [ ] p a s s w o r d s ; // P : S e c r e t
public boolean c h e c k (
S t r i n g username ,
S t r i n g q u e r y // P : C o n f i d e n t i a l
){
boolean match = f a l s e ;
boolean nameOkFlag = f a l s e ;
f o r ( i n t i =0; i  P u b l i c
nameOkFlag = true ;
i f
}
}
System . o ut . p r i n t ( nameOkFlag ) ; // A: P u b l i c
return match ; // A: P u b l i c
Figure 7: Password checking program
Statement 19, the return of the method, is annotated as
allowing information ﬂows at a security level up to P ublic
because the returned value —variable match— will be visi-
ble to the user.
Notice that the ﬁnal value of match depends on conﬁden-
tial and secret data therefore the program is not secure from
the point of view of non-interference property. However, the
program needs to inform to the user the result of the pass-
word checking process. Here is where declassiﬁcation plays
an important role.
In order to permit the ﬂow of the value stored in match to
a public channel, we add a declassiﬁcation tag (D) at line 14
indicating that the security level of the information stored
in match is reclassiﬁed from Secret to P ublic.
The tool takes into account the declassiﬁcation tag and
permits the ﬂow to statement 19. On the contrary, state-
ment 18, also annotated as a public channel, is reported as
the sink of an invalid ﬂow of conﬁdential information be-
cause nameOkF lag depends on the conﬁdential user names
list.
Figure 8 shows the secure slice of the password program.
Notice that statement 18 is commented out to avoid an in-
formation leak.
119
Figure 8: Secure slice of the password checking pro-
gram
5. RELATED WORK
Pioneering works on IFC —partially surveyed in [6]—
were mainly focused on run-time monitors, and Fenton’s
Data Mark Machine (DDM) [8] is the most prominent one.
The DMM implements dynamic IFC by associating each
variable and the program counter (pc) with a security class
and then it checks that the value of a variable is computed
from variables with the same or lower security class and in a
context —security level of pc— at the same or lower security
class.
Recently, run-time monitoring of information ﬂow has re-
covered the attention of the research community; we will
overview some contemporary works with the intention of
describing current trends of the ﬁeld.
Chandra and Franz [4] propose to use a trusted multi-level
security virtual machine (VM) to execute completely un-
trusted programs without the risk of producing invalid ﬂows.
They have implemented severals prototypes of these special
JVM that provides, in addition to the full functionality of a
standard JVM, an information-ﬂow-enforcement infrastruc-
ture. This infrastructure stands on a static transformation
phase of the original bytecode program that inserts instruc-
tions to be used later on to track implicit information ﬂows.
If the VM deduces that the execution of an instruction will
leak secret information, an exception is raised and program
execution aborted; therefore, as we mentioned in the intro-
duction of the paper, information about secret variables can
be leaked. This approach imposes a time overhead of up to
82%. No information is provided about the space overhead
due to the static transformation phase.
Trusted multi-level security VM has inspired the Dynamic
Information Flow Architecture for Java (DIFCA-J) [37]. The
main diﬀerence between both approaches is that DIFCA-J
is independent of particular JVM implementations. IFC in
DIFCA-J is not made by the JVM but through a special class
named Access Control Module that mimics JVM operations
using security labels instead of program values. The time
overhead is between 1300–1800% w.r.t. the original execu-
tion time and the static transformation phase of the original
program increase code size in between 200–280% [37].
Recently, in [20], Nair et al. proposed a JVM-based IFC
approach —similar to the one described in [4]— where in-
ternal data structures of the VM were extended to store
security labels.
A general dynamic information ﬂow tracking framework
(GIFT) for C programs is introduced in [15]. GIFT allows to
associate security tags with input data. Then it instruments
the application code to dynamically propagate these tags to
all the other data that are control/data-dependent. A test
with a set of computation-intensive applications concluded
that the run-time penalization imposed by the tool can reach
up to 166% and the space overhead up to 60%.
Besides the implemented approaches, there are other the-
oretical developments to mention.
Shroﬀ et al. [29] propose a runtime information ﬂow con-
trol system based on the dynamic tracking of indirect depen-
dencies between program statements. They target a high-
erorder functional language with mutable state, conditional
branching and let-binding. Unfortunately the system is un-
sound and secret information ﬂowing to public channels may
not be detected the ﬁrst time the ﬂow occurs. As a sound
alternative they deﬁne an information ﬂow analysis based
on statically-computed dependence information. However,
this approach mitigates the beneﬁts of run-time monitoring,
since it looses precision.
In [18], Le Guernic et al. describe a run-time monitoring
system for a simple sequential language with while-loops,
conditionals, assignments, and output commands. They use
an automaton to track information ﬂows. The automaton
receives abstractions of program events and deduces if the
information ﬂow is valid or not. The system, as mentioned
before, is the ﬁrst one to propose the alteration of regular
program behavior to keep the execution free of invalid ﬂows.
The monitor is deﬁned for a very simple language —the same
we use in this paper to explain our approach— it does not
allow common features like unstructured control ﬂow, nor
functions, nor pointers, and it is not clear if the automaton-
based approach would be applied to less simpler languages.
More recently, Le Guernic [17] extended the automaton to
cope with concurrent programs.
The largest part of contemporary research on static IFC
—surveyed in [27]— has its roots in Denning and Denning
work [7] on compile-time certiﬁcation mechanisms, and it
was dominated by the use of non standard type systems to
enforce conﬁdentiality [34].
Usually, type-based analysis is not ﬂow sensitive, context-
sensitive nor object sensitive, and its precision drastically
decreases in presence of not structured control ﬂow. These
limitations makes diﬃcult the use of type-based analysis
on real programming languages; however, there exist type-
based information ﬂow analyzers for languages such as Java
[19] and Caml [30].
The dependence graph-based approach to detect invalid
ﬂows used in this work is described in [12]. Then, in [11],
Hammer et al.
further developed the idea and introduced
a dataﬂow analysis framework to cope with declassiﬁcation.
Security levels are propagated through program dependen-
cies and then the actual incoming ﬂow is compared with the
allowed security level of output channels. If the incoming
ﬂow of an output channel is not lower nor equal than its
allowed level, then an invalid ﬂow has been found.
Many realistic systems need to declassify some kind of con-
ﬁdential information as part of their regular behavior; the
actual challenge is to diﬀerentiate between proper and im-
proper declassiﬁcation of conﬁdential information. Sabelfeld
and Sands [28] provide a survey of current research on infor-
mation ﬂow policies and enforcement mechanisms in pres-
ence of declassiﬁcation.
6. CONCLUSIONS
We have presented secure slicing, a program transforma-
tion used to extract secure slices of insecure programs. Se-
cure slices are obtained by statically detecting invalid ﬂows
in the source program and suitably modifying it to eliminate
the possibility of an information leak at run-time; therefore,
all executions of the secure slices are guaranteed to be se-
cure.
The information ﬂow analysis is made statically and, if an
invalid ﬂow is detected, the program is not rejected but stat-
ically modiﬁed to turn it secure. This way we alleviate two
main drawbacks of previous static and dynamic approaches
to IFC: the presence of invalid ﬂows does not imply the re-
jection of the whole program, and no space nor run-time
overload is imposed.
We have also shown how secure slicing can be applied to
programs that intentionally declassify secure information;
this is a distinguishing feature of our technique w.r.t. recent
work on dynamic IFC.
Currently, we are experimenting with our static informa-
tion ﬂow analysis tool for Java and JVM bytecode in order
to study if secure slicing scales to real world programs.
Acknowledgments
We thank anonymous reviewers for providing useful com-
ments.
7. REFERENCES
[1] Martin Abadi, Anindya Banerjee, Nevin Heintze, and
Jon G. Riecke. A core calculus of dependency. In
M. Ac, editor, POPL ’99. Proceedings of the 26th
ACM SIGPLAN-SIGACT on Principles of
programming languages, January 20–22, 1999, San
Antonio, TX, pages 147–160, New York, NY, USA,
1999. ACM Press.
[2] Gilles Barthe and Salvador Cavadini. From Interfering
to Non-interfering Programs (unpublished draft),
2007.
[3] Gilles Barthe, David Pichardie, and Tamara Rezk. A
Certiﬁed Lightweight Non-Interference Java Bytecode
Veriﬁer. In Proc. of 16th European Symposium on
Programming (ESOP’07), volume 4421 of Lecture
Notes in Computer Science, pages 125–140.
Springer-Verlag, 2007.
[4] D. Chandra and M. Franz. Fine-Grained Information
Flow Analysis and Enforcement in a Java Virtual
Machine. to appear in 23rd Annual Computer Security
Applications Conference (ACSAC 2007), Miami
Beach, Florida; December 2007.
[5] Zhenqiang Chen, Baowen Xu, and Jianjun Zhao. An
overview of methods for dependence analysis of
concurrent programs. SIGPLAN Not., 37(8):45–52,
August 2002.
[6] Dorothy E. Denning. A lattice model of secure
information ﬂow. Commun. ACM, 19(5):236–243, May
1976.
120
[7] Dorothy E. Denning and Peter J. Denning.
13(2):199–239, April 2004.
Certiﬁcation of programs for secure information ﬂow.
Commun. ACM, 20(7):504–513, July 1977.
[8] J. S. Fenton. Memoryless Subsystems. Computing J.,
17(2):143–147, 1974.
[9] Jeanne Ferrante, Karl J. Ottenstein, and Joe D.
Warren. The program dependence graph and its use in
optimization. ACM Trans. Program. Lang. Syst.,
9(3):319–349, July 1987.
[10] J. A. Goguen and J. Meseguer. Security Policies and
Security Models. sp, 00, 1982.
[11] C. Hammer, J. Krinke, and Frank Nodes. Intransitive
Noninterference in Dependence Graphs. Second
International Symposium on Leveraging Application of
Formal Methods, Veriﬁcation and Validation (ISoLA
2006), 2006.
[12] Christian Hammer, Jens Krinke, and Gregor Snelting.
Information Flow Control for Java Based on Path
Conditions in Dependence Graphs. In IEEE
International Symposium on Secure Software
Engineering, 2006.
[13] M. Harman, S. Danicic, Y. Sivagurunathan, and
D. Simpson. The next 700 slicing criteria. 2 nd UK
workshop on program comprehension (Durham
University, UK, July 1996), M. Munro, Ed., 1996.
[14] Susan Horwitz, Thomas Reps, and David Binkley.
Interprocedural slicing using dependence graphs. In
Proceedings of the ACM SIGPLAN ’88 Conference on
Programming Language Design and Implementation,
volume 23, pages 35–46, Atlanta, GA, June 1988.
[22] Raja V. Rai, Laurie Hendren, Vijay Sundaresan,
Patrick Lam, Etienne Gagnon, and Phong Co. Soot -
a Java Optimization Framework. In Proceedings of
CASCON 1999, pages 125–135, 1999.
[23] Raja V. Rai and Laurie J. Hendren. Jimple:
Simplifying Java Bytecode for Analyses and
Transformations. Technical report, Sable Research
Group, McGill University, Montreal, Quebec, Canada,
1988.
[24] V. Ranganath, T. Amtoft, A. Banerjee, J. Hatcliﬀ, and
M. Dwyer. A new foundation for control-dependence
and slicing for modern program structures. ACM
Trans. Program. Lang. Syst., 29(5):1–43, 2007.
[25] V. P. Ranganath and J. Hatcliﬀ. An Overview of the
Indus Framework for Analysis and Slicing of
Concurrent Java Software (Keynote Talk - Extended
Abstract). pages 3–7, 2006.
[26] Roscoe and Goldsmith. What Is Intransitive
Noninterference? In PCSFW: Proceedings of The 12th
Computer Security Foundations Workshop. IEEE
Computer Society Press, 1999.
[27] A. Sabelfeld and A. Myers. Language-Based
Information-Flow Security. IEEE Journal on Selected
Areas in Communications, 21(1):5–19, January 2003.
[28] Andrei Sabelfeld and David Sands. Dimensions and
Principles of Declassiﬁcation. In CSFW ’05:
Proceedings of the 18th IEEE Computer Security
Foundations Workshop (CSFW’05), pages 255–269,
Washington, DC, USA, 2005. IEEE Computer Society.
[15] Lap C. Lam and Tzi C. Chiueh. A General Dynamic
[29] Paritosh Shroﬀ, Scott Smith, and Mark Thober.
Information Flow Tracking Framework for Security
Applications. In Proceedings of the 22nd Annual
Computer Security Applications Conference
(ACSAC’06), pages 463–472. IEEE Computer Society,
2006.
Dynamic Dependency Monitoring to Secure
Information Flow. In CSF ’07: Proceedings of the 20th
IEEE Computer Security Foundations Symposium,
pages 203–217, Washington, DC, USA, 2007. IEEE
Computer Society.
[16] Butler W. Lampson. A note on the conﬁnement
[30] V. Simonet. Flow Caml in a nutshell. In Proceedings of
problem. Commun. ACM, 16(10):613–615, October
1973.
the ﬁrst APPSEM-II workshop, pages 152–165, 2003.
[31] Saurabh Sinha and Mary J. Harrold. Analysis and
[17] Gurvan Le Guernic. Automaton-based Conﬁdentiality
Monitoring of Concurrent Programs. In Computer
Security Foundations Symposium, 2007. CSF ’07. 20th
IEEE, pages 218–232, 2007.
[18] Gurvan Le Guernic, Anindya Banerjee, Thomas
Jensen, and David Schmidt. Automata-based
Conﬁdentiality Monitoring. In Proceedings of the
Annual Asian Computing Science Conference,
December June–August 2006.
Testing of Programs with Exception Handling
Constructs. Software Engineering, 26(9):849–871,
2000.
[32] Gregor Snelting, Torsten Robschink, and Jens Krinke.
Eﬃcient Path Conditions in Dependence Graphs for
Software Safety Analysis. ACM Trans. Softw. Eng.
Methodol., 15(4):410–457, October 2006.
[33] Frank Tip. A survey of program slicing techniques.
Journal of programming languages, 3:121–189, 1995.
[19] Andrew C. Myers. JFlow: Practical Mostly-Static
[34] Dennis M. Volpano and Geoﬀrey Smith. A
Information Flow Control. In Symposium on
Principles of Programming Languages, pages 228–241,
1999.
[20] Srijith K. Nair, Patrick N. D. Simpson, Bruno Crispo,
and Andrew S. Tanenbaum. A Virtual Machine Based
Information Flow Control System for Policy
Enforcement. In First International Workshop on Run
Time Enforcement for Mobile and Distributed Systems
(REM 2007), pages 1–11, Dresden, Germany, 2007.
[21] Alessandro Orso, Saurabh Sinha, and Mary J.
Harrold. Classifying data dependences in the presence
of pointers for program comprehension, testing, and
debugging. ACM Trans. Softw. Eng. Methodol.,
Type-Based Approach to Program Security. In
TAPSOFT ’97: Proceedings of the 7th International
Joint Conference CAAP/FASE on Theory and
Practice of Software Development, pages 607–621,
London, UK, 1997. Springer-Verlag.
[35] Mark D. Weiser. Program slices: formal, psychological,
and practical investigations of an automatic program
abstraction method. PhD thesis, University of
Michigan, Ann Arbor, 1979.
[36] Baowen Xu, Ju Qian, Xiaofang Zhang, Zhongqiang
Wu, and Lin Chen. A brief survey of program slicing.
SIGSOFT Softw. Eng. Notes, 30(2):1–36, March 2005.
121
[37] Sachiko Yoshihama, Takeo Yoshizawa, Yuji Watanabe,
Michiharu Kudoh, and Kazuko Oyanagi. Dynamic
Information Flow Control Architecture for Web
Applications. pages 267–282. 2007.
122