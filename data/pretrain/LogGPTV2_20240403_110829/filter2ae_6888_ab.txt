正常执行。当表达式被执行后，它便成为了我们最喜欢的常量类型，这种只执行参数的操作就被我定义为 `PartialEval` 。
    "SQL Admin"         => "SQL Admin"
    md5("koalr")        => "f2ebd1b28583a579fe12966d8f7c6d4b"
    substr(md5(r1),0,8) => "210cf7aa" # if r1 = 'admin'
接下来，我们可以将每种函数或是运算符视为一种匹配模式。比如 `contains` 就是让参数直接包含在响应里；再比如 `matches`
的参数应被视为一个正则，我们需要根据正则去生成一个假数据再填充到响应里。
    "response.header['token'] == 'yarx'" => resp.Header().Set('token', 'yarx')
    "'ad[m]{2}in'.bmatches(resp.body)"   => resp.Body.Write([]byte("admmin"))
这样每种模式都可以写成一个处理函数，其逻辑基本都是这样的流程：
  1. 从多个地方获取变量的值
  2. 把参数作为表达式执行，获取执行结果
  3. 将参数做对应处理然后写入到响应
经过上面这些处理，我们就有了一堆分析好的处理函数， 离 xray poc 的逆解析又近了一步！
## 流程
新版的 xray 规则在最外层增加了一个 expression，可以借助它自定义执行流程，比如假设在 rules 部分定义了 4 个规则，那么
expression 可以任意的去构造：
    rules: 
        r1: ...
        r2: ...
        r3: ...
        r4: ...
    expression: r1() && r2() && r3() && r4()
    expression: (r1() && r2()) || (r3() && r4())
    expression: r1() || (r2() && (r3() || r4()))
我们在编写 server
时也要符合这个定义才行，比如第一个要顺序执行4条规则且全部满足才可以。而后面两个我们可以取个最短路径来简化逻辑，比如最后一个我们可以只满足 r1
即可，这其实就是大家都学过的二叉树的深度问题，取最浅的一条能到达叶子节点的路径即可。
和执行流程相关的还有动态变量的问题，就是下面的这种情况：
    rules:
        r0:
            request:
                method: GET
                path: /
            expression: response.status == 200
            output:
                search: 'test_yarx_(?P\w+)".bsubmatch(response.body)'
                yarx_id: search["id"]
        r1:
            request:
                method: GET
                path: /{{yarx_id}}
            expression: response.status == 200
    expression: r0() && r1()
在这个例子中 r1 会用到 r0 的响应中的变量。这个乍看很复杂，不过稍加思考就会发现，服务端的响应我们是完全可控的，因此我们可以将 r0
的响应在解析的时候就固定下来，xray 收到响应一定会提取出和我们一样的变量值，所以后面用到该变量的地方也可以被直接替换成常量。对于这个例子，如果固定生成的
id 是 `deadbeef` ，那么这个规则实际上变成了下面的写法，这样做不仅简单了，还对减少下面要说到的路由冲突的问题有很大帮助。
    rules:
        r0:
            request:
                method: GET
                path: /
            expression: response.status == 200
        r1:
            request:
                method: GET
                path: /deadbeef
            expression: response.status == 200
    expression: r0() && r1()
## 缝合
经过了前面这么多的准备工作，我们终于可以开始着手编写服务端逻辑了，这其实就是把一堆的处理逻辑缝合在一起的过程。缝合的方式很简单，就是基于路由去调用。路由信息在
poc 中已经标明了，我们只需要将规则中的 `method`、`path`、`header` 等提取成一个 **唯一**
的特征，利用这个唯一的特征可以映射到上面写的处理函数，进而走通流程。我起初以为这个很简单，没想到这个点耗费了我编写这个项目最多的时间，其难点在于处理路由冲突，即有些情况下没法提取出唯一的特征。
比如下面这两个 poc，他们请求部分完全相同仅仅是表达式的判断不同，请求可能会命中其中任意一个规则进行处理，这就导致只能扫出其中的某一个漏洞。
我对这类情况的处理是做一次合并，合并后的规则会包含原有的两个规则的响应处理。由于 poc 中基本都是 `contains`
相关的处理，因此这种合并基本都是兼容的。当然，也有不兼容的情况，比如：
这里的 status 就是不兼容的，我们不可能让一个响应既是 200 又是 401。除此之外，还有更棘手的动态路由问题：
这些 poc 的路径过于简单又包含变量，导致诸如 `/admin.php`
的路径可能被任意一个匹配到，这显然是不合理的。上面的两个问题困扰了我好久，我最开始是计划支持所有 xray poc
的检测的，这个问题犹如心头刺让我很难受，挣扎几日之后最终承认当前版本下这是一个无解的问题。在此过程中我尝试减少冲突的思路有：
  * 动态变量的静态化  
就是上面说到的 output 的处理过程
  * 变量值的再确认  
同一个变量在 poc 的一次运行中是不变的值，而变量可能在不同的规则中匹配出多次
  * 调整路由顺序  
我写了一个巨大的排序规则来让 server 运行前把路由排个序，比如没有变量的要好于有变量的，path 长的好于 path 短的，包含 header
的好于不包含的以此来让静态路径优先匹配
  * 添加层级判断  
就是给 poc 的运行添加状态，比如第一个请求之后应该是第二个请求，如果第二个请求没来那么第一个请求就不应该被处理
这些方法除了最后一个我都实现了，而且确实是有效。相比之下最后一点并非实现不了，而是由于其不可避免的会影响并发扫描的效率被我去掉了。尽管用了这么多的
trick，但依然无法支持所有的 poc 同时扫描，后面我也不再钻牛角，我决定将一些过于灵活的 poc 直接去掉不加载，这个策略反而大幅提升了整体的检出率。
把上面的思想包装成代码，再稍微踩点坑就诞生了 
这个项目。截至到这篇文章写完时已经可以单端口瞬间检测出 280+ 漏洞（官方约 340个 poc)，这个数据伴随着后期的优化升级还会不断增加。
## 总结
我作为曾经的 xray 核心开发者做反制 xray 这种事看似有点过河拆桥，但其实 yarx 这反而有利于 xray 的发展。除了通过污染漏洞报告来
“反制” xray 外，还有至少这样两个有趣的用途：
  * 做 xray-like 的漏扫的集成测试  
可以检查集成了 xray 的漏扫产品从 yaml 输入到扫描出漏洞的整个流程是否按预期工作。借助 yarx 我还真发现了几个 xray 的陈年老
bug，提了个 issue 详情在这 [Issue 1493](https://github.com/chaitin/xray/issues/1493)
  * 做 xray 相关的蜜罐  
蜜罐类产品可以添加一个类别叫 xray-sensor，精准探测 xray 用了哪个 poc
发了什么包，感觉做成产品整个界面还挺好玩的。还有一种可行的情况是在网关处针对 xray
的扫描流量做一下转发，网关处的流量识别可以做的粗一点，比如只支持静态类型的 url 匹配，识别后再转到 yarx 进行处理，这样可以迷惑一下攻击者。
虽然这不是真正意义上的 xray 反制，但也算是填补了常见安全工具反制的一块拼图，这波是利好蓝队了。另外，文中的思路其实适用于任何扫描器，比如 nuclei
之类的也都可以用类似思路。甚至如果有同学乐意可以比社区常见的扫描器都搞一搞，扫描器没法用了才是脚本小子真正的末日（
* * *