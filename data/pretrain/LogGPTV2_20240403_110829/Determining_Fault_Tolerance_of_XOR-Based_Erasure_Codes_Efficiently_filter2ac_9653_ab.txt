317: end for
318: return (M , M , Q)
˜f (cid:1).S ← ˜f .S ∪ {s(cid:1)}
/∗ P(cid:1)
contains all parities in T .P that are connected to s(cid:1)
. ∗/
P(cid:1) ← {∀p ∈ T .P ,∃e ∈ T .E : e = s(cid:1)p}
/∗ P contains all parities in ˜f .P that are connected to s(cid:1)
. ∗/
P ← {∀p ∈ ˜f .P ,∃e ∈ T .E : e = s(cid:1)p}
˜f (cid:1).P ← (˜f .P ∪ P(cid:1)) \ P
if (˜f (cid:1) ∈ M ) then continue
˜fMIN ← l : l ∈ M ,∀r ∈ M , |l| ≤ |r|
if (|˜f (cid:1)| ≥ 2|˜fMIN|) then
if (is composite(T \ {˜f (cid:1)})) then continue
contains all data symbols that are adjacent to ˜f . ∗/
end if
Figure 1. ME Algorithm pseudo-code.
(cf.
lines 201–208), and in the second phase, child era-
sure patterns are repeatedly enumerated (cf. lines 209–214).
Each base erasure corresponds to one row of the Generator
matrix; it consists of a single data symbol s(cid:1)
and the parities
connected to it in the Tanner graph T (cf. line 205). Every
base erasure is enqueued on the erasures queue Q, a FIFO
queue, and inserted into M .
In the second phase of me search, minimal erasures are
dequeued from Q, and then me children generates and pro-
cesses the child erasure patterns. In me children, line 301
determines which data symbols are adjacent to ˜f . There
is a child erasure pattern for every adjacent data symbol
s(cid:1)
. Child erasure patterns are the XOR of ˜f with ˜fs(cid:1), the
base erasure corresponding to data symbol s(cid:1)
. The pseudo-
code is written in set notation to make the relationship to the
structure of T more apparent. A child is created as follows:
s(cid:1)
is added to the parent (cf. line 303); parities connected to
s(cid:1)
are added to the parent (cf. line 305); parities connected
to s(cid:1)
and to some data symbol in the parent are removed
(cf. lines 307 and 308). Regarding P, there exists at least
one such parity to remove, otherwise the data symbol s(cid:1)
would not be adjacent to ˜f (cf. line 301). If the child era-
sure pattern has previously been generated by me children,
i.e., it is already in the erasure patterns cache M , then ˜f (cid:1)
is not processed (cf. line 309). If the child erasure pattern
has not yet been processed, then it is added to M and to
the erasures queue Q (cf. lines 310 and 311 respectively).
Each child erasure pattern that is a minimal erasure is in-
serted into M (cf. line 316). Once all of the children are
processed, me children returns the updated M , M and Q.
Lines 312–315 deal with composite erasures: those child
erasure patterns that can be partitioned into multiple mini-
mal erasures and thus are not added to M . Only child era-
sure patterns at least twice as big as the shortest known min-
imal erasure can possibly be a composite erasure. Line 313
determines the length of the shortest minimal erasure in
M . A child erasure pattern shorter than this length must
be a minimal erasure since it is too small to be a com-
posite erasure. A child erasure pattern twice or more this
length is analyzed to determine if it is a minimal erasure or
a composite erasure. The function is composite called on
line 314 determines if ˜f (cid:1)
is a composite erasure or not. It
does so by testing the rank of the matrix that corresponds
to {T \ ˜f (cid:1)} ∪ {e ∈ ˜f (cid:1)}. It is necessary and sufﬁcient to
remove a single symbol e from ˜f (cid:1)
to test for minimality: ˜f (cid:1)
is either a minimal erasure, and so removing e yields a ma-
trix of full rank, or a composite erasure, and so removing e
yields a matrix not of full rank. (Note that removing erasure
e from ˜f (cid:1)
makes the symbol corresponding to e available for
decoding.)
Once the ME Algorithm completes, the minimal erasures
data structure M is trivially transformed into both the MEL
and the MEV.
3.2. Example execution
Consider the XOR-based erasure code with k = 4 and
m = 4 deﬁned by the following Generator matrix:
C =
s1
1
0
0
0
s2
0
1
0
0
s3
0
0
1
0
s4
0
0
0
1
p1
1
1
0
0
p2
0
1
1
0
p3
0
1
1
1
p4
1
1
0
1
˜fs1˜fs2˜fs3˜fs4
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:37:52 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007s1
s
2
s3
s4
p1
p
2
p3
p4
Figure 2. Systematic Tanner graph for code C
The columns in C are labeled as either a data column or a
parity column, and the rows are labeled as base erasures.
Figure 2 shows the systematic Tanner graph T for code
C. Table 2 summarizes the execution of the ME Algorithm
for the code deﬁned by C. The ﬁrst column lists the erasure
pattern ˆf being processed by me children, the second col-
umn lists the children of ˆf (possibly over multiple rows),
and the third column indicates (via a checkmark) if ˆf
is
inserted into M and enqueued in Q. The ﬁrst four rows
illustrate the base erasures ˜fs1 ,˜fs2 ,˜fs3 ,˜fs4 processed by
me search. The remaining rows illustrate the children gen-
erated by dequeuing erasure patterns from Q and indicates
which children are inserted into M . If a child is already in
M , then it is not inserted again. Consider the ﬁrst erasure
pattern dequeued from Q: (s1, p1, p4). From the systematic
Tanner graph, it is easy to see that the adjacent data sym-
bols are s2 and s4. The ﬁnal steps of the ME Algorithm
are elided because children generated by the remaining era-
sure patterns in Q are already in M . The MEL output by
the ME Algorithm is {(s1, p1, p4), (s3, p2, p3), (s4, p3, p4),
(s1, s2, s3), (s1, s2, p2, p3), (s1, s2, p2, p3), (s2, s3, p1, p4),
(s2, s4, p1, p2), (s2, s3, p1, p4), (s3, s4, p2, p4)}. Any ˜f
longer than m = 4 is elided from the MEL. The MEV output
by the ME Algorithm is (0, 0, 4, 5).
3.3. Correctness
In this section, we prove that the MEL of an XOR-based
erasure code completely describes its fault tolerance (i.e.,
contains all of the information that the EL does), and that the
ME Algorithm generates a complete MEL and so is correct.
We ﬁrst prove that the MEL is a complete description of
an XOR-based erasure code’s fault tolerance.
Theorem 3.1 If the fault tolerance of an XOR-based era-
sure code can be obtained through the EL, it can also be
obtained through the MEL.
Proof. By deﬁnition of minimality, every minimal erasure
is an erasure pattern. Now for each erasure pattern ˆf in EL,
write down all possible minimal erasures. This can be done
by exhaustively removing data and parity symbols from ˆf .
Q.dequeue
ˆf
M
(s1, p1, p4)
✓
(s2, p1, p2, p3, p4) ✓
(s3, p2, p3)
✓
(s4, p3, p4)
✓
(s1, s2, p2, p3)
✓
(s1, s4, p1, p3)
✓
(s2, p1, p2, p3, p4) (s1, s2, p2, p3)
✕
(s2, s3, p1, p4)
✓
(s2, s4, p1, p2)
✓
(s2, s3, p1, p4)
✕
(s3, s4, p2, p4)
✓
(s1, s4, p1, p3)
✕
(s2, s4, p1, p2)
✕
(s3, s4, p2, p4)
✕
(s1, s2, s3)
✓
(s1, s2, s4, p2, p4) ✓
. . .
. . .
(s1, s2, p2, p3)
. . .
(s1, p1, p4)
(s3, p2, p3)
(s4, p3, p4)
Table 2. Example ME Algorithm execution.
Clearly, from each of these minimal erasures, the original
erasure pattern ˆf can be generated by adding back the re-
spective data and parity symbols that were deleted. Now
take the union of all these minimal erasures. Since this
union is the MEL, and every erasure pattern in the EL can
be generated from some minimal erasure in MEL, the theo-
rem now follows. (cid:1)
Consider the Generator matrix for the code and some
erasure set f . We refer to the matrix that corresponds to
the Generator matrix with all of the data and parity columns
that correspond to f removed as the recovery matrix. We
refer to a recovery matrix as a defective recovery matrix if
it cannot be used to recover some data symbol. We refer to
the rows in the recovery matrix that correspond to the data
symbols in f —which we refer to via the notation f .S —as
the lost data rows.
Proposition 3.2 A recovery matrix is defective if and only
if its rank is less than k.
Proof. Follows from the deﬁnitions of erasure pattern and
defective recovery matrix. (cid:1)
Lemma 3.3 Every base erasure is a minimal erasure.
Proof. We ﬁrst argue that a base erasure ˜fb is an erasure pat-
tern. By deﬁnition, a base erasure precisely corresponds to
a row of the Generator matrix. The recovery matrix induced
by ˜fb has rank of k − 1 because it has an all zero row—the
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:37:52 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007single lost data row—and an (k − 1)× (k − 1) identity ma-
trix in the data submatrix. Therefore, by Proposition 3.2,
the recovery matrix is defective.
To show that a base erasure is a minimal erasure, we
need to establish that if any of the columns in the Generator
matrix, that are not in the recovery matrix, is added into the
recovery matrix, then the recovery matrix would have rank
k. If the data column sb corresponding to ˜fb is added into
the recovery matrix, then the data submatrix would contain
an k × k identity matrix, thus have full rank, and not be
defective.
If one of the parity columns corresponding to
some parity symbol p ∈ ˜fb.P is added into the recovery
matrix, then a column swap operation can move it into the
data submatrix. Column additions within the data submatrix
can then be performed until an identity matrix of size k × k
is established. (cid:1)
i=1
(cid:7)k
Lemma 3.4 The addition (XOR) of any subset of the col-
lection of base erasures is an erasure pattern.
Proof. Let {˜f1 , . . . ,˜fk} denote the set of base erasures, and
˜fi denote their sum. Consider the recovery ma-
f =
trix induced by f . Each of the lost data rows of the recovery
matrix can be written as a linear combination of all of the
other lost data rows. The lost data rows of the data sub-
matrix are all zeroes and so are linear combinations of one
another. The lost data rows of all the parity columns in the
recovery matrix have even parity. In each lost data row then,
each parity column is either a zero or a one: in either case, it
can be written as a linear combination of the other lost data
rows. If the column is a zero, then the other rows have even
parity, and their sum is zero; if it is a one, then the other
rows have odd parity and their sum is one. Therefore the
rank of the recovery matrix must be less than k and so is
defective; f is an erasure pattern. (cid:1)
Unfortunately, the above lemma cannot be strengthened
to say that f is a minimal erasure. The XOR of some sets
of base erasures in some codes result in composite erasures
comprised of two or more minimal erasures. However, all
minimal erasures can be generated through the addition of
base erasures. We prove this next.
Theorem 3.5 Every minimal erasure can be obtained by
the addition of some set of base erasures.
Proof. Consider a minimal erasure ˜f . By Proposition 3.2,
the rank of the recovery matrix induced by ˜f is less than
k, and therefore, at least one lost data row in the recovery
matrix is linearly dependent on the other lost data rows, or
all zeroes. Below we strengthen this observation.
Claim 3.1 Every lost data row in the recovery matrix in-
duced by ˜f is linearly dependent on the rest of the lost data
rows, or is all zeroes.
Proof. Suppose there exist lost data rows in the recovery
matrix that are not linearly dependent on the rest of the lost
data rows.
Ignore all such rows; the remaining lost data
rows are either linearly dependent on one another or a single
lost data row remains.
If a single lost data row remains,
by Lemma 3.3, it is a base erasure (and is all zeroes), a
contradiction to the minimality of ˜f . On the other hand,
let S (cid:1)
be the set of data symbols that correspond to the lost
data rows that are linearly dependent on one another. Then,
S (cid:1) ⊂ ˜f .S . Now, by Proposition 3.2, {S (cid:1)∪˜f .P} is an erasure
pattern, a contradiction to the minimality of ˜f . (cid:1)
Claim 3.2 In any subset of rows corresponding to lost data
symbols in the recovery matrix, if every row is linearly de-
pendent on the rest of the rows, then the respective parity
columns must have even parity.
Proof. Suppose there is a column that has odd parity. A
lost data row with a zero in this column cannot be linearly
dependent on all other lost data rows. (cid:1)
By Claims 3.1 and 3.2, the parity columns of the recov-
ery matrix induced by ˜f must have even parity. So, by an
argument similar to the proof of Lemma 3.4, ˜f can be writ-
ten as the sum of the base erasures that correspond to the
data symbols in ˜f .S . This proves the theorem. (cid:1)
3.4. Bounds on |MEL| and |EL|
(cid:10)
(cid:9)
The bound on the size of the EL is as follows:
|EL| ≤ m(cid:8)
i=1
k + m
i
< 2k +m
We use the fact that all erasure patterns of interest are less
than or equal to m in length to tighten the bound on |EL|.
Let BEL be the base erasures list: the XOR of each set
in the powerset of base erasures, except the null set. It is
thus the union of all minimal erasures and all composite
erasures. The bound on the size of the BEL is as follows:
(cid:11)(cid:12)m
i=1
2k
(cid:13)
(cid:14)
k
i
if m < k,
if m ≥ k.
(cid:14)(cid:19)
(cid:13)
(cid:19)
k
i
(cid:14)
,
(cid:12)m
(cid:14)
k +m