byte in the decryption of the ﬁrst Ci is larger than 0x7f, then
the byte at the same position in the decryption of the second
Ci will be smaller than or equal to 0x7f. The attacker can
then get the full plaintext of Ci by combining the bytes that
he gets from the decryptions of the two Ci.
One way to solve the second problem would be to repeatedly
perform requests to the oracle, changing part of the input,
until the output has as many bytes as expected. A more
efﬁcient aproach is to construct a large query such as
C1|Cknown|C2|Cknown|C3|Cknown|···|Cn|Cknown , where
Ci are groups of blocks that the attacker wants to decrypt and
known are the
Cknown = C1
last two blocks of any known ciphertext. Notice that C2
known
would be decrypted as a known plaintext Pknown. The
attacker can then split the output of the T-block oracle into
chunks using Pknown as the separator. He then calculates
the length of each chunk, ignores chunks that are losing
some bytes, and accepts only those chunks that don’t lose
any bytes. Further optimizations are possible using redudant
information present in the incomplete chunks.
known, where C1
known|C2
known|C2
With these optimizations, the attacker can use the T-block
as an efﬁcient decryption oracle to attack the framework.
Algorithm 5 describes how the attacker can use the T-block
oracle together with CBC-R to download ﬁles.
C. Attack Cost
The cost of attack consists of three parts, which are described
in this section. The ﬁrst part is the cost of ﬁnding a T-block,
which on average takes 256 HTTP requests.
487487
The second part is the cost of CBC-R. Although here we
only perform cost analysis for the case where the attacker
wants to download web.config, a similar analysis applies
to other ﬁles. Suppose the block size b is 16. The attacker
needs just one block for |||~/web.config (which is 15
bytes.) For each block, the attacker needs only one T-block
oracle call, which is equal to one HTTP request. So, the cost
of this part is negligible.
The third part is to ﬁnd a block C0 whose ﬁrst two bytes
after decryption match one of the magic byte values. Since
the ﬁrst two bytes of C0 can be one of the four values r#,
R#, q#, and Q#, the attacker needs on average 214 HTTP
requests to brute-force the ﬁrst two bytes of C0. To reduce
the number of requests, the attacker can build a large query
that contains the maximum number of blocks that ﬁt in a
single HTTP request. The attacker can construct a ciphertext
that contains a T-block, then 20 repetitions of Cr|Ci| ˜Cr|Ci,
separated by 19 pairs of C1
known, then ending with
known|C2
another pair of C1
known. Each repetition consumes 6
known|C2
AES blocks, or 6*16 = 96 bytes. With 20 repetitions, the full
ciphertext after conversion to BASE64 [19] is approximately
2048 bytes long, which is the maximum query size allowed
by ASP.NET. About half of these 20 repetitions would
lose some bytes, so the attacker can decrypt 10 blocks
per request. In summary, the attack takes on average about
256+214/10 = 1894 HTTP requests, each about 2048 bytes
long. In other words, the attacker has to send a total of
about 3MB of data to the server on average. Note that for
a particular target, the attacker can reuse T-block and C0 in
subsequent attacks to download other ﬁles.
VI. IMPACT AND COUNTERMEASURES
A. Impact
We have presented two attacks on ASP.NET v4.0. The
attacks are highly efﬁcient and have been demonstrated to
work under realistic scenarios. The best attack requires less
than 2,000 HTTP requests to steal secret cryptographic keys
in ASP.NET applications. After obtaining those keys, the
attacker can easily create authentication tickets that he can
use to sign in to any user account. Most applications have
administration interfaces, and if the attacker can gain access
to those areas, he can then sign in as an administrator
and seize control of the whole application. Aministration
interfaces often allow unlimited ﬁle uploading, which would
allow the attacker to achieve remote code execution.
There is other important information inside web.config
besides cryptographic keys. Since web.config is sup-
posed to be private, users and developers tend to put a
lot of sensitive information there. It is not uncommon to
see connection strings with usernames and passwords to
database stores, mail servers and directory services. We have
even seen web.config ﬁles that contain the password
of a Domain Administrator account in Microsoft Active
Directory.
Besides web.config, the described attacks can also be
used to download source code and other intellectual property.
The App_Code folder in ASP.NET applications contains
source code for shared classes and business objects (for
example, .cs and .vb ﬁles). Files within App_Code and any
other ﬁles inside the document root of applications can be
stolen.
To emphasize the real-world impact of our attacks, we
note that ASP.NET is a hugely popular web framework,
and it is believed that 25% of the applications online are
built using it. However, that number is far higher in the
corporate and ﬁnancial services sectors, and applications
such as online banking and e-commerce are prime targets
for this attack. DotNetNuke CMS5, the most popular public
ASP.NET application with over 600,000 installations, has
been demonstrated to be vulnerable to these attacks. Mi-
crosoft also acknowledged that Microsoft SharePoint, one of
the most popular enterprise collaboration applications, was
also affected. 6 Even microsoft.com was vulnerable.7 It is
also worth noting that Mono, the open source implementa-
tion of ASP.NET, was vulnerable to these attacks.8
B. Countermeasures
Our attacks, especially the T-block attack, are difﬁcult to
detect. After all, all of those thousands of requests sent to the
target are encrypted, and none of them cause any suspicious
logging errors. In other words, countermeasures such as
web application ﬁrewalls or network security monitoring can
hardly detect, let alone prevent, our attacks.
After initial details of our attacks were released to the public
[20], Microsoft released an immediate workaround.9 The
workaround focused on padding oracles, and, therefore, it
mitigated part of the ﬁrst attack. However, it completely
failed to address the second attack. After we sent more infor-
mation to Microsoft, they eventually released a patch that did
prevent all of our attacks [21]. It is strongly recommended
that ASP.NET users and developers immediately install this
ofﬁcial security update to protect against these attacks.
C. Related Work
Black and Urtubia [10] have generalized Vaudenay’s attack
to other padding schemes and modes of operations, and
5See http://www.dotnetnuke.com.
6See http://sharepoint.microsoft.com/blog/
7See http://forums.asp.net/p/1605099/4096837.aspx.
8See http://www.mono-project.com/Vulnerabilities#ASP.NET_Padding_Oracle
9See
http://weblogs.asp.net/scottgu/archive/2010/09/18/important-asp-
net-security-vulnerability.aspx.
presented a padding method that prevents the attack. Canvel
et al. [22] demonstrated the practicality of padding oracle
attacks by implementing an attack against the IMAP protocol
when used over SSL/TLS. In a typical setting, the attack
recovers the IMAP password within one hour. For many
years, this was the most pratical application of the attack
published.
Klima and Rosa [23] applied the idea of a “format correct-
ness oracle” (of which the padding oracle is a special case)
to construct a PKCS#7 validity oracle. Using this oracle,
they were able to decrypt one PKCS#7 formatted ciphertext
byte using an average of 128 oracle calls. For the Web,
Rizzo and Duong [14] used padding oracle attacks to crack
CAPTCHAs as well as to decrypt view states and session
state data in various popular web development frameworks.
The most vulnerable software studied in [14]
is the
JavaServer Faces (JSF) framework. Using CBC-R, an at-
tacker can create malicious JSF view states to attack web
applications. However, the security consequences of being
able to forge JSF view states depend on how the application
uses the view state information.
This paper is the ﬁrst to describe step-by-step how to use de-
cryption oracles and CBC-R to compromise any application
using the ASP.NET framework. The new attacks described
are more dangerous, generic and efﬁcient than any previous
published results involving padding oracles.
VII. CONCLUSIONS
In this paper, we analyze and efﬁciently exploit several
cryptographic ﬂaws in ASP.NET, the widely-used web appli-
cation framework developed by Microsoft. The most serious
vulnerability we discovered is the use of unauthenticated
encryption. This vulnerability is exacerbated by the reuse of
keys to encrypt data with very different levels of importance.
We present two practical and highly efﬁcient attacks that
allow an attacker to steal cryptographic secret keys, and
impersonate any user account
in ASP.NET applications.
These attacks are performed by abusing components present
in every application developed using the framework. The
applications are even more exposed if they use the secu-
rity features provided by ASP.NET, especially form based
authentication.
Cryptography is difﬁcult to implement correctly, and cryp-
tographers often advise non-cryptographers not to develop
their own cryptography. But if one looks more closely at
the current situation, it is evident that web developers and
users do not have much choice. ASP.NET developers still
have to ﬁgure out on their own how to use cryptographic
primitives correctly any time they want to build a secure
cryptographic protocol. This is not a problem speciﬁc to
ASP.NET. Most other popular web development frameworks
488488
do not provide their users and developers easy and secure
ways to use cryptography [14]. Popular scripting languages,
including Ruby, Python, PHP, provide cryptography libraries
as bindings to OpenSSL [24]. While OpenSSL is powerful,
it is a low-level library that again requires its users to know
how to use cryptographic primitives securely.
Unauthenticated encryption should be considered harmful.
This is not just a theoretical problem; rather, unauthenti-
cated encryption has repeatedly led to devastating attacks
against real systems. Any cryptographic API should use
authenticated encryption whenever its users want to encrypt
data. The development and popularization of high-level
cryptographic toolkits that include authenticated encryption
such as Keyczar [25], Cryptlib [26], and NaCl [27] is
the ﬁrst step to providing secure cryptographic software
libraries to the general public. The next step might be the
integration of these cryptographic toolkits into mainstream
web development frameworks.
Acknowledgments
We are grateful to many people for their help in writing this
paper. First of all, we would like to thank William Robertson,
Ned Bass and the anonymous reviewers for their work
and valuable comments that have signiﬁcantly improved
the quality of our initial manuscript. Our thanks to Michal
Trojnara, Giang Duc Pho, Luciano Notarfrancesco, Peter
Gutmann, Agustin Azubel, Matias Soler, Agustin Gianni
and especially Huong Lan Nguyen for the care with which
they reviewed the original draft; and for conversations that
clariﬁed our thinking on this and other matters. We would
also like to thank Kenneth Paterson and Serge Vaudenay for
their encouragement and instruction.
REFERENCES
[1] P. Nguyen, “Can We Trust Cryptographic Software? Crypto-
graphic Flaws in GNU Privacy Guard v1. 2.3,” in Advances
in Cryptology-EUROCRYPT 2004. Springer, 2004, pp. 555–
570.
[2] I. Goldberg and D. Wagner, “Randomness and the Netscape
Browser,” Dr Dobb’s Journal-Software Tools for the Profes-
sional Programmer, vol. 21, no. 1, pp. 66–71, 1996.
[3] P. Gutmann, “Lessons Learned in Implementing and Deploy-
ing Crypto Software,” in Proc. USENIX Security Symp, 2002,
pp. 315–325.
[4] K. Jallad, J. Katz, and B. Schneier, “Implementation of
Chosen-Ciphertext Attacks against PGP and GnuPG,” Infor-
mation Security, pp. 90–101, 2002.
[5] J. Katz and B. Schneier, “A Chosen-Ciphertext Attack against
Several E-mail Encryption Protocols,” in Proceedings of the
9th conference on USENIX Security Symposium-Volume 9.
USENIX Association, 2000, p. 18.
[6] B. Schneier, “Security in the Real World: How To Evaluate
Security Technology,” Computer Security Journal, vol. 15,
no. 4, p. 1, 1999.
[7] T. Yu, S. Hartman, and K. Raeburn, “The Perils of Unau-
thenticated Encryption: Kerberos Version 4,” in Proc. NDSS,
vol. 4. Citeseer, 2004.
[8] M. Bellare, T. Kohno, and C. Namprempre, “Breaking
and Provably Repairing the SSH Authenticated Encryption
Scheme: A Case Study of the Encode-then-Encrypt-and-MAC
Paradigm,” ACM Transactions on Information and System
Security (TISSEC), vol. 7, no. 2, p. 241, 2004.
[9] M. Bellare and C. Namprempre, “Authenticated Encryption:
Relations Among Notions and Analysis of the Generic Com-
position Paradigm,” Journal of Cryptology, vol. 21, no. 4, pp.
469–491, 2008.
[10] J. Black and H. Urtubia, “Side-channel Attacks On Symmetric
Encryption Schemes: The Case for Authenticated Encryp-
tion.”
[11] K. Paterson and A. Yau, “Cryptography in Theory and
Practice: The Case of Encryption in IPsec,” Advances in
Cryptology-EUROCRYPT 2006, pp. 12–29, 2006.
[12] ASP.NET, “The Ofﬁcial Microsoft Web Development Frame-
work. http://www.asp.net.”
[13] S. Vaudenay, “Security Flaws Induced by CBC Padding-
in Cryptology-
Applications
EUROCRYPT 2002. Springer, 2002, pp. 534–545.
in Advances
to SSL,”
[14] J. Rizzo and T. Duong, “Practical Padding Oracle Attacks,”
USENIX WOOT, 2010.
[15] J. An, Y. Dodis, and T. Rabin, “On the Security of Joint
Signature and Encryption,” in Advances in Cryptology-
EUROCRYPT 2002. Springer, 2002, pp. 83–107.
[16] H. Krawczyk, “The Order of Encryption and Authentication
for Protecting Communications (or: How Secure Is SSL?),”
in Advances in Cryptology—CRYPTO 2001. Springer, 2001,
pp. 310–331.
[17] M. Dworkin, “NIST Recommendation for Block Cipher
Modes of Operation, Methods and Techniques,” NIST Special
Publication.
[18] K. Paterson and A. Yau, “Padding Oracle Attacks On the ISO
CBC Mode Encryption Standard,” Topics in Cryptology–CT-
RSA 2004, pp. 1995–1995, 2004.
[19] S. Josefsson, “RFC 3548-The Base16, Base32, and Base64
Data Encodings. IETF,” 2003.
[20] T. Duong and J. Rizzo, “Padding Oracles Everywhere,”
EKOPARTY, 2010.
[26] P. Gutmann, “Cryptlib Encryption Tool Kit,” 2008.
[27] D. Bernstein, “Cryptography in NaCl.”
[28] A. Yau, K. Paterson, and C. Mitchell, “Padding Oracle
Attacks on CBC-mode Encryption with Secret and Random
IVs,” in Fast Software Encryption. Springer, 2005, pp. 299–
319.
[29] S. Stubblebine and V. Gligor, “On Message Integrity in Cryp-
tographic Protocols,” in Research in Security and Privacy,
1992. Proceedings., 1992 IEEE Computer Society Symposium
on.
IEEE, 2002, pp. 85–104.
[30] N. Borisov, I. Goldberg, and D. Wagner, “Intercepting Mobile
Communications: The Insecurity of 802.11,” in Proceedings
of the 7th annual international conference on Mobile com-
puting and networking. ACM, 2001, pp. 180–189.
[31] S. Bellovin, “Problem Areas for the IP Security Protocols,”
in Proceedings of the Sixth Usenix Unix Security Symposium,
1996, pp. 205–214.
489489
Microsoft
- Vulnerability
[21] Microsoft.
070
Information
http://www.microsoft.com/technet/security/bulletin/ms10-
070.mspx
MS10-
Could Allow
Available:
in ASP.NET
Disclosure.
[Online].
Security
Bulletin
[22] B. Canvel, A. Hiltgen, S. Vaudenay, and M. Vuagnoux,
“Password Interception in a SSL/TLS channel,” Advances in
Cryptology-CRYPTO 2003, pp. 583–599, 2003.
[23] V. Klima and T. Rosa, “Side Channel Attacks On CBC
Encrypted Messages in the PKCS# 7 Format,” IACR ePrint
Archive, vol. 98, p. 2003, 2003.
[24] E. Young, T. Hudson, and R. Engelschall, “OpenSSL:
The Open Source Toolkit for SSL/TLS,” World Wide Web,
http://www.openssl.org/, Last visited, vol. 9, 2011.
[25] A. Dey and S. Weis, “Keyczar: A Cryptographic Toolkit,”
2008.