bytes. Further, every packet increments the sequence number;
even pure acknowledgments carrying no data [31]. The re-
ceiver acknowledges the highest sequence number received;
since DCCP does not retransmit data, a TCP-like cumulative
acknowledgment does not make sense.
However, this design means that DCCP endpoints can get
out of sync after extended bursts of loss and reject valid packets
as not within the current sequence window. To mitigate this
issue, a third handshake–of SYNC and SYNCACK packets–is
used to exchange the current sequence numbers of both parties
and resynchronize the connection [31].
DCCP also features pluggable congestion control modules,
known as CCIDs. Two are currently standardized: CCID 2,
TCP-like Congestion Control, and CCID 3, TCP-Friendly Rate
Control (TRFC). We focus on CCID 2 in this work. It follows
the TCP SACK congestion control algorithm as closely as
possible [32]. There are several changes in order to handle the
switch from byte-based to packet-based sequence numbers.
Testing. For DCCP testing, we used iperf to measure
throughput. Since DCCP is not a reliable protocol, we mea-
sured performance based on server goodput, or actual data
received. As DCCP is currently only supported on Linux
and is fairly uncommon, we focused our efforts on a single
implementation, the Linux kernel 3.13 implementation.
In our testing, SNAKE discovered this attack against all of
our TCP implementations. Like the Reset Attack, this attack
utilizes a feature of the TCP speciﬁcation itself, which makes
it difﬁcult for implementations to protect against.
SNAKE tried just over 4,500 strategies against DCCP.
Of these,
identiﬁed 67 candidate strategies that caused
signiﬁcant performance issues or potential resource exhaustion.
This is about 1.5% of the total strategies tested.
it
1010
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:11:45 UTC from IEEE Xplore.  Restrictions apply. 
On-path attacks. As with TCP, DCCP was not designed
to be resilient to on-path attacks. Thus, we exclude all on-path
attacks found by SNAKE.
the connection’s allowed sending rate. It may even trigger a
timeout and subsequent slow start, assuming DCCP’s CCID 2
congestion control is in use.
False positives. We also found 2 attacks that were false
positives. As with TCP, these attacks are both hitseqwindow
strategies that attempt to inject packets into a target connec-
tion at sequence window intervals. Injecting this quantity of
packets tends to signiﬁcantly slow down the competing target
connection, irrespective of any malicious impact of the injected
packets. Thus, these strategies tend to fall below our attack
threshold.
Client and off-path attacks. Discarding the on-path at-
tacks and the two false positives leaves us with 38 strategies
that represent actual attacks. However, many of these strategies
are functionally the same attack, just repeated on different
ﬁelds or with different values. Ultimately, we found three
attacks; none of which have been reported in the literature.
We discuss each of these attacks below.
1) Acknowledgment Mung Resource Exhaustion Attack:
This attack is possible because a DCCP sender will not close
a connection until its send queue is empty. This send queue
defaults to 10 packets, but may be much larger for applications
like video streaming. As a result, if a connection’s congestion
control can be persuaded to send at the minimum rate, a
connection can be held in an open-but-useless state for a
very long time. By repeating this process, one can create an
effective resource exhaustion attack that may render the target
host unavailable.
Note that DCCP does not retransmit data. As a result,
while similar attacks against TCP last until TCP gives up
retransmitting a particular packet and resets the connection,
DCCP will continue sending at its minimum rate until the
application and the human trying to use it explicitly close the
connection. Once the application closes the connection, DCCP
will send all queued packets and then close the connection and
free related resources.
There are several ways to convince DCCP’s congestion
control to send at
its minimum rate. Most of them work
by invalidating or dropping the acknowledgments from the
receiver. Modifying the sequence or acknowledgment numbers
are very effective because this results in an additional exchange
of SYNC and SYNCACK packets.
2) In-window Acknowledgment Sequence Number Modiﬁ-
cation: This attack targets sequence numbers in the receiver’s
acknowledgment packets. Recall that sequence numbers in
DCCP are per-packet and that every packet increments the
sequence number; even pure acknowledgment packets.
If the sequence number of one of these acknowledgments
is increased, such that it is still sequence valid, the sender
will begin to acknowledge this bad acknowledgment number
in its data packets. However, when the receiver receives these
data packets it will ﬁnd they acknowledge packets that have
not yet been sent. As a result, it will drop these packets
and send a SYNC in response. The SYNC packet will result
in a SYNCACK packet from the sender, resynchronizing the
sequence numbers and allowing the connection to proceed.
However, by that point an entire window of packets will have
been dropped, resulting in DCCP’s congestion control reducing
To perform this attack, an attacker does not have to be
an endpoint. It sufﬁces to be able to sniff and spoof network
trafﬁc. Such an attacker can inject an acknowledgment with a
slightly higher sequence number and trigger this vulnerability.
3) REQUEST Connection Termination Attack: This attack
is an effective way to terminate a connection during the
connection initiation phase. A client enters the REQUEST state
on initiating a connection, immediately after having sent a
REQUEST packet to the server, and stays in this state until
it receives a RESPONSE packet from the server.
The only valid packets
in the REQUEST state are
RESPONSE or RESET; any other packet results in a reset. Note
that both the pseudo-code in RFC 4340 [31] and the Linux 3.13
DCCP implementation perform this packet type check before
checking the sequence numbers. Thus, it is possible to reset a
DCCP connection in the REQUEST state by sending any non-
RESPONSE packet with any sequence and acknowledgment
numbers.
This makes the attack exploitable by anyone who can sniff
and spoof packets. An off-path, third party attacker can launch
this attack, if they can guess the connection initiation time (to
within an RTT) and the source port.
C. Beneﬁts of State-based Strategy Generation
Our state-based strategy generation algorithm enabled us
to ﬁnd 9 attacks against 2 transport protocols and a total
of 5 implementations. 5 of these attacks were previously
unknown. To accomplish this, we required about 60 hours per
tested implementation. Removing parallelism, this becomes
300 hours of computation per tested implementation.
By contrast, the time-interval-based attack injection ap-
proach discussed in Section IV-B requires trying our malicious
strategies at intervals of 5 microseconds, which is roughly the
amount of time needed to send a minimum sized TCP packet
at 100Mbits/sec. Thus, there are 12 million possible injection
points in a 1 minute test connection. For each of these injection
points, we would have to test about 60 different malicious
strategies resulting from the 8 general malicious actions and
the 13 ﬁelds in the TCP header. This results in 720 million
strategies to test.
At 2 minutes to test each strategy, this would require
24 million hours of computation. At an equivalent level of
parallelism, this would take 548 years to complete, which is
clearly impractical.
The send-packet-based attack injection approach is more
practical. A one minute non-attack test with TCP results in the
sending of about 13,000 packets. For each of these packets,
we would need to test about 53 different malicious strategies
for packet manipulation, resulting in a total of 689,000 strate-
gies. This would require 22,967 hours of computation. At an
equivalent level of parallelism, this would take about 191 days.
The send-packet-based attack injection also provides no
support for packet injection attacks modeling third party, off-
path attackers. As a result, it would be impossible to ﬁnd the
Reset and Syn-Reset attacks using this attack injection model.
1111
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:11:45 UTC from IEEE Xplore.  Restrictions apply. 
VII. CONCLUSION
Transport layer networking protocols form an important
part of the Internet, yet, to date, their testing has been mostly
manual and ad-hoc. This has resulted in a stream of vulner-
abilities stretching back to the 1980’s. To help remedy this
situation, we present SNAKE, a tool to allow systematic testing
of unmodiﬁed transport protocol implementations, utilizing
the protocol state machine to reduce the search space. We
demonstrate SNAKE by testing 2 different protocols, TCP and
DCCP, and 5 implementations, including both open-source and
closed-source systems. We found 9 attacks, 5 of which we
believe to be unknown in the literature. SNAKE requires only
a description of the protocol packet headers and protocol state
machine, both readily obtained from protocol speciﬁcation
documents. We believe SNAKE can contribute to securing the
transport layer of modern network stacks.
ACKNOWLEDGMENT
This material is based in part upon work supported by
the National Science Foundation under Grant Number CNS-
1223834. Any opinions, ﬁndings, and conclusions or recom-
mendations expressed in this material are those of the authors
and do not necessarily reﬂect the views of the National Science
Foundation.
REFERENCES
[1] G. Lyon, “Nmap,” 2014. [Online]. Available: http://nmap.org/
[2] N. Cardwell, Y. Cheng, L. Brakmo, M. Mathis, B. Raghavan,
N. Dukkipati, H.-k. J. Chu, A. Terzis, and T. Herbert, “Packetdrill:
Scriptable network stack testing, from sockets to packets,” in USENIX
Annual Technical Conference. USENIX, 2013, pp. 213–218.
[3] Centre for the Protection of National Infrastructure, “Security assess-
ment of the transmission control protocol,” Centre for the Protection of
National Infrastructure, Tech. Rep. CPNI Technical Note 3/2009, 2009.
[4] V. Paxson, M. Allman, S. Dawson, W. Fenner, J. Griner, I. Heavens,
K. Lahey, J. Semke, and B. Volz, “Known TCP implementation prob-
lems,” RFC 2525 (Informational), Mar. 1999.
[5] N. Kothari, R. Mahajan, T. Millstein, R. Govidan, and M. Musuvathi,
“Finding protocol manipulation attacks,” in Proceedings of the ACM
SIGCOMM 2011 Conference. ACM, 2011, pp. 26–37.
[6] H. Lee, J. Seibert, E. Hoque, C. Killian, and C. Nita-Rotaru, “Turret:
A platform for automated attack ﬁnding in unmodiﬁed distributed
system implementations,” in IEEE 34th International Conference on
Distributed Computing Systems (ICDCS).
IEEE, 2014, pp. 660–669.
[7] B. Guha and B. Mukherjee, “Network security via reverse engineering
of TCP code: Vulnerability analysis and proposed solutions,” IEEE
Network, vol. 11, no. 4, pp. 40–48, 1997.
[8] V. Kumar, P. Jayalekshmy, G. Patra, and R. Thangavelu, “On remote
exploitation of TCP sender for low-rate ﬂooding denial-of-service
attack,” IEEE Communications Letters, vol. 13, no. 1, pp. 46–48, 2009.
[9] A. Kuzmanovic and E. Knightly, “Low-rate TCP-targeted denial of
service attacks and counter strategies,” IEEE/ACM Transactions on
Networking, vol. 14, no. 4, pp. 683–696, 2006.
[10] R. Morris, “A weakness in the 4.2 BSD unix TCP/IP software,” AT&T
Bell Leboratories, Tech. Rep., 1985.
[11] S. Savage, N. Cardwell, D. Wetherall, and T. Anderson, “TCP conges-
tion control with a misbehaving receiver,” ACM SIGCOMM Computer
Communication Review, vol. 29, no. 5, p. 71, Oct. 1999.
[12]
J. Touch, “Defending TCP against spooﬁng attacks,” RFC 4953 (Infor-
mational), Jul. 2007.
[13] P. Watson, “Slipping in the window: TCP reset attacks,” CanSecWest,
http://bandwidthco.com/
[Online]. Available:
Tech. Rep.,
whitepapers/netforensics/tcpip/TCPResetAttacks.pdf
2004.
[14] G. Banks, M. Cova, V. Felmetsger, K. Almeroth, R. Kemmer, and
G. Vigna, “SNOOZE: Toward a Stateful NetwOrk prOtocol fuzZEr,”
in Information Security Conference, ser. Lecture Notes in Computer
Science, S. Katsikas, J. Lopez, M. Backes, S. Gritzalis, and B. Preneel,
Eds., vol. 4176. Springer, 2006, pp. 343–358.
[15] H. J. Abdelnur, R. State, and O. Festor, “KiF: A stateful SIP fuzzer,” in
Proceedings of the 1st International Conference on Principles, Systems
and Applications of IP Telecommunications, ser. IPTComm ’07. ACM,
2007, pp. 47–56.
[16]
J. Wang, T. Guo, P. Zhang, and Q. Xiao, “A model-based behavioral
fuzzing approach for network service,” in Third International Confer-
ence on Instrumentation, Measurement, Computer, Communication and
Control (IMCCC).
IEEE, 2013, pp. 1129–1134.
[17] P. Tsankov, M. T. Dashti, and D. Basin, “SECFUZZ: Fuzz-testing
security protocols,” in 7th International Workshop on Automation of
Software Test (AST), 2012, pp. 1–7.
[18] C. Y. Cho, D. Babic, P. Poosankam, K. Z. Chen, E. X. Wu, and D. Song,
“MACE: Model-inference-assisted concolic exploration for protocol and
vulnerability discovery,” in USENIX Security Symposium. USENIX,
2011.
[19] H. Guo, M. Wu, L. Zhou, G. Hu, J. Yang, and L. Zhang, “Practical soft-
ware model checking via dynamic interface reduction,” in Proceedings
of the Twenty-Third ACM Symposium on Operating Systems Principles,
ser. SOSP ’11. ACM, 2011, p. 265.
[20] Y. Wang, Z. Zhang, D. D. D. Yao, B. Qu, and L. Guo, “Inferring
protocol state machine from network traces: A probabilistic approach,”
in Proceedings of the 9th International Conference on Applied Cryp-
tography and Network Security, ser. ACNS’11. Springer-Verlag, Jun.
2011, pp. 1–18.
[21]
J. C. King, “Symbolic execution and program testing,” Communications
of the ACM, vol. 19, no. 7, pp. 385–394, 1976.
[22]
J. Postel, “User datagram protocol,” RFC 768 (Standard), Aug. 1980.
[23] S. Floyd, M. Handley, J. Padhye, and J. Widmer, “TCP friendly
rate control (TFRC): Protocol speciﬁcation,” RFC 5348 (Proposed
Standard), Sep. 2008.
[24]
J. Widmer and M. Handley, “TCP-friendly multicast congestion control
(TFMCC): Protocol speciﬁcation,” RFC 4654 (Experimental), Aug.
2006.
[25] M. Musuvathi and D. R. Engler, “Model checking large network
protocol implementations,” in Proceedings of the 1st Symposium on Net-
worked Systems Design and Implementation, ser. NSDI’04. USENIX
Association, 2004, pp. 155–168.
[26]
J. Postel, “Transmission control protocol,” RFC 793 (Standard), Sep.
1981.
[27] E. Gansner, E. Koutsoﬁos, and S. North, “Drawing graphs with dot,”
[Online]. Available: http://www.graphviz.org/Documentation/
2006.
dotguide.pdf
[28] WebHosting
Talk,
and
technology,” 2004. [Online]. Available: https://www.webhostingtalk.
com/showthread.php?t=293069
security
hosting
“DOS
attack
–
[29] M. Allman, V. Paxson, and E. Blanton, “TCP congestion control,” RFC
5681 (Draft Standard), p. 18, Sep. 2009.
[30] O. Andreasson, “TCP variables,” 2002. [Online]. Available: https:
//www.frozentux.net/ipsysctl-tutorial/chunkyhtml/tcpvariables.html
[31] S. Floyd, M. Handley, and E. Kohler, “Datagram congestion control
protocol (DCCP),” RFC 4340 (Proposed Standard), 2006.
[32] S. Floyd and E. Kohler, “Proﬁle for datagram congestion control
protocol (DCCP) congestion control ID 2: TCP-like congestion control,”
RFC 4341 (Proposed Standard), 2006.
1212
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:11:45 UTC from IEEE Xplore.  Restrictions apply.