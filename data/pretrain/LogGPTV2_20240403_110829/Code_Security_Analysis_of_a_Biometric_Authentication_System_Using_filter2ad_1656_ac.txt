constitute a ﬂaw in the scheme proposed in
[VB03], since we extended that scheme in ways
based on previous experiences.
After receiving this result from the ATP, we
ran the attack generator implemented in Pro-
log to actually exhibit the attack (by deter-
mining the valuations of the message variables,
possibly of diﬀerent protocol sessions). We now
explain the result. It turns out that in our im-
plementation, the authentication phase of the
protocol is not suﬃciently bound to the part
where ﬁrstly the session key is exchanged and
then the misuse counter decremented and the
biometric match performed.
The attack proceeds as follows: First, the
attacker runs one execution of the protocol us-
ing the stolen smart-card and breaks up be-
fore the biometric match is performed, e.g. by
pulling the smart-card out of the card-reader.
Note that at this point, the misuse counter is
decremented, since the biometric authentica-
tion has not been successfully completed. The
ﬁrst misuse counter is unchanged, since the
smart-card is legimate and was therefore suc-
cessfully authenticated at the host.
One should note that when the smart-card
is pulled out (and thus the power cut oﬀ), the
smart-card returns to its initial state (except
that the misuse counter is saved) and is again
ready to start another execution of the proto-
col. Thus, the attacker can now start another
execution of the protocol with the same card.
When the authentication phase is ﬁnished, the
attacker now manipulates the communication
between the host system and the smart card
reader so that the smart-card is cut oﬀ from
the further communication, and she directly
communicates with the host system. This way,
she aims to make sure that she can now per-
form tests in order to get to a positive match
of the biosensor using fake biometric samples.
For that, she now has to perform the inter-
action with the host system in the messages
responsible to the secure update of the misuse
counter herself in order to convince the host
system that it still communicates with the le-
gitimate card and that the card in fact decre-
ments its misuse counter. However, this can
now be done by replaying the messages from
the previous protocol execution.
This is due to the fact that in the proto-
col, the host requests the session key from the
smart-card. Although the session key returned
by the smart-card is supposed to be protected
with a MAC using the private key shared be-
tween the host system and the card, and al-
though it is correctly checked by the host that
this is actually the case, replay of the session
key from the previous session is not prevented.
And although the host performs the decremen-
tation of the session key itself, and later checks
correctly that the smart-card actually stored
the decremented key, the host has to request
the current state of the misuse counter from
the smart-card to start with. At that point,
the attacker can again replay the correspond-
ing message from the smart-card in the previ-
ous protocol run, which again sends the default
value of the misuse counter to the host. As in
the previous run, this value is decremented and
sent to the smart-card to be stored. The smart-
card is then queried whether it actually stored
this decremented value. Again, this check is
protected by a MAC which is actually correctly
veriﬁed, but again the exact message from the
smart-card in the previous protocol run can be
reused. Then, the biometric reference data is
requested from the smart-card, and again the
response from the previous run is reused here.
That way, the attacker proceeds to the point
where the biometric match is performed, al-
though the misuse counter was not again decre-
mented on the card.
The second part of the attack can be iter-
ated arbitrarily many times without decremen-
tation of the misuse counter. That way, the
biometric match can eventually be tricked with
an inacceptable probability of success.
Note that we do not assume that the at-
tacker somehow obtains the session key from a
previous protocol run. In fact, after the suc-
cessful attack against the protocol, the attacker
still does not know the session key. Thus, this
attack is diﬀerent from previous session key re-
play attacks and speciﬁc to the way the mis-
use counter mechanism is implemented which
is necessary in biometric authentication proto-
col, due to the inherent failure rates in biomet-
ric matching.
When examining the
it
turned out that the security ﬂaw found in our
implementation was made possible since the
speciﬁcation were not suﬃciently detailed with
speciﬁcations,
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:12:51 UTC from IEEE Xplore.  Restrictions apply. 
8
respect to the generation of the MACs used.
When the speciﬁcation was specialized to pre-
scribe that the random numbers exchanged in
the authentication phase are used in the gen-
eration of the MACs, and our implementa-
tion changed accordingly, the attack described
above was not any more possible. We could
in fact show that the protocol is secure in
the sense of the security conjecture formulated
above. Again, this result was obtained with
SPASS within less than a minute computing
time on an AMD Athlon processor with 1533
MHz. clock frequency and 1024 MB RAM.
5 Lessons Learned
We discuss some of the experiences gained
during the application of our approach pre-
sented in this paper.
One of the lessons learned was that the
amount of work one has to invest in order to
apply our method is dependent on how the
code was constructed. Our method needs the
least amount when it is applied by the soft-
ware developers in the course of programming
the code.
It is more eﬀort to apply our ap-
proach to legacy systems, since performing the
abstractions that are necessary requires some
understanding of the software.
With respect to the preciseness of our anal-
ysis, we already mentioned that our method
does not suﬀer from false negatives in the sense
that it ﬁnds all attacks which exist relative to
our adversary model, provided that the an-
notations introduced by the user are correct.
The method does admit the existence of false
positives in the sense that attack possibilities
found may not have a counter-part in reality,
because of the abstrations introduced for eﬃ-
ciency. False positives would have to be ex-
pected for example in a situation where an
adversary can construct a secret out of two
pieces of data which he can gain in two mutu-
ally exclusive conditional branches in the pro-
tocol, which in the most abstract application
of our approach would both be taken into ac-
count. However, during several application
case-studies so far, including the one presented
here, this problem has not become apparent.
Also, the fact that a false positive does not
constitute a realistic attack becomes apparent
by using the Prolog attack generator.
6 Related Work
[CDW04] reports on the usage of the model-
checker MOPS on security-critical Unix-based
applications with respect to low-level security
properties such as the proper dropping of priv-
ileges, the avoidance of race conditions when
accessing ﬁles, and the secure creation of tem-
porary ﬁles. The approach is applied to ap-
plications with over one million lines of code
where more than a dozen new security weak-
nesses in widely-deployed applications were
found. Compared to our work, that approach
is focussed on low-level implementation details,
while we aim to analyze speciﬁcally the se-
cure usage of cryptographic operations in im-
plementations.
[DDMP03] presents a tool which automates
the detection of high-risk security-critical func-
tions based on the observation validated in an
experiment in the paper that functions near
a source of input are most likely to contain a
security vulnerability. The tool is applied to
three open source applications with known vul-
nerabilities and the privilege separation code
in the OpenSSH server daemon. Compared to
this approach, our approach is directed more
speciﬁcally to attacks against certain security
requirements such as secrecy of data, against
which the code is analyzed in depth.
[DM03] uses a tool which repositions stack
allocated arrays at compile time by preserv-
ing the semantics of the program with a small
performance penalty. The paper considers the
semantics-preserving transformation of stack
allocated arrays to heap allocated ”pointers to
arrays”. Compared to that work, ours is not
concerned with the buﬀer-overﬂow type of er-
rors, but with security ﬂaws arising from design
errors in the security protocol logic.
There are other approaches to using FOL
automated theorem provers for cryptoprotocol
analysis, so far applied mainly on the spec-
iﬁcation level.
[Sch97] formalizes the well-
known BAN logic in ﬁrst-order logic and uses
the atp SETHEO to proof statements in the
BAN logic. It is diﬀerent from our approach
which is based on the knowledge of the ad-
versary, instead of the beliefs of the protocol
participants.
[Wei99] analyzes the Neuman-
Stubblebine key exchange protocol using ﬁrst-
order monadic Horn formulas and the atp
Spass. This approach diﬀers from ours for ex-
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:12:51 UTC from IEEE Xplore.  Restrictions apply. 
9
ample in that in general we also admit non-
monadic Horn formulas (and even non-Horn
formulas), to be able to consider unbounded
state when necessary to express a security
property.
[Coh03] uses ﬁrst-order invariants
to verify cryptographic protocols against safety
properties. The approach is supported by the
atp TAPS. Compared to our approach, the
method does not generate counter-examples
(that is, attacks) in case a protocol is found
to be insecure.
7 Conclusion
We presented an approach using automated
theorem provers for ﬁrst order logic to under-
stand the security requirements provided by C
code implementations of cryptographic proto-
cols. Our approach constructs a logical ab-
straction of the code which can be used to
analyze the code for security properties (such
as conﬁdentiality) with automated theorem
provers. One should note that it is not our
goal to provide an automated full formal ver-
iﬁcation of C code using formal logic but to
increase understanding of cryptoprotocol im-
plementations in an approach which is as au-
tomated as possible. Note also that our focus
here is on high-level security properties such as
secrecy and authenticity, and not on detecting
low-level security ﬂaws such as buﬀer overﬂows.
We demonstrated our approach at the hand
of an industrial-strength biometric authentica-
tion protocol based on experiences from an in-
dustrial research and development project. In
all, although our approach is not completely
automatic, it turned out to be applicable with
reasonable eﬀort in industrial practice.
Acknowledgements Many thanks go to
Mark Yampolskiy for help with constructing
the control ﬂow graphs used for this work.
References
[Abs04]
AbsInt.
2004.
aicall.
http://www.aicall.de/,
[CDW04] Hao Chen, Drew Dean, and David Wagner.
Model checking one million lines of c code.
In NDSS. The Internet Society, 2004.
[CKY03]
E. Clarke, D. Kroening, and K. Yorav.
Behavioral consistency of C and Verilog
programs using bounded model checking.
Technical Report CMU-CS-03-126, School
[Coh03]
of Computer Science, Carnegie Mellon Uni-
versity, 2003.
E. Cohen. First-order veriﬁcation of cryp-
tographic protocols. Journal of Computer
Security, 11(2):189–216, 2003.
[DY83]
[Gol03]
[Mea91]
[DM03]
[RS98]
[Sch97]
Facets of security.
[DDMP03] D. DaCosta, C. Dahn, S. Mancoridis, and
V. Prevelakis. Characterizing the ’security
vulnerability likelihood’ of software func-
In ICSM, pages 266–. IEEE Com-
tions.
puter Society, 2003.
Christopher Dahn and Spiros Mancoridis.
Using program transformation to secure C
programs against buﬀer overﬂows. In A.v.
Deursen, E. Stroulia, and M.D. Storey, ed-
itors, WCRE, pages 323–333. IEEE Com-
puter Society, 2003.
D. Dolev and A. Yao. On the security of
public key protocols. IEEE Transactions
on Information Theory, IT-29(2):198–208,
1983.
D. Gollmann.
In
C. Priami, editor, Global Computing (GC
2003), volume 2874 of LNCS, pages 192–
202. Springer, 2003.
C. Meadows. A system for the speciﬁcation
and analysis of key management protocols.
In IEEE Symposium on Security and Pri-
vacy, pages 182–195, 1991.
P. Ryan and S. Schneider. An attack on
a recursive authentication protocol. Infor-
mation Processing Letters, 65:7–10, 1998.
J. Schumann. Automatic veriﬁcation of
cryptographic protocols with SETHEO.
In W. McCune, editor, 14th Interna-
tional Conference on Automated Deduc-
tion (CADE-14), volume 1249 of LNCS,
pages 87–100. Springer, 1997.
seCse tool (webinterface and download).
http://www4.in.tum.de/˜secse.
G. Sutcliﬀe and C. Suttner.
The
TPTP problem library for automated
theorem proving, 2001.
Available at
http://www.tptp.org.
E-SETHEO:
G. Stenz and A. Wolf.
An automated3
In
R. Dyckhoﬀ, editor, Automated Reasoning
with Analytic Tableaux and Related Meth-
ods (TABLEAUX 2000), volume 1847 of
LNCS, pages 436–440. Springer, 2000.
C. Viti and S. Bistarelli.
Study and
development of a remote biometric au-
thentication protocol. Technical Report
IIT B4-04/2003, Consiglio Nazionale
delle Ricerche, Istituto di Informatica e
Telematica, September 2003. Available at
http://dienst.isti.cnr.it/Dienst/UI/2.0/
Describe/ercim.cnr.iit/2003-B4-
04?tiposearch=ercim&langver=.
C. Weidenbach. Towards an automatic
analysis of security protocols in ﬁrst-order
logic. In H. Ganzinger, editor, 16th Inter-
national Conference on Automated Deduc-
tion (CADE-16), volume 1632 of LNCS,
pages 314–328, 1999.
theorem prover.
[sec]
[SS01]
[SW00]
[VB03]
[Wei99]
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:12:51 UTC from IEEE Xplore.  Restrictions apply. 
10