case 常量表达式: 语句
default: 语句 由标识符构成的标号声明了该标识符。标识符标号的惟一用途就是作为 goto 语句的跳转目
标。标识符的作用域是当前函数。因为标号有自己的名字空间，因此不会与其它标识符混淆，
并且不能被重新声明。详细信息参见 A.11.1 节。
case 标号和 default 标号用在 switch 语句中(参见 A.9.4 节)。case 标号中的常量
表达式必须为整型。
标号本身不会改变程序的控制流。
A.9.2              表达式语句
大部分语句为表达式语句，其形式如下所示: 表达式语句:
表达式 opt;
大多数表达式语句为赋值语句或函数调用语句。表达式引起的所有副作用在下一条语句执行 前结束。没有表达式的语句称为空语句。空语句常常用来为循环语句提供一个空的循环体或 设置标号。
A.9.3              复合语句
当需要把若干条语句作为一条语句使用时，可以使用复合语句(也称为"程序块")。函 数定义中的函数体就是一个复合语句。
复合语句:
{声明表 opt 语句表 opt}
声明表:
声明
声明表 声明 语自表
语句
语句表 语句 如果声明表中的标识符位于程序块外的作用域中，则外部声明在程序块内将被挂起(参见
A.11.1 节)，在程序块之后再恢复其作用。在同一程序块中，一个标识符只能声明一次。此规
则也适用于同一名字空间的标识符(参见 A.11  节)，不同名字空间的标识符被认为是不同的。
自动对象的初始化在每次进入程序块的顶端时执行，执行的顺序按照声明的顺序进行。 如果执行跳转语句进入程序块，则不进行初始化。Static 类型的对象仅在程序开始执行前初 始化一次。
A.9.4              选择语句
选择语句包括下列几种控制流形式: 选择语句:
if (表选式) 语句
if (表达式) 语句 else 语句
switch (表达式) 语句
在两种形式的 if 语句中，表达式(必须为算术类型或指针类型)首先被求值(包括所有 的副作用)，如果不等于 0，则执行第一个子语句。在第二种形式中，如果表达式为 0，则执 行第二个子语句，通过将 else 与同一嵌套层中碰到的最近的未匹配 else 的 if 相连接，可 以解决 else 的歧义性问题。
switch 语句根据表达式的不同取值将控制转向相应的分支。关键字 switch 之后用圆括 号括起来的表达式必须为整型，此语句控制的子语句一般是复合语句。子语句中的任何语句 可带一个或多个 case 标号(参见 A.9.1 节)。控制表达式需要进行整型提升(参见 A.6.1 节)， case 常量将被转换为整型提升后的类型。同一 switch 语句中的任何两个 case 常量在转换 后不能有相同的值。一个 switch 语句最多可以有一个 default 标号。swltch 语句可以嵌 套，case 或 default 标号与包含它的最近的 switch 相关联。
switch 语句执行时，首先计算表达式的值及其副作用，并将其值与每个 case 常量比较， 如果某个 case 常量与表达式的值相同，则将控制转向与该 case 标号匹配的语句。如果没有 case 常量与表达式匹配，并且有 default 标号，则将控制转向 default 标号的语句。如 果没有 case 常量匹配，且没有 default 标号，则 switch 语句的所有子语句都不执行。
说明:在本书第 1 版中，switch 语句的控制表达式与 case 常量都必须为 int 类型。
A.9.5              循环语句
循环语句用于指定程序段的循环执行。 循环语句
while (表达式) 语句
do 语句 while (表达式);
for (表达式 opt; 表达式 opt; 表达式 opt) 语句
在 while 语句和 do 语句中，只要表达式的值不为 0，其中的子语句将一直重复执行。表 达式必须为算术类型或指针类型。while 语句在语句执行前测试表达式，并计算其副作用， 而 do 语句在每次循环后测试表达式。
在 for 语句中，第一个表达式只计算一次，用于对循环初始化。该表达式的类型没有限 制。第二个表达式必须为算术类型或指针类型，在每次开始循环前计算其值。如果该表达式 的值等于 0，则 for 语句终止执行。第三个表达式在每次循环后计算，以重新对循环进行初 始化，其类型没有限制。所有表达式的副作用在计算其值后立即结束。如果子语句中没有 continue 语句，则语句
for (表达式 1; 表达式 2; 表达式 3) 语句 等价于
表达式 1;
while (表达式 2) {
语句 表达式 3;
}
for 语句中的 3 个表达式中都可以省略。第二个表达式省略时等价于测试一个非 0 常量。
A.9.6              跳转语句
跳转语句用于无条件地转移控制。 跳转语句:
goto 标识符; continue;
break;
return 表达式 opt;
在 goto 语句中，标识符必须是位于当前函数中的标号(参见 A.9.1 节)。控制将转移到标号指 定的语句。
continue 语句只能出现在循环语句内，它将控制转向包含此语句的最内层循环部分。 更准确地说，在下列任一语句中:
while (...) {              do {              for (...) {
...              ...              ...
contin: ;              contin: ;              contin: ;
}              } while (...);              }
如果 continuet 语句不包含在更小的循环语句中，则其作用与 goto contin 语句等价。
break 语句只能用在循环语句或 switch 语句中，它将终止包含该语句的最内层循环语 句的执行，并将控制转向被终止语句的下一条语句。
return 语句用于将控制从函数返回给调用者。当 return 语句后跟一个表达式时，表达 式的值将返回给函数调用者。像通过赋值操作转换类型那样，该表达式将被转换为它所在的 函数的返回值类型。
控制到达函数的结尾等价于一个不带表达式的 return 语句。在这两种情况下，返回值 都是没有定义的。
A.10 外部声明
提供给 C 编译器处理的输入单元称为翻译单元。它由一个外部声明序列组成，这些外部 声明可以是声明，也可以是函数定义。
翻译单元:
外部声明
翻译单元 外部声明 外部声明:
函数定义 声明
与程序块中声明的作用域持续到整个程序块的末尾类似，外部声明的作用域一直持续到 其所在的翻译单元的末尾。外部声明除了只能在这一级上给出函数的代码外，其语法规则与 其它所有声明相同。
A.10.1           函数定义
函数定义具有下列形式: 函数定义:
声明说明符 opt 声明符 声明表 opt 复合语句 声明说明符中只能使用存储类说明符 extern 或 static。有关这两个存储类说明符之间的区
别，参见 A.11.2 节。
函数可返回算术类型、结构、联合、指针或 vold 类型的值，但不能返回函数或数组类型。 函数声明中的声明符必须显式指定所声明的标识符具有函数类型，也就是说，必须包含下列 两种形式之一(参见 A.8.6 节):
直接声明符(形式参数类型表) 直接声明符(标识符表 opt)
其中，直接声明符可以为标识符或用圆括号括起来的标识符。特别是，不能通过 typedef 定 义函数类型。
第一种形式是一种新式的函数定义，其形式参数及类型都在形式参数类型表中声明，函 数声明符后的声明表必须空缺。除了形式参数类型表中只包含 void 类型(表明该函数没有形 式参数)的情况外，形式参数类型表中的每个声明符都必须包含一个标识符。如果形式参数 类型表以“ , ..."结束，则调用该函数时所用的实际参数数目就可以多于形式参数数目。 va_arg 宏机制在标准头文件 b) ? a : b;
return (m > c) ? m : c;
}
其中，int 是声明说明符;max(int a, int b, int c)是函数的声明符;{...}是 函数代码的程序块。相应的旧式定义如下所示:
int max(a, b, c)
int a, b, c;
{
/* ... */
}
其中，int max(a, b, c)是声明符，int a, b, c;是形式参数的声明表。
A.10.2          外部声明
外部声明用于指定对象、函数及其它标识符的特性。术语"外部"表明它们位于函数外 部，并且不直接与关键字 extern 连接。外部声明的对象可以不指定存储类，也可指定为 extern 或 static。
同一个标识符的多个外部声明可以共存于同一个翻译单元中，但它们的类型和连接必须 保持一致，并且标识符最多只能有一个定义。
如果一个对象或函数的两个声明遵循 A.8.10 节中所述的规则，则认为它们的类型是一 致的。并且，如果两个声明之间的区别仅仅在于:其中一个的类型为不完整结构、联合或枚 举类型(参见 A.8.3 节)，而另一个是对应的带同一标记的完整类型，则认为这两个类型是一 致的。此外，如果一个类型为不完整数组类型(参见 A.8.6 节)，而另一个类型为完整数组类 型，其它属性都相同，则认为这两个类型是一致的。最后，如果一个类型指定了一个旧式函 数，而另一个类型指定了带形式参数声明的新式函数，二者之间其它方面都相同，则认为它 们的类型也是一致的。
如果一个对象或函数的第一个外部声明包含 static 说明符，则该标识符具有内部连接， 否则具有外部连接。有关连接的详细信息，参见 A.11.2 节中的讨论。
如果一个对象的外部声明带有初值，则该声明就是一个定义。如果一个外部对象声明不 带有初值，并且不包含 extern 说明符，则它是一个临时定义。如果对象的定义出现在翻译 单元中。则所有临时定义都将仅仪被认为是多余的声明;如果该翻译单元中不存在该对象的 定义，则该临时定义将转变为一个初值为 0 的定义。
每个对象都必须有且仅有一个定义。对于具有内部连接的对象，该规则分别适用于每个 翻译单元，这是因为，内部连接的对象对每个翻译单元是惟一的。对于具有外部连接的对象， 该规则适用于整个程序。
说明:虽然单一定义规则(0ne•definition rule)在表达上与本书第  1 版有所不同， 但在效果上是等价的。某些实现通过将临时定义的概念一般化而放宽了这个限制。在另一种 形式中，一个程序中所有翻译单元的外部连接对象的所有临时定义将集中进行考虑，而不是 在各翻译单元中分别考虑，UNIX 系统通常就采用这种方法，并且被认为是该标准的一般扩展。 如果定义在程序中的某个地方出现，则临时定义仅被认为是声明，但如果没有定义出现，则 所有临时定义将被转变为初值为 0 的定义。
A.11 作用域与连接
一个程序的所有单元不必同时进行编译。源文件文本可保存在若干个文件中，每个文件 中可以包含多个翻译单元，预先编译过的例程可以从库中进行加载，程序中函数间的通信可 以通过调用和操作外部数据来实现。
因此，我们需要考虑两种类型的作用域:第一种是标识符的词法作用域，它是体现标识 符特性的程序文本区域;第二种是与具有外部连接的对象和函数相关的作用域，它决定各个 单独编译的翻译单元中标识符之间的连接。
A.11.1             词法作用域
标识符可以在若干个名字空间中使用而互不影响。如果位于不同的名字空间中，即使是 在同一作用域内，相同的标识符也可用于不同的目的。名字空间的类型包括:对象、函数、 类型定义名和枚举常量;标号;结构标记、联合标记和枚举标记;各结构或联合自身的成员。
说明:这些规则与本手册第 1 版中所述的内容有几点不同。以前标号没有自己的名字空 间;结构标记和联合标记分别有各自的名字空间，在某些实现中杖举标记也有自己的名字空 间;把不同种类的标记放在同一名字空间中是新增加的限制。与第  1 版之间最大的不同在于:
每个结构和联合都为其成员建立不同的名字空间，因此同一名字可出现在多个不同的结构中。 这一规则在最近几年使用得很多。
在外部声明中，对象或函数标识符的词法作用域从其声明结束的位置开始，到所在翻译 单元结束为止。函数定义中形式参数的作用域从定义函数的程序块开始处开始，并贯穿整个 函数;函数声明中形式参数的作用域到声明符的末尾处结束。程序块头部中声明的标识符的 作用域是其所在的整个程序块。标号的作用域是其所在的函数。结构标记、联合标记、枚举 标记或枚举常量的作用域从其出现在类型说明符中开始，到翻译单元结束为止(对外部声明 而言)或到程序块结束为止(对函数内部声明而言)。
如果某一标识符显式地在程序块(包括构成函数的程序块)头部中声明，则该程序块外 部中此标识符的任何声明都将被挂起，直到程序块结束再恢复其作用。
A.11.2           连接
在翻译单元中，具有内部连接的同一对象或函数标识符的所有声明都引用同一实体，并 且，该对象或函数对这个翻译单元来说是惟一的。具有外部连接的同一对象或函数标识符的 所有声明也引用同一实体，并且该对象或函数是被整个程序中共享的。
如 A.10.2 节所述，如果使用了 static 说明符，则标识符的第一个外部声明将使得该标 识符具有内部连接，否则，该标识符将具有外部连接。如果程序块中对一个标识符的声明不 包含 extern 说明符，则该标识符没有连接，并且在函数中是惟一的。如果这种声明中包含 extern 说明符，并且，在包含该程序块的作用域中有一个该标识符的外部声明，则该标识符 与该外部声明具有相同的连接，并引用同一对象或函数。但是，如果没有可见的外部声明， 则该连接是外部的。
A.12 预处理
预处理器执行宏替换、条件编译以及包含指定的文件，以#开头的命令行(“    #"前可以有 空格)就是预处理器处理的对象。这些命令行的语法独立于语言的其它部分，它们可以出现 在任何地方，其作用可延续到所在翻译单元的末尾(与作用域无关)。行边界是有实际意义的; 每一行都将单独进行分析(有关如何将行连结起来的详细信息参见 A.12.4  节)。对预处理器而 言，记号可以是任何语言记号，也可以是类似于#include 指令(参见 A.12.4 节)中表示文件名 的字符序列，此外，所有未进行其它定义的字符都将被认为是记号。但是，在预处理器指令 行中，除空格、横向制表符外的其它空白符的作用是没有定义的。
预处理过程在逻辑上可以划分为几个连续的阶段(在某些特殊的实现中可以缩减)。
1)首先，将 A.12.1 节所述的三字符序列替换为等价字符。如果操作系统环境需要，还 要在源文件的各行之间插入换行符。
节)。
2)将指令行中位于换行符前的反斜杠符\删除掉，以把各指令行连接起来(参见    A.12.2
3)将程序分成用空白符分隔的记号。注释将被替换为一个空白符。接着执行预处理指令， 并进行宏扩展(参见 A.12.3 节A.12.10 节)。
4)将字符常量和字符串字面值中的转义字符序列(参见 A.2.5 节与 A.2.6 节)替换为 等价字符，然后把相邻的字符串字面值连接起来。
5)收集必要的程序和数据，并将外部函数和对象的引用与其定义相连接，翻译经过以上 处理得到的结果，然后与其它程序和库连接起来。
A.12.1           三字符序列
C 语育源程序的字符集是 7 位 ASCII 码的子集，但它是 ISO 646•1983 不变代码集的超集。 为了将程序通过这种缩减的字符集表示出来，下列所示的所有三字符序列都要用相应的单个 字符替换，这种替换在进行所有它他处理之前进行。
??=
#
??(
[
??