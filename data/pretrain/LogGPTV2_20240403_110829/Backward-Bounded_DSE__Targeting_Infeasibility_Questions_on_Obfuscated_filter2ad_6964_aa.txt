title:Backward-Bounded DSE: Targeting Infeasibility Questions on Obfuscated
Codes
author:S&apos;ebastien Bardin and
Robin David and
Jean-Yves Marion
2017 IEEE Symposium on Security and Privacy
Backward-Bounded DSE:
Targeting Infeasibility Questions
on Obfuscated Codes(cid:2)
Sébastien Bardin
CEA, LIST,
Robin David
CEA, LIST,
Jean-Yves Marion
Université de Lorraine,
91191 Gif-Sur-Yvette, France
PI:EMAIL
91191 Gif-Sur-Yvette, France
CNRS and Inria, LORIA, France
PI:EMAIL
PI:EMAIL
Abstract—Software deobfuscation is a crucial activity in secu-
rity analysis and especially in malware analysis. While standard
static and dynamic approaches suffer from well-known short-
comings, Dynamic Symbolic Execution (DSE) has recently been
proposed as an interesting alternative, more robust than static
analysis and more complete than dynamic analysis. Yet, DSE ad-
dresses only certain kinds of questions encountered by a reverser,
namely feasibility questions. Many issues arising during reverse,
e.g., detecting protection schemes such as opaque predicates, fall
into the category of infeasibility questions. We present Backward-
Bounded DSE, a generic, precise, efﬁcient and robust method
for solving infeasibility questions. We demonstrate the beneﬁt
of the method for opaque predicates and call stack tampering,
and give some insight for its usage for some other protection
schemes. Especially, the technique has successfully been used
on state-of-the-art packers as well as on the government-grade
X-Tunnel malware – allowing its entire deobfuscation. Backward-
Bounded DSE does not supersede existing DSE approaches, but
rather complements them by addressing infeasibility questions
in a scalable and precise manner. Following this line, we propose
sparse disassembly, a combination of Backward-Bounded DSE
and static disassembly able to enlarge dynamic disassembly in
a guaranteed way, hence getting the best of dynamic and static
disassembly. This work paves the way for robust, efﬁcient and
precise disassembly tools for heavily-obfuscated binaries.
I. INTRODUCTION
Context. Obfuscation [1] is a prevalent practice aiming at
protecting some functionalities or properties of a program. Yet,
while its legitimate goal is intellectual property protection,
obfuscation is widely used for malicious purposes. Therefore,
(binary-level) software deobfuscation is a crucial task in reverse-
engineering, especially for malware analysis.
A ﬁrst step of deobfuscation is to recover the most accurate
control-ﬂow graph of the program (disassembly), i.e., to recover
all instructions and branches of the program under analysis.
This is already challenging for non-obfuscated codes due to
tricky (but common) low-level constructs [2] like indirect
control ﬂow (computed jumps, jmp eax) or the interleaving
of code and data. But the situation gets largely worst in the
case of obfuscated codes.
(cid:2) Work partially funded by ANR, grant 12-INSE-0002.
Standard disassembly approaches are essentially divided
into static methods and dynamic methods. On one hand, static
(syntactic) disassembly tools such as IDA or Objdump have
the potential to cover the whole program. Nonetheless, they
are easily fooled by obfuscations such as code overlapping
[3], opaque predicates [4], opaque constants [5], call stack
tampering [6] and self-modiﬁcation [7]. On the other hand,
dynamic analysis cover only a few executions of the program
and might miss both signiﬁcant parts of the code and crucial
behaviors. Dynamic Symbolic Execution (DSE) [8], [9] (a.k.a
concolic execution) is a recent and fruitful formal approach to
automatic testing, recently proposed as an interesting approach
for disassembly [10], [11], [12], [13], [14], more robust than
static analysis and covering more instructions than dynamic
analysis. Currently, only dynamic analysis and DSE are robust
enough to address heavily obfuscated codes.
Problem. Yet, these dynamic methods only address reachability
issues, namely feasibility questions, i.e., veriﬁying that certain
events or setting can occur, e.g., that an instruction in the code
is indeed reachable. Contrariwise, many questions encountered
during reversing tasks are infeasibility questions, i.e., checking
that certain events or settings cannot occur. It can be used
either for detecting obfuscation schemes, e.g., detecting that a
branch is dead, or to prove their absence, e.g., proving that a
computed jump cannot lead to an improper address.
These infeasibility issues are currently a blind spot of
both standard and advanced disassembly methods. Dynamic
analysis and DSE do not answer the question because they only
consider a ﬁnite number of paths while infeasibility is about
considering all paths. Also, (standard) syntactic static analysis
is too easily fooled by unknown patterns. Finally, while recent
semantic static analysis approaches [15], [13], [16], [17] can
in principle address infeasibility questions, they are currently
neither scalable nor robust enough.
At ﬁrst sight infeasibility is a simple mirror of feasibility,
however from an algorithmic point of view they are not the
same. Indeed, since solving feasibility questions on general
programs is undecidable, practical approaches have to be one-
sided, favoring either feasibility (i.e., answering “feasible” or
© 2017, Sébastien Bardin. Under license to IEEE.
DOI 10.1109/SP.2017.36
633
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:31 UTC from IEEE Xplore.  Restrictions apply. 
"don’t know”) or infeasibility (i.e., answering "don’t know” or
“infeasible”). While there currently exist robust methods for
answering feasibility questions on heavily obfuscated codes,
no such method exist for infeasibility questions.
Goal and challenges. In this article, we are interested in
solving automatically infeasibility questions occurring during
the reversing of (heavily) obfuscated programs. The intended
approach must be precise (low rates of false positives and false
negatives) and able to scale on realistic codes both in terms
of size (efﬁcient) and protection – including self-modiﬁcation
(robustness), and generic enough for addressing a large panel
of infeasibility issues. Achieving all these goals at the same
time is particularly challenging.
Our proposal. We present Backward-Bounded Dynamic Sym-
bolic Execution (BB-DSE), the ﬁrst precise, efﬁcient, robust
and generic method for solving infeasibility questions. To
obtain such a result, we have combined in an original and
fruitful way, several state-of-the-art key features of formal
software veriﬁcation methods, such as deductive veriﬁcation
[18], bounded model checking [19] or DSE. Especially, the
technique is goal-oriented for precision, bounded for efﬁciency
and combines dynamic information and formal reasoning for
robustness.
Contribution. The contribution of this paper are the following:
• First, we highlight the importance of infeasibility issues in
reverse and the urging need for automating the investiga-
tion of such problems. Indeed, while many deobfuscation-
related problems can be encoded as infeasibility questions
(cf. Section V) it remains a blind spot of state-of-the-art
disassembly techniques.
• Second, we propose the new Backward-Bounded DSE
algorithm for solving infeasibility queries arising during
deobfuscation (Section IV). The approach is both precise
(low rates of false positives and false negatives), efﬁcient
and robust (cf. Table I), and it can address in a generic
way a large range of deobfuscation-related questions –
for instance opaque predicates, call stack tampering or
self-modiﬁcation (cf. Section V). The technique draws
from several separated advances in software veriﬁcation,
and combines them in an original and fruitful way. We
present the algorithm along with its implementation within
the BINSEC open-source platform 1 [20], [21].
• Third, we perform an extensive experimental evaluation
of the approach, focusing on two standard obfuscation
schemes, namely opaque predicates and call stack tam-
pering. In a set of controlled experiments with ground
truth based on open-source obfuscators (cf. Section
VI), we demonstrate that our method is very precise
and efﬁcient. Then, in a large scale experiment with
standard packers (including self-modiﬁcation and other
advanced protections), the technique is shown to scale on
realistic obfuscated codes, both in terms of efﬁciency and
robustness (cf. Section VI).
• Finally, we present two practical applications of Backward-
Bounded DSE. First, we describe an in-depth case-
study of the government-grade malware X-TUNNEL [22]
(cf. Section VIII), where BB-DSE allows to identify
and remove all obfuscations (opaque predicates). We
have been able to automatically extract a de-obfuscated
version of functions – discarding almost 50% of dead
and “spurious” instructions, and providing an insights
into its protection schemes, laying a very good basis for
further in-depth investigations. Second, we propose sparse
disassembly (cf. Section IX), a combination of Backward-
Bounded DSE, dynamic analysis and standard (recursive,
syntactic) static disassembly allowing to enlarge dynamic
disassembly in a precise manner – getting the best of
dynamic and static techniques, together with encouraging
preliminary experiments.
Discussion. Several remarks must be made about the work
presented in this paper.
• First, while we essentially consider opaque predicates
and call stack tampering, BB-DSE can also be useful in
other obfuscation contexts, such as ﬂattening or virtual-
ization. Also self-modiﬁcation is inherently handled by
the dynamic aspect of BB-DSE.
• Second, while we present one possible combination for
sparse disassembly, other combinations can be envisioned,
for example by replacing the initial dynamic analysis
by a (more complete) DSE [10] or by considering more
advanced static disassembly techniques [2].
• Finally, some recent works target opaque predicate detec-
tion with standard forward DSE [12]. As already pointed
out, DSE is not tailored to infeasibility queries, while
BB-DSE is – cf. Sections VI and XI.
Impact. Backward-Bounded DSE does not supersede existing
disassembly approaches, it complements them by addressing
infeasibility questions. Altogether, this work paves the way for
robust, precise and efﬁcient disassembly tools for obfuscated
binaries, through the careful combination of static/dynamic and
forward/backward approaches.
TABLE I: Disassembly methods for obfuscated codes
feasibility
query
(cid:2)/×(†)
infeasibility
query
×
×
efﬁciency
robustness
(cid:2)
×
(cid:2)
(cid:2)
(cid:2)
(cid:2)/×(††)
dynamic analysis
DSE
static analysis
(syntactic)
×
static analysis
(semantic)
×
BB-DSE
(†): follow only a few traces
(††): very limited reasoning abilities
(‡): can have false positive and false negative, yet very low in practice
(cid:2)
(cid:2)(‡)
×
(cid:2)
(cid:2)
(cid:2)
×
×
(cid:2)
1http://binsec.gforge.inria.fr/
634
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:31 UTC from IEEE Xplore.  Restrictions apply. 
II. BACKGROUND
Obfuscation. These transformations [1] aim at hiding the real
program behavior. While approaches such as virtualization or
junk insertion make instructions more complex to understand,
other approaches directly hide the legitimate instructions of the
programs – making the reverser (or the disassembler) missing
essential parts of the code while wasting its time in dead code.
The latter category includes for example code overlapping,
self-modiﬁcation, opaque predicates and call stack tampering.
We are interested here in this latter category. For the sake
of clarity, this paper mainly focuses on opaque predicates and
call stack tampering.
• An opaque predicate always evaluates to the same value,
and this property is ideally difﬁcult
to deduce. The
infeasible branch will typically lead the reverser (or
disassembler) to a large and complex portion of useless
junk code. Figure 1 shows the x86 encoding of the opaque
predicate 7y2 − 1 (cid:2)= x2, as generated by O-LLVM [23].
This condition is always false for any values of DS:X,
DS:Y, so the conditional jump jz  is never
going to be taken.
• A (call) stack tampering, or call/ret violation, consists
in breaking the assumption that a ret instruction returns
to the instruction following the call (return site), as
exempliﬁed in Figure 2. The beneﬁt is twofold: the reverser
might be lured into exploring useless code starting from
the return site, while the real target of the ret instruction
will be hidden from static analysis.
eax, ds:x
ecx, ds:y
mov
mov
imul ecx, ecx
imul ecx, 7
sub
ecx, 1
imul eax, eax
cmp
ecx, eax
jz
 //false jump to junk
.... ........
//real code
Fig. 1: opaque predicate: 7y2 − 1 (cid:2)= x2
:
call 
..... // return site
..... // junk code
..... // junk code
:
[...]
push X
ret //jump to X instead
//of return site
Fig. 2: Standard stack tampering
Disassembly. We call legit an instruction in a binary if it is
executable in practice. Two expected qualities for disassembly
are (1) soundness: does the algorithm recover only legit
instructions?, (2) completeness: does the algorithm recover all
legit instructions? Standard approaches include linear sweep,
recursive disassembly and dynamic disassembly.
635
• Recursive disassembly statically explores the executable
ﬁle from a given (list of) entry point(s), recursively
following the possible successors of each instruction. This
technique may miss a lot of instructions, typically due
to computed jumps (jmp eax) or self-modiﬁcation. The
approach is also easily fooled into disassembling junk code
obfuscated by opaque predicates or call stack tampering.
As such, the approach is neither sound nor complete.
• Linear sweep linearly decodes all possible instructions
in the code sections. The technique aims at being more
complete than recursive traversal, yet it comes at the price
of many additional misinterpreted instructions. Meanwhile,
the technique can still miss instructions hidden by code
overlapping or self-modiﬁcation. Hence the technique is
unsound, and incomplete on obfuscated codes.
• Dynamic disassembly retrieves only legit instructions and
branches observed at runtime on one or several executions.
The technique is sound, but potentially highly incomplete
– yet, it does recover part of the instructions masked by
self-modiﬁcation, code overlapping, etc.
For example, while Objdump is solely based on linear
sweep, IDA performs a combination of linear sweep and
recursive disassembly (geared with heuristics).
Dynamic Symbolic Execution. Dynamic Symbolic Execution
(DSE) [9], [8] (a.k.a concolic execution) is a formal technique
for exploring program paths in a systematic way. For each path
π, the technique computes a symbolic path predicate Φπ as a
set of constraints on the program input leading to follow that
path at runtime. Intuitively, Φπ is the conjunction of all the
branching conditions encountered along π. This path predicate
is then fed to an automatic solver (typically a SMT solver
[24]). If a solution is found, it corresponds to an input data
exercising the intended path at runtime. Path exploration is
then achieved by iterating on all (user-bounded) program paths,
and paths are discovered lazily thanks to an interleaving of
dynamic execution and symbolic reasoning [25], [26]. Finally,
concretization [25], [26], [27] allows to perform relevant under-
approximations of the path predicate by using the concrete
information available at runtime.
The main advantages of DSE are correctness (no false
negative in theory, a bug reported is a bug found) and robustness
(concretization does allow to handle unsupported features of the
program under analysis without losing correctness). Moreover,
the approach is easy to adapt to binary code, compared to other
formal methods [28], [8], [29], [30]. The very main drawback
of DSE is the so-called path explosion problem: DSE is doomed
to explore only a portion of all possible execution paths. As
a direct consequence, DSE is incomplete in the sense that it
can only prove that a given path (or objective) is feasible (or
coverable), but not that it is infeasible.
DSE is interesting for disassembly and deobfuscation since
it enjoys the advantages of dynamic analysis (especially,
sound disassembly and robustness to self-modiﬁcation or code
overlapping), while being able to explore a larger set of
behaviors. Yet, while on small examples DSE can achieve
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:31 UTC from IEEE Xplore.  Restrictions apply. 
complete disassembly, it often only slightly improves coverage
(w.r.t. pure dynamic analysis) on large and complex programs.
III. MOTIVATION
Let us consider the obfuscated pseudo-code given in Figure 3.
The function  contains an opaque predicate in 1(cid:3) and
a call stack tampering in 2(cid:3).
:
if (C) { 1(cid:3)
call 
//junk a(cid:2)
}
else {
call  b(cid:2)
:
.....
push  2(cid:3)