// The hr as a decimal number
m_nHR = hr;
// The hr as a hex number
m_strHRX.Format( "%x", hr );
m_strHRX = "0x" + m_strHRX;
// show the 1st 16 bits (SCODE)
m_nCode = HRESULT_CODE( hr );
// Show facility code as a decimal number
m_nFac = HRESULT_FACILITY( hr );
// Show the severity bit
m_nSev = HRESULT_SEVERITY( hr );
// Use the _com_error object to 
// format a message string. This is 
// Much easier then using ::FormatMessage
m_strStatus= e.ErrorMessage();
// show bits
m_strBinary = HrToBits( hr );
return TRUE;
}
// This method converts an HRESULT into 
// a string of 1's and 0's
CString CBeepDeluxeDlg::HrToBits( HRESULT hr)
{
50    Chapter 4 •
Creating your own COM Clients and Servers 
char temp[32 + 8  + 1 ]; // 32 bits + 8 spaces + NULL
unsigned long mask = 0x80000000; // bit mask (msb)
int count = 0;
// ensure that there is a null terminator at the end
memset( temp, 0, sizeof(temp));
// loop all 32 bits
for( int i=31; i>=0; i-- )
{
// set the character value to 0 or 1 if bit is set
temp[count++] = (hr & mask) ? '1' : '0';
// put 1 space every 4 characters
if ((i%4) == 0)  // mod operator
{
temp[count++] = ' ';
}
// shift bitmask 1 right
mask = mask >> 1;
}
return temp;
}
// Execute an extensive test of the COM client
void CBeepDeluxeDlg::OnButtonRun() 
{
CWaitCursor cur; // show hourglass
UpdateData( TRUE ); // update variables
// status value
HRESULT hr = S_OK;
// define a test clsid 
CLSID clsid = BAD_GUID;
// remote server info
COSERVERINFO cs;
// Init structures to zero
memset(&cs, 0, sizeof(cs));
Client Side
51
Additonal Information and Updates: http://www.iftech.com/dcom
// Allocate the server name in 
// the COSERVERINFO structure
cs.pwszName = m_strServer.AllocSysString();
// structure for CoCreateInstanceEx
MULTI_QI qi[1];
memset(qi, 0, sizeof(qi));
// Initialize COM
if (m_nRadio != 1)
{
hr = CoInitialize(0);
}
// set CLSID
if (m_nRadio != 2)
{
clsid = CLSID_DispatchTypes;
}
// set IID
if (m_nRadio != 3)
{
// Fill the qi with a valid interface
qi[0].pIID = &IID_IDispatchTypes;
}
else
{
// send it a bad Interface
qi[0].pIID = &BAD_GUID;
}
// set a low level of security
hr = CoInitializeSecurity(NULL, -1, NULL, NULL,
RPC_C_AUTHN_LEVEL_NONE, 
RPC_C_IMP_LEVEL_IMPERSONATE,
NULL, 
EOAC_NONE, 
NULL);
if (SUCCEEDED(hr))
52    Chapter 4 •
Creating your own COM Clients and Servers 
{
// get the interface pointer
hr = CoCreateInstanceEx( clsid, NULL, 
CLSCTX_SERVER, 
&cs, 1, qi );
// call method if the interface was created
if (SUCCEEDED(hr))
{
// extract the interface from the QI structure
IDispatchTypes *pI = 
(IDispatchTypes*)qi[0].pItf;
// call method
hr = pI->Beep(100);
// The HRESULT will be displayed later if there 
was an error
// release the pointer even if there was an 
error on the method
pI->Release();
}
}
// display HRESULT on screen
ShowStatus( hr );
// close COM
CoUninitialize();
// Update screen
UpdateData( FALSE );
}
The main feature of this program is the top part of the
OnButtonRun function, which selectively breaks different parts
of the application in response to the radio button settings. Then
the HRESULT value is dismantled and displayed. 
Client Side
53
Additonal Information and Updates: http://www.iftech.com/dcom
When creating your own MFC clients, you will want to fol-
low this same general plan. You may want to place the CoInitial-
ize and CoUninitialize functions elsewhere in the application so
they are not called constantly (for example, in InitInstance and
ExitInstance). You may wish to do the same with the call to
CoInitializeSecurity, CoCreateInstanceEx and Release depending
on how many calls you are planning to make to an interface. If
you are calling a large number of functions in an interface,
clearly you will want to call CoCreateInstanceEx and Release
only once. 
54    Chapter 4 •
Creating your own COM Clients and Servers 
F
I
V
E
5
Understanding 
ATL-Generated 
Code   
The source code for our server DLLs is being generated by ATL.
For many people it is perfectly OK to never look at the code ATL
created. For others, "not knowing" the details of this code is
unacceptable. This chapter gives you a quick tour of the code
produced by ATL. The code for the server DLL that is now sitting
on your hard drive really resides in three different types of files. 
• First, there are the traditional C++ source and header files.
Initially, all of this code is generated by the ATL wizards. 
• The Beep method was added by the "Add Method" dia-
log, which modified the MIDL interface definition. The
MIDL source code is in an IDL file - in this example it's
BeepServer.IDL. The MIDL compiler will use this file to
create several output files. These files will take care of
much of the grunt work of implementing the server. As
we add methods to the COM object, we'll be adding defi-
nitions the IDL file. 
• The third group of source files are automatically gener-
ated MIDL output files created by the MIDL compiler.
These files are source code files, but because they are
automatically generated by the MIDL compiler from IDL
56    Chapter 5 •
Understanding ATL-Generated Code 
source code, these files are never modified directly either
by wizards or by developers. You might call them "second
generation files" - the wizard created an IDL file and the
MIDL compiler created source code files from that IDL
file. The files created by the MIDL compiler include: 
1.
BeepServer.RGS - Registration script for the server. 
2.
BeepServer.h - This file contains definitions for the
COM components. 
3.
BeepServer_i.c - GUID structures for the COM
components. 
4.
Proxy/Stub files - This includes "C" source code,
DLL definitions, and makefile (.mk) for the Proxy
and Stub.  
The ATL wizard also creates an application "resource". If
you look in the project resources, you'll find it under "REGIS-
TRY". This resource contains the registration script defined in
BeepServer.RGS. The name of the resource is IDR_BEEPOBJ. 
We look at all of these different components in the sections
below. See also Chapter 15 for additional details on ATL.
The Main C++ Module
When we ran the ATL COM AppWizard, we chose to create a
DLL-based server and we chose not to use MFC. The first selec-
tion screen of the wizard determined the overall configuration of
the server. 
The AppWizard created a standard DLL module. This type
of standard DLL does not have a WinMain application loop, but
it does have a DllMain function used for the initialization of the
DLL when it gets loaded: 
CComModule _Module;
BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_BeepObj, CBeepObj)
END_OBJECT_MAP()
The Main C++ Module
57
Additonal Information and Updates: http://www.iftech.com/dcom
/////////////////////////////////////////////////////
// DLL Entry Point
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwRea-
son, LPVOID /*lpReserved*/)
{
if (dwReason == DLL_PROCESS_ATTACH)
{
_Module.Init(ObjectMap, hInstance);
DisableThreadLibraryCalls(hInstance);
}
else if (dwReason == DLL_PROCESS_DETACH)
_Module.Term();
return TRUE;    // ok
}
Really all the DllMain function does is check if a client is
attaching to the DLL and then does some initialization. At first
glance, there's no obvious indication that this is a COM applica-
tion at all. 
The COM portion of our new server is encapsulated in the
ATL class CComModule. CComModule is the ATL server base
class. It contains all the COM logic for registering and running
servers, as well as starting and maintaining COM objects. CCom-
Module is defined in the header file "atlbase.h". This code
declares a global CComModule object in the following line: 
CComModule _Module;
This single object contains much of the COM server func-
tionality for our application. Its creation and initialization at the
start of program execution sets a chain of events in motion.
ATL requires that your server always name its global CCom-
Module object "_Module". It's possible to override CComModule
with your own class, but you aren't allowed to change the name. 
If we had chosen an executable-based server, or even a DLL
with MFC, this code would be significantly different. There
would still be a CComModule-based global object, but the entry
58    Chapter 5 •
Understanding ATL-Generated Code 
point of the program would have been WinMain(). Choosing a
MFC-based DLL would have created a CWinApp-based main
object.  
Object Maps
The CComModule is connected to our COM object (CBeepObj)
by the object map seen in the previous section. An object map
defines an array of all the COM objects the server controls. The
object map is defined in code using the OBJECT_MAP macros.
Here is our DLL's object map: 
BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_BeepObj, CBeepObj)
END_OBJECT_MAP()
The OBJECT_ENTRY macro associates the CLSID of the
object with a C++ class. It's common for a server to contain more
than one COM object - in that case there will be an
OBJECT_ENTRY for each one.  
Export File
Our In-Process DLL, like most DLLs, has an export file. The
export file will be used by the client to connect to the exported
functions in our DLL. These definitions are in the file BeepS-
erver.def: 
; BeepServer.def : Declares the module parameters.
LIBRARY      "BeepServer.DLL"
EXPORTS
DllCanUnloadNow     @1 PRIVATE
DllGetClassObject   @2 PRIVATE
DllRegisterServer   @3 PRIVATE
DllUnregisterServer@4 PRIVATE
Export File
59
Additonal Information and Updates: http://www.iftech.com/dcom
It is important to note what is not exported: there are no
custom methods here. There is no export for the "Beep" method.
These are the only exports you should see in a COM DLL.
Looking into the BeepServer.CPP file, we see that the imple-
mentation of these four functions is handled by the COM appli-
cation class. Here's the code for DllRegisterServer: 
// DllRegisterServer - Adds entries to the system reg-
istry
STDAPI DllRegisterServer(void)
{
// registers object, typelib and all interfaces in 
typelib
return _Module.RegisterServer(TRUE);
}
In this case, the DLL just calls ATL's CComModule::Regis-
terServer() method. CComModule implements the server registra-
tion in a way that is compatible with In-Process, Local, and
Remote COM servers. The other three exported DLL functions
are equally spartan. The actual implementation is hidden in the
ATL templates. 
Most of the code described above is DLL specific code. You
will only get this configuration if you choose to create a DLL-
based server. None of the code in the main module is COM spe-
cific. The main module is entirely devoted to the infrastructure
required to deliver COM objects in a DLL, and this code will be
significantly different depending on the type of server. The
actual code inside the server is much more uniform. The imple-
mentation of a coclass and interface is identical regardless of the
type of server (DLL, EXE, server) you create. You should be able
to take a coclass from a DLL server and implement it in an EXE-
based server with few changes. 
60    Chapter 5 •
Understanding ATL-Generated Code 
The COM Object - "CBeepObj"
A COM server has to implement at least one COM object. We are
using a single object named "CBeepObj". One of the most inter-
esting things about this object is that the code was entirely gen-
erated by ATL wizards. It is quite remarkable how compact this
object definition turns out to be. The class definition is found in
BeepObj.h: 
// BeepObj.h : Declaration of the CBeepObj
#include "resource.h"       // main symbols
//////////////////////////////////////////////////////
// CBeepObj
class ATL_NO_VTABLE CBeepObj : 
public CComObjectRootEx,
public CComCoClass (and CComObjectRoot<>) are the
root ATL object class. These classes handle all the reference
counting and management of the COM class. This includes the
implementation of the three required IUnknown interface func-
tions: QueryInterface(), AddRef(), and Release(). When our
CBeepObj object is created by the server, this base class will
keep track of it throughout its lifetime. 
The template for CComObjectRootEx specifies the argument
CComSingleThreadModel. Single threading means that the COM
object won't have to handle access by multiple threads. During
the setup of this object we specified "Apartment threading".
Apartment threading uses a windows message loop to synchro-
nize access to the COM object. This approach is the easiest
because it eliminates many threading issues. 
CComCoClass<> defines the Class factories that create ATL
COM objects. Class factories are special COM classes that are
used to create COM objects. The CComCoClass uses a default
type of class factory and allows aggregation.  
IBeepObj is the interface this server implements. An inter-
face is defined as a C++ struct (recall that structs in C++ act like a
class but can have only public members). If you dig into the
automatically generated file BeepServer.h, you'll find that MIDL
has created a definition of our interface. 
interface DECLSPEC_UUID(
"36ECA947-5DC5-11D1-BD6F-204C4F4F5020")
    IBeepObj : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT 
STDMETHODCALLTYPE Beep( 
62    Chapter 5 •
Understanding ATL-Generated Code 
            /* [in] */ long lDuration) = 0;
};
The DECLSPEC_UUID macro lets the compiler associate a
GUID with the interface name. Note that our single method
"Beep" is defined as a pure virtual function. When the CBeepObj
is defined, it will have to provide an implementation of that
function. 
One peculiar thing about the Class definition of CBeepObj is
the ATL_NO_VTABLE attribute. This macro is an optimization
that allows for faster object initialization. 
The Class Definition
Our object uses a default constructor. You can add special initial-
ization here if required, but there are some limitations. One con-
sequence of using the ATL_NO_VTABLE, is that you aren't
allowed to call any virtual methods in the constructor. A better
place for complex initialization would be in the FinalConstruct
method (which is inherited from CComObjectRootEx.) If you
want to use FinalConstruct, override ATL's default by declaring it
in the class definition. It will be called automatically by the ATL
framework. (FinalConstruct is often used to create aggregated
objects.) 
The DECLARE_REGISTRY_RESOURCEID() macro is used to
register the COM object in the system registry. The parameter to
this macro, IDR_BEEPOBJ, points to a resource in the project.
This is a special kind of resource that loads the MIDL generated
".rgs" file. 
BEGIN_COM_MAP is a macro that defines an array of COM
interfaces that the CComObjectRoot<> class will manage. This
class has one interface, IBeepObj. IBeepObj is our custom inter-
face. It's common for COM objects implement more than one
interface. All supported interfaces would show up here, as well
as in the class inheritance at the top of the class definition. 