冒泡排序的思想就是不断地在交换，通过交换完成最终的排序，这和做股票短线
频繁操作的人是类似的。我们可不可以像只有在时机非常明确到来时才出手的股票高
手一样，也就是在排序时找到合适的关键字再做交换，并且只移动一次就完成相应关
键字的排序定位工作呢？这就是选择排序法的初步思想。
选择排序的基本思想是每一趟在n-i+1(i=1.2"n-1)个记录中选取关键字最小
的记录作为有序序列的第1个记录。我们这里先介绍的是简单选择排序法。
9.4.1简单选择排序算法
简单选择排序法（SimpleSelectionSort）就是通过n-i次关键字间的比较，从
n-i+1个记录中选出关键字最小的记录，并和第i（1length;i++)
min-i;
1将当前下标定义为最小值下标·/
for（j-1+1;j1engthj++）/*环之后的数据/
if（L->r[min]>L->r{51）
如果有小于当前最小值的关键字*/
min-J:
/将此关键字的下标赋佳给min·/
if （i!=min)
/若min不等于i，说明找到最小值，交换*/
sap（L,1,min）;
/.交换L->r[1]与L->z[min]的值-/
---
## Page 409
代码应该说不难理解，针对待排序的关键字序列是（9，1,5.8,3.74.6.2}，对1从1循
环到8。当i=1时，Lr[i]=9，min开始是1，然后与j=2到9比较L.r[min]与Lr[i]的
大小，因为j=2时最小，所以min=2。最终交换了Lr[2]与Lr[1]的值。如图9-4-1所
示，注意，这里比较了8次，却只交换数据操作一次。
下标0123456789
915837462
交换
i=1min=2
图 9-4-1
当i=2时，Lr[i]=9，min开始是2，经过比较后，min=9，交换Lr[min]与Lr[]
的值。如图9-4-2所示，这样就找到了第二位置的关键字。
下标0123456789
195837462
一交换
i2 min=9
图 9-4-2
当i=3时，Lr[i]=5，min开始是3，经过比较后，min=5，交换Lr[min]与Lr[i]
的值。如图9-4-3所示。
125837469
交换
i=3 min=5
图9-4-3
之后的数据比较和交换完全雷同，最多经过8次交换，就可完成排序工作。
9.4.2简单选择排序复杂度分析
从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样
也就节约了相应的时间。分析它的时间复杂度发现，无论最好最差的情况，其比较次
数都是一样的多，第1趟排序需要进行n一i次关键字的比较，此时需要比较
次。而对于交换次数而言，当最好的时候，交
2
换为0次，最差的时候，也就初始降序时，交换次数为#一1次，基于最终的排序时间
385
---
## Page 410
大语数据结构
是比较与交换的次数总和，因此，总的时间复杂度依然为0（n²)。
应该说，尽管与冒泡排序同为0（n²)，但简单选择排序的性能上还是要略优于冒泡
排序。
9.5直接插入排序
扑克牌是我们几乎每个人都可能玩过的游戏。最基本的扑克玩法都是一边摸牌，
一边理牌。假如我们拿到了这样一手牌，如图9-5-1所示。啊，似乎是同花顺呀，别
急，我们得理一理顺序才知道是否是真的同花顺。请问，如果是你，应该如何理牌
$
$
图 9-5-1
应该说，哪怕你是第一次玩扑克牌，只要认识这些数字，理牌的方法都是不用教
的。将3和4移动到5的左侧，再将2移动到最左侧，顺序就算是理好了。这里，我
们的理牌方法，就是直接插入排序法。
9.5.1直接插入排序算法
直接插入排序（StraightInsertionSort）的基本操作是将一个记录插入到已经排
好序的有序表中，从而得到一个新的、记录数增1的有序表。
顾名思义，从名称上也可以知道它是一种插入排序的方法。我们来看直接插入排
序法的代码。
1*对顺序表L作直楼插入排序*/
1void InsertSort（Sqlist*L）
2
3
inti.j;
4
for（i=2:ilength;i++)
5
6
if（L->r[1]r[i-1]）/·需将L->r[i]袖入有序子表/
386
---
## Page 411
第9章排序
7
[T]xr[j+1]-L->r[j];
·记录后移·
11
[0]xLr[i-1]，因此没有移动的记录，时间复
杂度为0（n）。
当最坏的情况，即待排序表是逆序的情况，比如（6,5.4,3.2}，此时需要比较
2
2
2
次。因此，我们得出直接插入排序法的时间复杂度为0（n2）。从这里也看出，同样的
0[n2]时间复杂度，直接插入排序法比冒泡和简单选择排序的性能要好一些。
9.6希尔排序
给大家出一道智力题。请问“VII”是什么？
嗯，很好，它是罗马数字的7。现在我们要给它加上一笔，让它变成8（VII），应
该是非常简单，只需要在右侧加一竖线即可。
现在我请大家试着对罗马数字9，也就是“X”增加一笔，把它变成6，应该怎么
做？
（几分钟后）
我这里有3种另类的方法可以实现它。
方法一：观察发现“x”其实可以看作是一个正放一个倒置两个“v”。因此我们，
给“IX”中间加一条水平线，上下颠倒，然后遮住下面部分，也就是说，我们所谓的
加上一笔就是遮住一部分，于是就得到“V1”，如图9-6-1所示。
VI
图9-6-1
68C
---
## Page 414
大语数据结构
方法二：在“Ix”前面加一个“s”，此时构成一个英文单词“SIX”，这就等于得
到一个6了。哈哈，我听到下面一片哗然，我刚有没有说一定要是“VI”呀，我只说
把它变成6而已，至于是罗马数字还是英文单词，我可没有限制。显然，你们的思维
受到了我前面举例的“vVI1”转变为“vI”的影响，如图9-6-2所示。
图9-6-2
方法三：在“Ix”后面加一个“6”，得到“1X6”，其结果当然是数字6了。大
家笑了，因为这个想法实在是过分，把字母“1”当成了数字1，字母“x”看成了
乘号。可谁又规定说这是不可以的呢？只要没违反规则，得到6即可，如图9-6-3
所示。
IX IX6
-9-6 国
智力题的答案介绍完了3。大家会发现，看似解决不了的问题，还真不一定就没
有办法，也许只是暂时没想到罢了。
我们都能理解，优秀排序算法的首要条件就是速度”。于是人们想了许许多多的
办法，目的就是为了提高排序的速度。而在很长的时间里，众人发现尽管各种排序算
法花样繁多（比如前面我们提到的三种不同的排序算法），但时间复杂度都是0（n²)，
似乎没法超越了25。此时，计算机学术界充斥着“排序算法不可能突破0（n2)”的声
音。就像刚才大家做智力题的感觉一样，“不可能”成了主流。
终于有一天，当一位科学家发布超越了0（n2)新排序算法后，紧接着就出现了好几
种可以超越O（n²）的排序算法，并把内排序算法的时间复杂度提升到了0（nlogn）。“不
可能超越0（n2）彻底成为了历史。
从这里也告诉我们，做任何事，你解决不了时，想一想“Nothingis
impossible!”，虽然有点唯心，但这样的思维方式会让你更加深入地思考解决方案，而
不是匆忙的放弃。
注”：水智力题摘台《在脑录一例猛敲一下）。
注”：还有其他要家，速度是第一位。
注”：这里排序是指内持序。
390
---
## Page 415
第9章排序
9.6.1希尔排序原理
现在，我要讲解的算法叫希尔排序（ShellSort）。希尔排序是D.LShell于1959年
提出来的一种排序算法，在这之前排序算法的时间复杂度基本都是0（n2)的，希尔排
序算法是突破这个时间复杂度的第一批算法之一。
我们前一节讲的直接插入排序，应该说，它的效率在某些时候是很高的，比如，
我们的记录本身就是基本有序的，我们只需要少量的插入操作，就可以完成整个记录
集的排序工作，此时直接插入很高效。还有就是记录数比较少时，直接插入的优势也
比较明显。可问题在于，两个条件本身就过于苛刻，现实中记录少或者基本有序都属
于特殊情况。
不过别急，有条件当然是好，条件不存在，我们创造条件也是可以去做的。于是
科学家希尔研究出了一种排序方法，对直接插入排序改进后可以增加效率。
如何让待排序的记录个数较少呢？很容易想到的就是将原本有大量记录数的记录
进行分组。分割成若干个子序列，此时每个子序列待排序的记录个数就比较少了，然
后在这些子序列内分别进行直接插入排序，当整个序列都基本有序时，注意只是基本
有序时，再对全体记录进行一次直接插入排序。
此时一定有同学开始疑惑了。这不对呀，比如我们现在有序列是{9，1,5,8,3，7，4,6
2），现在将它分成三组，{9，1,5}，{8,3.7}，{4,6,2}，哪怕将它们各自排序排好了，变成
（1,5,9），（3,7,8），{2,4,6），再合并它们成（1,5,9.3,7,8,2.4,6），此时，这个序列还是杂乱
无序，谈不上基本有序，要排序还是重来一遍直接插入有序，这样做有用吗？需要强
调一下，所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小
的基本在中间，像（2.1,3,6,4,7,5,8,9}这样可以称为基本有序了。但像（1,5.9,3,7,8,2,4,6}
这样的9在第三位，2在倒数第三位就谈不上基本有序。
问题其实也就在这里，我们分割待排序记录的目的是减少待排序记录的个数，并
使整个序列向基本有序发展。而如上面这样分完组后就各自排序的方法达不到我们的
要求。因此，我们需要采取跳跃分割的策略：将相距某个“增量”的记录组成一个子
序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不
是局部有序。
9.6.2希尔排序算法
好了，为了能够真正弄明白希尔排序的算法，我们还是老办法一模拟计算机在
391
---
## Page 416
大语数保结构
执行算法时的步骤，还研究算法到底是如何进行排序的。
希尔排序算法代码如下。
1·对版序表L作希尔排序*/
1void ShellSort（SqList*L）
2
inti,]:
中
int increment=L->length;
5
do
6
7