#BHUSA @BlackHatEvents
PISE: Automatic Protocol Reverse Engineering
Ron Marcovich, Orna Grumberg and Gabi Nakibly
#BHUSA @BlackHatEvents
Ron Marcovich
M.Sc. Student
Introductions
Dr. Gabi Nakibly
Senior Adjunct 
Lecturer
Distinguished 
Researcher
Formerly at
Prof. Orna Grumberg
Faculty Member
#BHUSA @BlackHatEvents
Agenda
What is protocol 
RE?
What is PISE all 
about?
How PISE does its 
magic?
S: 250 
OK
start
R: HELO
S: 250 OK
R: MAIL 
FROM
R: RCPT TO
S: 250 OK
R: DATA
S: 550
R: RCPT TO
R: RSET
#BHUSA @BlackHatEvents
Motivation and Background
#BHUSA @BlackHatEvents
Hi
Hello
How are you?
I am fine.
Tuesday
What is protocol reverse engineering?
#BHUSA @BlackHatEvents
250 OK
HELO
250 OK
MAIL FROM
RCPT TO
Mail Client
Mail Server
What is protocol reverse engineering?
#BHUSA @BlackHatEvents
250 OK
start
HELO
250 OK
MAIL FROM
RCPT TO
250 OK
DATA
550
RCPT TO
RSET
RCPT%20TO:*%0D%0A
R:
R:
R:
R:
R:
S:
S:
S:
S:
R:
Mail Server
What is protocol reverse engineering?
#BHUSA @BlackHatEvents
data
init
data
finish
data
Server
Client
Motivation I – Finding Bugs
#BHUSA @BlackHatEvents
init
getFile
deny
SesameGetFile
file
Server
Client
Motivation II – Finding backdoors
#BHUSA @BlackHatEvents
C&C 
channel
Get info
Send Spam
DoS 
Motivation III – Analyzing Malware
#BHUSA @BlackHatEvents
It can be days or even weeks!
Protocol RE is Hard!
#BHUSA @BlackHatEvents
start
R: HELO
S: 250 OK
R: MAIL FROM
S: 250 OK
R: RCPT TO
S: 250 OK
R: DATA
S: 550
R: RCPT TO
R: RSET
RCPT%20TO:*%0D%0A
Research Goal
#BHUSA @BlackHatEvents
No past traffic 
captures
No active 
protocol peer
No source 
code
No Assumptions
#BHUSA @BlackHatEvents
PISE is action, Examples and Demo
#BHUSA @BlackHatEvents
First, we crafted a toy example
login
ok1/ok2
logout1/logout2
#BHUSA @BlackHatEvents
SMTP client
We wanted to get to the real thing
#BHUSA @BlackHatEvents
Messages’ formats are extracted as well!
We wanted to get to the real thing
#BHUSA @BlackHatEvents
Remember those days when we had no idea what Zoom is?
☺☺☺☺☺☺
Then COVID came….
#BHUSA @BlackHatEvents
Then we tried to work with gh0st RAT
#BHUSA @BlackHatEvents
Under the Hood
#BHUSA @BlackHatEvents
Q
A
L* Algorithm
Symbolic Execution
Overview
#BHUSA @BlackHatEvents
L* Algorithm (Automata Learning)
Q: Is a given message exchange valid by the 
protocol?
#BHUSA @BlackHatEvents
{R:init, S:start} 
{R:init, R:init}  
init
start
data
finish
idle
open
close
R:init
S:start
R:finish
Using L* Algorithm
R:data
Client
Server
#BHUSA @BlackHatEvents
We do not know what are the protocol’s 
message types!!
Let’s assume for now we do know the message types.
But there is a problem!
#BHUSA @BlackHatEvents
L* 
algorithm
Symbolic 
Execution
Is this sequence of 
message types 
valid for the 
protocol?
Yes/No
Answering Membership queries
#BHUSA @BlackHatEvents
a > 3 ,b = 2789
Symbolic Execution
#BHUSA @BlackHatEvents
Is {R: Init, S: Start, R: Data} valid for the protocol?
msg  Receive()
if (msg is Init)
true
false
Send(Start)
Msg ← Receive()
If (msg is Data)
true
false
.
.
.
Send(Error)
.
.
.
Error()
R: Init 
S: Start
R: Data
Answering Membership queries
#BHUSA @BlackHatEvents
Is {R: Data} valid for the protocol?
msg  Receive()
if (msg is Init)
true
false
Send(Start)
Msg ← Receive()
If (msg is Data)
true
false
.
.
.
Send(Error)
.
.
.
Error()
R: Data
Answering Membership queries
#BHUSA @BlackHatEvents
• Let M = {M1, .., Mn}
• Whenever send/receive procedures are called for the i-th time, append a predicate that 
identifies Mi, as constraint
• After n {send/receive}s, if there are feasible executions – then the sequence M is valid
Send/receive 
a message
(i-th time)
Constraint to 
Mi
Answering Membership queries
Gray: valid state
Red: invalid for the sequence
Magenta: valid for the sequence
#BHUSA @BlackHatEvents
• Intercept calls to send and receive procedures
How to identify a send or receive?
#BHUSA @BlackHatEvents
As said, we do not know is advance the protocol’s message types. 
We utilize update membership queries to discover it little by little.
L* 
algorithm
Symbolic 
Execution
Is this sequence of 
message types 
valid for the 
protocol?
Yes/No
If yes, here is a message 
type that can follow the 
sequence.
Extend L* to 
handle the new 
message type
Discovering message types
#BHUSA @BlackHatEvents
What message types can follow {R: Init}?
msg  Receive()
if (msg is Init)
true
false
Send(Start)
Msg ← Receive()
If (msg is Data)
.
.
.
Error()
R: Init 
Get 
examples
Probing for following message types
#BHUSA @BlackHatEvents
What message types can follow {R: Init, S: Start}?
msg  Receive()
if (msg is Init)
true
false
Send(Start)
Msg ← Receive()
If (msg is Data)
true
false
.
.
.
Send(Error)
.
.
.
Error()
R: Init 
S: Start
Unknown 
symbolic value
???
Probing for following message types
#BHUSA @BlackHatEvents
msg  receive()
if (msg begins with ‘data’) {
// Constraint: msg begins with ‘Data’
} else {
// I can’t parse this message, error
}
Resume Execution:
Wait for message to 
be parsed
Constraints are 
developed 
according to the 
parsing logic
Get concrete 
messages that 
match constraints
Probing for following message types
#BHUSA @BlackHatEvents
Example 
Messages
Find features of 
message type
Concrete messages → Message type
RCPT%20TO:*%0D%0A
RCPT TO: PI:EMAIL
RCPT TO: PI:EMAIL
RCPT TO: PI:EMAIL
#BHUSA @BlackHatEvents
Use symbolic execution to learn if a given sequence of messages is 
valid and if so, what are the next messages the program expects to 
receive or is about to send.
{R: init, S: start} - A valid sequence. A next message is data.
{R: data} – Not a valid sequence.
Based on this information use a well-known algorithm (called L* 
algorithm) to  reconstruct the protocol’s state machine.
init
start
data
finish
S:start
idle
open
close
R:init
R:finish
R:data
Tying it all together
#BHUSA @BlackHatEvents
{S:start,R:data,R:finish}
M={}
idle
open
close
R:init
R:data
R:finish
M={R:init}
S:start
An illustrative example
L* 
algorithm
Symbolic 
Execution
Yes ☺
{R:init}
mnext=
valid ?
M={R:init,S:start}
M={R:data}
No 
M={R:init,R:data}
M={R:init,R:data,R:finish}
{}
Message Types
R:init
S:start
R: data
R: finish
#BHUSA @BlackHatEvents
PISE’s interacts with the binary using symbolic execution.
This means that PISE is as good or as bad as the symbolic tool used.
Currently, PISE supports only Angr. 
- Trouble supporting threads.
- Does not fully support windows API
L* 
algorithm
Symbolic 
Execution
Caveats
#BHUSA @BlackHatEvents
https://github.com/ron4548/PISEServer
Q
A
L* Algorithm
Symbolic Execution
start
R: HELO
S: 250 OK
R: MAIL 
FROM
S: 250 OK
R: RCPT TO
S: 250 OK
R: DATA
S: 550
R: RCPT TO
R: RSET
Summary
#BHUSA @BlackHatEvents
Questions
https://github.com/ron4548/PISEServer