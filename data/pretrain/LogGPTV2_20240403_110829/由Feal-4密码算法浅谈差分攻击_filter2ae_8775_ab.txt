    L3 = Y
    R3 = L4 ^ F(Y ^ K3)
使用L3和R3继续上面的过程，可以猜解出K2。这个过程需要改变的是使用的差分特征，猜解K3时使用的差分特征是0x8080000080800000，猜解K2时使用差分特征
0x0000000080800000，可以像K3那样构建方程
由于K3已知，可以算出此时的Y0和Y1
Y0 = L ^ F(K3 ^ R0 ^ L0)
Y1 = L ^ F(K3 ^ R1 ^ L1)
同理可以由差分数据流得到Z’
Z’ = L3’ ^ 0x02000000
其中 L3’ = R4’ = L’ ^ R’
此时猜解K2，构建Z’的等式
Z’ = F(Y0 ^ K2) ^ F(Y1 ^ K2)
Z’ = L3’ ^ 0x02000000
得到K2
同理，用差分特征0x00000000 02000000 可以求解出K1
那么如何求解K0和K4、K5呢？theamazingking
博客上讲到，无法使用差分方法求解K0，只能直接猜解K0，然后求出对应的K4和K5，然后使用其他选择明文分组验证猜解的K0 K4 K5
正确性。经过测试我发现其实是可以使用差分的方式求K0的。
还是使用差分特征0x0000000002000000，此时构建K0的方程针对 X’ 构建。有了K3 K2
K1后，我们就有了第一轮加密的左右输出，从而有了L1’ 和 R1’，于是  
`X' = L1' ^ 0x00000000 = L1'`
另一方面，猜解K0，得到
    X0 = F(R1_0 ^ K0)
    X1 = F(R1_1 ^ K0)
    X' = X0 ^ X1
我们同样可以得到K0的等式。
###  提高破解速度
上述过程已经可以实现子密钥的恢复，但是枚举空间是2的32次方，theamazingking的 C demo
程序就是使用的这种算法。C程序的运行时间已经较慢了，使用Python实现破解程序，速度慢到无法承受。得益于Feal-4轮函数的设计，我们还能以更快的速度找到子密钥，方法如下
首先定义M函数，针对4字节输入产生4字节输出，如下
其中z表示zero,0x00
然后对所有可能的四字节序列，计算 Q0 和 Q1
此时有这样的结论：如果A恰好等于M(K3)，那么下面的式子成立
将式子展开，就能看到等式左右两边相等
基于这种方式，我们可以将猜解子密钥的过程分为两步。
第一步，猜解16位的M(K3)，即 `M(K3) = (0, a0, a1, 0)`，猜解的空间是2的16次方
通过上述步骤得到 Q0 和 Q1，然后与 Z’ 建立方程，
    Q0 ^ Q1 = F[ M(Y0) ^ (0, a0, a1, 0) ] ^ F[ M(Y1) ^ (0, a0, a1, 0) ]
    Z' = L' ^ 0x02000000
    Q0 ^ Q1 的8-23位 = Z' 的8-23位
通过上述三行式子，枚举全部的 M(K3)，得到所有可能的 M(K3)
第二步，根据`K3 = (c0, c0^a0, c1^a1, c1)`，继续猜解 c0
c1两个字节，猜解方式依然是基于Z’构建等式，猜解的空间是2的16次方，就可以得到完整的子密钥 K3。
通过这种子密钥求解方式，两次2的16次方的枚举，共2的17次方的枚举次数，就可以求解出子密钥K3，K2 K1
K0的求解方式一样。实际测试中，效率提升非常明显。
以上就是对Feal-4的差分攻击过程。上述分析过程仍然有可以改进的地方，比如选择明文的数量。以及使用破解K0的方式，用同一组选择明文破解K3 和
K2，第二组选择明文破解K1 和 K0，这样需要的选择明文数更少。由于时间原因我没有再做测试。
## 三、实例
*ctf 2019 的 notfeal 问题就是这样一个使用差分方式攻击Feal密码的例子。不过该程序对原始Feal-4进行了改动。有以下两点
第一，F函数的输出被逆序了。
第二，Feistel架构左右颠倒了。
只要理解了差分攻击的过程，不难调整差分过程，完成攻击。
由于输出逆序，三轮使用的差分特征要调整为
1.0×0000000080800000
2.0×8080000080800000
3.0×0000000200000002
该问题限定的选择明文数量是50组，实际上使用36组就可以成功。
代码很乱就不放了。可参考 sixstar 在github上的官方 writeup（该wp使用的就是theamazingking的C代码）
值得一提的是，差分攻击得到的子密钥组不唯一，但是都可以正确解密。