扩展的例子
209
在Java中通过变量构建正则表达式
String SubDomain =*(?i:[a-z0-9]1[a-z0-9][-a-z0-9]*[a-z0-9])";
String TopDomains="(?x-i:com\\b
\n"+
ledu\\b
\n+
1biz\\b
\n”+
Iin(?:t1fo) \\b
\n*+
Imi1\\b
\n"+
Inet\\b
\n"
+
lorg\\b
\n"
+
1[a-z][a-z]\\b
\n"+//countrycodes
")
\n";
String Hostname =
. :) 。
+SubDomain+
*\\.)+"+TopDomains;
String NOT_IN
≤
";\*
<>（)\[\\]{}\\S\\x7F-\\xFF;
String NOT_END
=
"!.,?";
String ANYWHERE
=
[~
[+NON+NION+
String EMBEDDED =
" [ *
[+NON+
String UrlPath =
*(+ +HMN++++) *+HMN+
String Url =
" (?x:
\n"+
ib
\n*+
##
匹配hostname
\n"+
（
\n*+
(?:ftp 1http s?）://[-\\w]+(\\.\\w[-\\w]*)+\n"+
\n"+
+Hostname +
\n*+
1
\n*+
可能出现端口号
\n"+
（？：:\\d+）？
\n*+
\n"+
下面的部分可能出现，以\开头
\n"+
(？：
（++
\n"+
//现在把正则表达式编译为正则对象
Pattern UrlRegex=Pattern.compile(Url);
//现在准备在文本中应用，寻找ur1..，
保持数据的协调性
Keeping in Sync with Your Data
我们来看一个长一点的例子，它有点极端，但很清楚地说明了保持协调的重要性（同时提
供了一些保持协调的方法）。
假设，需要处理的数据是一系列连续的5位数美国邮政编码（ZIPCodes），而需要提取的是
以44开头的那些编码。下面是一点抽样，我们需要提取的数值用粗体表示：
03824531449411615213441829505344272752010217443235
---
## Page 236
210
第5章：正则表达式实用技巧
最容易想到的d\d\d\d\di，它能匹配所有的邮政编码。在Perl中可以用@zipe=m/\d\d\
d\d\d/g：来生成以邮政编码为元素的list（为了让这些例子看起来更整洁，我们假设需要处
理的文本在Perl的默认目标变量$_中，见79)。如果使用其他语言，也只需要循环调用正
则表达式的find方法。我们关注的是正则表达式本身，而不是语言的实现机制，所以下面
继续使用Perl。
回到d\d\d\d\d，下面提到的这一点很快就会体现出其价值；在整个解析过程中，这个
正则表达式任何时候都能够匹配一绝对没有传动装置的驱动和重试（我假设所有的数据
都是规范的，此假设与具体情况密切相关）。
很明显，把d\d\d\d\d改为44\d\d\d来查找以44开头的邮政编码不是个好办法
匹配失败之后，传动装置会驱动前进一个字符，对44的匹配不再是从每个邮政编码的第
一位开始。44\d\d\d会错误地匹配‘.5314494116…。
当然，我们可以在正则表达式的开头添加A，但是这样只能对付一行文本中的第一个邮政
编码。我们需要手动保持正则引擎的协调，才能忽略不需要的邮政编码。这里的关键是，
移动。
根据期望保持匹配的协调性
下面列举了几种办法用来跳过不需要的邮政编码。把它们添加到正则表达式44\d\d\d之
前，可以获得期望的结果。非捕获型括号用来匹配不期望的邮政编码，这样能够快速地略
过它们，找到匹配的邮政编码，在第一个S1的捕获括号中：
（？：[4]\d\d\d\d1\d[4]\d\d\d)*]
这种硬办法（brute-forcemethod）主动略过非44开头的邮政编码（当然，用[1235-9]1
替代[~4]可能更合适，但我之前说过，假设处理的是规范的数据）。注意，我们不能
使用（？：[^4][~4]\d\d\d）*，因为它不会匹配（也就无法略过）43210这样不期望
的邮政编码。
.(\p\p\p\p\(i））
这个办法跳过非44开头的邮政编码。其中的想法与之前并无差别，但用正则表达式写
出来就显得大不一样。比较这两段描述和相关的正则表达式就会发现，在这里，期望
的邮政编码（以44开头）导致逆序环视（？！44）失败，于是略过停止。
---
## Page 237
扩展的例子
211
[.（p\p\P\P\p\:)
这个办法使用忽略优先量词，只有在需要的时候才略过某些文本。我们把它放在真正
需要匹配的正则表达式前面，所以如果那个表达式失败，它就会匹配个邮政编码。
忽略优先（…)*？i导致这一切的发生。因为存在忽略优先量词，（?：\d\d\d\d\d）甚
至都不会尝试匹配，在后面的表达式失败之前。星号确保了，它会重复失败，直到最
终找到匹配文本，这样就能只跳过我们希望跳过的文本。
把这个表达式和"（44\d\d\d）合起来，就得到：
@zips=m/(?:\d\d\d\d\d)*？(44\d\d\d) /g;
它能够提取以44开头的邮编，而主动跳过其他的邮编（在“@array=m/…/g”的情况下，
字符串，因为我们知道每次匹配的“起始匹配位置”都是某个邮政编码的开头位置，也就
保证下一次匹配是从-个邮政编码的开始，这正是正则表达式期望的。
不匹配时也应当保证协调性
我们是否能保证，每次正则表达式都在邮政编码字符串的开头位置应用？显然不是！我们
手动跳过了不符合要求的邮政编码，可一旦不需要继续匹配，本轮匹配失败之后自然就是
驱动过程和重试，这样就会从邮政编码字符串之中的某个位置开始一一我们的方法不能处
理这种情况。
再来看数据样本：
03824531449411615213441829503544272 7,5.2 010217443235
匹配的代码以粗体标注（第三组不符合要求），主动跳过的代码以下画线标注，通过驱动过
程-重试略过的字符也标记出来。在44272匹配之后，目标文本中再也找不到匹配，所以本
轮尝试宣告失败。但总的尝试并没有宣告失败。传动机构会进行驱动，从字符事的下一-个
字符开始应用正则表达式，这样就破坏了协调性。在第四次驱动之后，正则表达式略过
10217，错误地匹配44323。
调性。如果我们能取消驱动过程，或者保证驱动过程不会添麻烦，问题就解决了。
办法之一是禁止驱动过程，即在前两种办法中的（44\d\d\d）：之后添加？，将其改为匹配
优先的可选项。这样，刻意安排的（?：（?！44）\d\d\d\d\d）*或（?：[^4）\d\d\d\dl\d
---
## Page 238
212
第5章：正则表达式实用技巧
{^4]\d\d\d)*就只会在两种情况下停止：发生符合要求的匹配，或者邮政编码字符串结
束（这也是此方法不适用于第三个表达式的原因）。这样，如果存在符合要求的邮政编码，
（44\d\d\d）？就能匹配，而不会强迫回溯。
这个办法仍然不够完善。原因之一是，即便目标字符串中没有符合要求的邮政编码，也会
匹配成功，接下来的处理程序会变得更复杂。不过，其优点在于速度很快，因为不需要回
溯，也不需要传动装置进行任何驱动过程。
使用\G保证协调
更通用的办法是在这三个表达式末尾添加G（130)。因为每个表达式的每次匹配都以符
合要求的邮政编码结尾，下次匹配开始时就不会进行驱动。而如果有驱动过程，开头的G
会立刻导致匹配失败，因为在大多数流派中，只有在未发生驱动过程的情况下，它才能成
功匹配（但在Ruby和其他规定G表示“本次匹配起始位置”的流派中不成立131）
所以第二个表达式就变成了：
@zips=m/G(?:(?!44)\d\d\d\d\d)*(44\d\d\d)/g;
匹配之后不需要进行任何特殊检查。
本例的意义
我首先承认，这个例子有点极端，不过，它包含了许多保证正则表达式与数据协调性的知
识。如果现实生活中需要处理这样的问题，我可能不会完全用正则表达式来解决。我会直
接用\d\d\d\d\d来提出每个邮政编码，然后检查它是否以“44开头。在Perl中是这样：
@zipS=（）：#确保数组为空
while(m/(\d\d\d\d\d)/g）{
Sz1p=$1;
if（substr（$zip,0.2）eq“44"）{
push @zips,Szip:
对Gi有兴趣的读者请参考132页的补充内容，尽管本书写作时只能举Perl的例子。
---
## Page 239
扩展的例子
213
解析CSV文件
Parsing CSV Files
解析CSV（逗号分隔值）文件有点麻烦，因为每个程序都有自己的CSV文件格式。首先来
看如何解析MicrosoftExcel生成的CSV文件，然后再看其他格式（注3）。幸运的是，Microsoft
的格式是最简单的。以逗号分隔的值要么是“纯粹的”（仅仅包含在括号之前），要么是在
双引号之间（这时数据中的双引号以一对双引号表示）。
下面是个例子：
Ten Thousand,10000,2710,,"10,000",“It's "*10 Grand""，baby*,10K
这一行包含七个字段（fields）：
Ten·Thousand
10000
2710*
空字段
10,000
It's*"10·Grand",*baby
10K
为了从此行解析出各个字段，我们的正则表达式需要能够处理两种格式。非引号格式包含
引号和逗号之外的任何字符，可以用["，]+匹配。
双引号字段可以包含逗号、空格，以及双引号之外的任何字符。还可以包含连在一起的两
1""）*（为效率考虑，我们可以使用固化分组（？>）来替代（？：），不过这个话题留
到下一章。259）。
“*]：）+“
出宽松排列（111）格式：
#引号和追号之外的文本.
[^*, ] +
...或者是...
1
#：..双引号字段（其中容许出现连在一起的成对双引号）
#起始双引号
(？：[~"]1**）*
“#结束双引号
注3：在第6章，讨论完效率问题之后，会给出处理MicrosoftExcel的最终程序（271）。
---
## Page 240
214
第5章：正则表达式实用技巧
现在这个表达式可以实际应用到包含CSV文本行的字符事上了，但如果我们希望真正利用
匹配结果，就应该知道具体是哪个多选分支匹配了。如果是双引号字符串，就需要去掉首
尾两端的双引号，把其中紧挨着的两个双引号替换为单个双引号。
我能想到的办法有两个。其一是检查匹配结果的第一个字符是否双引号，如果是，则去掉
第一个和最后一个字符（双引号），然后把中间的‘’替换为‘"'。这办法够简单，但如
果使用捕获型括号会更简单。如果我们给捕获字段的每个子表达式添加捕获型括号，可以
在匹配之后检查各个分组的值：
#引号和追号之外的文本.：，
（[",]+)
#...或者是...
#：..双引号字段（其中容许出现连在一起的成对双引号）
"#起始双引号
（。（.[]：））
”#结束双引号
如果是第一个分组捕获，则不需要进行任何处理，如果是第二个分组，则只需要把‘"
替换为‘’即可。
下面给出Perl的程序，稍后（找出某些bug之后）给出Java和VB.NET（在第10章给出
PHP的程序r480)。下面是Perl程序，假设数据位于s1ine中，而且.已经去掉了结尾的换
行符（换行符不属于最后的字段！）：
while (Sline =~ m{
#引号和逗号之外的文本..
（[,]+)
...或者是...
#：..双引号宇段（其中容许出现连在一起的成对双引号）
#起始双引号
(?：[*]1**) *)
#结束双引号
(x6(
if (defined $1){