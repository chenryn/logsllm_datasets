status changes from the on-screen consent dialog (e.g., minimized,
unfocused).
Our current prototype implements the tracking routines only for
pointer input devices, which means that users can express their
consent only by using the mouse. However, adding support for
keyboard input using the same principle should be straightforward.
Moreover, the performance overhead introduced by the addition of
keyboard tracing is expected to be minimal simply because key-
board events are less frequent than mouse events in web browsing.
3.4 Correlator
One of the key challenges in BLADE is establishing the 1-1 map-
ping between user download authorizations and downloaded ﬁles.
The Correlator addresses this problem and ensures the authenticity
of user-consented ﬁle downloads. Guaranteeing authenticity pre-
vents potential attacks seeking to deliver a malicious download, ei-
ther by prompting deceptive dialogs or subverting benign browser
downloads.
Since BLADE is independent of the browser and treats it as a
black box, only the external behavior of the browser (e.g., inter-
actions with OS) is visible to it. Hence, the Correlator analyzes
information available in the OS kernel, oblivious to the internal
download handling of browsers. As browsers invariably rely on
the OS to provide network and ﬁle system capabilities, all kernel
drivers including the Correlator have the chance to peek into each
transaction and retrieve a wealth of information about it. For exam-
ple, network trafﬁc incurred by a browser is fully transparent to the
Correlator (at multiple kernel system levels) while it is being pro-
cessed in the OS network protocol stack. Similarly, the Correlator
can intercept ﬁle system access operations from the browser.
The Correlator associates a ﬁle download with a user authoriza-
tion in two steps: it discovers the correlation candidate ﬁle, and
then validates its authenticity. We now demonstrate why a ﬁle that
passes these two steps while being correlated with a given user au-
thorization is assured to be in compliance with that authorization.
Recall the tuple form of an inferred user authorization discussed
earlier in this section (URL, Path). Here, we use the second ele-
ment, the destination path in the local storage, plus the ﬁle name as
a criteria for discovering the correlation-candidate. Whenever a ﬁle
has been written with the same path and name as that of a pending
authorization, the Correlator marks it as a correlation candidate and
starts the validation process immediately. We call it a candidate be-
cause the adversary in our threat model is able to replace the ﬁle
content after fully compromising the browser.
The ﬁrst element of the authorization tuple, the source domain,
indicates the origin location of the ﬁle content and is used for source
validation. We implement the following source validation tech-
nique based on content comparison. First, we keep a log of inbound
transport-level stream for each TCP session created by supervised
processes, which is later compared with the download candidate. If
the content of a particular download-candidate appears in a stream
log that corresponds to the source URL recorded in the authoriza-
tion tuple, the candidate is validated and the correlation process
completes with the candidate being correlated with the user autho-
rization. Our content-comparison approach works even when en-
cryption is used (e.g., HTTPS, VPN), because browsers rely on OS
support to process transactions of this kind. The user-level APIs are
simply wrappers for kernel functions and therefore plaintext con-
tent can always be obtained by kernel drivers prior to encryption
(when sending) or after decryption (when receiving). Furthermore,
browser-level compression/encoding schemes (e.g., SDCH), which
only apply to web streams that are natively rendered by browsers,
do not interfere with the BLADE correlation process.
Although the source validation idea is straightforward, an efﬁ-
cient comparison algorithm and a reliable implementation require
careful consideration. From a performance perspective, the Cor-
relator should avoid unnecessary stream logging and halt ongoing
log writes once they are deemed unnecessary. Moreover, stream
recording needs to be performed only when there is an incoming
authorized download ﬁle and needs to consider only inbound con-
tent. Hence, a new logging process will be initiated, only when
a download consent dialog requesting a download permission pops
up, and only on streams sharing the same remote endpoint as the au-
thorization dialog. A subtle issue is that the source of the download
ﬁle is identiﬁed by a URL on the authorization dialog, while the re-
mote end of a stream is identiﬁed by an IP address. The Correlator
performs a domain name lookup in the local DNS cache to resolve
the corresponding IP address(es). Integrity of the local DNS cache
is guaranteed in our threat model because it is being maintained by
a trusted kernel component. The logging terminates either when the
user denies the download request or after the last stacked authoriza-
tion permitting that source has been correlated with a ﬁle download.
As native browser downloaders are all single-threaded, our current
prototype does not support the case of multi-threaded downloads
where content of a single ﬁle comes from multiple streams.
4443.5 I/O Redirector
BLADE introduces the secure zone (i.e., a virtual storage area) as
a mechanism to restrict execution of disk footprints that are caused
by supervised processes but not explicitly allowed by users. Unlike
sandboxing, which blindly isolates execution of untrusted code, the
secure zone of BLADE is intelligent enough to selectively contain
potential threats and ultimately prevent them.
The design philosophy of the secure zone is based on the closure
property of browser disk writes derived from our study of generic
disk access patterns by browsers. The robustness of this property
was evaluated by exercising popular browsers with multiple web
browsing workloads (see § 4.1 C).
Closure property: On a clean computer running commodity OS
and browsers, let P = {p | p : any browser process}, and F ,
Fauth, Fint and F (cid:48) be four sets of ﬁles on disk:
F = {f | f : any f ile written by p, where p ∈ P};
Fauth = {fa | fa : any -authorized browser download};
Fint = F − Fauth (given Fauth ⊂ F is always true);
F (cid:48) = {f(cid:48) | f(cid:48) : any f ile opened by p(cid:48), where p(cid:48) ∈ ¯P};
We observe that Fint ∩ F (cid:48) ≈ ∅. This implies that, except for user-
authorized download ﬁles (Fauth), any other ﬁle to which browser
process (P ) writes data is not normally accessed by non-browser
processes ( ¯P ). More generally, it indicates that the disk data that is
written by browsers without explicit user consent is well-contained
within an implicit scope on disk, and thus should not be accessed by
other processes or executed by any program entity. Discovering this
scope inspired our design of the secure zone. The I/O Redirector
plays a central role in managing the secure zone by enforcing the
following policies:
P1 : Any new ﬁle created by a supervised process is redirected
to the secure zone.
P2 : Any existing ﬁle modiﬁed by a supervised process is saved
as a shadow copy in the secure zone, without change to
the original ﬁle.
P3 : I/O redirection is transparent to supervised processes.
P4 : I/O redirection only applies to supervised processes. Files
in the secure zone can only be accessed via redirection.
P5 : No execution is allowed for ﬁles in the secure zone.
P6 : Any ﬁle correlated with a user download authorization is
remapped to the ﬁlesystem.
Together these policies enable a complete containment of disk
footprints affected by content delivered through browser processes
without user knowledge, while still preserving the browser usabil-
ity due to transparency.
Figure 3 provides a high-level overview of how the I/O Redirec-
tor handles the two types of ﬁle accesses in order to enforce P 1 –
P 3 listed above: the upper subﬁgure shows that the browser is try-
ing to write C:\a.exe to the disk (i.e., opening a ﬁle handle with
write privilege). Upon receiving the request, the I/O Redirector ﬁrst
checks the existence of the ﬁle’s shadow copy “\SecureZone\
C\a.exe”. If it exists, i.e., the ﬁle has been previously created or
modiﬁed by the supervised process, the I/O Redirector immediately
forwards the request down to the ﬁle system driver with the target
being modiﬁed into the path of the shadow copy. Otherwise, the I/O
Redirector might need to create such a shadow copy before modify-
ing and redirecting the request, depending on whether the request
is to create a new ﬁle “Disk1\C\a.exe” or to modify/replace
an old one. Finally, the browser that obtains the returned ﬁle han-
dle is unaware that it is operating on a shadow copy of the ﬁle in
the secure zone. The lower subﬁgure shows that a read request is
redirected to the shadow copy “\SecureZone\C\a.htm” if it
exists. Otherwise, the request is passed down to the ﬁle system
without the need for redirection. The I/O Redirector also provides
Figure 3: Browser ﬁle access (top: write; bottom: read) request
processing by the I/O Redirector
a different ﬁle system view to supervised processes, which hides
the separation of ﬁles inside and outside the secure zone.
To enforce P 4, which guarantees the nonpropagation property of
ﬁles in the secure zone, the I/O Redirector simply passes through
ﬁle access requests from processes that are not supervised (i.e., no
redirection happens), except for denying those that are obtaining
handles to ﬁles in the secure zone. The policy P 5, ﬁle execution
prevention, is performed by blocking executable images from being
mapped into the memory. Speciﬁcally, the I/O Redirector intercepts
AcquireForSectionSynchronization operations on ﬁles
located in the secure zone. This is a necessary operation performed
by the Windows kernel to load all forms of executables including
normal program (.exe, .msi) startups, dynamic library (.dll) loads
and driver module (.sys) installations.
When the Correlator successfully matches a previously inferred
user download authorization with a ﬁle written to the secure zone,
the I/O Redirector is notiﬁed and the ﬁle is remapped back to the
ﬁlesystem instantly.
4. EVALUATION
We evaluate our BLADE prototype in terms of system effec-
tiveness and performance overhead. Our effectiveness evaluation
demonstrates the solid defense that BLADE provides against real-
world drive-by download attacks and its resilience to false posi-
BrowsersSecureZoneDisk1I/O RedirectorFileSysView(1) OpenFile:  ( to Write )    C:\a.exeFile SystemDriver(3)Redirect     OpenFile:     \SecureZone\C\a.exe(2)** CopyFile:        \Disk1\C\a.exe      To \SecureZone\C\a.exe(4) File    C:\a.exe    Opened    For WriteBrowsersSecureZoneDisk1I/O RedirectorFileSysView(1) OpenFile:   ( to Read )    C:\a.htmFile SystemDriver(2) Redirect     ReadFile:     \SecureZone\C\a.htm(3)* ReadFile:    \Disk1\C\a.htm(4) File    C:\a.htm    Opened    For Read            * (3) only happens if \SecureZone\C\a.htm does not exist.            ** (2) only happens if\Disk1\C\Downloads\a.exe exists and  \SecureZone\C\a.exe does not exist.User-Level Kernel-Level User-Level Kernel-Level 445of instrumentation is to gather auxiliary evidence about potential
drive-by installs for false negative evaluation. An in-VM agent then
creates a browser instance and navigates it to the malicious URL.
After a delay of one minute, BLADE’s output and instrumentation
logs are synchronously redirected outside the VM for ofﬂine post-
mortem analysis.
We parse the instrumentation log to identify speciﬁc events that
we then interpret in evaluating several potential experimental out-
comes. In particular, we track three key experiment outcomes:
C1 :(T|F ) URL test session caused a BLADE alert
C2 :(T|F ) URL test session attempted to load/execute a ﬁle
C3 :(T|F ) URL test session produced a ﬁle write outside the
from the secure zone
secure zone
C1 can be conﬁrmed from BLADE’s alert log. System call event
logs, especially events related to ﬁlesystem and process manage-
ment, can help identify occurrences of C2 and C3. The testbed
then derives the following evaluation metrics, which are deﬁned as
logic combinations of conditional occurrences.
True Positive
False Negative
False Positive
True Negative
:= C1 ∧ (C2 ∨ C3)
:= C1 ∧ (C2 ∨ C3)
:= C1 ∧ (C2 ∨ C3)
:= C1 ∧ (C2 ∨ C3)
The testbed has been operational for 3 months and visited 3,992
unique malicious URLs (please see www.blade-defender.
org/eval-lab for updated statistics and results). The dataset
that was collected also offers a glimpse into the Internet’s con-
temporary drive-by malware landscape as summarized in Figure
4. Figure 4 (a) shows the distribution of exploit kits encountered
during our experiments illustrating the growing popularity of com-
mercialized exploit kits. Eleonore and JustExploit seem to be the
most popular. Figure 4 (b) shows the distribution of attacks by vul-
nerable software. We ﬁnd that (i) pdf exploits currently dominate,
(ii) attackers increasingly prefer targeting plug-ins over browsers
because of the wider attack surface, and (iii) they largely rely on
commercialized exploit kits to launch reliable attacks.
Figure 4 (c) displays the distribution of successful attacks based
on browser and software conﬁguration. Not surprisingly, we ﬁnd
that all tested browsers are vulnerable. We ﬁnd that the Internet Ex-
plorer 6.0 system conﬁgured with Adobe Reader 8.0, Adobe Flash
8.0, and JVM 5.0 is the most vulnerable. A similarly conﬁgured
Firefox 3.0 system experiences less than half the number of exploits
and is comparable to Internet Explorer 8 running Adobe Reader 9.0
and JVM 6.0. Table 1 summarizes results from our daily evalua-
tion. The number of trials is more than the number of unique URLs
because each URL might appear on the list for multiple days and
is tested on multiple VM conﬁgurations. As shown in Table 1(a),
BLADE was successful at blocking all 7,925 attempted drive-by
malware installs while generating zero false alarms. Furthermore,
all downloaded malicious binaries were safely quarantined into the
secure zone. While these results might be surprising at ﬁrst glance,
they are expected because BLADE is designed in an exploit obliv-
ious manner.
It is worth noting that at no point did our system
design or implementation necessitate additional tuning to handle a
new exploit or shellcode type. Table 1(b) provides a summary of
the malware binaries captured. The 7,925 trials pushed 9,745 bina-
ries (certain sites push more than one binary) which included 8,126
EXEs and 1,619 DLLs. The average detection rate of these binaries