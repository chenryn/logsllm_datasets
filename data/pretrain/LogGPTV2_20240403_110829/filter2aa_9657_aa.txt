# 正则
---
- https://www.kancloud.cn/imxieke/ruby-base/107304
---
Ruby 的特点是“万物皆对象”，正则表达式也不例外。正则表达式对象所属的类就是接下来我们将要介绍的 Regexp 类。
# 关于正则表达式
下面我们开始介绍有关正则表达式的一些概念及用法。
**正则表达式的写法与用法**
正则表达式描述的是一种“模式”，该模式被用于匹配字符串。一般情况下，我们把正则表达式模式的对象（`Regexp` 类对象）称为“正则表达式对象”，或直接称为“正则表达式”。
到目前为止，我们都是使用纯文本文字作为模式，而实际上还有更复杂的模式。例如，通过模式可以很简单地匹配“首字符为 A 到 D 中的某个字母，从第 2 个字符开始为数字”这样的字符串（这个模式可写为 `/[A-D]\d+/`）。
但模式也并非是万能的，例如像“与 Ruby 类似的字符串”这种含糊的模式就无法书写。模式说明的东西应该更具体一些，例如“以 R 开头，以 y 结尾，由 4 个字母组成”（这个模式可写为 `/R..y/`）。
**正则表达式对象的创建方法**
在程序中，通过用 `//` 将表示正则表达式模式的字符串括起来，就可以非常简单地创建出正则表达式。
另外，我们也可以使用类方法 `Regexp.new(str)` 来创建对象。当程序中已经定义了字符串对象 `str`，且希望根据这个字符串来创建正则表达式时，用这个方法会比较好。
```ruby
re = Regexp.new("Ruby")
```
除上述两种方法外，与数组、字符串一样，我们也可以通过使用 `%` 的特殊语法来创建。正则表达式的情况下使用的是 `%r`，如果正则模式中包含 `/`，用这种方法会比较方便。语法如下所示：
- `%r` (模式)
- `%r` 
- `%r` |模式|
- `%r!` 模式!
# 正则表达式的模式与匹配
了解正则表达式的创建方法后，接下来讨论一下模式。`=~` 方法是正则表达式中常用的方法，可以用来判断正则表达式与指定字符串是否匹配。
```
正则表达式 =~ 字符串
```
无法匹配时返回 `nil`，匹配成功则返回该字符串起始字符的位置。
Ruby 会将 `nil` 与 `false` 解析为“假”，将除此以外的值解析为“真”，因此，如果要根据匹配结果执行不同的处理，则可以像下面这样写。
```ruby
if 正则表达式 =~ 字符串
 匹配时的处理
else
 不匹配时的处理
end
```
我们还可以使用 `!~` 来颠倒“真”与“假”。
**匹配普通字符**
们首先来看看如何通过模式进行简单的匹配。当模式中只写有英文、数字时，正则表达式会单纯地根据目标字符串中是否包含该模式中的字符来判断是否匹配
> 匹配部分都用▶匹配部分◀来表示
模式	| 字符串	| 匹配部分
- | - | -
/ABC/	| "ABC"	    | "▶ABC◀"
/ABC/	| "ABCDEF"	| "▶ABC◀DEF"
/ABC/	| "123ABC"	| "123▶ABC◀"
/ABC/	| "A1B2C3"	| （不匹配）
/ABC/	| "AB"	    | （不匹配）
/AB/	| "abc"	    | （不匹配）
**匹配行首与行尾**
在上面的例子中，`/ABC/` 模式的情况下，只要是包含 `ABC` 的字符串就都可以匹配。但如果我们只想匹配 ABC 这一字符串，也就是说只匹配 `"ABC"`，而不匹配 `"012ABC"`、`"ABCDEF"` 等，这时的模式应该怎么写呢？这种情况下，我们可以使用模式 `/^ABC$/`。
`^`、`$` 是有特殊意义的字符。但它们并不用于匹配 `^` 与 `$` 字符。像这样的特殊字符，我们称之为元字符（meta character）。
`^` 表示匹配行首，`$` 表示匹配行尾。也就是说，模式 `/^ABC/` 匹配行首为 `ABC` 的字符串，模式 `/ABC$/` 匹配行尾为 `ABC` 的字符串。
模式	| 字符串	| 匹配部分
- | - | -
/^ABC$/	| "ABC"	    | "▶ABC◀"
/^ABC$/	| "ABCDEF"	| （不匹配）
/^ABC$/	| "123ABC"	| （不匹配）
/^ABC/	| "ABC"	    | "▶ABC◀"
/^ABC/	| "ABCDEF"	| "▶ABC◀DEF"
/^ABC/	| "123ABC"	| 不匹配
/ABC$/	| "ABC"	    | "▶ABC◀"
/ABC$/	| "ABCDEF"	| （不匹配）
/ABC$/	| "123ABC"	| "123▶ABC◀"
**行首与行尾**
`^`、`$` 分别匹配“行首”、“行尾”，而不是“字符串的开头”、“字符串末尾”。匹配字符串的开头用元字符 `\A`，匹配字符串的末尾用元字符 `\z`。
这两种情况有什么不同呢？ Ruby 的字符串，也就是 `String` 对象中，所谓的“行”就是用换行符 `(\n) `间隔的字符串。因此模式 `/^ABC/` 也可以匹配字符串 `"012\nABC"`。也就是说
```
012
ABC
```
像上面这种跨两行的字符串的情况下，由于第 2 行是以 `ABC` 开头的，因此也可以匹配。
那么为什么要将行首 `/` 行尾与字符串的开头 `/` 结尾分开定义呢？这是有历史原因的。
具体来说，原本正则表达式只能逐行匹配字符串，不能匹配多行字符串。因此就可以认为一个“字符串”就是一“行”。
但是，随着正则表达式的广泛使用，人们开始希望可以匹配多行字符串。而如果仍用 `^`、`$` 来匹配字符串的开头、结尾的话就很容易造成混乱，因此就另外定义了匹配字符串开头、结尾的元字符。
另外，还有一个与 `\z` 类似的表现，就是 `\Z`，不过两者的作用有点不一样。`\Z` 虽然也是匹配字符串末尾的元字符，但它有一个特点，就是如果字符串末尾是换行符，则匹配换行符前一个字符。
```ruby
p "abc\n".gsub(/\z/, "!")    => "abc\n!"
p "abc\n".gsub(/\Z/, "!")    => "abc!\n!"
```
我们一般常用 `\z`，而很少使用 `\Z`。
**指定匹配字符的范围**
时候我们会希望匹配“ABC 中的 1 个字符”。像这样，选择多个字符中的 1 个时，我们可以使用 `[]`。
- `[AB]`    ……A或B
- `[ABC]`   ……A或B或C
- `[CBA]`    ……同上（与[]中的顺序无关）
- `[012ABC]` ……0、1、2、A、B、C中的1个字符
    不过，如果按照这样的写法，那么匹配“从 A 到 Z 的全部英文字母”时就麻烦了。这种情况下，我们可以在 `[]` 中使用 `-`，来表示一定范围内的字符串。
- `[A-Z]`   ……从A到Z的全部大写英 文字母
- `[a-z]`    ……从a 到z 的全部小写英文字母
- `[0-9]`    ……从0到9 的全部数字
- `[A-Za-z]`  ……从A到Z与从a到z的全部英文字母
- `[A-Za-z_]` ……全部英 文字母与 _
    > 备注 字符的范围也称为“字符类”。请注意这里的“类”与面向对象中的“类”的意义是不一样的。
    如果 `-` 是 `[]` 中首个或者最后 1 个字符，那么就只是单纯地表示 `-` 字符。反过来说，如果 `-` 表示的不是字符类，而是单纯的字符 `-`，那么就必须写在模式的开头或者末尾。
- `[A-Za-z0-9_-]` ……全部英文字母、全部数字、_、-
    在 `[]` 的开头使用 `^` 时，`^` 表示指定字符以外的字符。
- `[^ABC]`   ……A、B、C 以外的字符
- `[^a-zA-Z]` ……a 到 z，A 到 Z（英文字母）以外的字符
    表为一些实际进行匹配的例子。另外，在 1 个模式中还可以使用多个 `[]`
    模式	    | 字符串	| 匹配部分
    - | - | -
    /[ABC]/	        | "B"	    | "▶B◀"
    /[ABC]/	        | "BCD"	    | "▶B◀CD"
    /[ABC]/	        | "123"	    | （不匹配）
    /a[ABC]c/	    | "aBc"	    | "▶aBc◀"
    /a[ABC]c/	    | "1aBcDe"	| "1▶aBc◀De"
    /a[ABC]c/	    | "abc"	    | （不匹配）
    /[^ABC]/	    | "1"	    | "▶1◀"
    /[^ABC]/	    | "A"	    | （不匹配）
    /a[^ABC]c/	    | "aBcabc"	| "aBc▶abc◀"
    /[ABC][AB]/	    | "AB"	    | "▶AB◀"
    /[ABC][AB]/	    | "AA"	    | "▶AA◀"
    /[ABC][AB]/	    | "CA"	    | "▶CA◀"
    /[ABC][AB]/	    | "CCCCA"	| "CCC▶CA◀"
    /[ABC][AB]/	    | "xCBx"	| "x▶CB◀x"
    /[ABC][AB]/	    | "CC"	    | （不匹配）
    /[ABC][AB]/	    | "CxAx"	| （不匹配）
    /[ABC][AB]/	    | "C"	    | （不匹配）
    /[0-9][A-Z]/	| "0A"	    | "▶0A◀"
    /[0-9][A-Z]/	| "000AAA"	| "00▶0A◀AA"
    /[^A-Z][A-Z]/	| "1A2B3C"	| "▶1A◀2B3C"
    /[^0-9][^A-Z]/	| "1A2B3C"	| "1▶A2◀B3C"
**匹配任意字符**
有时候我们会希望定义这样的模式，即“不管是什么字符，只要匹配 1 个字符就行”。这种情况下，我们可以使用元字符 `.`。
- `……`匹配任意字符
    模式	    | 字符串	    | 匹配部分
    - | - | -
    /A.C/	    | "ABC"	        | "▶ABC◀"
    /A.C/	    | "AxC"	        | "▶AxC◀"
    /A.C/	    | "012A3C456"	| "012▶A3C◀456"
    /A.C/	    | "AC"	        | （不匹配）
    /A.C/	    | "ABBC"	    | （不匹配）
    /A.C/	    | "abc"	        | （不匹配）
    /aaa.../	| "00aaabcde"	| "00▶aaabcd◀e"
    /aaa.../	| "aaabb"	    | （不匹配）
然而，可能有读者会问：“程序在什么时候会需要能够匹配任意字符的字符呢”。的确，任意字符都能匹配的话，也就没有必要特意指定了。
在下面两种情况下，一般会使用这个元字符。
在希望指定字符数时使用 `/^...$/` 这样的模式可以匹配字符数为 3 的行。与元字符 `*` 配合使用
**使用反斜杠的模式**
与字符串一样，我们也可以使用 +1 个英文字母这样的形式来表示换行、空白等特殊字符。
- `\s`
    表示空白符，匹配空格（0x20）、制表符（Tab）、换行符、换页符
    模式	    | 字符串	    | 匹配部分
    - | - | -
    /ABC\sDEF/	| "ABC DEF"	    | "▶ABC DEF◀"
    /ABC\sDEF/	| "ABC\tDEF"	| "▶ABC\tDEF◀"
    /ABC\sDEF/	| "ABCDEF"  	| （不匹配）
- `\d`
    匹配 0 到 9 的数字
    模式	            | 字符串	        | 匹配部分
    - | - | -
    /\d\d\d-\d\d\d\d/	| "012-3456"	    | "▶012-3456◀"
    /\d\d\d-\d\d\d\d/	| "01234-012345"	| "01▶234-0123◀45"
    /\d\d\d-\d\d\d\d/	| "ABC-DEFG"    	| （不匹配）
    /\d\d\d-\d\d\d\d/	| "012-21"      	| （不匹配）
- `\w`
    匹配英文字母与数字