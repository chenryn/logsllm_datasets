A.1用C#重写HelloWorld示例（库选项和HelloWorld程序）
279
String
msg_body = Encoding.AsCII.GetString(evt_args.Body);
chan.BasicAck(evt_args.DeliveryTag,
false);
4消息确认
if(msg_body =="quit"）{
chan.BasicCancel(consumer_tag);
 msbuild
Microsoft (R) Build Engine Version 4.0.30319.1
[Microsoft .NET Framework, Version 4.0.30319.1]
Copyright (C) Microsoft Corporation 2o07.All rights reserved.
Done Building Project "\HelloWorldConsumer.csproj" ...
Done Building Project "\HelloWorldConsumer.sln" (default targets).
Build succeeded.
0 Warning(s)
0 Error(s)
TimeElapsed00:00:00.17
PS > .\bin\Debug\HelloWorldConsumer.exe 192.168.241.1
现在，在另一个终端上构建生产者并发送一段测试消息：
PS\HelloWorldProducer>msbuild
Microsoft (R) Build Engine Version 4.0.30319.1
[Microsoft .NET Framework, Version 4.0.30319.1]
Copyright (C) Microsoft Corporation 2007. All rights reserved,
Done Building Project "\HelloWorldProducer.sln
"(default targets).
Build succeeded.
0Warning(s)
0 Error(s)
3你可能需要将.NETframework完整路径添加到系统环境变量PATH中。举例来说，用于该示例的测试
系统上的.NETframework路径为C:\Windows\Microsoft.NETFramework\v4.0.30319。
---
## Page 305
A.1用C#重写HelloWorld示例（库选项和HelloWorld程序）
283
PS>.\bin\Debug\HelloWorldProducer.exe192.168.241.1\
"Hellothereworld!"
PS>
EWindows PowerShell
Y:NGitRepositori
11:29AM
11/22/2011
图A.5打开终端，用于测试生产者和消费者
回到消费者终端，消息到达了吗？
PS >.\bin\Debug\HelloWorldConsumer.exe 192.168.241.1
Message Body: Hello there world!
嗯，不错！C#版生产者和消费者可以工作了！由于C#版HelloWorld应用是
由原始Python应用直接演变而来的，因此它们可以互相合作！为了尝试一些跨语言
通信的好处（见图A.6），试试用第2章的hello_world_producer·py向正在运
行的C#版消费者发布一条消息吧！
---
## Page 306
284
附录A在Java和.NET上使用Rabbit
P
S
O
图A.6跨平台的消息通信实战！
现在你掌握了在.NET平台上使用RabbitMQ的基础，让我们快速地把在第4章
编写的告警服务器转换成C#版本吧。
A.2再访告警系统：将告警应用迁移到面向事件
的.NET平台
在学习了C#版的HelloWorld之后，你也许会想我们已经为你讲解了足够多的
RabbitMQ.NET基础，你能在脑子里对本书剩余的例子进行转换了。你答对了90%。
我们没有提到的是如何使用基于事件的方法来消费消息。在Python的客户端Pika上，
所有的消费者均用回调函数（面向事件的）为每一个订阅进行注册，并在之后当订
阅的消息到达时，函数被触发。就像你在C# Hello World 消费者上看到的那样，它
使用QueueingBasicConsumer来管理订阅和消息消费，因此需要的是一个基于
轮询的方法。但是如果你是一位.NET开发人员，并且像我们一样更偏好面向事件
---
## Page 307
A.2再访告警系统：将告警应用迁移到面向事件的.NET平台
285
持面向事件的消费模型。为了演示如何在.NET中使用面向事件的消费接口，我们
将第4章的告警服务器示例转换为C#版本，并展示相关部分。如果要看告警服务
器消费者（以及生产者）的完整C#版本的话，请从伴随本书的示例代码库中检出
这部分代码：https://github.com/rabbitinaction/sourcecode。
在我们开始之前，由于原始的告警示例使用JSON通信，因此你需要选择一
个.NETJSON库。在该示例中，你将使用由James Newton-King编写的JSON.NET 4.0
库：http://json.codeplex.com/。在从Codeplex安装了最新版本之后，请将JSON.NET
库的引用添加到你的项目中（默认的安装路径位于C:\ProgramFiles\JSON.NET\Bin\
Net35)。
在.NET中，转变为面向事件的消费模型的最主要改变在于使用
EventingBasicConsumer 作为消费者对象，而非 QueueingBasicConsumer :
EventingBasicConsumer
C_consumer = new EventingBasicConsumer {Model = chan};
注意，由于EventingBasicConsumer没有定义构造函数，因此你在实例化
的时候将c_consumer的Model属性直接设置引用为信道对象（chan）。为什么说
EventingBasicConsumer是面向事件的原因在于它在内部使用了C#的事件和委
托，并在接收到消费者订阅的消息时，触发一个预定义的回调函数列表。为了将函
数（在本例中为critical_notify）添加到回调函数列表，你需要将它添加到消
费者对象的 Received 属性，然后调用 BasicConsume:
c_consumer.Received += critical_notify;
chan.BasicConsume("critical",
false,
C_consumer) ;
对EventingBasicConsumer回调函数的唯一需求是它的返回值为void，并
且接收IBasicConsumer 和BasicDeliverEventArgs 对象作为参数。让我们看
看C#版本的critical_notify长什么样子。
4不幸的是，RabbitMQ的Java客户端没有可用的面向事件的消费接口。
---
## Page 308
286
附录A在Java和.NET上使用Rabbit
清单A.4Critical通知订阅回调处理函数
private static void critical_notify(IBasicConsumer consumer)
BasicDeliverEventArgs eargs){
1获取消息
string[] EMAIL_RECIPS = new string[]
体和属性
{"PI:EMAIL"};
IBasicProperties msg_props = eargs.BasicProperties;
String msg_body = Encoding.AscII.GetString(eargs.Body);
②使用JSON
msg_body = JsonConvert.Deserializeobject
解码消息体
(msg_body);
send_mail(EMAIL_RECIPS,
"CRITICAL ALERT",
将解码的消
msg_body);
息内容用邮
③件发送
Console.WriteLine("Sent alert via e-mail!Alert Text:"
msg_body +"Recipients:"+
string.Join(",",EMAIL_RECIPS)）;
consumer.Model.BasicAck(eargs.DeliveryTag,
false);