wrap/decrypt attack based on asymmetric keys
sensitive keys are directly readable
unextractable keys are directly readable (forbidden by the standard)
sensitive/unextractable keys can be changed into nonsensitive/extractable
ﬁrst attack found by Tookan
Table 3: Summary of results on devices
The attacker can then decrypt {|k1|}k2 since he knows key k2.
SATMC discovered this variant of the attack on vulnerable
tokens. We note that despite its apparent simplicity, this
attack has not appeared before in the PKCS#11 security
literature [6, 8].
Attack a2 is a variant of the previous ones in which the
wrapping key is a public key pub(z) and the decryption key
is the corresponding private key priv(z):
Wrap:
ADecrypt:
h(n2, pub(z)), h(n1, k1) → {k1}pub(z)
h(n2, priv(z)), {k1}k2 → k1
In this case too, the possibility of importing key pairs simpli-
ﬁes even more the attacker’s task by allowing him to import
a public wrapping key while knowing the corresponding pri-
vate key. Once the wrap of the sensitive key has been per-
formed, the attacker can decrypt the obtained ciphertext
using the private key.
Attack a3 is a clear ﬂaw in the PKCS#11 implementation.
It is explicitly required that the value of sensitive keys should
never be communicated outside the token. In practice, when
the token is asked for the value of a sensitive key, it should
return some “value is sensitive” error code. Instead, we found
that some of the analysed devices just return the plain key
value, ignoring this basic policy. Attack a4 is similar to a3:
PKCS#11 requires that keys declared to be unextractable
should not be readable, even if they are nonsensitive. If they
are in fact readable, this is another violation of PKCS#11
security policy.
Finally, attack a5 refers to the possibility of changing sen-
sitive and unextractable keys respectively into nonsensitive
and extractable ones. Only the Sata and Gemalto SafeSite
Classic V2 tokens allow this operation. However, notice that
this attack is not adding any new ﬂaw for such devices, given
that attacks a3 and a4 are already possible and sensitive or
unextractable keys are already accessible.
4.3 Model-checking results
Column ‘mc’ reports which of the attacks has been auto-
matically rediscovered via model-checking. SATMC termi-
nates once it has found an attack, hence we report the attack
that was found ﬁrst. Run-times for ﬁnding the attacks vary
from a couple of seconds to just over 3 minutes. We evaluate
the performance of the model checker further in section 6.
267Intermediate approaches are in fact possible:
5. FINDING SECURE CONFIGURATIONS
As we noted in the last section, none of the tokens we
tested are able to import and export sensitive keys in a
secure fashion.
In particular, all the analysed tokens are
either insecure or have been drastically restricted in their
functionality, e.g. by completely disabling wrap and un-
wrap.
the
standard can be patched without necessarily removing the
wrapping functionality [9]. In this section, we present Cryp-
tokiX, a software (ﬁXed) implementation of a Cryptoki to-
ken, whose security is conﬁgurable by selectively enabling
diﬀerent patches. As well as providing Tookan with test
data, this proof-of-concept of a secure token has also been
adopted for educational purposes in a security lab class at
the University of Venice, during which students are chal-
lenged to extract a sensitive key from a token which has
only a subset of the patches turned on, so as to be insecure
but not easy to attack [2].
Our starting point is openCryptoki [13], an open-source
PKCS#11 implementation for Linux including a software
token for testing. As shown in Table 3, the analysis of open-
Cryptoki software token has revealed that it is subject to all
the non-trivial attacks. This is in a sense expected, as it im-
plements the standard ‘as is’, i.e., with no security patches.
We have thus extended openCryptoki with:
Conﬂicting attributes. We have seen, for example, that
it is insecure to allow the same key to be used for wrapping
and decrypting. In CryptokiX it is possible to specify a set
of conﬂicting attributes.
Sticky attributes. We know that some attributes should
always be sticky, such as sensitive. This is also useful when
combined with the ‘conﬂicting attributes’ patch above:
if
wrap and decrypt are conﬂicting, we certainly want to avoid
that the wrap attribute can be unset so as to allow the de-
crypt attribute to be set.
Wrapping formats. It has been shown that specifying a
non-conﬂicting attribute policy is not suﬃcient for security
[6, 8]. A wrapping format should also be used to correctly
bind key attributes to the key. This prevents attacks where
the key is unwrapped twice with conﬂicting attributes. Some
existing devices already include such wrapping formats; an
example is the Eracom ProtectServer [9].
Secure templates. We limit the set of admissible attribute
combinations for keys in order to avoid that they ever as-
sume conﬂicting roles at creation time. This is conﬁgurable
at the level of the speciﬁc PKCS#11 operation. For ex-
ample, we can deﬁne diﬀerent secure templates for diﬀerent
operations such as key generation and unwrapping.
A way to combine the ﬁrst three patches with a wrapping
format that binds attributes to keys in order to create a
secure token has already been demonstrated [11]. Here we
show how the fourth patch works, as it is an original idea
for a conﬁguration that has not yet appeared in the liter-
ature. This patch does not require any new cryptographic
mechanisms to be added to the standard, making it quite
simple and cheap to incorporate into existing devices. We
consider here a set of templates with attributes sensitive and
extractable always set. Other attributes wrap, unwrap, en-
crypt and decrypt are set as follows:
Key generation: we allow three possible templates:
2. encrypt and decrypt, for cryptographic operations;
3. neither of the four attributes set, i.e. the default tem-
plate if none of the above is speciﬁed.
Key creation/import: we allow two possible templates
for any key created with CreateObject or imported with
Unwrap:
1. unwrap,encrypt set and wrap,decrypt unset;
2. none of the four attributes set.
The templates for key generation are rather intuitive and
correspond to a clear separation of key roles, which seems
a sound basis for a secure conﬁguration. The rationale be-
hind the single template for key creation/import, however,
is less obvious and might appear rather restrictive. The idea
is to allow wrapping and unwrapping of keys while ‘halving’
the functionality of created/unwrapped keys: these latter
keys can only be used to unwrap other keys or to encrypt
data, wrapping and decrypting under such keys are forbid-
den. This, in a sense, oﬀers an asymmetric usage of imported
keys: to achieve full-duplex encrypted communication two
devices will each have to wrap and send a freshly generated
key to the other device. Once the keys are unwrapped and
imported in the other devices they can be used to encrypt
outgoing data in the two directions. Notice that imported
keys can never be used to wrap sensitive keys. Note also that
we require that all attributes are sticky on and oﬀ, and that
we assume for bootstrapping that any two devices that may
at some point wish to communicate have a shared long term
symmetric key installed on them at personalisation time.
This need only be used once in each direction. Our solution
works well for pairwise communication, where the overhead
is just one extra key, but would be more cumbersome for
group key sharing applications.
We analysed the developed solution by extracting the
model using Tookan. A model for SATMC was constructed
using the abstraction option (see section 3.2). Given the
resulting model, SATMC terminates with no attacks in a
couple of seconds, allowing us to conclude the patch is safe
in our abstract model for unbounded numbers of fresh keys
and handles. Note that although no sensitive keys can be
extracted by an intruder, there is of course no integrity
check on the wrapped keys that are imported. Indeed, with-
out having an encryption mode with an integrity check this
would seem to be impossible. This means that one cannot
be sure that a key imported on to the device really corre-
sponds to a key held securely on the intended receipient’s
device. This limitation would have to be taken into account
when evaluating the suitability of this conﬁguration for an
application. CryptokiX is available online5.
6. CONCLUSION
We conclude by evaluating the state of commercial se-
curity tokens, the performance of Tookan, and lessons for
future key management APIs.
The state of the art in PKCS#11 security tokens seems
rather poor. In our sample of 17 devices, we found 5 tokens
that trivially gave up their sensitive keys in complete disre-
gard of the standard, 3 that were vulnerable to a variety of
1. wrap and unwrap, for exporting/importing other keys;
5http://secgroup.ext.dsi.unive.it/cryptokix
268key separation attacks, and a further smartcard that allowed
unextractable keys to be read in breach of the standard.
The remainder provide no functionality for secure transport
of sensitive keys. We sent vulnerability reports to the man-
ufacturers concerned at least 5 months before publication.
Their responses can be viewed at the project website6.
The tokens we have encountered so far have not provided
much of a challenge for Tookan. At the start of the project,
we hoped to encounter tokens that were patched in an ef-
fort to mitigate the attacks. Instead we found tokens with
simple ﬂaws or minimal functionality. Attacks were found
on all the vulnerable tokens, usually in just a few seconds.
The potential value of the tool is perhaps best indicated by
the work in section 5, where we implement patches on a
software token simulator obtaining a fully featured software
prototype of a secure (at least in our model) token, capable
of wrapping and unwrapping keys. The software token can
be reverse-engineered accurately by our automated frame-
work, indicating that Tookan is ready to analyse more so-
phisticated devices as soon as they become available on the
market. Our software token might be useful as a reference to
develop such next-generation devices. In future work we will
be extending our model to more cryptographic detail. We
would also like to try Tookan on PKCS#11 based devices
currently outside our budgets, such as Hardware Security
Modules (HSMs).
Finally, there are at least two new standards which ad-
dress key management currently at the draft stage: IEEE
1619.37 (for secure storage) and OASIS Key Management In-
teroperability Protocol (KMIP)8. Although neither is aimed
at cryptographic tokens, it is clear there is a move towards
better standards for key management in general. Given the
apparent diﬃculty of constructing a secure interface based
on PKCS#11, this seems a timely intervention. Our conclu-
sions based on the research in this paper are that the new
standards should:
• Specify clearly what security properties an interface
complying to the standard should uphold. Our ex-
perimental evidence suggests that the security goals in
PKCS#11, i.e. protection of sensitive or unextractable
keys, are apparently too well hidden for some imple-
menters to notice. A clear set of security properties
would make life substantially easier for application de-
velopers as well.
• Include a format for key wrapping that securely pre-
serves key metadata (i.e. attributes etc.). This has
already been noted by recent proposals for secure in-
terfaces [4, 7].
• Treat explicitly the problem of key roles, and give guid-
ance to avoid conﬂicting roles. Again this issue has
been treated by recent proposals for APIs in the aca-
demic literature [4, 7].
• Make provision for compliance testing, to weed out
poorly implemented tokens, and make testing results
publicly available.
6http://secgroup.ext.dsi.unive.it/pkcs11-security
7https://siswg.net
8http://www.oasis-open.org/committees/kmip/
7. REFERENCES
[1] A. Armando and L. Compagna. SAT-based
model-checking for security protocols analysis. Int. J.
Inf. Sec., 7(1):3–32, 2008. Software available at
http://www.ai-lab.it/satmc. Currently developed
under the AVANTSSAR project,
http://www.avantssar.eu.
[2] L. Baloci and A. Vianello. Un sistema per lo studio
della sicurezza. Baccalaureate Thesis, University of
Venice, Italy, April 2010.
[3] M. Bond. Attacks on cryptoprocessor transaction sets.
In Proceedings of the 3rd International Workshop on
Cryptographic Hardware and Embedded Systems
(CHES’01), volume 2162 of LNCS, pages 220–234,
Paris, France, 2001. Springer.
[4] C. Cachin and N. Chandran. A secure cryptographic
token interface. In Computer Security Foundations
(CSF-22), pages 141–153, Long Island, New York,
2009. IEEE Computer Society Press.
[5] R. Clayton and M. Bond. Experience using a low-cost
FPGA design to crack DES keys. In Cryptographic
Hardware and Embedded System - CHES 2002, pages
579–592, 2002.
[6] J. Clulow. On the security of PKCS#11. In 5th
International Workshop on Cryptographic Hardware
and Embedded Systems (CHES 2003), pages 411–425,
2003.
[7] V. Cortier and G. Steel. A generic security API for
symmetric key management on cryptographic devices.
In M. Backes and P. Ning, editors, Proceedings of the
14th European Symposium on Research in Computer
Security (ESORICS’09), volume 5789 of Lecture Notes
in Computer Science, pages 605–620, Saint Malo,
France, Sept. 2009. Springer.
[8] S. Delaune, S. Kremer, and G. Steel. Formal analysis
of PKCS#11. In Proceedings of the 21st IEEE
Computer Security Foundations Symposium (CSF’08),
pages 331–344, Pittsburgh, PA, USA, June 2008.
IEEE Computer Society Press.
[9] S. Delaune, S. Kremer, and G. Steel. Formal analysis
of PKCS#11 and proprietary extensions. Journal of
Computer Security, 2009. To appear.
[10] D. Dolev and A. Yao. On the security of public key
protocols. IEEE Transactions in Information Theory,
2(29):198–208, March 1983.
[11] S. Fr¨oschle and G. Steel. Analysing PKCS#11 key
management APIs with unbounded fresh data. In
P. Degano and L. Vigan`o, editors, Revised Selected
Papaers of the Joint Workshop on Automated
Reasoning for Security Protocol Analysis and Issues in
the Theory of Security (ARSPA-WITS’09), volume
5511 of Lecture Notes in Computer Science, pages
92–106, York, UK, Aug. 2009. Springer.
[12] D. Longley and S. Rigby. An automatic search for
security ﬂaws in key management schemes. Computers
and Security, 11(1):75–89, March 1992.
[13] openCryptoki.
http://sourceforge.net/projects/opencryptoki/.
[14] RSA Security Inc., v2.20. PKCS #11: Cryptographic
Token Interface Standard., June 2004.
269