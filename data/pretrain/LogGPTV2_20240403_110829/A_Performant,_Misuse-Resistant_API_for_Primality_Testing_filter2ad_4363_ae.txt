Richard Crandall and Carl Pomerance. Prime numbers: a computational
perspective, volume 182. Springer Science & Business Media, 2006. pp.136-
140.
[CP06]
[DLP93]
Ivan Damg˚ard, Peter Landrock, and Carl Pomerance. Average case error
estimates for the strong probable prime test. Mathematics of Computation,
61(203):177–194, 1993.
[EBFK13] Manuel Egele, David Brumley, Yanick Fratantonio, and Christopher Kruegel.
An empirical study of cryptographic misuse in Android applications. In
Sadeghi et al. [SGY13], pages 73–84.
[FGMP15] Marc Fischlin, Felix G¨unther, Giorgia Azzurra Marson, and Kenneth G.
Paterson. Data is a stream: Security of stream-based channels. In Rosario
Gennaro and Matthew J. B. Robshaw, editors, CRYPTO 2015, Part II,
volume 9216 of LNCS, pages 545–564. Springer, Heidelberg, August 2015.
[FHP+13] Sascha Fahl, Marian Harbach, Henning Perl, Markus Koetter, and Matthew
Smith. Rethinking SSL development in an appiﬁed world. In Sadeghi et al.
[SGY13], pages 49–60.
[GLL17]
[GMP19]
[GIW+18] Peter Leo Gorski, Luigi Lo Iacono, Dominik Wermke, Christian Stransky,
Sebastian M¨oller, Yasemin Acar, and Sascha Fahl. Developers deserve
security warnings, too: On the eﬀect of integrated security advice on cryp-
tographic API misuse. In Mary Ellen Zurko and Heather Richter Lipford,
editors, Fourteenth Symposium on Usable Privacy and Security, SOUPS
2018, Baltimore, MD, USA, August 12-14, 2018., pages 265–281. USENIX
Association, 2018.
Shay Gueron, Adam Langley, and Yehuda Lindell. AES-GCM-SIV: speciﬁ-
cation and analysis. IACR Cryptology ePrint Archive, 2017:168, 2017.
Steven D. Galbraith, Jake Massimo, and Kenneth G. Paterson. Safety in
numbers: On the need for robust diﬃe-hellman parameter validation. In
Dongdai Lin and Kazue Sako, editors, PKC 2019, Part II, volume 11443 of
LNCS, pages 379–407. Springer, Heidelberg, April 2019.
Matthew Green and Matthew Smith. Developers are not the enemy!: The
need for usable security APIs. IEEE Security & Privacy, 14(5):40–46, 2016.
Peter Gutmann. Lessons learned in implementing and deploying crypto
software. In Dan Boneh, editor, Proceedings of the 11th USENIX Security
Symposium, San Francisco, CA, USA, August 5-9, 2002, pages 315–325.
USENIX, 2002.
Achim Jung. Implementing the RSA cryptosystem. Computers & Security,
6(4):342–350, 1987.
[GS16]
[Gut02]
[Jun87]
[KSD13] Cameron F. Kerry, Acting Secretary, and Charles Romine Director. FIPS
PUB 186-4 FEDERAL INFORMATION PROCESSING STANDARDS
PUBLICATION Digital Signature Standard (DSS), 2013.
[LCWZ14] David Lazar, Haogang Chen, Xi Wang, and Nickolai Zeldovich. Why does
cryptographic software fail?: A case study and open problems. In Asia-
Paciﬁc Workshop on Systems, APSys’14, Beijing, China, June 25-26, 2014,
pages 7:1–7:7. ACM, 2014.
[LMBW18] David Lie, Mohammad Mannan, Michael Backes, and XiaoFeng Wang,
[Mau95]
[Mil75]
[Mon92]
editors. ACM CCS 2018. ACM Press, October 2018.
Ueli M. Maurer. Fast generation of prime numbers and secure public-key
cryptographic parameters. Journal of Cryptology, 8(3):123–155, September
1995.
Gary L Miller. Riemann’s hypothesis and tests for primality. In Proceedings
of seventh annual ACM symposium on Theory of computing, pages 234–239.
ACM, 1975.
Peter L. Montgomery.
f (Xm, Xn, Xm−n) via Lucas chains. Unpublished manuscript, 1992.
Evaluating recurrences of
form Xm+n =
[MVOV96] Alfred J Menezes, Paul C Van Oorschot, and Scott A Vanstone. Handbook
of Applied Cryptography. CRC press, 1996.
[NDT+17] Alena Naiakshina, Anastasia Danilova, Christian Tiefenau, Marco Herzog,
Sergej Dechand, and Matthew Smith. Why do developers get password
storage wrong?: A qualitative usability study. In Bhavani M. Thuraisingham,
David Evans, Tal Malkin, and Dongyan Xu, editors, ACM CCS 2017, pages
311–328. ACM Press, October / November 2017.
[NKMB17] Sarah Nadi, Stefan Kr¨uger, Mira Mezini, and Eric Bodden. “Jumping
Through Hoops”: Why do java developers struggle with cryptography APIs?
In Jan J¨urjens and Kurt Schneider, editors, Software Engineering 2017,
Fachtagung des GI-Fachbereichs Softwaretechnik, 21.-24. Februar 2017,
Hannover, Deutschland, volume P-267 of LNI, page 57. GI, 2017.
Carl Pomerance. Are there counter-examples to the Baillie-PSW primality
test? Dopo Le Parole aangeboden aan Dr. A. K. Lenstra., 1984.
Christopher Patton and Thomas Shrimpton. Partially speciﬁed channels:
The TLS 1.3 record layer without elision. In Lie et al. [LMBW18], pages
1415–1428.
to 25 · 109. Mathematics of Computation, 35(151):1003–1026, 1980.
[PSW80] Carl Pomerance, John L Selfridge, and Samuel S Wagstaﬀ. The pseudoprimes
[Pom84]
[PS18]
[Rab80] Michael O Rabin. Probabilistic algorithm for testing primality. Journal of
[Rog04]
[RS06]
number theory, 12(1):128–138, 1980.
Phillip Rogaway. Nonce-based symmetric encryption. In Bimal K. Roy
and Willi Meier, editors, FSE 2004, volume 3017 of LNCS, pages 348–359.
Springer, Heidelberg, February 2004.
Phillip Rogaway and Thomas Shrimpton. A provable-security treatment
of the key-wrap problem. In Serge Vaudenay, editor, EUROCRYPT 2006,
volume 4004 of LNCS, pages 373–390. Springer, Heidelberg, May / June
2006.
[SGY13] Ahmad-Reza Sadeghi, Virgil D. Gligor, and Moti Yung, editors. ACM CCS
2013. ACM Press, November 2013.
[WvO08] Glenn Wurster and Paul C. van Oorschot. The developer is the enemy.
In Matt Bishop, Christian W. Probst, Angelos D. Keromytis, and Anil
Somayaji, editors, Proceedings of the 2008 Workshop on New Security
Paradigms, Lake Tahoe, CA, USA, September 22-25, 2008, pages 89–97.
ACM, 2008.
A Cost Model for Prime Generation
Sieving can be recast as a one-time trial division of the ﬁrst candidate n with the
ﬁrst s odd primes (OpenSSL uses s = 2047), followed by per candidate updating
of a table of remainders. We assume the latter can be done essentially for free
compared to other operations and ignore its cost henceforth. Then the average
cost of primality generation when the underlying primality test uses up to t
rounds of MR testing but no trial division, is given by:
(cid:32) s(cid:88)
(cid:33)
Ci
+(cid:0)ln(2k) · (1 − σs)/2(cid:1) · CM R + (t − 1) · CM R.
(5)
i=1
Here the ﬁrst term comes from sieving. The second term comes from, on average,
inspecting ln(2k) · (1 − σs)/2 odd, composite candidates in the sieved version of
the list n, n + 2, n + 4, . . . before encountering a prime, and doing 1 MR test to
reject each composite (recall that, because of sieving, the density of primes in the
list n, n + 2, n + 4, . . . is boosted by a factor 1/(1 − σs); recall also that almost
every random composite is rejected with just 1 MR test). The third term comes
from doing a further t − 1 MR tests when a prime is ﬁnally found. To model
OpenSSL’s performance, we would set t according to Table 1.
It should be evident from expression (5) that, as with trial division, working
with large s in the initial sieve is not proﬁtable: eventually, the gains made
from decreasing the term 1 − σs are outweighed by the cost of initial sieving by
trial division. Moreover, this model neglects the true cost of updating the table
of remainders between candidates. This cost is linear in s (albeit with a small
constant) and so heightens the eﬀect. A more detailed model including this cost
could of course be developed.
If we now assume that (redundant) trial division with r ≤ s primes is also
carried out in the underlying primality test, and that the test uses up to t(cid:48) rounds
of MR testing, then the average cost becomes:
(cid:32) s(cid:88)
(cid:33)
Ci
+(cid:0)ln(2k) · (1 − σs)/2(cid:1) · ((
r(cid:88)
Ci) + CM R) + (t(cid:48) − 1) · CM R
(6)
i=1
i=1
Here, the additional cost compared to (5) is precisely that of doing a full set of
r trial divisions for each candidate – this cost is always incurred because when
r ≤ s, all the candidates which might fail trial division at some early stage have
already failed on sieving. To model the performance of OpenSSL with our chosen
primality test, MR64, t(cid:48) must be set to 64 rather than the values in Table 1; the
diﬀerence means that, when a prime is ﬁnally encountered, the cost of testing it
will be higher.
The diﬀerence in the costs as expressed in (5) and (6) is given by:
r(cid:88)
(cid:0)ln(2k) · (1 − σs)/2(cid:1) · (
i=1
Ci) + δt · CM R
(7)
where δt = t(cid:48) − t, depending on k, is the diﬀerence in the maximum number of
rounds of MR testing carried out in the two cases.
For MR64 and MRAC, and for k of cryptographic size, δt ranges between 59
and 61. For our selected primality test, MR64 with input-length-dependent trial
division, r in the above expression is also k-dependent, and is set by Table 4. The
ﬁrst term in (7) accounts for the cost of redundant trial division over the ﬁrst
r primes for N := ln(2k) · (1 − σs)/2 diﬀerent candidates. Here both r and N
are in the range of a few hundred. For example, when k = 1024 we set r = 128,
and when s = 2047, we have N ≈ 41. Hence, when k = 1024, we do about 5200
redundant trial divisions, compared to an extra δt = 59 MR tests. For this k,
the extra MR tests are about 8 times more expensive than the redundant trial
divisions (roughly 17.5ms versus 2ms based on our experimental timings). This
indicates that the redundant trial division contributes much less to the overhead
of prime generation than do the extra MR tests that are necessary to make our
primality test secure in all use cases.
Note that this analysis ignores the fact that OpenSSL aborts and restarts with
a fresh, random value whenever an MR test fails; this eﬀect may be signiﬁcant
in practice and we leave a detailed evaluation to future work. Note also that
this modelling deﬁciency does not aﬀect our experimental results reported in
the main body, since they were obtained by measuring the running time of the
actual OpenSSL code.
B Reference Implementation of the Baillie-PSW test
For completeness, we include here our code that implements a Baillie-PSW
primality test in the context of OpenSSL’s bn prime.c. Functions from the
existing OpenSSL code-base have been omitted.
bn prime bpsw.c
int B N _ i s _ p r i m e _ B P S W _ e x ( BIGNUM *a , BN_CTX * ctx_passed ,
int d o _ t r i a l _ d i v i s i o n , B N _ G E N C B * cb )
{
int i , j , l , ret = -1;
int k ;
BN_CTX * ctx = NULL ;
BIGNUM * A1 , * A1_odd , * check = BN_new (); /* taken from ctx */
B N _ M O N T _ C T X * mont = NULL ;
T R I A L _ D I V I S I O N _ P R I M E S = 129;
B N _ s e t _ w o r d ( check , 2); // only testing MR to base 2
/* Take care of the really small primes 2 & 3 */
if ( B N _ i s _ w o r d (a , 2) || B N _ i s _ w o r d (a , 3))
return 1;
/* Check odd and bigger than 1 */
if (! B N _ i s _ o d d ( a ) || BN_cmp (a , B N _ v a l u e _ o n e ())  2
if ( BN_cmp ( two , n )==1) { // 1 if a > b i . e b < a
BN_free ( two );
return 0;
}
if ( BN_cmp (n , two )==0) {
BN_free ( two );
return 1;
}