### References

- **[CP06]** Richard Crandall and Carl Pomerance. *Prime Numbers: A Computational Perspective*, Volume 182. Springer Science & Business Media, 2006. pp. 136-140.
- **[DLP93]** Ivan Damgård, Peter Landrock, and Carl Pomerance. "Average Case Error Estimates for the Strong Probable Prime Test." *Mathematics of Computation*, 61(203):177–194, 1993.
- **[EBFK13]** Manuel Egele, David Brumley, Yanick Fratantonio, and Christopher Kruegel. "An Empirical Study of Cryptographic Misuse in Android Applications." In Sadeghi et al. [SGY13], pages 73–84.
- **[FGMP15]** Marc Fischlin, Felix Günther, Giorgia Azzurra Marson, and Kenneth G. Paterson. "Data is a Stream: Security of Stream-Based Channels." In Rosario Gennaro and Matthew J. B. Robshaw (eds.), *CRYPTO 2015, Part II*, LNCS 9216, pages 545–564. Springer, Heidelberg, August 2015.
- **[FHP+13]** Sascha Fahl, Marian Harbach, Henning Perl, Markus Koetter, and Matthew Smith. "Rethinking SSL Development in an Appified World." In Sadeghi et al. [SGY13], pages 49–60.
- **[GIW+18]** Peter Leo Gorski, Luigi Lo Iacono, Dominik Wermke, Christian Stransky, Sebastian Möller, Yasemin Acar, and Sascha Fahl. "Developers Deserve Security Warnings, Too: On the Effect of Integrated Security Advice on Cryptographic API Misuse." In Mary Ellen Zurko and Heather Richter Lipford (eds.), *Fourteenth Symposium on Usable Privacy and Security, SOUPS 2018*, Baltimore, MD, USA, August 12-14, 2018, pages 265–281. USENIX Association, 2018.
- **[GLL17]** Shay Gueron, Adam Langley, and Yehuda Lindell. "AES-GCM-SIV: Specification and Analysis." *IACR Cryptology ePrint Archive*, 2017:168, 2017.
- **[GMP19]** Steven D. Galbraith, Jake Massimo, and Kenneth G. Paterson. "Safety in Numbers: On the Need for Robust Diffie-Hellman Parameter Validation." In Dongdai Lin and Kazue Sako (eds.), *PKC 2019, Part II*, LNCS 11443, pages 379–407. Springer, Heidelberg, April 2019.
- **[GS16]** Matthew Green and Matthew Smith. "Developers Are Not the Enemy!: The Need for Usable Security APIs." *IEEE Security & Privacy*, 14(5):40–46, 2016.
- **[Gut02]** Peter Gutmann. "Lessons Learned in Implementing and Deploying Crypto Software." In Dan Boneh (ed.), *Proceedings of the 11th USENIX Security Symposium*, San Francisco, CA, USA, August 5-9, 2002, pages 315–325. USENIX, 2002.
- **[Jun87]** Achim Jung. "Implementing the RSA Cryptosystem." *Computers & Security*, 6(4):342–350, 1987.
- **[KSD13]** Cameron F. Kerry, Acting Secretary, and Charles Romine Director. *FIPS PUB 186-4: Federal Information Processing Standards Publication Digital Signature Standard (DSS)*, 2013.
- **[LCWZ14]** David Lazar, Haogang Chen, Xi Wang, and Nickolai Zeldovich. "Why Does Cryptographic Software Fail?: A Case Study and Open Problems." In *Asia-Pacific Workshop on Systems, APSys'14*, Beijing, China, June 25-26, 2014, pages 7:1–7:7. ACM, 2014.
- **[LMBW18]** David Lie, Mohammad Mannan, Michael Backes, and XiaoFeng Wang (eds.). *ACM CCS 2018*. ACM Press, October 2018.
- **[Mau95]** Ueli M. Maurer. "Fast Generation of Prime Numbers and Secure Public-Key Cryptographic Parameters." *Journal of Cryptology*, 8(3):123–155, September 1995.
- **[Mil75]** Gary L. Miller. "Riemann's Hypothesis and Tests for Primality." In *Proceedings of Seventh Annual ACM Symposium on Theory of Computing*, pages 234–239. ACM, 1975.
- **[Mon92]** Peter L. Montgomery. "Evaluating Recurrences of Form \(X_{m+n} = f(X_m, X_n, X_{m-n})\) via Lucas Chains." Unpublished manuscript, 1992.
- **[MVOV96]** Alfred J. Menezes, Paul C. van Oorschot, and Scott A. Vanstone. *Handbook of Applied Cryptography*. CRC Press, 1996.
- **[NDT+17]** Alena Naiakshina, Anastasia Danilova, Christian Tiefenau, Marco Herzog, Sergej Dechand, and Matthew Smith. "Why Do Developers Get Password Storage Wrong?: A Qualitative Usability Study." In Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu (eds.), *ACM CCS 2017*, pages 311–328. ACM Press, October / November 2017.
- **[NKMB17]** Sarah Nadi, Stefan Krüger, Mira Mezini, and Eric Bodden. "Jumping Through Hoops: Why Do Java Developers Struggle with Cryptography APIs?" In Jan Jürjens and Kurt Schneider (eds.), *Software Engineering 2017, Fachtagung des GI-Fachbereichs Softwaretechnik, 21.-24. Februar 2017, Hannover, Deutschland*, LNI P-267, page 57. GI, 2017.
- **[Pom84]** Carl Pomerance. "Are There Counter-Examples to the Baillie-PSW Primality Test?" *Dopo Le Parole aangeboden aan Dr. A. K. Lenstra*, 1984.
- **[PS18]** Christopher Patton and Thomas Shrimpton. "Partially Specified Channels: The TLS 1.3 Record Layer Without Elision." In Lie et al. [LMBW18], pages 1415–1428.
- **[PSW80]** Carl Pomerance, John L. Selfridge, and Samuel S. Wagstaff. "The Pseudoprimes to \(25 \times 10^9\)." *Mathematics of Computation*, 35(151):1003–1026, 1980.
- **[Rab80]** Michael O. Rabin. "Probabilistic Algorithm for Testing Primality." *Journal of Number Theory*, 12(1):128–138, 1980.
- **[Rog04]** Phillip Rogaway. "Nonce-Based Symmetric Encryption." In Bimal K. Roy and Willi Meier (eds.), *FSE 2004*, LNCS 3017, pages 348–359. Springer, Heidelberg, February 2004.
- **[RS06]** Phillip Rogaway and Thomas Shrimpton. "A Provable-Security Treatment of the Key-Wrap Problem." In Serge Vaudenay (ed.), *EUROCRYPT 2006*, LNCS 4004, pages 373–390. Springer, Heidelberg, May / June 2006.
- **[SGY13]** Ahmad-Reza Sadeghi, Virgil D. Gligor, and Moti Yung (eds.). *ACM CCS 2013*. ACM Press, November 2013.
- **[WvO08]** Glenn Wurster and Paul C. van Oorschot. "The Developer Is the Enemy." In Matt Bishop, Christian W. Probst, Angelos D. Keromytis, and Anil Somayaji (eds.), *Proceedings of the 2008 Workshop on New Security Paradigms, Lake Tahoe, CA, USA, September 22-25, 2008*, pages 89–97. ACM, 2008.

### A Cost Model for Prime Generation

Sieving can be recast as a one-time trial division of the first candidate \( n \) with the first \( s \) odd primes (OpenSSL uses \( s = 2047 \)), followed by per-candidate updating of a table of remainders. We assume the latter can be done essentially for free compared to other operations and ignore its cost henceforth. Then, the average cost of primality generation when the underlying primality test uses up to \( t \) rounds of MR testing but no trial division, is given by:

\[
\sum_{i=1}^{s} C_i + \left(\ln(2k) \cdot \frac{1 - \sigma_s}{2}\right) \cdot C_{MR} + (t - 1) \cdot C_{MR}
\]

Here, the first term comes from sieving. The second term comes from, on average, inspecting \(\ln(2k) \cdot \frac{1 - \sigma_s}{2}\) odd, composite candidates in the sieved version of the list \( n, n + 2, n + 4, \ldots \) before encountering a prime, and doing 1 MR test to reject each composite (recall that, because of sieving, the density of primes in the list \( n, n + 2, n + 4, \ldots \) is boosted by a factor \(\frac{1}{1 - \sigma_s}\); recall also that almost every random composite is rejected with just 1 MR test). The third term comes from doing a further \( t - 1 \) MR tests when a prime is finally found. To model OpenSSL’s performance, we would set \( t \) according to Table 1.

It should be evident from the expression above that, as with trial division, working with large \( s \) in the initial sieve is not profitable: eventually, the gains made from decreasing the term \( 1 - \sigma_s \) are outweighed by the cost of initial sieving by trial division. Moreover, this model neglects the true cost of updating the table of remainders between candidates. This cost is linear in \( s \) (albeit with a small constant) and so heightens the effect. A more detailed model including this cost could, of course, be developed.

If we now assume that (redundant) trial division with \( r \leq s \) primes is also carried out in the underlying primality test, and that the test uses up to \( t' \) rounds of MR testing, then the average cost becomes:

\[
\sum_{i=1}^{s} C_i + \left(\ln(2k) \cdot \frac{1 - \sigma_s}{2}\right) \cdot \left(\sum_{i=1}^{r} C_i + C_{MR}\right) + (t' - 1) \cdot C_{MR}
\]

Here, the additional cost compared to the previous expression is precisely that of doing a full set of \( r \) trial divisions for each candidate – this cost is always incurred because when \( r \leq s \), all the candidates which might fail trial division at some early stage have already failed on sieving. To model the performance of OpenSSL with our chosen primality test, MR64, \( t' \) must be set to 64 rather than the values in Table 1; the difference means that, when a prime is finally encountered, the cost of testing it will be higher.

The difference in the costs as expressed in the two expressions is given by:

\[
\left(\ln(2k) \cdot \frac{1 - \sigma_s}{2}\right) \cdot \sum_{i=1}^{r} C_i + \delta_t \cdot C_{MR}
\]

where \(\delta_t = t' - t\), depending on \( k \), is the difference in the maximum number of rounds of MR testing carried out in the two cases.

For MR64 and MRAC, and for \( k \) of cryptographic size, \(\delta_t\) ranges between 59 and 61. For our selected primality test, MR64 with input-length-dependent trial division, \( r \) in the above expression is also \( k \)-dependent, and is set by Table 4. The first term in the expression accounts for the cost of redundant trial division over the first \( r \) primes for \( N := \ln(2k) \cdot \frac{1 - \sigma_s}{2} \) different candidates. Here both \( r \) and \( N \) are in the range of a few hundred. For example, when \( k = 1024 \), we set \( r = 128 \), and when \( s = 2047 \), we have \( N \approx 41 \). Hence, when \( k = 1024 \), we do about 5200 redundant trial divisions, compared to an extra \(\delta_t = 59\) MR tests. For this \( k \), the extra MR tests are about 8 times more expensive than the redundant trial divisions (roughly 17.5 ms versus 2 ms based on our experimental timings). This indicates that the redundant trial division contributes much less to the overhead of prime generation than do the extra MR tests that are necessary to make our primality test secure in all use cases.

Note that this analysis ignores the fact that OpenSSL aborts and restarts with a fresh, random value whenever an MR test fails; this effect may be significant in practice and we leave a detailed evaluation to future work. Note also that this modeling deficiency does not affect our experimental results reported in the main body, since they were obtained by measuring the running time of the actual OpenSSL code.

### B. Reference Implementation of the Baillie-PSW Test

For completeness, we include here our code that implements a Baillie-PSW primality test in the context of OpenSSL’s `bn_prime.c`. Functions from the existing OpenSSL code-base have been omitted.

```c
// bn_prime_bpsw.c
int BN_is_prime_BPSW_ex(BIGNUM *a, BN_CTX *ctx_passed, int do_trial_division, BN_GENCB *cb) {
    int i, j, l, ret = -1;
    int k;
    BN_CTX *ctx = NULL;
    BIGNUM *A1, *A1_odd, *check = BN_new(); /* taken from ctx */
    BN_MONT_CTX *mont = NULL;
    TRIAL_DIVISION_PRIMES = 129;
    BN_set_word(check, 2); // only testing MR to base 2

    /* Take care of the really small primes 2 & 3 */
    if (BN_is_word(a, 2) || BN_is_word(a, 3))
        return 1;

    /* Check odd and bigger than 1 */
    if (!BN_is_odd(a) || BN_cmp(a, BN_value_one()) <= 0)
        return 0;

    // Additional implementation details and checks go here
}
```

This code snippet provides a basic structure for implementing the Baillie-PSW primality test within the OpenSSL framework. Further details and additional checks would be required for a complete and robust implementation.