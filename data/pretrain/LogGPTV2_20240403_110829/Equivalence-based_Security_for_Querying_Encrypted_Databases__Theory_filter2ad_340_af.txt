χI ⊢ ∀~x. (g → ϕ) : δg ∪ δc
Univ
The ﬁrst premise of UNIV checks that we have only a ﬁnite
number of substitutions for ~x that satisfy g with respect
to χI and with equality scheme δg. This is necessary for
termination of ereduce. The second and third premises
check that g yields concrete substitutions for all quantiﬁed
variables ~x and its own free variables. The last premise
checks that ϕ is well-moded.
8.
IMPLEMENTATION AND EVALUATION
We have implemented EunomiaDET, EunomiaKH, ereduceDET
and ereduceKH using OpenSSL version 1.0.1e. For deter-
Figure 4: Experimental results on HIPAA policies
ministic encryption, we use AES with a variation of the
CMC mode [22] with a ﬁxed IV and a 16-byte block size.
We use 256-bit keys. For the AKH scheme, we use the li-
brary by Popa et al. [34]. The underlying elliptic curve is
the NIST-approved NID X9 62 prime192v1.
We report our empirical evaluation of ereduceDET and
ereduceKH. We run experiments on a 2.67GHz Intel Xeon
X5650 CPU with Debian Linux 7.6 and 50GB of RAM,
of which no more than 3.0 GB is used in any experiment.
SQLite version 3.8.7.1 is used to store the plaintext and en-
crypted logs. We aggressively index all database columns in
input argument positions. In EunomiaDET, the index is built
over deterministically encrypted values; in EunomiaKH, the
index is built over hashed values. We use privacy policies
derived from the GLBA and HIPAA privacy rules and cover
4 and 13 representative clauses of these rules, respectively.
We use synthetically generated plaintext audit logs. Given
an input policy and a desired number of privacy sensitive ac-
tions, our audit log generation algorithm randomly decides
whether each action will be policy compliant or not. To gen-
erate log entries for a compliant action, the algorithm tra-
verses the abstract syntax tree of the policy and generates
instances of atoms that together satisfy the policy. For the
non-compliant actions, we randomly choose atoms to falsify
a necessary condition. Our synthetic log generator also out-
puts the mOPED data structure but with plaintext values
for timestamps. We generate logs containing between 2000
and 14000 privacy-sensitive actions. Each plaintext log is
separately encrypted with the EunomiaDET and EunomiaKH
schemes. The maximum plaintext audit log size we consid-
ered is 17 MB. The corresponding maximum encrypted log
sizes in EunomiaDET and EunomiaKH are 67.3MB and 267MB,
respectively. Most of the size overhead of the EunomiaKH-
encrypted log comes from the keyed hashes.
We measure the relative overhead of running ereduce on
logs encrypted with EunomiaDET and EunomiaKH, choosing
reduce on plaintext audit log as the baseline. We exper-
iment with both RAM-backed and disk-backed versions of
SQLite. We report here only the memory-backed results (the
disk-backed results are similar). Figure 4 shows the average
1141execution time per privacy-sensitive action for the HIPAA
policy in all three conﬁgurations (GLBA results are similar).
The number of privacy-sensitive actions (and, hence, the log
size) varies on the x-axis. The overhead of EunomiaDET is
very low, between 3% and 9%. This is unsurprising, because
no cryptographic operations are needed during audit. The
overhead comes from the need to read and compare longer
(encrypted) ﬁelds in the log and from having to use the
mOPED data structure. With EunomiaKH, overheads are
much higher, ranging from 63% to 406%. These overheads
come entirely from two sources: the cost of reading a much
larger database and the cost of performing hash adjustments
to check equality of values in diﬀerent columns. We observe
that the overhead due to the increased database size is more
than that due to hash adjustment. For the policies we exper-
imented with, the per-action overhead due to database size
grows linearly, but the overhead due to hash adjustments is
relatively constant. About 30% of ereduce’s overhead when
running on EunomiaKH comes from key-adjustments. Hence,
there is room for substantial improvement by caching previ-
ous key-adjustments, which we do not do currently.
9. RELATED WORK
Functional and predicate encryption. Functional en-
cryption [13, 20, 27, 30] allows the declassiﬁcation of any
stipulated function of data, given only the ciphertext of the
data and a decryption key. Functional encryption can be
used to implement audit over encrypted logs: The declas-
siﬁcation function can perform the audit and return the
outcome. However, existing functional encryption schemes
are not eﬃcient enough to be practically usable for audit.
Property-preserving encryption [31] and predicate encryp-
tion [38, 14, 24] are a special case of functional encryption
where the function returns a boolean value. Predicate en-
cryption can also be used to implement audit when the goal
is only to ﬁnd whether or not there is a violation (which is
a boolean outcome). However, this is usually insuﬃcient for
audit in practice. Pandey and Rouselakis [31] describe sev-
eral notions of security for symmetric predicate encryption.
Our security deﬁnition IND-CPLADET (resp., IND-CPLAKH)
is inspired by their LoR security deﬁnition.
Searchable audit log. Waters et al. [41] present a frame-
work for log conﬁdentiality and integrity with the ability
to search based on keywords. They use hash chains for
integrity and identity-based encryption [12] with extracted
keywords to provide conﬁdentiality and search [11]. In our
work, we consider conﬁdentiality of the data, but not in-
tegrity. Complementary techniques can ensure integrity of
the audit log [36, 37, 25, 23]. Our framework supports more
expressive policies than that of Waters et al. Additionally,
audit requires timestamp comparison, which their frame-
work does not support.
Order-preserving encryption. A symmetric encryption
scheme that maintains the order of the plaintext data is pro-
posed by Boldyreva et al. [10]. This scheme does not satisfy
the ideal IND-OCPA security deﬁnition. Popa et al. present
the mOPE scheme, which we enhance to support timestamp
comparison with displacements [33]. Recently, Kerschbaum
and Schr¨opfer present a keyless order-preserving encryption
scheme for outsourced data [26].
In their approach, the
owner of the plaintext data must keep a dictionary map-
ping plaintexts to ciphertexts, which would be undesirable
in our setting, where the objective is to outsource storage to
a cloud.
Querying outsourced database. Hacig¨um¨u¸s et al. [21]
develop a system that allows querying over encrypted data
by asking the client to decrypt data. In contrast, our schemes
require no interaction with the client for read-only queries.
Tu et al. [40] introduce split client/server query execution
for processing analytical queries on encrypted databases.
Our schemes do not require any query processing on the
client-side. Damiani et al.
[17] develop a secure indexing
approach for querying an encrypted database. In contrast,
we do not require modiﬁcation to the indexing algorithm of
the DBMS.
CryptDB [34] uses a trusted proxy to dynamically choose
an encryption scheme for each database column, based on
the query operations being performed on the column. More-
over, CryptDB does not provide a complete, rigorous char-
acterization of its conﬁdentiality properties, which we do.
However, CryptDB supports all SQL queries, whereas we
cannot support aggregation queries.
Privacy policy compliance checking. Prior work on
logic-based compliance checking algorithms focuses on plain-
text logs [8, 7, 9, 16, 19]. In particular, this paper adapts
our prior work [19] to execute on encrypted logs. The key
addition is the EQ mode check, which provides additional
information about predicate arguments that may be com-
pared for equality during the audit of a policy.
10. SUMMARY
In this paper, we have presented two database encryp-
tion schemes, EunomiaDET and EunomiaKH, that reveal just
enough information to allow projection, selection, join, com-
parison and displaced comparison queries. We present a
novel deﬁnition of database equivalence, which character-
izes the conﬁdentiality properties provided by our schemes.
We prove that our schemes are secure. As a concrete ap-
plication, we show how to execute audit for privacy policy
violations over logs that have been encrypted using either of
our schemes. This requires a new static analysis of policies,
which tracks pairs of columns that may be joined during
audit.
Acknowledgements. This work was partially supported
by the NSF grants CNS 1064688, CNS 1116991, CNS 1314688,
and CCF 042442 and the AFOSR MURI grant FA9550-11-1-
0137. The authors thank the anonymous reviewers for their
helpful comments.
11. REFERENCES
[1] Health Insurance Portability and Accountability Act,
1996. U.S. Public Law 104-191.
[2] Gramm-Leach-Bliley Act, 1999. U.S. Public Law
106-102.
[3] H. Andr´eka, I. N´emeti, and J. van Benthem. Modal
languages and bounded fragments of predicate logic.
Journal of Philosophical Logic, 27(3):217–274, 1998.
1142[4] K. Apt and E. Marchiori. Reasoning about prolog
programs: From modes through types to assertions.
Formal Aspects of Computing, 1994.
[5] A. Askarov and A. Sabelfeld. Gradual release:
Unifying declassiﬁcation, encryption, and key release
policies. In IEEE S&P, 2007.
[6] S. Bajaj and R. Sion. Trusteddb: A trusted hardware
based database with privacy and data conﬁdentiality.
In SIGMOD, 2011.
[7] D. Basin, F. Klaedtke, S. Marinovic, and E. Zalinescu.
Monitoring of temporal ﬁrst-order properties with
aggregations. In RV, 2013.
equations, and inner products. In EUROCRYPT,
2008.
[25] J. Kelsey and B. Schneier. Minimizing bandwidth for
remote access to cryptographically protected audit
logs. In Recent Advances in Intrusion Detection, 1999.
[26] F. Kerschbaum and A. Schroepfer. Optimal
average-complexity ideal-security order-preserving
encryption. In CCS, 2014.
[27] A. Lewko, T. Okamoto, A. Sahai, K. Takashima, and
B. Waters. Fully secure functional encryption:
Attribute-based encryption and (hierarchical) inner
product encryption. In EUROCRYPT, 2010.
[8] D. Basin, F. Klaedtke, S. Marinovic, and E. Z˘alinescu.
[28] M. Naveed, S. Kamara, and C. V. Wright. Inference
Monitoring compliance policies over incomplete and
disagreeing logs. In RV, 2012.
[9] A. Bauer, J.-C. K¨uster, and G. Vegliach. From
propositional to ﬁrst-order monitoring. In RV. 2013.
[10] A. Boldyreva, N. Chenette, Y. Lee, and A. O’Neill.
Order-preserving symmetric encryption. In
EUROCRYPT, 2009.
[11] D. Boneh, G. D. Crescenzo, R. Ostrovsky, and
G. Persiano. Public key encryption with keyword
search. Cryptology ePrint Archive, Report 2003/195.
[12] D. Boneh and M. Franklin. Identity-based encryption
from the Weil pairing. In CRYPTO, 2001.
[13] D. Boneh, A. Sahai, and B. Waters. Functional
encryption: Deﬁnitions and challenges. In TCC, 2011.
[14] D. Boneh and B. Waters. Conjunctive, subset, and
range queries on encrypted data. In TCC, 2007.
[15] O. Chowdhury, D. Garg, L. Jia, and A. Datta.
Equivalence-based Security for Querying Encrypted
Databases: Theory and Application to Privacy Policy
Audits. Technical Report CMU-CyLab-15-003, Cylab,
Carnegie Mellon University, 2015. Available at
http://arxiv.org/abs/1508.02448.
[16] O. Chowdhury, L. Jia, D. Garg, and A. Datta.
Temporal mode-checking for runtime monitoring of
privacy policies. In CAV, 2014.
[17] E. Damiani, S. D. C. Vimercati, S. Jajodia,
S. Paraboschi, and P. Samarati. Balancing
conﬁdentiality and eﬃciency in untrusted relational
dbmss. In CCS, 2003.
attacks against property-preserving encrypted
databases. In CCS, 2015.
[29] U. D. of Health & Human Services. Cignet Health
Fined a $4.3M Civil Money Penalty for HIPAA
Privacy Rule Violations. Available at
http://www.hhs.gov/ocr/privacy/hipaa/
enforcement/examples/cignetcmp.html.
[30] A. O’Neill. Deﬁnitional issues in functional
encryption. Cryptology ePrint Archive, Report
2010/556, 2010. http://eprint.iacr.org/2010/556.
[31] O. Pandey and Y. Rouselakis. Property preserving
symmetric encryption. In EUROCRYPT, 2012.
[32] R. A. Popa. Building practical systems that compute
on encrypted data. PhD thesis, MIT, 2014.
[33] R. A. Popa, F. H. Li, and N. Zeldovich. An
ideal-security protocol for order-preserving encoding.
In IEEE S&P, 2013.
[34] R. A. Popa, C. M. S. Redﬁeld, N. Zeldovich, and
H. Balakrishnan. CryptDB: Protecting conﬁdentiality
with encrypted query processing. In SOSP, 2011.
[35] R. A. Popa and N. Zeldovich. Cryptographic
treatment of CryptDB’s adjustable join. Technical
Report MIT-CSAIL-TR-2012-006, 2012.
[36] B. Schneier and J. Kelsey. Cryptographic support for
secure logs on untrusted machines. In USENIX
Security Symposium, 1998.
[37] B. Schneier and J. Kelsey. Secure audit logs to
support computer forensics. ACM TISSEC,
2(2):159–176, 1999.
[18] H. DeYoung, D. Garg, L. Jia, D. Kaynar, and
[38] E. Shen, E. Shi, and B. Waters. Predicate privacy in
A. Datta. Experiences in the logical speciﬁcation of
the HIPAA and GLBA privacy laws. In WPES, 2010.
[19] D. Garg, L. Jia, and A. Datta. Policy auditing over
incomplete logs: Theory, implementation and
applications. In CCS, 2011.
[20] V. Goyal, O. Pandey, A. Sahai, and B. Waters.
Attribute-based encryption for ﬁne-grained access
control of encrypted data. In CCS, 2006.
[21] H. Hacig¨um¨u¸s, B. Iyer, C. Li, and S. Mehrotra.
Executing SQL over encrypted data in the
database-service-provider model. In SIGMOD, 2002.
[22] S. Halevi and P. Rogaway. A tweakable enciphering
mode. In CRYPTO, 2003.
[23] J. E. Holt. Logcrypt: Forward security and public
veriﬁcation for secure audit logs. In ACSW Frontiers,
2006.
[24] J. Katz, A. Sahai, and B. Waters. Predicate
encryption supporting disjunctions, polynomial
encryption systems. In TCC, 2009.
[39] D. X. Song, D. Wagner, and A. Perrig. Practical
techniques for searches on encrypted data. In IEEE S
& P, 2000.
[40] S. Tu, M. F. Kaashoek, S. Madden, and N. Zeldovich.
Processing analytical queries over encrypted data. In
PVLDB, 2013.
[41] B. R. Waters, D. Balfanz, G. Durfee, and D. K.
Smetters. Building an encrypted and searchable audit
log. In NDSS, 2004.
1143