formanycommonalgorithmsandmodes. Thatmeans
anyone,whetherauthorizedormalicious,whoobtainsthe
secretkeycanproceedtouseit.
Thisiswhereasymmetriccryptographycanbeofuse.
AsymmetricCryptography
Manyoftheproblemsassociatedwithsymmetric-key
encryptionaresolvedbyasymmetric(orpublic-key)
cryptography,whichusestwoseparatebutmathematically
relatedkeys.Oneisavailabletothepublicandtheotheris
keptprivate.Dataencryptedbytheprivatekeycanbe
decryptedonlybythepublickey,anddataencryptedbythe
publickeycanbedecryptedonlybytheprivatekey.Ifthe
privatekeyisprotectedproperlyandkept,well,private,then
dataencryptedwiththepublickeyremainsconfidential,since
youneedthecloselyguardedprivatekeytodecryptit.Not
onlythat,butyoucouldusetheprivatekeytoauthenticatea
user.Theusercouldusetheprivatekeytosignmessages,for
example,whichthepubliccoulddecryptusingthepublickey.
So,youmightbeasking,“What’sthecatch?Ifpublic-key
cryptographyprovidesalltheseassurances,whydoweeven
havesymmetric-keycryptography?”Goodquestion,you!The
problemwithpublic-keyencryptionisitsspeed;it’salot
slowerthanitssymmetriccounterpart.Togetthebestofboth
worlds(andavoidtheworst),you’lloftenfindorganizations
usingahybridapproach:they’lluseasymmetriccryptoforthe
initialcommunicationsnegotiation,establishinganencrypted
1
channelthroughwhichtheycreateandexchangeasymmetric
key(oftencalledasessionkey).Becausethesessionkeyis
fairlysmall,usingpublic-keycryptoforthisprocessrequires
littleoverhead.Boththeclientandserverthenhaveacopyof
thesessionkey,whichtheyusetomakefuture
communicationsfaster.
Let’slookatacoupleofcommonusecasesforpublic-key
crypto.Specifically,we’lllookatencryption,signature
validation,andmutualauthentication.
EncryptionandSignatureValidation
Forthisfirstexample,you’llusepublic-keycryptotoencrypt
anddecryptamessage.You’llalsocreatethelogictosigna
messageandvalidatethatsignature.Forsimplicity,you’ll
includeallofthislogicinasinglemain()function.Thisis
meanttoshowyouthecorefunctionalityandlogicsothatyou
canimplementit.Inareal-worldscenario,theprocessisa
littlemorecomplex,sinceyou’relikelytohavetworemote
nodescommunicatingwitheachother.Thesenodeswould
havetoexchangepublickeys.Fortunately,thisexchange
processdoesn’trequirethesamesecurityassurancesas
exchangingsymmetrickeys.Recallthatanydataencrypted
withthepublickeycanbedecryptedonlybytherelated
privatekey.So,evenifyouperformaman-in-the-middle
attacktointerceptthepublic-keyexchangeandfuture
communications,youwon’tbeabletodecryptanyofthedata
encryptedbythesamepublickey.Onlytheprivatekeycan
decryptit.
Let’stakealookattheimplementationshowninListing
11-5.We’llelaborateonthelogicandcryptographic
functionalityaswereviewtheexample.
funcmain(){
var(
errerror
privateKey*rsa.PrivateKey
publicKey*rsa.PublicKey
message,plaintext,ciphertext,signature,label[]byte
)
ifprivateKey,err=rsa.GenerateKey(rand.Reader,2048)❶;err!=nil{
log.Fatalln(err)
}
publicKey=&privateKey.PublicKey❷
label=[]byte("")
message=[]byte("Somesupersecretmessage,maybeasessionkeyeven")
ciphertext,err=rsa.EncryptOAEP(sha256.New(),rand.Reader,publicKey,
message,label)❸
iferr!=nil{
log.Fatalln(err)
}
fmt.Printf("Ciphertext:%x\n",ciphertext)
plaintext,err=rsa.DecryptOAEP(sha256.New(),rand.Reader,privateKey,
ciphertext,label)❹
iferr!=nil{
log.Fatalln(err)
}
fmt.Printf("Plaintext:%s\n",plaintext)
h:=sha256.New()
h.Write(message)
signature,err=rsa.SignPSS(rand.Reader,privateKey,crypto.SHA256,
h.Sum(nil),nil)❺
iferr!=nil{
log.Fatalln(err)
}
fmt.Printf("Signature:%x\n",signature)
err=rsa.VerifyPSS(publicKey,crypto.SHA256,h.Sum(nil),signature,nil)❻
iferr!=nil{
log.Fatalln(err)
}
fmt.Println("Signatureverified")
}
Listing11-5:Asymmetric,orpublic-key,encryption(/ch-11/public-key/main.go/)
Theprogramdemonstratestwoseparatebutrelatedpublic-
keycryptofunctions:encryption/decryptionandmessage
signing.Youfirstgenerateapublic/privatekeypairbycalling
thersa.GenerateKey()function❶.Yousupplyarandomreader
andakeylengthasinputparameterstothefunction.Assuming
therandomreaderandkeylengthsareadequatetogeneratea
key,theresultisan*rsa.PrivateKeyinstancethatcontainsafield
whosevalueisthepublickey.Younowhaveaworkingkey
pair.Youassignthepublickeytoitsownvariableforthesake
ofconvenience❷.
Thisprogramgeneratesthiskeypaireverytimeit’srun.In
mostcircumstances,suchasSSHcommunications,you’ll
generatethekeypairasingletime,andthensaveandstorethe
keystodisk.Theprivatekeywillbekeptsecure,andthe
publickeywillbedistributedtoendpoints.We’reskipping
keydistribution,protection,andmanagementhere,and
focusingonlyonthecryptographicfunctions.
Nowthatyou’vecreatedthekeys,youcanstartusingthem
forencryption.Youdosobycallingthefunction
rsa.EncryptOAEP()❸,whichacceptsahashingfunction,areader
touseforpaddingandrandomness,yourpublickey,the
messageyouwishtoencrypt,andanoptionallabel.This
functionreturnsanerror(iftheinputscausethealgorithmto
fail)andourciphertext.Youcanthenpassthesamehashing
function,areader,yourprivatekey,yourciphertext,anda
labelintothefunctionrsa.DecryptOAEP()❹.Thefunction
decryptstheciphertextbyusingyourprivatekeyandreturns
thecleartextresult.
Noticethatyou’reencryptingthemessagewiththepublic
key.Thisensuresthatonlytheholderoftheprivatekeywill
havetheabilitytodecryptthedata.Nextyoucreateadigital
signaturebycallingrsa.SignPSS()❺.Youpasstoit,again,a
randomreader,yourprivatekey,thehashingfunctionyou’re
using,thehashvalueofthemessage,andanilvalue
representingadditionaloptions.Thefunctionreturnsany
errorsandtheresultingsignaturevalue.Muchlikehuman
DNAorfingerprints,thissignatureuniquelyidentifiesthe
identityofthesigner(thatis,theprivatekey).Anybody
holdingthepublickeycanvalidatethesignaturetonotonly
determinetheauthenticityofthesignaturebutalsovalidatethe
integrityofthemessage.Tovalidatethesignature,youpass
thepublickey,hashfunction,hashvalue,signature,and
additionaloptionstorsa.VerifyPSS()❻.Noticethatinthiscase
you’repassingthepublickey,nottheprivatekey,intothis
function.Endpointswishingtovalidatethesignaturewon’t
haveaccesstotheprivatekey,norwillvalidationsucceedif
youinputthewrongkeyvalue.Thersa.VerifyPSS()function
returnsnilwhenthesignatureisvalidandanerrorwhenit’s
invalid.
Hereisasamplerunoftheprogram.Itbehavesas
expected,encryptingthemessagebyusingapublickey,
decryptingitbyusingaprivatekey,andvalidatingthe
signature:
$gorunmain.go
Ciphertext:a9da77a0610bc2e5329bc324361b480ba042e09ef58e4d8eb106c8fc0b5
--snip--
Plaintext:Somesupersecretmessage,maybeasessionkeyeven
Signature:68941bf95bbc12edc12be369f3fd0463497a1220d9a6ab741cf9223c6793
--snip--
Signatureverified
Nextup,let’slookatanotherapplicationofpublic-key
cryptography:mutualauthentication.
MutualAuthentication
Mutualauthenticationistheprocessbywhichaclientand
serverauthenticateeachother.Theydothiswithpublic-key
cryptography;boththeclientandservergenerate
public/privatekeypairs,exchangepublickeys,andusethe
publickeystovalidatetheauthenticityandidentityofthe
otherendpoint.Toaccomplishthisfeat,boththeclientand
servermustdosomelegworktosetuptheauthorization,
explicitlydefiningthepublickeyvaluewithwhichtheyintend
tovalidatetheother.Thedownsidetothisprocessisthe
administrativeoverheadofhavingtocreateuniquekeypairs
foreverysinglenodeandensuringthattheserverandthe
clientnodeshavetheappropriatedatatoproceedproperly.
Tobegin,you’llknockouttheadministrativetasksof
creatingkeypairs.You’llstorethepublickeysasself-signed,
PEM-encodedcertificates.Let’susetheopensslutilitytocreate
thesefiles.Onyourserver,you’llcreatetheserver’sprivate
keyandcertificatebyenteringthefollowing:
$opensslreq-nodes-x509-newkeyrsa:4096-keyoutserverKey.pem-out
serverCrt.pem-days365
Theopensslcommandwillpromptyouforvariousinputs,to
whichyoucansupplyarbitraryvaluesforthisexample.The
commandcreatestwofiles:serverKey.pemandserverCrt.pem.
ThefileserverKey.pemcontainsyourprivatekey,andyou
shouldprotectit.TheserverCrt.pemfilecontainstheserver’s
publickey,whichyou’lldistributetoeachofyourconnecting
clients.
Foreveryconnectingclient,you’llrunacommandsimilar
totheprecedingone:
$opensslreq-nodes-x509-newkeyrsa:4096-keyoutclientKey.pem-out
clientCrt.pem-days365
Thiscommandalsogeneratestwofiles:clientKey.pemand
clientCrt.pem.Muchaswiththeserveroutput,youshould
protecttheclient’sprivatekey.TheclientCrt.pemcertificate
filewillbetransferredtoyourserverandloadedbyyour
program.Thiswillallowyoutoconfigureandidentifythe
clientasanauthorizedendpoint.You’llhavetocreate,
transfer,andconfigureacertificateforeachadditionalclient
sothattheservercanidentifyandexplicitlyauthorizethem.
InListing11-6,yousetupanHTTPSserverthatrequiresa
clienttoprovidealegitimate,authorizedcertificate.
funchelloHandler(whttp.ResponseWriter,r*http.Request){❶
fmt.Printf("Hello:%s\n",r.TLS.PeerCertificates[0].Subject.CommonName)❷
fmt.Fprint(w,"Authenticationsuccessful")
}
funcmain(){
var(
errerror
clientCert[]byte
pool*x509.CertPool
tlsConf*tls.Config
server*http.Server
)
http.HandleFunc("/hello",helloHandler)
ifclientCert,err=ioutil.ReadFile("../client/clientCrt.pem")❸;err!=nil{
log.Fatalln(err)
}
pool=x509.NewCertPool()
pool.AppendCertsFromPEM(clientCert)❹
tlsConf=&tls.Config{❺
ClientCAs:pool,
ClientAuth:tls.RequireAndVerifyClientCert,
}
tlsConf.BuildNameToCertificate()❻
server=&http.Server{
Addr:":9443",
TLSConfig:tlsConf,❼
}
log.Fatalln(server.ListenAndServeTLS("serverCrt.pem","serverKey.pem")❽)
}
Listing11-6:Settingupamutualauthenticationserver(/ch-11/mutual-
auth/cmd/server/main.go)
Outsidethemain()function,theprogramdefinesa
helloHandler()function❶.AswediscussedwaybackinChapters
3and4,thehandlerfunctionacceptsanhttp.ResponseWriter
instanceandthehttp.Requestitself.Thishandlerisprettyboring.
Itlogsthecommonnameoftheclientcertificatereceived❷.
Thecommonnameisaccessedbyinspectingthehttp.Request’s
TLSfieldanddrillingdownintothecertificatePeerCertificates
data.Thehandlerfunctionalsosendstheclientamessage
indicatingthatauthenticationwassuccessful.
Buthowdoyoudefinewhichclientsareauthorized,and
howdoyouauthenticatethem?Theprocessisfairlypainless.
Youfirstreadtheclient’scertificatefromthePEMfilethe
clientcreatedpreviously❸.Becauseit’spossibletohave
morethanoneauthorizedclientcertificate,youcreatea
certificatepoolandcallpool.AppendCertsFromPEM(clientCert)toadd
theclientcertificatetoyourpool❹.Youperformthisstepfor
eachadditionalclientyouwishtoauthenticate.
Next,youcreateyourTLSconfiguration.Youexplicitlyset
theClientCAsfieldtoyourpoolandconfigureClientAuthto
tls.RequireAndVerifyClientCert❺.Thisconfigurationdefinesyour
poolofauthorizedclientsandrequiresclientstoproperly
identifythemselvesbeforethey’llbeallowedtoproceed.You
issueacalltotlsConf.BuildNameToCertificate()sothattheclient’s
commonandsubjectalternatenames—thedomainnamesfor
whichthecertificatewasgenerated—willproperlymapto
theirgivencertificate❻.YoudefineyourHTTPserver,
explicitlysettingyourcustomconfiguration❼,andstartthe
serverbycallingserver.ListenAndServeTLS(),passingtoittheserver
certificateandprivate-keyfilesyoucreatedpreviously❽.
Notethatyoudon’tusetheclient’sprivate-keyfileanywhere
intheservercode.Aswe’vesaidbefore,theprivatekey
remainsprivate;yourserverwillbeabletoidentifyand
authorizeclientsbyusingonlytheclient’spublickey.Thisis
thebrillianceofpublic-keycrypto.
Youcanvalidateyourserverbyusingcurl.Ifyougenerate
andsupplyabogus,unauthorizedclientcertificateandkey,
you’llbegreetedwithaverbosemessagetellingyouso:
$curl-ik-XGET--certbadCrt.pem--keybadKey.pem\
https://server.blackhat-go.local:9443/hello
curl:(35)gnutls_handshake()failed:Certificateisbad
You’llalsogetamoreverbosemessageontheserver,
somethinglikethis:
http:TLShandshakeerrorfrom127.0.0.1:61682:remoteerror:tls:unknown
certificateauthority
Ontheflipside,ifyousupplythevalidcertificateandthe
keythatmatchesthecertificateconfiguredintheserverpool,
you’llenjoyasmallmomentofgloryasitsuccessfully
authenticates:
$curl-ik-XGET--certclientCrt.pem--keyclientKey.pem\
https://server.blackhat-go.local:9443/hello
HTTP/1.1200OK
Date:Fri,09Oct202016:55:52GMT
Content-Length:25
Content-Type:text/plain;charset=utf-8
Authenticationsuccessful
Thismessagetellsyoutheserverworksasexpected.
Now,let’shavealookataclient(Listing11-7).Youcan
runtheclientoneitherthesamesystemastheserverora
differentone.Ifit’sonadifferentsystem,you’llneedto
transferclientCrt.pemtotheserverandserverCrt.pemtothe
client.
funcmain(){
var(
errerror
certtls.Certificate
serverCert,body[]byte
pool*x509.CertPool
tlsConf*tls.Config
transport*http.Transport
client*http.Client
resp*http.Response
)
ifcert,err=tls.LoadX509KeyPair("clientCrt.pem","clientKey.pem");err!=nil
{❶
log.Fatalln(err)
}
ifserverCert,err=ioutil.ReadFile("../server/serverCrt.pem");err!=nil{❷
log.Fatalln(err)
}
pool=x509.NewCertPool()
pool.AppendCertsFromPEM(serverCert)❸
tlsConf=&tls.Config{❹
Certificates:[]tls.Certificate{cert},
RootCAs:pool,
}
tlsConf.BuildNameToCertificate()❺
transport=&http.Transport{❻
TLSClientConfig:tlsConf,
}
client=&http.Client{❼
Transport:transport,
}
ifresp,err=client.Get("https://server.blackhat-go.local:9443/hello");err!=nil{
❽
log.Fatalln(err)
}
ifbody,err=ioutil.ReadAll(resp.Body);err!=nil{❾
log.Fatalln(err)
}
deferresp.Body.Close()
fmt.Printf("Success:%s\n",body)
}
Listing11-7:Themutualauthenticationclient(/ch-11/mutual-
auth/cmd/client/main.go)
Alotofthecertificatepreparationandconfigurationwill
looksimilartowhatyoudidintheservercode:creatingapool
ofcertificatesandpreparingsubjectandcommonnames.
Sinceyouwon’tbeusingtheclientcertificateandkeyasa
server,youinsteadcalltls.LoadX509KeyPair("clientCrt.pem",
"clientKey.pem")toloadthemforuselater❶.Youalsoreadthe
servercertificate,addingittothepoolofcertificatesyouwish
toallow❷.Youthenusethepoolandclientcertificates❸to
buildyourTLSconfiguration❹,andcall
tlsConf.BuildNameToCertificate()tobinddomainnamestotheir
respectivecertificates❺.
Sinceyou’recreatinganHTTPclient,youhavetodefinea
transport❻,correlatingitwithyourTLSconfiguration.You
canthenusethetransportinstancetocreateanhttp.Clientstruct
❼.AswediscussedinChapters3and4,youcanusethis
clienttoissueanHTTPGETrequestvia
client.Get("https://server.blackhat-go.local:9443/hello")❽.
Allthemagichappensbehindthescenesatthispoint.
Mutualauthenticationisperformed—theclientandtheserver
mutuallyauthenticateeachother.Ifauthenticationfails,the
programreturnsanerrorandexits.Otherwise,youreadthe
HTTPresponsebodyanddisplayittostdout❾.Runningyour
clientcodeproducestheexpectedresult,specifically,that
therewerenoerrorsthrownandthatauthenticationsucceeds:
$gorunmain.go
Success:Authenticationsuccessful
Yourserveroutputisshownnext.Recallthatyou
configuredtheservertologahellomessagetostandard
output.Thismessagecontainsthecommonnameofthe
connectingclient,extractedfromthecertificate:
$gorunmain.go
Hello:client.blackhat-go.local
Younowhaveafunctionalsampleofmutual
authentication.Tofurtherenhanceyourunderstanding,we
encourageyoutotweakthepreviousexamplessotheywork
overTCPsockets.
Inthenextsection,you’lldedicateyoureffortstoamore
deviouspurpose:brute-forcingRC2encryptioncipher
symmetrickeys.