# AFL源码分析（Ex.2）——附录（Part 2）
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0\. 写在前面
**本文全文参考了[da1234cao](https://github.com/da1234cao)师傅的`Github`仓库
的相关内容，我对全文中机翻程度过高以致未正确表达原文语义、异译程度过高以致偏离原文语义、语句不通顺或不合语法的大量文本进行了修改，特此说明。以下文章中的“原译者”即代指[da1234cao](https://github.com/da1234cao)师傅。**
此文章主要是对`AFL`仓库中`doc`目录下的所有文档进行翻译。
  * [x] env_variables.txt(环境变量手册) —— 历史文章(Part 1)
  * [ ] historical_notes.txt(历史记录)
  * [ ] INSTALL(安装说明)
  * [x] life_pro_tips.txt(使用技巧) —— 历史文章(Part 1)
  * [x] notes_for_asan.txt(`ASAN`模式手册) —— 本文
  * [x] parallel_fuzzing.txt(同步`fuzz`模式手册) —— 本文
  * [ ] perf_tips.txt
  * [ ] QuickStartGuide.txt
  * [ ] sister_projects.txt
  * [ ] status_screen.txt
  * [ ] technical_details.txt
后续附录将继续翻译以上列表中的文章。
## 1\. notes_for_asan.txt(ASAN模式手册)
这个文件讨论了在`ASAN`下`fuzzing`的一些注意事项，并提出了一些备选方案。一般使用手册请参阅自述文件。
[原译者注释：总体是介绍`ASAN`的使用注意。不仅仅适用于模糊测试：使用`32`位编译`or`运行前估算下内存使用]
###  1.1 内容提要
`64`位系统上的`ASAN`要求大量内存，而这种方式导致的崩溃，很难与程序自身导致的崩溃区别开来。
**因此，使用`ASAN`进行`fuzzing`只推荐在以下四种情况下使用:**
  * 在`32`位系统上，我们总是可以强制设置合理的内存限制(`-m 800`左右是一个很好的选择)
  * 在`64`位系统上，需要能完成进行以下动作之一: 
    * 在`32`位模式下编译二进制文件(`gcc -m32`)
    * 能精确测量程序需要的内存(可使用)译者注：`recidivm`通过以不同的内存限制运行多次目标程序来估计目标程序的峰值虚拟内存使用量。
    * 能限制程序内存的使用(`Linux`下可以使用`cgroup`，具体可参阅`experimental/asan_cgroups`)
若要使用`ASAN`进行编译，请在调用`make clean all`之前设置`AFL_USE_ASAN = 1`。`afl-gcc / afl-clang`包装器会选择并添加适当的标志。请注意，`ASAN`与`-static`不兼容，因此请注意这一点。(也可以使用`AFL_USE_MSAN=1`以启用`MSAN`)
**还可以选择使用未启用`ASAN`机制的二进制文件生成语料库，然后将其输入给启用了`ASAN`的测试程序集以检查错误**。
这样速度更快，并且可以为您提供可供比对的结果。
您还可以尝试使用`libdislocator`作为一种轻量且较为稳定的替代方法。(关于此库文件的相关表述请参见父目录中的`libdislocator/
README.dislocator`)
###  1.2 详细介绍
`ASAN`为`bookkeeping`机制分配了很大的虚拟地址空间区域。因为其中大多数空间都从未真正访问过，因此`OS`无需为该进程分配任何实际的内存页，并且`ASAN`抢占的`VM`本质上是已被释放的——但此空间的映射依然会被`OS`标准内存限制技术所限制(`RLIMIT_AS`,又名`ulimit
-v`)。
最后，`afl-fuzz`试图保护您免受`fuzzer`偏离正常逻辑并开始消耗所有可用内存去徒劳的企图解析格式错误的输入文件。
这种情况出乎意料地经常发生，因此对于几乎任何一个模糊测试者来说，强制执行这样的限制都是很重要的 ——
让内核`OOM`处理程序介入并开始杀死随机进程以释放资源。当然，这不是一个很好的方法。
不幸的是，`Unix`系统无法提供一种可移植的方式来限制实际分配给进程的页面数量，从而区分该进程和`ASAN`进行的无害的争抢内存空间的行为。
原则上，有三种标准的方法来限制堆的大小：
  * `RLIMIT_AS`机制(`ulimit -v`)限制了虚拟空间的大小，但是如前所述，它并不关注该进程实际使用的页面数，因此在这里无济于事。
  * `RLIMIT_DATA`机制(`ulimit -d`)看起来很合适，但它仅适用于传统的`sbrk()/brk()`方法请求堆空间，现代的分配器，包括`glibc`中的分配器，通常改为依赖`mmap()`，这将完全规避此限制。
  * 最后，`RLIMIT_RSS`限制(`ulimit -m`)听起来像我们所需要的，但是在`Linux`上不起作用——主要是因为没人愿意实现它。
此外，`cgroup`也是一个不错的工具，但是它们是特定于`Linux`分发版本的，即使在`Linux`系统上也不是通用的，并且它需要`root`权限才能设置。
我有点犹豫是否要让`afl-fuzz`要求具有`root`权限。 因此，
**如果您使用的是`Linux`，并且想使用`cgroups`，请查阅`experimental/asan_cgroups/`中附带的贡献脚本**。
**在无法使用`cgroup`的系统中，我们没有一种可移植的好方法来避免将`ASAN`分配计入内存限制**。
在`32`位系统上，或者对于以`32`位模式()`-m32`)编译的二进制文件，这没什么大不了的。`ASAN`大约需要`600-800MB`左右的内存(实际所需内存取决于编译器)。因此，您要做的就是使用`-m`指定比其所需内存高一点的内存。
在`64`位系统上，情况更加棘手，因为`ASAN`分配所需要的大小非常离谱——旧版本约为`17.5 TB`，最新版本接近`20 TB`。
您系统中的实际内存量可能远小于这个需求内存量，除非您以外科手术的精确度进行内存限制，否则您将无法获得针对`OOM`错误的保护。
在我的系统上，稍早版本的`gcc`的`ASAN`占用的内存量约为`17,825,850 MB`。
对于最新的`clang`，它是`20,971,600MB`。但是这并不能保证这些数字是稳定的，如果您仅仅尝试了几次就将它们认为是固定值，那么您将处于危险之中。
要获得准确的数字，可以使用`Jakub
Wilk`([http://jwilk.net/software/recidivm)开发的`recidivm`工具。](http://jwilk.net/software/recidivm\)%E5%BC%80%E5%8F%91%E7%9A%84%60recidivm%60%E5%B7%A5%E5%85%B7%E3%80%82)
如果您没有以上所述的内存限制条件，则您在对`64`位二进制文件进行模糊测试时，不建议使用`ASAN`，除非您确信此机制很健壮并可以通过额外的方式进行强制内存限制。(在这种情况下，可以在调用`afl-fuzz`时指定`-m none`将其设置为无限制的内存)
除了使用`recidivm`或不加限制地运行`afl`，您还有其他两种不错的选择：
  1. 使用不启用`ASAN`机制的二进制文件构建测试用例集，然后在更可控的环境中使用`ASAN`、`Valgrind`或其他内存破坏检测工具进行检查。
  2. 使用`-m32`(`32`位模式)编译目标程序(如果系统支持)。
###  1.3 QEMU 模式
`ASAN`、`MSAN`和其他的清理检测程序似乎与`QEMU`用户仿真模式不兼容，因此请不要尝试将它们与`-Q`选项一起使用；`QEMU`似乎并不喜欢这些工具使用的影子`VM`技术，并且可能只会随后分配所有物理内存，然后崩溃。
###  1.4 ASAN 以及 OOM 崩溃
默认情况下，`ASAN`将内存分配失败视为致命错误，立即导致程序崩溃。
由于这与常规的`POSIX`语义背道而驰(并且在其他行为正常的程序中引起了安全问题的出现)，因此我们尝试通过在`ASAN_OPTIONS`中指定`allocator_may_return_null
= 1`来禁用此功能。
不幸的是，据网上资料所说，在标准分配器仅返回`NULL`的情况下，此设置仍会导致`ASAN`触发镜像崩溃。
如果这干扰了您的模糊测试工作，则您可能想查看此错误报告： 
###  1.5 UBSAN 机制
一些人对使用`UBSAN`进行模糊测试缠上了兴趣。 **但请注意，官方不支持此功能！**