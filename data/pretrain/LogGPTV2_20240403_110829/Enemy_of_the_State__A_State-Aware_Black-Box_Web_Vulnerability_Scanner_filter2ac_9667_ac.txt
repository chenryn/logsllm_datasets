SCARF
Vanilla Forums
WackoPicko v2
WordPress v2
WordPress v3
Description
Photo hosting.
Discussion forum.
Discussion forum.
Stanford conference and research forum.
Discussion forum.
Intentionally vulnerable web application.
Blogging platform.
Blogging platform.
Version
3.0.2
2.0.4
3.0.10
2007-02-27
2.0.17.10
2.0
2.0
3.2.1
Lines of Code
26,622
16,034
110,186
798
43,880
900
17,995
71,698
Table 1: Applications that we ran the crawlers against to measure vulnerabilities discovered and code coverage.
high, the user must manually inspect each vulner-
ability reported to determine the validity. This re-
quires a security-conscious user to evaluate the re-
ports. Moreover, false positives erode the user’s
trust in the tool and make the user less likely to use
it in the future.
• Code Coverage. The percentage of the web appli-
cation’s code that the black-box web vulnerability
scanner executes while it crawls and fuzzes the ap-
plication. This measures how effective the scanner
is in exercising the functionality of the web applica-
tion. Moreover, code coverage is an excellent met-
ric for another reason: A black-box web vulnera-
bility scanner, by nature, cannot ﬁnd a vulnerability
along a code path that it does not execute. There-
fore, greater code coverage means that a scanner
has the potential to discover more vulnerabilities.
Note that this is orthogonal to fuzzing capability:
A fuzzer—no matter how effective—will never be
able to discover a vulnerability on a code path that
it does not execute.
We use both the metrics previously described in our
evaluation. However, our main focus is on code cover-
age. This is because a scanner with greater code cover-
age will be able to discover more vulnerabilities in the
web application.
However, code coverage is not a perfect metric. Evalu-
ating raw code coverage percentage numbers can be mis-
leading. Ten percent code coverage of an application
could be horrible or excellent depending on how much
functionality the application exposes. Some code may
be intended only for installation, may be only for ad-
ministrators, or is simply dead code and cannot be ex-
ecuted. Therefore, comparing code coverage normalized
to a baseline is more informative, and we use this in our
evaluation.
6.1 Experiments
We evaluated our approach by running our state-aware-
scanner along with three other vulnerability scanners
Scanner Description
wget
GNU command-line
website downloader.
w3af Web Application At-
tack and Audit Frame-
work.
skipﬁsh Open-source,
high-
performance vulnera-
bility scanner.
Our state-aware vul-
nerability scanner.
state-
aware-
scanner
Language
C
Version
1.12
Python
1.0-stable
C
2.03b
Python
1.0
Table 2: Black-box web vulnerability scanners that we
compared.
against eight web applications. These web applications
range in size, complexity, and functionality. In the rest of
this section, we describe the web applications, the black-
box web vulnerability scanners, and the methodology we
used to validate our approach.
6.1.1 Web Applications
Table 1 provides an overview of the web applications
used with a short description, a version number, and lines
of executable PHP code for each application. Because
our approach assumes that the web application’s state
changes only via requests from the user, we made slight
code modiﬁcations to three web applications to reduce
the inﬂuence of external, non-user driven, forces, such as
time. Please refer to Appendix A for a detailed descrip-
tion of each application and what was changed.
6.1.2 Black-Box Web Vulnerability Scanners
This section describes the black-box web vulnerability
scanners that were compared against our approach, along
with the conﬁguration or settings that were used. Ta-
ble 2 contains a short description of each scanner, the
scanner’s programming language, and the version num-
ber. Appendix B shows the exact conﬁguration that was
used for each scanner.
wget is a free and open-source application that is used
to download ﬁles from a web application. While not a
vulnerability scanner, wget is a crawler that will make
all possible GET requests it can ﬁnd. Thus, it provides an
excellent baseline because vulnerability scanners make
POST requests as well as GET requests and should dis-
cover more of the application than wget.
wget is launched with the following options: recur-
sive, download everything, and ignore robots.txt.
w3af is an open-source black-box web vulnerability
scanner which has numerous fuzzing modules. We en-
abled the blindSqli, eval, localFileInclude, osCommand-
ing, remoteFileInclude, sqli, and xss fuzzing plugins.
skipﬁsh is an open-source black-box web vulnerability
scanner whose focus is on high speed and high perfor-
mance. Skipﬁsh epitomizes the “shotgun” approach, and
boasts about making more than 2,000 requests per sec-
ond to a web application on a LAN. Skipﬁsh also at-
tempts to guess, via a dictionary or brute-force, directory
names. We disabled this behavior to be fair to the other
scanners, because we do not want to test the ability to
guess a hidden directory, but how a scanner crawls a web
application.
state-aware-scanner is our state-aware black-box vul-
nerability scanner. We use HtmlUnit [19] to issue the
HTTP requests and render the HTML responses. Af-
ter crawling and building the state-graph, we utilize the
fuzzing plugins from w3af to generate fuzzing requests.
Thus, any improvement in code coverage of our crawler
over w3af is due to our state-aware crawling, since the
fuzzing components are identical.
6.1.3 Methodology
We ran each black-box web vulnerability scanner against
a distinct, yet identical, copy of each web application.
We ran all tests on our local cloud [34].
Gallery, WordPress v2, and WordPress v3 do not re-
quire an account to interact with the website, thus each
scanner is simply told to scan the test application.
For the remaining applications (PhpBB v2, PhpBB v3,
SCARF, Vanilla Forums, and WackoPicko v2), it is difﬁ-
cult to fairly determine how much information to give the
scanners. Our approach only requires a username/pass-
word for the application, and by its nature will discover
the requests that log the user out, and recover from them.
However, other scanners do not have this capability.
Thus, it is reasonable to test all scanners with the same
level of information that we give our scanner. However,
the other scanners lack the ability to provide a username
and password. Therefore, we did the next best thing: For
those applications that require a user account, we log into
the application and save the cookie ﬁle. We then instruct
the scanner to use this cookie ﬁle while scanning the web
application.
While we could do more for the scanners, like prevent-
ing them from issuing the logout request for each appli-
cation, we believe that our approach strikes a fair com-
promise and allows each scanner to decide how to crawl
the site. Preventing the scanners from logging out of the
application also limits the amount of the application they
will see, as they will never see the web application from
a guest’s perspective.
6.2 Results
Table 3 shows the results of each of the black-box web
vulnerability scanners against each web application. The
column “% over Baseline” displays the percentage of
code coverage improvement of the scanner against the
wget baseline, while the column “Vulnerabilities” shows
total number of reported vulnerabilities, true positives,
unique true positives among the scanners, and false pos-
itives.
The prototype implementation of our state-aware-
scanner had the best code coverage for every application.
This veriﬁes the validity of our algorithm: Understand-
ing state is necessary to better exercise a web application.
Figure 6 visually displays the code coverage percent
improvement over wget. The most important thing to
take from these results is the improvement state-aware-
scanner has over w3af. Because we use the fuzzing com-
ponent of w3af, the only difference is in our state-aware
crawling. The results show that this gives state-aware-
scanner an increase in code coverage from as little as half
a percent to 140.71 percent.
Our crawler discovered three unique vulnerabilities,
one each in PhpBB v2, SCARF, and WackoPicko v2.
The SCARF vulnerability is simply a XSS injection on
the comment form. w3af logged itself out before fuzzing
the comment page. skipﬁsh ﬁled the vulnerable page un-
der “Response varies randomly, skipping checks.” How-
ever, the content of this page does not vary randomly, it
varies because skipﬁsh is altering it. This random cate-
gorization also prevents skipﬁsh from detecting the sim-
ple XSS vulnerability on WackoPicko v2’s guestbook.
This result shows that a scanner needs to understand the
web application’s internal state to properly decide why a
page’s content is changing.
Skipﬁsh was able to discover 15 vulnerabilities in
Vanilla Forums. This is impressive, however, 14 stem
from a XSS injection via the referer header on an error
page. Thus, even though these 14 vulnerabilities are on
different pages, it is the same root cause.
Surprisingly, our scanner produced less false positives
than w3af. All of w3af’s false positives were due to
faulty timing detection of SQL injection and OS com-
Scanner
Application
% over Baseline
Vulnerabilities
state-aware-scanner Gallery
Gallery
w3af
Gallery
skipﬁsh
wget
Gallery
PhpBB v2
state-aware-scanner
PhpBB v2
skipﬁsh
PhpBB v2
w3af
wget
PhpBB v2
PhpBB v3
state-aware-scanner
PhpBB v3
skipﬁsh
PhpBB v3
w3af
PhpBB v3
wget
state-aware-scanner
SCARF
SCARF
skipﬁsh
SCARF
w3af
wget
SCARF
state-aware-scanner Vanilla Forums
Vanilla Forums
w3af
Vanilla Forums
wget
skipﬁsh
Vanilla Forums
state-aware-scanner WackoPicko v2
skipﬁsh
WackoPicko v2
WackoPicko v2
w3af
wget
WackoPicko v2
state-aware-scanner WordPress v2
WordPress v2
w3af
wget
WordPress v2
skipﬁsh
WordPress v2
state-aware-scanner WordPress v3
WordPress v3
w3af
skipﬁsh
WordPress v3
WordPress v3
wget
16.20%
15.77%
10.96%
0%
38.34%
5.10%
1.04%
0%
115.45%
60.21%
16.16%
0%
67.03%
55.66%
21.55%
0%
30.89%
1.06%
0%
-2.32%
241.86%
194.77%
101.15%
0%
14.49%
12.49%
0%
-18.34%
9.84%
9.23%
3.89%
0%
Reported
0
3
0
True Unique
0
0
0
0
0
0
False
0
3
0
4
3
5
0
2
0
1
0
0
0
0
17
5
4
5
0
0
1
0
3
1
3
2
1
0
0
0
1
0
0
0
0
15
5
3
5
0
0
0
0
0
0
1
0
0
0
0
0
1
0
0