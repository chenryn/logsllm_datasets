by applications can vary, token-based authentication works like this:
应用程序保护令牌完整性的一种更可靠的方法是对令牌进行签名，并在其到达服务器时验证令牌签名。签名用于验证数据的完整性。它们是特殊的字符串，只有如果您知道秘密密钥才能生成。由于没有办法在不知道秘密密钥的情况下生成有效签名，而且只有服务器知道秘密密钥是什么，因此有效的签名表明令牌可能未被客户端或任何第三方更改。虽然应用程序的实现可能会有所不同，但基于令牌的身份验证的工作方式如下：
1.  The user logs in with their credentials.
2.  The server validates those credentials and provides the user with a
    signed token.
3.  [ ]{#c03.xhtml#Page_41 .pagebreak title="41"} The user sends the
    token with every request to prove their identity.
4.  Upon receiving and validating the token, the server reads the user's
    identity information from the token and responds with confidential
    data.
### JSON Web Tokens {#c03.xhtml#h2-123456c01-0004}
The *JSON Web Token (* *JWT* *)* is one of the most commonly used types
of authentication tokens. It has three components: a header, a payload,
and a signature.
JSON Web
Token（JWT）是最常用的身份验证令牌之一。它有三个组成部分：头部、负载和签名。
The *header* identifies the algorithm used to generate the signature.
It's a base64url-encoded string containing the algorithm name. Here's
what a JWT header looks like:
头部标识用于生成签名的算法。这是一个base64url编码的字符串，包含算法名称。以下是JWT头的样式：
    eyBhbGcgOiBIUzI1NiwgdHlwIDogSldUIH0K
This string is the base64url-encoded version of this text:
这个字符串是这段文本的base64url编码版本：
    { "alg" : "HS256", "typ" : "JWT" }
The *payload* section contains information about the user's identity.
This section, too, is base64url encoded before being used in the token.
Here's an example of the payload section, which is the base64url-encoded
string of `      { "     ` `      user_name     `{.variable}
`      " : "     ` `      admin     `{.variable} `      ", }     ` :
载荷部分包含有关用户身份的信息。在将该部分用于令牌之前，也会进行base64url编码。以下是载荷部分的示例，这是"{"user_name"："admin"}"的base64url编码字符串：
    eyB1c2VyX25hbWUgOiBhZG1pbiB9Cg
Finally, the *signature* section validates that the user hasn't tampered
with the token. It's calculated by concatenating the header with the
payload, then signing it with the algorithm specified in the header, and
a secret key. Here's what a JWT signature looks like:
最后，签名部分验证用户没有篡改令牌。它通过将头部与有效载荷串联起来，然后使用头部中指定的算法和秘钥进行签名来计算。以下是JWT签名的样式：
    4Hb/6ibbViPOzq9SJflsNGPWSk6B8F6EqVrkNjpXh7M
For this specific token, the signature was generated by signing the
string
`      eyBhbGcgOiBIUzI1NiwgdHlwIDogSldUIH0K.eyB1c2VyX25hbWUgOiBhZG1pbiB9Cg     `
with the HS256 algorithm using the secret key `      key     ` . The
complete token concatenates each section (the header, payload, and
signature), separating them with a period ( `      .     ` ):
该特定令牌的签名是使用HS256算法使用密钥key签名字符串eyBhbGcgOiBIUzI1NiwgdHlwIDogSldUIH0K.eyB1c2VyX25hbWUgOiBhZG1pbiB9Cg而生成的。完整的令牌将每个部分（标头，载荷和签名）连接起来，用句点（.）隔开：
    eyBhbGcgOiBIUzI1NiwgdHlwIDogSldUIH0K.eyB1c2VyX25hbWUgOiBhZG1pbiB9Cg.4Hb/6ibbViPOzq9SJflsNGPWSk6B8F6EqVrkNjpXh7M
When implemented correctly, JSON web tokens provide a secure way to
identify the user. When the token arrives at the server, the server can
verify that the token has not been tampered with by checking that the
signature is correct. Then the server can deduce the user's identity by
using the information contained in the payload section. And since the
user does not have access to the secret key used to sign the token, they
cannot alter the payload and sign the token themselves.
当 JSON Web Token
被正确实现时，它提供了一种安全的方式来识别用户。当令牌到达服务器时，服务器可以通过检查签名是否正确来验证令牌未被篡改。然后，服务器可以通过使用负载部分所包含的信息来推断用户的身份。由于用户无法访问用于签署令牌的秘钥，因此他们无法更改有效负载并签署令牌。
[ ]{#c03.xhtml#Page_42 .pagebreak title="42"} But if implemented
incorrectly, there are ways that an attacker can bypass the security
mechanism and forge arbitrary tokens.
但是，如果未正确实施，攻击者可以绕过安全机制并伪造任意令牌。
#### Manipulating the alg Field {#c03.xhtml#h3-123456c01-0001}
Sometimes applications fail to verify a token's signature after it
arrives at the server. This allows an attacker to simply bypass the
security mechanism by providing an invalid or blank signature.
有时，应用程序在接收到令牌后无法验证其签名。这使得攻击者可以通过提供无效或空白的签名来轻松绕过安全机制。
One way that attackers can forge their own tokens is by tampering with
the `      alg     ` field of the token header, which lists the
algorithm used to encode the signature. If the application does not
restrict the algorithm type used in the JWT, an attacker can specify
which algorithm to use, which could compromise the security of the
token.
攻击者可以通过篡改token头的\"alg\"字段来伪造自己的令牌。该字段列出用于编码签名的算法。如果应用程序不限制JWT中使用的算法类型，攻击者可以指定要使用的算法，从而危及令牌的安全性。
JWT supports a `      none     ` option for the algorithm type. If the
`      alg     ` field is set to `      none     ` , even tokens with
empty signature sections would be considered valid. Consider, for
example, the following token:
JWT支持算法类型中的无选项。如果alg字段设置为none，则即使签名部分为空的令牌也将被视为有效。例如，请考虑以下令牌：
    eyAiYWxnIiA6ICJOb25lIiwgInR5cCIgOiAiSldUIiB9Cg.eyB1c2VyX25hbWUgOiBhZG1pbiB9Cg.
This token is simply the base64url-encoded versions of these two blobs,
with no signature present:
这个令牌只是这两个 Blob 的 base64url 编码版本，没有签名。
    { "alg" : "none", "typ" : "JWT" } { "user" : "admin" }
This feature was originally used for debugging purposes, but if not
turned off in a production environment, it would allow attackers to
forge any token they want and impersonate anyone on the site.
该功能最初用于调试目的，但如果在生产环境中未关闭，则会允许攻击者伪造任何令牌并冒充站点上的任何人。
Another way attackers can exploit the `      alg     ` field is by
changing the type of algorithm used. The two most common types of
signing algorithms used for JWTs are HMAC and RSA. HMAC requires the
token to be signed with a key and then later verified with the same key.
When using RSA, the token would first be created with a private key,
then verified with the corresponding public key, which anyone can read.
It is critical that the secret key for HMAC tokens and the private key
for RSA tokens be kept a secret.
攻击者利用alg域的另一种方式是改变使用的算法类型。用于JWT的两种最常见的签名算法类型是HMAC和RSA。HMAC需要使用密钥对令牌进行签名，然后使用相同的密钥进行验证。在使用RSA时，令牌首先会使用私钥创建，然后使用对应的公钥进行验证，任何人都可以读取。重要的是，HMAC令牌的密钥和RSA令牌的私钥必须保密。
Now let's say that an application was originally designed to use RSA
tokens. The tokens are signed with a private key A, which is kept a
secret from the public. Then the tokens are verified with public key B,
which is available to anyone. This is okay as long as the tokens are
always treated as RSA tokens. Now if the attacker changes the
`      alg     ` field to HMAC, they might be able to create valid
tokens by signing the forged tokens with the RSA public key, B. When the
signing algorithm is switched to HMAC, the token is still verified with
the RSA public key B, but this time, the token can be signed with the
same public key too.
现在我们假设一个应用程序原本是设计用于使用RSA令牌。令牌使用私钥A进行签名，该私钥被保密不公开。然后使用公钥B进行令牌验证，而该公钥可供任何人使用。只要始终将令牌视为RSA令牌，这是可以的。现在，如果攻击者更改alg字段为HMAC，则可能通过使用RSA公钥B对伪造令牌进行签名来创建有效令牌。当签名算法切换为HMAC时，令牌仍然使用RSA公钥B进行验证，但这次，令牌也可以使用相同的公钥进行签名。
#### Brute-Forcing the Key {#c03.xhtml#h3-123456c01-0002}
It could also be possible to guess, or *brute-force* , the key used to
sign a JWT. The attacker has a lot of information to start with: the
algorithm used to sign the token, the payload that was signed, and the
resulting signature. If [ ]{#c03.xhtml#Page_43 .pagebreak title="43"}
the key used to sign the token is not complex enough, they might be able
to brute-force it easily. If an attacker is not able to brute-force the
key, they might try leaking the secret key instead. If another
vulnerability, like a directory traversal, external entity attack (XXE),
or SSRF exists that allows the attacker to read the file where the key
value is stored, the attacker can steal the key and sign arbitrary
tokens of their choosing. We'll talk about these vulnerabilities in
later chapters.
攻击者有可能通过猜测或暴力攻击密钥来签名
JWT。攻击者有很多信息可供参考：签名令牌使用的算法、已签名的有效负载以及签名结果。如果用于签名令牌的密钥不够复杂，他们可能很容易地进行暴力攻击。
如果攻击者无法暴力攻击密钥，他们可能会尝试泄露秘密密钥。
如果存在其他漏洞，例如目录遍历、外部实体攻击（XXE）或SSRF，允许攻击者读取密钥值存储的文件，则攻击者可以窃取密钥并签名其选择的任意令牌。我们将在后面的章节中讨论这些漏洞。
#### Reading Sensitive Information {#c03.xhtml#h3-123456c01-0003}
Since JSON web tokens are used for access control, they often contain
information about the user. If the token is not encrypted, anyone can
base64-decode the token and read the token's payload. If the token
contains sensitive information, it might become a source of information
leaks. A properly implemented signature section of the JSON web token
provides data integrity, not confidentiality.
由于JSON
Web令牌用于访问控制，因此它们通常包含有关用户的信息。如果令牌未加密，则任何人都可以对其进行base64解码并读取其有效载荷。如果令牌包含敏感信息，则它可能成为信息泄漏的来源。JSON
Web令牌的正确实施的签名部分提供了数据完整性，而不是保密性。
These are just a few examples of JWT security issues. For more examples
of JWT vulnerabilities, use the search term *JWT security issues* . The
security of any authentication mechanism depends not only on its design,
but also its implementation. JWTs can be secure, but only if implemented
properly.
这些只是JWT安全问题的一些例子。如果想了解更多JWT漏洞的例子，请使用搜索词JWT安全问题。任何身份验证机制的安全性不仅取决于其设计，还取决于其实施。JWT可以很安全，但前提是必须正确实施。
### The Same-Origin Policy {#c03.xhtml#h2-123456c01-0005}
The *same-origin policy (* *SOP)* is a rule that restricts how a script
from one origin can interact with the resources of a different origin.
In one sentence, the SOP is this: a script from page A can access data
from page B only if the pages are of the same origin. This rule protects
modern web applications and prevents many common web vulnerabilities.
同源策略是一条规则，限制来自一个源的脚本与不同源的资源进行交互。简单来说，同源策略就是这样的：只有当页面A和B的源相同时，页面A的脚本才能访问页面B的数据。该规则保护现代Web应用程序，防止许多常见的Web漏洞。
Two URLs are said to have the same origin if they share the same
protocol, hostname, and port number. Let's look at some examples. Page A
is at this URL:
如果两个URL共享相同的协议，主机名和端口号，则称它们具有相同的来源。让我们看一些示例。页面A在此URL上：
1.  *https://medium.com/@vickieli*
It uses HTTPS, which, remember, uses port 443 by default. Now look at
the following pages to determine which has the same origin as page A,
according to the SOP:
它使用 HTTPS，需要记住，默认使用 443
端口。现在查看以下页面，确定哪个页面与页面 A 拥有相同的来源，遵守 SOP。
1.  *https://medium.com/*
2.  *http://medium.com/*
3.  *https://twitter.com/@vickieli7*
4.  *https://medium.com:8080/@vickieli*
The *https://medium.com/* URL is of the same origin as page A, because
the two pages share the same origin, protocol, hostname, and port
number. The other three pages do not share the same origin as page A.
*http://medium.com/* is of a different origin from page A, because their
protocols differ. *https://medium.com/* uses HTTPS, whereas
*http://medium.com/* uses [ ]{#c03.xhtml#Page_44 .pagebreak title="44"}
HTTP. *https://twitter.com/@vickieli7* is of a different origin as well,
because it has a different hostname. Finally,
*https://medium.com:8080/@vickieli* is of a different origin because it
uses port 8080, instead of port 443.
\`https://medium.com/\` 和 \`page A\`
具有相同的源，因为它们共享相同的源、协议、主机名和端口号。其他三个页面与
\`page A\` 不共享相同的源。\`http://medium.com/\` 与 \`page A\`
来源不同，因为它们的协议不同。\`https://medium.com/\` 使用 HTTPS，而
\`http://medium.com/\` 使用 HTTP。\`https://twitter.com/@vickieli7\`
来源也不同，因为它有不同的主机名。最后，\`https://medium.com:8080/@vickieli\`
来源不同，因为它使用了 8080 端口，而不是 443 端口。
Now let's consider an example to see how SOP protects us. Imagine that
you're logged in to your banking site at *onlinebank.com* .
Unfortunately, you click on a malicious site, *attacker.com* , in the
same browser.
现在让我们考虑一个例子，看看SOP如何保护我们。想象你正在onlinebank.com网站登录你的银行账户。不幸的是，你在同一个浏览器中点击了一个恶意网站attacker.com。
The malicious site issues a GET request to *onlinebank.com* to retrieve
your personal information. Since you're logged into the bank, your
browser automatically includes your cookies in every request you send to
*onlinebank.com* , even if the request is generated by a script on a
malicious site. Since the request contains a valid session ID, the
server of *onlinebank.com* fulfills the request by sending the HTML page
containing your info. The malicious script then reads and retrieves the
private email addresses, home addresses, and banking information
contained on the page.
恶意网站向onlinebank.com发出GET请求，以检索您的个人信息。由于您已登录银行，在您发送到onlinebank.com的每个请求中，您的浏览器会自动包含您的Cookie，即使该请求是由恶意网站上的脚本生成的。由于请求包含有效的会话ID，onlinebank.com的服务器通过发送包含您信息的HTML页面来满足请求。恶意脚本然后读取和检索该页面上包含的私人电子邮件地址、家庭地址和银行信息。
Luckily, the SOP will prevent the malicious script hosted on
*attacker.com* from reading the HTML data returned from *onlinebank.com*
. This keeps the malicious script on page A from obtaining sensitive
information embedded within page B.
幸运的是，SOP可以防止攻击者.com上托管的恶意脚本能阅读来自onlinebank.com的HTML数据，这可以保护页面A上的恶意脚本无法获得嵌入在页面B中的敏感信息。
## Learn to Program {#c03.xhtml#h1-123456c01-0006}
You should now have a solid background to help you understand most of
the vulnerabilities we will cover. Before you set up your hacking tools,