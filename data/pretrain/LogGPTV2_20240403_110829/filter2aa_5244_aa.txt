# kernel UAF
UAF å³ Use After Freeï¼Œé€šå¸¸æŒ‡çš„æ˜¯**å¯¹äºé‡Šæ”¾åæœªé‡ç½®çš„å‚æ‚¬æŒ‡é’ˆçš„åˆ©ç”¨**ï¼Œæ­¤å‰åœ¨ç”¨æˆ·æ€ä¸‹çš„ heap é˜¶æ®µå¯¹äº ptmalloc çš„åˆ©ç”¨å¾ˆå¤šéƒ½æ˜¯åŸºäºUAFæ¼æ´è¿›è¡Œè¿›ä¸€æ­¥çš„åˆ©ç”¨ã€‚
åœ¨ CTF å½“ä¸­ï¼Œå†…æ ¸çš„â€œå †å†…å­˜â€ä¸»è¦æŒ‡çš„æ˜¯ç›´æ¥æ˜ å°„åŒºï¼ˆdirect mapping areaï¼‰ï¼Œå¸¸ç”¨çš„åˆ†é…å‡½æ•° kmalloc ä»æ­¤å¤„åˆ†é…å†…å­˜ï¼Œå¸¸ç”¨çš„åˆ†é…å™¨ä¸º slubï¼Œè‹¥æ˜¯åœ¨ kernel ä¸­å­˜åœ¨ç€å‚æ‚¬æŒ‡é’ˆï¼Œæˆ‘ä»¬åŒæ ·å¯ä»¥ä»¥æ­¤å®Œæˆå¯¹ slab/slub å†…å­˜åˆ†é…å™¨çš„åˆ©ç”¨ï¼Œé€šè¿‡ Kernel UAF å®Œæˆææƒã€‚
## å†…æ ¸å †åˆ©ç”¨ä¸ç»‘æ ¸
slub allocator ä¼šä¼˜å…ˆä»å½“å‰æ ¸å¿ƒçš„ `kmem_cache_cpu` ä¸­è¿›è¡Œå†…å­˜åˆ†é…ï¼Œåœ¨å¤šæ ¸æ¶æ„ä¸‹å­˜åœ¨å¤šä¸ª `kmem_cache_cpu` ï¼Œç”±äºè¿›ç¨‹è°ƒåº¦ç®—æ³•ä¼šä¿æŒæ ¸å¿ƒé—´çš„è´Ÿè½½å‡è¡¡ï¼Œå› æ­¤æˆ‘ä»¬çš„ exp è¿›ç¨‹å¯èƒ½ä¼šè¢«åœ¨ä¸åŒçš„æ ¸å¿ƒä¸Šè¿è¡Œï¼Œè¿™ä¹Ÿå°±å¯¼è‡´äº†åˆ©ç”¨è¿‡ç¨‹ä¸­ kernel object çš„åˆ†é…æœ‰å¯èƒ½ä¼šæ¥è‡ªä¸åŒçš„ `kmem_cache_cpu` ï¼Œè¿™ä½¿å¾—åˆ©ç”¨æ¨¡å‹å˜å¾—å¤æ‚ï¼Œä¹Ÿé™ä½äº†æ¼æ´åˆ©ç”¨çš„æˆåŠŸç‡ã€‚
> æ¯”å¦‚è¯´ä½ åœ¨ core 0 ä¸Šæ•´äº†ä¸ª double freeï¼Œå‡†å¤‡ä¸‹ä¸€æ­¥åˆ©ç”¨æ—¶ exp è·‘åˆ° core 1å»äº†ï¼Œé‚£å°±å¾ˆå®¹æ˜“è®©äººæ‘¸ä¸ç€å¤´è„‘ :ï¼ˆ
å› æ­¤ä¸ºäº†ä¿è¯æ¼æ´åˆ©ç”¨çš„ç¨³å®šï¼Œ**æˆ‘ä»¬éœ€è¦å°†æˆ‘ä»¬çš„è¿›ç¨‹ç»‘å®šåˆ°ç‰¹å®šçš„æŸä¸ª CPU æ ¸å¿ƒä¸Š**ï¼Œè¿™æ · slub allocator çš„æ¨¡å‹å¯¹æˆ‘ä»¬è€Œè¨€ä¾¿ç®€åŒ–æˆäº† `kmem_cache_node + kmem_cache_cpu` ï¼Œæˆ‘ä»¬ä¹Ÿèƒ½æ›´åŠ æ–¹ä¾¿åœ°è¿›è¡Œæ¼æ´åˆ©ç”¨ã€‚
ç°ç¬”è€…ç»™å‡ºå¦‚ä¸‹å°† exp è¿›ç¨‹ç»‘å®šè‡³æŒ‡å®šæ ¸å¿ƒçš„æ¨¡æ¿ï¼š
```c
#include 
/* to run the exp on the specific core only */
void bind_cpu(int core)
{
    cpu_set_t cpu_set;
    CPU_ZERO(&cpu_set);
    CPU_SET(core, &cpu_set);
    sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);
}
```
## é€šç”¨ kmalloc flag
`GFP_KERNEL` ä¸ `GFP_KERNEL_ACCOUNT`  æ˜¯å†…æ ¸ä¸­æœ€ä¸ºå¸¸è§ä¸é€šç”¨çš„åˆ†é… flagï¼Œå¸¸è§„æƒ…å†µä¸‹ä»–ä»¬çš„åˆ†é…éƒ½æ¥è‡ªåŒä¸€ä¸ª `kmem_cache` â€”â€”å³é€šç”¨çš„ `kmalloc-xx` ã€‚
è¿™ä¸¤ç§ flag çš„åŒºåˆ«ä¸»è¦åœ¨äº `GFP_KERNEL_ACCOUNT` æ¯” `GFP_KERNEL` å¤šäº†ä¸€ä¸ªå±æ€§â€”â€”**è¡¨ç¤ºè¯¥å¯¹è±¡ä¸æ¥è‡ªç”¨æˆ·ç©ºé—´çš„æ•°æ®ç›¸å…³è”**ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¯¸å¦‚ `msg_msg` ã€`pipe_buffer`ã€`sk_buffçš„æ•°æ®åŒ…` çš„åˆ†é…ä½¿ç”¨çš„éƒ½æ˜¯ `GFP_KERNEL_ACCOUNT` ï¼Œè€Œ `ldt_struct` ã€`packet_socket` ç­‰ä¸ç”¨æˆ·ç©ºé—´æ•°æ®æ²¡æœ‰ç›´æ¥å…³è”çš„ç»“æ„ä½“åˆ™ä½¿ç”¨ `GFP_KERNEL`ã€‚
åœ¨5.9 ç‰ˆæœ¬ä¹‹å‰`GFP_KERNEL` ä¸ `GFP_KERNEL_ACCOUNT` å­˜åœ¨éš”ç¦»æœºåˆ¶ï¼Œåœ¨ [è¿™ä¸ª commit](https://github.com/torvalds/linux/commit/10befea91b61c4e2c2d1df06a2e978d182fcf792) ä¸­å–æ¶ˆäº†éš”ç¦»æœºåˆ¶ï¼Œè‡ªå†…æ ¸ç‰ˆæœ¬ 5.14 èµ·ï¼Œåœ¨ [è¿™ä¸ª commit](https://github.com/torvalds/linux/commit/494c1dfe855ec1f70f89552fce5eadf4a1717552) å½“ä¸­åˆé‡æ–°å¼•å…¥ï¼š
- å¯¹äºå¼€å¯äº† `CONFIG_MEMCG_KMEM` ç¼–è¯‘é€‰é¡¹çš„ kernel è€Œè¨€ï¼ˆé€šå¸¸éƒ½æ˜¯é»˜è®¤å¼€å¯ï¼‰ï¼Œå…¶ä¼šä¸ºä½¿ç”¨ `GFP_KERNEL_ACCOUNT` è¿›è¡Œåˆ†é…çš„é€šç”¨å¯¹è±¡**åˆ›å»ºä¸€ç»„ç‹¬ç«‹çš„ `kmem_cache` â€”â€”åä¸º `kmalloc-cg-*`** ï¼Œä»è€Œå¯¼è‡´ä½¿ç”¨è¿™ä¸¤ç§ flag çš„ object ä¹‹é—´çš„éš”ç¦»ã€‚
## slub åˆå¹¶ & éš”ç¦»
slab alias æœºåˆ¶æ˜¯ä¸€ç§å¯¹åŒç­‰/ç›¸è¿‘å¤§å° object çš„ `kmem_cache` è¿›è¡Œ**å¤ç”¨**çš„ä¸€ç§æœºåˆ¶ï¼š
- å½“ä¸€ä¸ª `kmem_cache` åœ¨åˆ›å»ºæ—¶ï¼Œè‹¥å·²ç»å­˜åœ¨èƒ½åˆ†é…ç›¸ç­‰/è¿‘ä¼¼å¤§å°çš„ object çš„ `kmem_cache` ï¼Œåˆ™**ä¸ä¼šåˆ›å»ºæ–°çš„ kmem\_cacheï¼Œè€Œæ˜¯ä¸ºåŸæœ‰çš„ kmem\_cache èµ·ä¸€ä¸ª aliasï¼Œä½œä¸ºâ€œæ–°çš„â€ kmem\_cache è¿”å›**ã€‚
ä¸¾ä¸ªğŸŒ°ï¼Œ`cred_jar` æ˜¯ä¸“é—¨ç”¨ä»¥åˆ†é… `cred` ç»“æ„ä½“çš„ `kmem_cache`ï¼Œåœ¨ Linux 4.4 ä¹‹å‰çš„ç‰ˆæœ¬ä¸­ï¼Œå…¶ä¸º `kmalloc-192` çš„ aliasï¼Œå³ cred ç»“æ„ä½“ä¸å…¶ä»–çš„ 192 å¤§å°çš„ object éƒ½ä¼šä»åŒä¸€ä¸ª `kmem_cache`â€”â€”`kmalloc-192` ä¸­åˆ†é…ã€‚
å¯¹äºåˆå§‹åŒ–æ—¶è®¾ç½®äº† `SLAB_ACCOUNT` è¿™ä¸€ flag çš„ `kmem_cache` è€Œè¨€ï¼Œåˆ™ä¼šæ–°å»ºä¸€ä¸ªæ–°çš„ `kmem_cache` è€Œéä¸ºåŸæœ‰çš„å»ºç«‹ aliasï¼ŒğŸŒ°å¦‚åœ¨æ–°ç‰ˆçš„å†…æ ¸å½“ä¸­ `cred_jar` ä¸ `kmalloc-192` ä¾¿æ˜¯ä¸¤ä¸ªç‹¬ç«‹çš„ `kmem_cache`ï¼Œ**å½¼æ­¤ä¹‹é—´äº’ä¸å¹²æ‰°**ã€‚
## ä¾‹é¢˜ï¼šCISCN2017 - babydriver
[attachment here](https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/kernel/CISCN2017-babydriver)
### åˆ†æ
å…ˆè§£å‹ rootfs.cpio çœ‹ä¸€ä¸‹æœ‰ä»€ä¹ˆæ–‡ä»¶
```bash
CISCN2017_babydriver [masterâ—] mkdir core
CISCN2017_babydriver [masterâ—] cd core 
core [masterâ—] mv ../rootfs.cpio rootfs.cpio.gz
core [masterâ—â—] gunzip ./rootfs.cpio.gz 
core [masterâ—] ls
rootfs.cpio
core [masterâ—] cpio -idmv /dev/console
  10   â”‚ exec 2>/dev/console
  11   â”‚
  12   â”‚ insmod /lib/modules/4.4.72/babydriver.ko
  13   â”‚ chmod 777 /dev/babydev
  14   â”‚ echo -e "\nBoot took $(cut -d' ' -f1 /proc/uptime) seconds\n"
  15   â”‚ setsid cttyhack setuidgid 1000 sh
  16   â”‚
  17   â”‚ umount /proc
  18   â”‚ umount /sys
  19   â”‚ poweroff -d 0  -f
  20   â”‚
â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```
æ ¹æ® init çš„å†…å®¹ï¼Œ12 è¡ŒåŠ è½½äº† `babydriver.ko` è¿™ä¸ªé©±åŠ¨ï¼Œæ ¹æ® pwn çš„ä¸€èˆ¬å¥—è·¯ï¼Œè¿™ä¸ªå°±æ˜¯æœ‰æ¼æ´çš„ LKM äº†ã€‚init çš„å…¶ä»–å‘½ä»¤éƒ½æ˜¯ linux å¸¸ç”¨çš„å‘½ä»¤ï¼Œå°±ä¸å†è§£é‡Šäº†ã€‚
æŠŠè¿™ä¸ªé©±åŠ¨æ–‡ä»¶æ‹¿å‡ºæ¥ã€‚
```bash
core [masterâ—] cp ./lib/modules/4.4.72/babydriver.ko ..
core [masterâ—] cd ..
CISCN2017_babydriver [masterâ—] check ./babydriver.ko
./babydriver.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=8ec63f63d3d3b4214950edacf9e65ad76e0e00e7, with debug_info, not stripped
[*] '/home/m4x/pwn_repo/CISCN2017_babydriver/babydriver.ko'
    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x0)
```
æ²¡æœ‰å¼€ PIEï¼Œæ—  canary ä¿æŠ¤ï¼Œæ²¡æœ‰å»é™¤ç¬¦å·è¡¨ï¼Œå¾ˆ niceã€‚
ç”¨ IDA æ‰“å¼€åˆ†æï¼Œæ—¢ç„¶æ²¡æœ‰å»é™¤ç¬¦å·è¡¨ï¼Œshift + F9 å…ˆçœ‹ä¸€ä¸‹æœ‰ä»€ä¹ˆç»“æ„ä½“ï¼Œå¯ä»¥å‘ç°å¦‚ä¸‹çš„ç»“æ„ä½“ï¼š
```asm
00000000 babydevice_t    struc ; (sizeof=0x10, align=0x8, copyof_429)
00000000                                         ; XREF: .bss:babydev_struct/r
00000000 device_buf      dq ?                    ; XREF: babyrelease+6/r
00000000                                         ; babyopen+26/w ... ; offset
00000008 device_buf_len  dq ?                    ; XREF: babyopen+2D/w
00000008                                         ; babyioctl+3C/w ...
00000010 babydevice_t    ends
00000010
```
å†çœ‹ä¸€ä¸‹ä¸»è¦å‡½æ•°
**babyioctl:** å®šä¹‰äº† 0x10001 çš„å‘½ä»¤ï¼Œå¯ä»¥é‡Šæ”¾å…¨å±€å˜é‡ babydev\_struct ä¸­çš„ device\_bufï¼Œå†æ ¹æ®ç”¨æˆ·ä¼ é€’çš„ size é‡æ–°ç”³è¯·ä¸€å—å†…å­˜ï¼Œå¹¶è®¾ç½® device\_buf\_lenã€‚
```C
// local variable allocation has failed, the output may be wrong!
void __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg)
{
  size_t v3; // rdx
  size_t v4; // rbx
  __int64 v5; // rdx
  _fentry__(filp, *(_QWORD *)&command);
  v4 = v3;
  if ( command == 0x10001 )
  {
    kfree(babydev_struct.device_buf);
    babydev_struct.device_buf = (char *)_kmalloc(v4, 0x24000C0LL);
    babydev_struct.device_buf_len = v4;
    printk("alloc done\n", 0x24000C0LL, v5);
  }
  else
  {
    printk("\x013defalut:arg is %ld\n", v3, v3);
  }
}
```
**babyopen:** ç”³è¯·ä¸€å—ç©ºé—´ï¼Œå¤§å°ä¸º 0x40 å­—èŠ‚ï¼Œåœ°å€å­˜å‚¨åœ¨å…¨å±€å˜é‡ babydev\_struct.device\_buf ä¸Šï¼Œå¹¶æ›´æ–° babydev\_struct.device\_buf\_len
```C
int __fastcall babyopen(inode *inode, file *filp)
{
  __int64 v2; // rdx
  _fentry__(inode, filp);
  babydev_struct.device_buf = (char *)kmem_cache_alloc_trace(kmalloc_caches[6], 0x24000C0LL, 0x40LL);
  babydev_struct.device_buf_len = 64LL;
  printk("device open\n", 0x24000C0LL, v2);
  return 0;
}
```
**babyread:** å…ˆæ£€æŸ¥é•¿åº¦æ˜¯å¦å°äº babydev\_struct.device\_buf\_lenï¼Œç„¶åæŠŠ babydev\_struct.device\_buf ä¸­çš„æ•°æ®æ‹·è´åˆ° buffer ä¸­ï¼Œbuffer å’Œé•¿åº¦éƒ½æ˜¯ç”¨æˆ·ä¼ é€’çš„å‚æ•°
```C
void __fastcall babyread(file *filp, char *buffer, size_t length, loff_t *offset)
{
  size_t v4; // rdx
  _fentry__(filp, buffer);
  if ( babydev_struct.device_buf )
  {
    if ( babydev_struct.device_buf_len > v4 )
      copy_to_user(buffer, babydev_struct.device_buf, v4);
  }
}
```
**babywrite:** ç±»ä¼¼ babyreadï¼Œä¸åŒçš„æ˜¯ä» buffer æ‹·è´åˆ°å…¨å±€å˜é‡ä¸­
```C
void __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset)
{
  size_t v4; // rdx
  _fentry__(filp, buffer);
  if ( babydev_struct.device_buf )
  {
    if ( babydev_struct.device_buf_len > v4 )
      copy_from_user(babydev_struct.device_buf, buffer, v4);
  }
}
```
**babyrelease:** é‡Šæ”¾ç©ºé—´ï¼Œæ²¡ä»€ä¹ˆå¥½è¯´çš„
```C
int __fastcall babyrelease(inode *inode, file *filp)
{
  __int64 v2; // rdx
  _fentry__(inode, filp);
  kfree(babydev_struct.device_buf);
  printk("device release\n", filp, v2);
  return 0;
}
```
è¿˜æœ‰ babydriver\_init() å’Œ babydriver\_exit() ä¸¤ä¸ªå‡½æ•°åˆ†åˆ«å®Œæˆäº† **/dev/babydev** è®¾å¤‡çš„åˆå§‹åŒ–å’Œæ¸…ç†ï¼ŒæŸ¥ä¸€ä¸‹å‡½æ•°çš„ç”¨æ³•å³å¯ï¼Œä¸å†åˆ†æã€‚
### æ€è·¯
æ²¡æœ‰ç”¨æˆ·æ€ä¼ ç»Ÿçš„æº¢å‡ºç­‰æ¼æ´ï¼Œä½†å­˜åœ¨ä¸€ä¸ªä¼ªæ¡ä»¶ç«äº‰å¼•å‘çš„ UAF æ¼æ´ï¼š
- å¦‚æœæˆ‘ä»¬åŒæ—¶æ‰“å¼€ä¸¤ä¸ªè®¾å¤‡ï¼Œç¬¬äºŒæ¬¡ä¼šè¦†ç›–ç¬¬ä¸€æ¬¡åˆ†é…çš„ç©ºé—´ï¼Œå› ä¸º babydev\_struct æ˜¯å…¨å±€çš„ã€‚åŒæ ·ï¼Œå¦‚æœé‡Šæ”¾ç¬¬ä¸€ä¸ªï¼Œé‚£ä¹ˆç¬¬äºŒä¸ªå…¶å®æ˜¯è¢«æ˜¯é‡Šæ”¾è¿‡çš„ï¼Œè¿™æ ·å°±é€ æˆäº†ä¸€ä¸ª UAFã€‚