SemDS evaluates the similarity of the domains (concept classes) of properties o and i.
The properties ”gDay” and ”day” have the domain concepts TheDate and Calendar-Date,
respectively, i.e., d(gDay) = TheDate and d(day) = Calendar-Date. Therefore,
SemDS(TheDate, Calendar-Date) is evaluated the following way:
p(TheDate) ={gMonth, gYear, gDay}
p(Calendar-Date)={absolute_time, year, month,day, dayOfTheWeek, monthOfTheYear}
| p(TheDate) ˙ p(Calendar- Date)|
SemDS(TheDate, Calendar-Date)= = 0.5
| p(TheDate) ¨ p(Calendar- Date)|
178
This result, 0.5, indicates that the domains of properties o and i are somewhat
similar, which follows our perception that the concepts TheDate and Calender-Date are
similar.
The second function to be evaluated is SynS(no, ni). This function computes the
syntactic similarity of the property names no and ni. In our example, the similarity of
properties gDay and day is evaluated to 0.8. This result indicates a close syntactic
similarity between the two property names. Other examples of the application of the
function SynS for the properties involved in our example are:
SynS(gDay, dayOfTheWeek) = 0.29
SynS(gMonth, monthOfTheYear) = 0.44
The last function to be evaluated is function SemRS(r(o), r(i)), which calculates the
similarity of the ranges of properties o and i. For the properties gDay and day, the
following metric is obtained:
SemRS(r(gDay), r(day)) = SemRS(short, integer) = 1.0
This result indicates that the workflow system that will be enacting the process being
constructed supports the connection of parameters of type short to parameters of type
integer. An example of a connection among properties not supported or desired is the
following one:
SemRS(r(gDay), r(dayOfTheWeek)) = SemRS(short, string) = 0.0
Having calculated the functions SemDS, SynS, and SemRS, we can now compute
function S. The result of evaluating S(gDay, day) is,
179
3 0.5*0.8*1.0 =0.74
Table 4-7 shows the results of applying function S(o, i) to various properties of the
concept classes TheDate and Calendar-Date.
Table 4-7 – Examples of the evaluation of function S(o, i).
o i SemDS SynS SemRS S
gMonth dayOfTheWeek 0.5 0.12 0.0 0.0
gYear monthOfTheYear 0.5 0.35 0.0 0.0
gDay month 0.5 0.0 1.0 0.0
gDay year 0.5 0.0 1.0 0.0
gDay day 0.5 0.8 1.0 0.74
gDay time 0.5 0.0 1.0 0.0
gDay monthOfTheYear 0.5 0.0 0.0 0.0
gYear year 0.5 0.86 1.0 0.75
gMonth monthOfTheYear 0.5 0.44 0.0 0.0
gMonth month 0.5 0.89 1.0 0.76
Once all the possible mappings between the properties of the output concept class
TheDate and the input concept class Calendar-Date are evaluated, the function
SemS’’ (TheDate, Calendar-Date) returns the result shown in Table 4-8 line b). The table
also shows the results for all the five cases initially considered inF igure 4-7.
180
Table 4-8 – Example of computing function SemS’’ (O,I).
ST O SO I SemS’’(O, I)
(a) ST TheDate SO Date 2.58
1
(b) ST TheDate SO Calendar-Date 2.25
2
(c) ST TheDate SO Event 2.14
3
(d) ST TheDate SO Scientific-Event 2.05
4
(e) ST TheDate SO Time-Point 0.00
5
The function SemS’’ (O, I) returns the cumulative degree of similarity of the
mappings between two concept classes, i.e., it corresponds to the sum of the weights
associated with a bipartite graph constructed with the properties of the output concept and
the properties of the input concept. While the function SemS’’ (O, I) gives some
information relatively to the possible mapping of two input and output parameters, the
function does not take into account the number of mandatory inputs that need to be
satisfied. Thus, a more significant and useful piece of information is the result obtained
from applying function p(O, I), which normalizes function SemS’’ (O, I) with respect to
the number of input properties of the concept class I. The results of applying function
p(O, I) to our example is shown in Table 4-9.
181
Table 4-9 – Example of computing function p (O, I).
ST O SO I p(O, I)
(a) ST TheDate SO Date 0.65
1
(b) ST TheDate SO Calendar-Date 0.38
2
(c) ST TheDate SO Event 0.31
3
(d) ST TheDate SO Scientific-Event 0.26
4
(e) ST TheDate SO Time-Point 0.00
5
It can be seen that function p(O, I) returns values closer to 1, when the concept
classes being compared exhibit a higher degree of simliarity. This is the case for the
concepts W (DateTime).TheDate and W (Time).Calendar-Date. When two concepts are not
similar the function returns 0, which is the case for the concepts W (DateTime).TheDate
and W (Time).Time-Point.
4.6.3.5 MAPPING OUTPUTS WITH INPUTS
While the algorithm presented does not explicitly show how the mapping between the
outputs and inputs of two services which maximize the degree of integration is
constructed, this is achieved by keeping track of the best mapping obtained when
computing function P (Os, Is) and function SemS’’ (O, I).
4.7 SYSTEM ARCHITECTURE
The core of our work has already been presented in the previous section, with the
description of the algorithm to match a ST against a set of SOs. Therefore, in this section
we will only briefly describe the architecture of our prototype. Our system is composed
of two main services: registry service and discovery service, as illustrated inF igure 4-9.
182
Web Server
Registry
SSeerrvviiccee NNaammee UURRII IInnppuutt OOuuttppuutt ……
Workflow Management System
SO DDAAMMLL--SS
t
1
ST
t t t t
CClliieenntt a 2 b a
Register Search Engine
t
Search n
Parse DAML-S Discovery Service
DDAAMMLL--SS
Store DAML-S
Registry Advertise
file
Service
SSeerrvviiccee
Unadvertise
Service Name
Figure 4-9 – System Architecture
The services available (registry and discovery services) to users and to the WfMS are
both implemented using servlets and are accessible through HTTP. We are considering
extending the access to allow RMI calls.
Suppliers access the registry service to advertise and unadvertise their Web services.
To make an advertisement, a supplier registers a DAML-S service object (SO) with the
system. To unadvertise a service, the only information necessary is the name of the
service.
Clients and customers typically access the system to find Web services previously
registered (Figure 4-10). This is achieved by sending a service template (ST) to the
system. The service template specifies the requiremenst about the service to discover.
Service templates are described using DAML-S, more precisely by using the profile.daml
ontology (see section 4.4.3).
183
Figure 4-10 – Web Service Discovery page.
Once the system receives an advertisement or a discovery message, the SO or the ST
received are parsed, using the Jena toolkit (Jena 2002). The Jena DAML API provides
support for loading DAML ontologies onto Jena RDF models. Since DAML-S parsers
are not yet available, we have built a very simple DAML-S parser on top of the Jena
Toolkit to extract specific information from service objects – such as service name,
service description, QoS model, inputs, and outputs. The syntactic, operational, and
semantic similarity functions will make use of this information .
The information retrieved from parsing a service advertisement is stored in a registry
(Figure 4-9). The registry is a service capability table, where service descriptions are
added or removed in response to advertised and unadvertised messages. The registry
table and its contents are stored in physical memory for fast access.
184
When the system receives a discovery message (i.e., a ST) from a workflow system
for example, it is parsed and matched against the set of SOs registered. The results are
ranked according to the criteria specified when the ST was sent to the system (Figure
4-10). Three ranking methods are available, based on: syntactic, semantic, and
operational metrics. Better matches are characterized by a score closer to 1. Finally, the
ranked candidates are returned to the entity that issued the query. Figure 4-11 shows the
results of a query.
Figure 4-11 – Web Service Discovery Results page
For each SO present in the registry, a detailed information sheet comparing it against
the ST is constructed. It includes the results of evaluating the SO against the ST:
185
syntactically, based on operations, and semantically. Finally, it also includes the
suggested data mappings between the ST and the SO (which outputs should be connected
to which inputs).
4.8 RELATED WORK
Our work is directly related to ontology-based Web service discovery, search, match, and
integration, and indirectly related to information retrieval systems and information
integration systems.
The work that most closely relates to ours is described in Paolucci, Kawamura et al.
(2002). They present an algorithm that deals with the localization of Web services, but
they do not address the interoperability problem. Their system also uses the service
profile ontology from the DAML-S specification language. Their work considers only the
matching of input/output concepts defined by the same ontology. When input/output
concepts from different ontologies are matched, the algorithm simply evaluates the match
to “fail”. This is a limitation. Web services are heterogeneous and autonomous by nature;
therefore it is advantageous to compare outputs and inputs that subscribe to different
ontologies. The similarity function described is based on the taxonomy of the ontology,
accounting for the parent/child relationship between concepts. If the concepts associated
with an output and with an input do not have a parent/child relationship the algorithm
evaluates the match to a “fail” and does not try to assess a degree of similarity. The
algorithm uses the minimal distance between concepts in the taxonomy tree. We believe
that a feature-based approach rather than one employing the taxonomy of the ontology
achieves better precision in the discovery process. What makes two concepts distinct is
not always their distance in a taxonomy tree, but the number of properties in which they
are the same and in which they are different. As a last difference, operational metrics of
Web services are not taken into account when discovering services.
186
González-Castillo, Trastour et al. (2001) also use DAML+OIL to semantically
describe Web services; their approach to the matchmaking of services is based on a
subsumption tree. Their algorithm follows a very similar approach to the one taken by
Paolucci, Kawamura et al. (2002), in the sense that it only accounts for relationships
among concepts defined within the same ontology. Their system does not use DAML-S
for the description of Web services (the system was developed before its existence).
Instead, they have developed their own specification for Web service description ,but no
notion of inputs and outputs was defined. As a result, the matching of Web services is
carried out based on service description, not accounting for inputs and outputs. Their
approach does not target the discovery of Web services based on operational metrics, nor
does it deal with the Web service integration problem.
Another approach that also uses a specific language to describe service
advertisements and requests is the LARKS (Language for Advertisement and Request for
Knowledge Sharing) system (Sycara, Klusch et al. 1999). The LARKS language can be
seen as a precursor of the DAML-S specification. The system uses ontologies defined by
a concept language (ITL). Their approach does not provide an automatic solution for the
computation of the similarity of concepts defined in distinct ontologies. Furthermore, the
technique used to calculate the similarity of ontological concepts involves the
construction of a weighted associative network, where the weights indicate the belief in
relationships. While they argue that the weights can be set automatically by default, it is
clear that the construction of realistically weighted relationships requires human
involvement, which becomes a hard task when thousands of agents are available. Their
work does not consider the matchmaking of agent-based operational metrics. While the
output and input parameters of agents are compared using syntactic and semantic
matching methods, the algorithm presented does not provide supply a mapping of
potential connections between the outputs and inputs of two agents that yields a
maximum degree of integration.
187
In the information retrieval area, Bejamins and Fensel (1998) present the (KA)2
system, an ontology-based information retrieval system for the World-Wide Web. The
system allows a community to build a knowledge base collectively, based on consensual
knowledge, by populating a shared ontology. Using the shared ontology, a web-crawler
accesses the web pages and uses the ontology to infer answers. The FindUr project
(McGuinness 1998) is another initiative in ontology-based information retrieval on the
Web. Their work focuses on query expansion and online searching. The use of ontologies
has been shown to improve the search from the perspectives of recall and precision, as
well as ease of query formation. The OntoSeek (Guarino, Masolo et al. 1999) project has
also shown that ontologies improve content-based searches. Their work focuses on
specific classes of information repositories: yellow pages and product catalogues.
Richardson and Smeaton (1995) introduce an approach to information retrieval based on
computing a semantic distance measurement between concepts or words and using this
word distance to compute the similarity between a query and a document.
Ontologies have been employed as a common basis for information integration.
Ontologies allow for the modeling of the semantic structure of individual information
sources, as well describing models of a domain that are independent of any particular
information source. Several systems have been developed using this solution. Projects
include Carnot (Woelk, Cannata et al. 1993), InfoSleuth (Bayardo, Bohrer et al. 1997),
SIMS (Arens, Hsu et al. 1996), OBSERVER (Mena, Kashyap et al. 1996; Kashyap and
Sheth 1998), and COIN (Bressan, Fynn et al. 1997). These projects differ from our work
in their reduced number of ontologies involved in the integration process and due to their
approaches, which require user involvement to manually resolve diffreences among
ontologies. Additionally, a vast amount of the work done is directed to solve schematic
differences in multidatabase systems; this does not face the schema polarity problem .
188
4.9 CONCLUSIONS
In this paper we have presented a set of challenges that the emergence of Web services
and e-services has brought to organizations. While in some cases Web services may be
utilized in an isolated form, it is normal to expect Web services to be integrated as part of
workflows processes. This entails research in two areas. Mechanisms to efficiently
discover Web services during an e-workflow (i.e., a workflow managing traditional tasks
and Web services) composition process and to facilitate their subsequent integration with
the e-workflow host.
We present a methodology and a set of algorithms for Web service discovery based
on three dimensions: syntax, operational metrics, and semantics. This approach allows for
Web service discovery not only based on functional requirements, but also on operational
metrics.
The need to discover workflow components based on operational metrics has a
greater importance when Web services are involved, as compared to workflow tasks. The
autonomy of Web services does not allow for users to identify their operational metrics at
design time, i.e., before their actual execution. The development of mechanisms for the
discovery of Web services based on operational metrics allows organizations to translate
their vision into their business processes more efficiently, since -eworkflows can be
designed according to QoS requirements, goals, and objectives.
To facilitate the discovery and posteriori integration of Web service into workflows
we propose an approach based on the use of ontologies to describe workflow tasks and
Web service interfaces. Ontology-based approaches have already proved to be an
important solution to information integration in order to achieve interoperability. During
an e-workflow composition, there is a loss of semantics associated with Web service task
interfaces because a large part of the domain knowledge a developer employs when
deploying a Web service is not present at composition time.
189
In our work we have devised an algorithm and implemented a prototype to discover
and facilitate the resolution of structural and semantic differences during the integration
process with an e-workflow. The algorithm uses a feature-based model to find similarities
across workflow tasks and Web service interfaces. The system determines and evaluates