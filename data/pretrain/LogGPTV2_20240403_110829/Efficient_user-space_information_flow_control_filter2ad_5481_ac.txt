Figure 5: Sparse Labeling for Encodings
σ, θ, e1 ↓pc σ1, true
σ1, θ, e2 ↓pc σ(cid:48), v
σ, θ, (if e1 then e2 else e3) ↓pc σ(cid:48), v
[S-THEN]
σ, θ, e1 ↓pc σ1, true k
σ1, θ, e2 ↓pc(cid:116)k σ(cid:48), v
σ, θ, (if e1 then e2 else e3) ↓pc σ(cid:48),(cid:104)k(cid:105)pc v
[S-THEN-SLOW]
σ, θ, e1 ↓pc σ1, v1
σ1, θ, e2 ↓pc σ2, v2
σ, θ, (pair e1 e2) ↓pc σ2, (v1, v2)
σ, θ, e ↓pc σ(cid:48), (v1, v2)
σ, θ, (fst e) ↓pc σ(cid:48), v1
σ, θ, e ↓pc σ(cid:48), (v1, v2)
σ, θ, (snd e) ↓pc σ(cid:48), v2
σ, θ, e1 ⇓pc σ1, v1
σ1, θ[x := v1], e2 ⇓pc σ(cid:48), v
σ, θ, (let x = e1 in e2) ⇓pc σ(cid:48), v
σ, θ, e1 ⇓pc σ1, v1
σ1, θ, e2 ⇓pc σ(cid:48), v
σ, θ, (e1; e2) ⇓pc σ(cid:48), v
[S-PAIR]
[S-FST]
[S-SND]
[S-LET]
[S-SEMI]
PROOF By induction on the derivation of σ, e ⇓H σ(cid:48), v, and
case analysis on the ﬁnal rule in the derivation.
• [S-CONST], [S-FUN], [S-VAR]: σ(cid:48) = σ.
• [S-APP], [S-APP-SLOW], [S-LABEL], [S-PRIM], [S-PRIM-SLOW],
[S-DEREF], [S-DEREF-SLOW]: By induction.
• [S-REF]: σ and σ(cid:48) agree on their common domain.
• [S-ASSIGN]: Let σ(cid:48) = σ2[a := v]. From the no-sensitive-
upgrade check, H = label(a). By Lemma 5, σ2(a) ∼H
H v
and so σ2 ≈H σ(cid:48). By induction, σ ≈H σ1 ≈H σ2. Also,
dom(σ) ⊆ dom(σ1) ⊆ dom(σ2) = dom(σ(cid:48)). Hence,
σ ≈H σ(cid:48).
• [S-ASSIGN-SLOW]: Similar.
We next show that non-inference holds for the sparse-
labeling semantics: if e is executed twice from H-compatible
stores and H-equivalent substitutions, then the two execu-
tions yield H-compatible resulting stores and H-equivalent
resulting values.
THEOREM 2 (Non-Interference for Sparse Labeling).
If
σ1 ≈H σ2
θ1 ∼pc
H θ2
σ1, θ1, e ↓pc σ(cid:48)
σ2, θ2, e ↓pc σ(cid:48)
1, v1
2, v2
σ, θ, e ↓pc σ(cid:48), (v1, v2)k
σ, θ, (fst e) ↓pc σ(cid:48),(cid:104)k(cid:105)pc v1
σ, θ, e ↓pc σ(cid:48), (v1, v2)k
σ, θ, (snd e) ↓pc σ(cid:48),(cid:104)k(cid:105)pc v2
[S-FST-SLOW]
[S-SND-SLOW]
then
1 ≈H σ(cid:48)
σ(cid:48)
v1 ∼pc
2
H v2
PROOF By induction on the derivation σ1, θ1, e ↓pc σ(cid:48)
1, v1
and case analysis on the last rule used in that derivation. The
details of the case analysis are presented in Appendix A.
5. Experimental Results
In order to evaluate the relative costs of universal and sparse
labeling, we developed three different language implemen-
tations. The implementations all support the same language,
which is an extension of λinfo with features necessary for re-
alistic programming. These features include pairs and lists
built as a native part of the language, strings, and associated
utility functions. The three implementations are:
• NOLABEL is a traditional interpreter that performs no
labeling or information ﬂow analysis, and so establishes
our baseline for performance;
• UNIVERSALLABEL, which implements the universal la-
beling semantics; and
• SPARSELABEL, which implements the sparse labeling
semantics.
Benchmark
SumList
UserPwdFine
UserPwdCoarse
FileSys0
FileSys25
FileSys50
FileSys100
FileSysExplicit
ImplicitFlowTrue
ImplicitFlowFalse
Average
Table 1: Benchmark Results
NOLABEL
(secs/100k runs)
2.295382
1.248581
1.251994
23.206768
24.843616
24.840610
24.455563
24.470711
0.028825
0.031577
-
UNIVERSALLABEL
(vs NOLABEL)
1.94
1.63
2.45
3.38
3.00
3.54
4.12
Information leak prevented
Information leak prevented
1.04
2.64
SPARSELABEL
(vs. NOLABEL)
0.79
1.12
1.03
1.07
1.22
1.27
1.62
Information leak prevented
Information leak prevented
1.01
1.14
(vs. UNIVERSALLABEL)
0.41
0.68
0.42
0.32
0.41
0.36
0.39
Information leak prevented
Information leak prevented
0.98
0.50
We compared these implementations on the following
benchmark programs:
• SumList: Calculates the sum for a list of 100 numbers.
There are no labels so that we can show the overhead
when information ﬂow is not needed.
• UserPwdFine: Simulates a login by looking up a user-
name and password in an association list. The passwords
stored in the list are labeled as “secret”.
• UserPwdCoarse: Identical to UserPwdFine, except that
the entire association list is labeled as “secret”.
• FileSys0: Reads a ﬁle from an in-memory ﬁle system
implemented in our target language, and represented as
a directory tree structure. The ﬁle system contains 1023
directories and 2048 regular ﬁles, and contains no non-
trivial labels.
• FileSys25, FileSys50, and FileSys100: Identical to
FileSys0, except that 25%, 50%, and 100% of the ﬁles
and directories are labeled as “secret”, respectively.
• FileSysExplicit: Identical to FileSys100, except
that this benchmark causes a information leak by an ex-
plicit ﬂow.
• ImplicitFlowTrue and ImplicitFlowFalse: Imple-
ments the implicit information ﬂow leak example dis-
cussed in Section 3, where the conﬁdential variable x is
given values of true and false, respectively.
We ran our tests on a MacBook Pro with a 2.6 GHz Intel
Core 2 Duo processor, 4 gigabytes of RAM, and running
OS X version 10.5.6. All three language implementations
were interpreters written in Objective Caml and compiled to
native code with ocamlopt version 3.10.0. All benchmarks
were run 100,000 times, and Table 1 summarizes the results.
In almost all cases, NOLABEL performs the fastest but
permits information leaks, as on FILESYSEXPLICIT and
IMPLICITFLOWTRUE benchmarks. (Note that IMPLICIT-
FLOWFALSE leaks one bit of termination information in all
three implementations, as expected.) Column three shows
the slowdown of UNIVERSALLABEL over NOLABEL, which
is on average more than a 2.6x slowdown, and may be unac-
ceptable in many situations. In contrast, column ﬁve shows
that the SPARSELABEL running time is only 50% of the
UNIVERSALLABEL running time. Thus, our results show
that the sparse labeling runs much closer to the speed of
code with no labels.
Our tests also identiﬁed an additional, unexpected bene-
ﬁt of the sparse labeling strategy. The SPARSELABEL im-
plementation was noticeably less affected by differences in
the style of programmer annotations. This is most visible
in the results of UserPwdFine and UserPwdCoarse. The
UNIVERSALLABEL implementation suffered a 50% perfor-
mance penalty, even though there were less annotations.
Whenever a ﬁeld is pulled from a secure list, it must be
given a label matching the list. In contrast, the SPARSELA-
BEL implementation’s performance was comparable on both
UserPwdFine and UserPwdCoarse. Thus, with a sparse la-
beling strategy, the programmer is to some degree insulated
from performance concerns, and can instead focus on the
proper policy from a security perspective.
While these experimental results are for a preliminary,
interpreter-based implementation, these results do suggest
that sparse labeling may also provide signiﬁcant beneﬁts in
a highly-optimized language implementation. We are cur-
rently adding sparse labeling into the Narcissus JavaScript
implementation [Eich] and are exploring how to incorporate
these ideas into the SpiderMonkey trace-based compiler for
JavaScript [Gal et al. 2009].
6. Related Work
Denning’s seminal work [Denning 1976] outlines the gen-
eral approach to dynamic information ﬂow. Denning and
Denning [1977] presents a static analysis to certify pro-
grams as being information-ﬂow secure. Sabelfeld and My-
ers [2003] provide an extensive survey of prior research on
information ﬂow. Among other things, they discuss vari-
ous covert channels, including timing channels and resource
exhaustion channels. We do not address these attacks in
λinfo, and instead focus only on implicit and explicit ﬂows.
Venkatakrishnan et al. [2006] perform a hybrid of static and
dynamic analysis. The static analysis is used to transform
the code in order to instrument it with the appropriate run-
time checks.
Several approaches use type systems for information ﬂow
analysis. Volpano et al. [1996] introduce a type system based
on Denning’s model and proved its soundness. Heintze and
Riecke [1998] create a simple calculus and show how it can
be expanded to deal with concurrency, assignment, and in-
tegrity. Pottier and Simonet [2003] introduce type inference
to ML (speciﬁcally a variation called Core ML).
Non-interference is one of the most common correctness
criteria for information ﬂow analyses. Barthe et al. [2004]
discuss better approaches for analyzing non-interference,
which were extended by Terauchi and Aiken [2005]. McLean
[1992] shows that non-interference can be proved on a trace,
rather than the usual intermediate step of a state machine.
Boudol [2008] argues that non-interference is not necessar-
ily the best property to use, speciﬁcally because it rules out
programs that deliberately declassify information. Instead,
the author suggests using an intensional notion of security.
Fenton [1974] presents a dynamic analysis for informa-
tion ﬂow; the analysis requires that each mutable variable
has a ﬁxed security label, which is somewhat restrictive. Our
approach allows these security labels to be dynamically up-
graded, while the no-sensitive-upgrade check still prohibits
implicit information leaks.
A few papers highlight the challenges of working with
more advanced features of languages. Banerjee and Nau-
mann [2002] address complications caused by dynamic
memory allocation for information ﬂow analysis. King et al.
[2008] highlight the problems with false alarms caused by
implicit ﬂows, and in particular exceptions. λinfo has neither
of these features; extending it to address these topics remains
an area for future work.
Web programming has become one of the central targets
for information ﬂow analyses. On the server side, Haldar
et al. [2005] introduce dynamic taint propagation for Java.
Lam et al. [2008] focus on defending against SQL injection
and cross-site scripting attacks. Zheng and Myers [2008] ad-
dress web encryption speciﬁcally through static information
ﬂow analysis. Dealing with information release (e.g., for
password validation) is an interesting case for information
ﬂow, since certain outputs must be declassiﬁed; Both Chong
and Myers [2004] and Fournet and Rezk [2008] address this.
In addition to the server-side, there has been a great deal
of interest in information ﬂow analysis for client-side pro-
gramming. Primarily, this centers around Java applets and,
more recently, JavaScript. Myers and Liskov [1997] use a
decentralized information control model for Java applets.
JFlow [Myers 1999] has become one of the standards for
information ﬂow analysis on the JVM. Chandra and Franz
[2007] also combine static and dynamic analysis for the
JVM, but permitting the information ﬂow policies to be
changed at runtime. Interestingly, client-side research is
more focused on conﬁdentiality, whereas server-side pro-
gramming tends to address integrity concerns in more depth.
Unlike with Java code, JavaScript is not compiled in ad-
vance. Faced with this limitation,Vogt et al. [2007] add in-
formation ﬂow analysis to JavaScript that relies on dynamic
analysis whenever possible. Although we have not directly
dealt with JavaScript, this is one of our central motivations.
Although static analysis has been considered indispens-
able in many approaches, the beneﬁts of dynamic analysis
are becoming appreciated. Le Guernic et al. [2006] discuss
using dynamic automaton-based monitoring. Askarov et al.
[2008] highlight the risks with Denning-style analysis. In
particular, they show that if intermediary output is allowed,
the assumption that only one bit of information leaks with
termination is not valid. Although λinfo does not technically
permit intermediary output, it will be a clear concern as we
extend sparse labeling to more realistic languages. Malacaria
and Chen [2008] also provide a framework for quantifying
exactly how much information can leak with a given model.
O’Neill et al. [2006] have highlighted some of the complica-
tions that are introduced through interactive programs. Since
many web-based applications fall into this domain, this is of
particular interest to us.
Our sparse labeling strategy is inspired by prior work on
contracts [Findler 2002] and language interoperation [Gray
et al. 2005]. In particular, each security domain can be
viewed as a separate “language”, and explicit labels function
as proxies that permit transparent interoperation between
these multiple languages.
7. Conclusions
With the increasing importance of JavaScript and similar
languages, fast and correct information ﬂow analysis at run
time is essential. We have shown that, through sparse label-
ing, it is possible to track information ﬂow dynamically with
reduced overhead. We believe these techniques may help to
further safe client-side scripting.
Acknowledgments
We thank Brendan Eich, Andreas Gal, and Michael Franz for
valuable discussions on dynamic information ﬂow analysis.
References
Aslan Askarov, Sebastian Hunt, Andrei Sabelfeld, and David
Sands. Termination-insensitive noninterference leaks more than
just a bit. In ESORICS ’08: Proceedings of the 13th European
Symposium on Research in Computer Security, pages 333–348,
Berlin, Heidelberg, 2008. Springer-Verlag.
Anindya Banerjee and David A. Naumann.
Secure informa-
tion ﬂow and pointer conﬁnement in a java-like language.
In
IEEE Computer Security Foundations Workshop, pages 253–
267. IEEE Computer Society, 2002.
Gilles Barthe, Pedro R. D’Argenio, and Tamara Rezk. Secure in-
formation ﬂow by self-composition. In IEEE Computer Security
Foundations Workshop, pages 100–114. IEEE Computer Soci-
ety, 2004.