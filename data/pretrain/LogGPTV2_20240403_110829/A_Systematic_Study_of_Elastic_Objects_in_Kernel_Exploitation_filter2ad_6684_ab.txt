(e.g., n=objB->N in Figure 2), we preserve the calling sites and further
perform backward analysis for the taint source corresponding to the
data argument mentioned above (e.g., the argument src in Figure 2).
Slightly different from our backward taint analysis applied to the
length argument, we first follow the data flow reversely and track
down all the sites where the corresponding data argument is ini-
tialized (e.g., ❶ src=&buffer, ❷ src=&objA->buffer, and ❸ src=objA->p).
Starting from these variable assignment sites, we then analyze the
type of the variable accordingly.
For the variable referencing a memory region on the stack (e.g.,
the dotted line ❶ in Figure 2), we conclude that an adversary could
potentially obtain an ability to overread data on the stack if an
overwriting capability allows the adversary to manipulate the cor-
responding length argument through the variable identified on the
heap (e.g., objB->N in Figure 2). By using this stack overread capabil-
ity, we can further conclude the capability of disclosing the stack
canary and the return address to bypass KASLR. Concerning the
variables allocated on the non-stack region (i.e., the heap area3),
they could be categorized into the following two types, providing
an adversary with different exploitability.
The first type indicates the variable referencing the address of
one field in a kernel object (e.g., the dotted line ❷ in Figure 2). For
this type of variable, we conclude that an adversary could poten-
tially obtain an ability to bypass KASLR or forge a legitimate heap
cookie. The reason is that an adversary could utilize an overwriting
capability to vary the corresponding length argument (e.g., objB->N
3Note that the kernel needs to determine the size of the buffer on the global area at
the compilation time. Therefore, a variable tied to a data argument cannot be present
on the global region if the data argument references an elastic buffer.
Figure 2: The illustration of backward taint analysis starting
from copy_to_user(). Argument n originates from field N inside
elastic object objB. From different paths, taint analysis con-
cludes argument src could come from three different vari-
ables indicated by ❶∼❸.
For allocation functions in kmem-cache, mcache_alloc, or uma_zalloc
(cid:44)→ series, their first argument is always a static or global pointer
referencing a special cache/zone. For example, to allocate a ker-
nel object in the type of struct seq_file, the allocation function
kmem_cache_zalloc() puts seq_file_cache as its first argument, explic-
itly specifying the cache/zone the object belongs to. For a kernel
object allocated in this manner, we can easily point out the cor-
responding cache/zone in which the object fits. Different from
allocation functions designed for the special cache/zone, alloca-
tion functions in kmalloc, kalloc, and malloc series use constant or
sometimes constant plus a variable as its first argument, indicating
the size of the allocated object. For the functions with a constant
as their first argument, we can easily associate the kernel object
with the corresponding cache/zone. For example, if the Linux ker-
nel allocates an object with 132 bytes, we can associate the cache
kmalloc-192 with the object because a 132-byte kernel object is too
large for kmalloc-128 and overly small for kmalloc-256. For the allo-
cation functions with the first argument in the form of a constant
plus a variable, at this particular stage, we temporarily tie the corre-
sponding object to all the general caches/zones with the size greater
than the constant.
3.2 Filtering out Object Candidates
Recall that the length field in an elastic object indicates the size of a
kernel buffer. Also, to use an elastic object to perform exploitation,
one must ensure there is a channel to disclose the data in the buffer
to the userspace. However, the object candidates identified above do
not imply that their enclosed integer variable represents the size of
Sample record[+]                ip_options(1)[cache]         kmalloc_16*(2)[len offset]    [8, 9)(3)[ptr offset]    NA (4)[alloc site]    net/ipv4/ip_output.c:1251(5)[leak  anchor]  net/ipv4/ip_sockglue.c:1356(6)[capability]    stack canary, KASLRNpp and N are in the same objectHeapnArbitrary memorybufferoverread    copy_to_user (dst, src, n )Stack    n = objB->N    bufferoverreadn    canary…overread    nret addrbuffer123  src = &buffer  src = &objA->buffer  src = objA->p 123Figure 3: The summarization of vulnerability capability &
demonstration of buffer overread through the capability.
in Figure 2), follow the corresponding path to trigger the critical
function (e.g., copy_to_user()), and eventually obtain an overread
primitive on the heap. Using a state-of-the-art technique [11, 12]
to manipulate heap layout, the adversary could easily turn this
overread ability on the heap into the ability to bypass KASLR and
heap cookie protector.
The second type of variables are pointers enclosed in the kernel
objects (e.g., the dotted line ❸ in Figure 2). For this type of vari-
able, before drawing any conclusion, we take one additional step,
which continues backward taint analysis, and examines whether
the variable, as well as that tied to the length argument, are both in
the same object. In this work, we conclude that the kernel objects
with such a property can potentially provide an adversary with the
ability to not only bypass KASLR but, more importantly, perform
arbitrary kernel read. The reason behind this conclusion is as fol-
lows. For variables (associated with the length and data arguments)
enclosed in the same kernel object, an adversary could potentially
allocate the object in the cache/zone same as that of the vulnerable
object and thus utilize the overwriting ability to manipulate both
variables accordingly (e.g., manipulating p and N in Figure 2). Since
the variable tied to the length argument indicates how many bytes
of data one could read, and the other variable specifies from which
memory region one could read the data, the manipulation capability
turns the overwriting vulnerability into an arbitrary read primitive.
With this primitive, the adversary could read the content in the
interrupt descriptor table (IDT), compute the base address, and
thus circumvent KASLR. Besides, as the previous research [43] has
already demonstrated, the adversary could also use this arbitrary
read primitive to dump memory and search for the string “root:!:”
in the memory. Since this string is part of the file “/etc/shadow”, the
adversary could disclose a user’s hashed password and potentially
recover the password by using password cracker (e.g., John the
Ripper password cracker [56]).
In this work, for each of leaking anchors surviving from the
analysis above, we store the corresponding conclusive capabilities
in a database for the consecutive analysis (e.g., “stack canary” and
“KASLR” depicted in Figure 2). For the elastic kernel objects and
corresponding structures included in the candidate set but not asso-
ciated with any critical functions, they do not satisfy the definition
of elastic kernel objects (i.e., having a channel to disclose data in
the elastic kernel buffer to userspace). Therefore, we discard such
objects and structures from the candidate set. By following the
analysis above as well as the way to knock off unqualified elastic
objects, we can eventually filter out all the elastic kernel objects
useful for exploitation and, thus, mitigation circumvention.
3.3 Pairing Vulnerabilities with Objects
Through the analysis above, we could obtain the information re-
garding each of the elastic objects. As is shown in Figure 2, the
information includes (1) the caches or zones tied to each object, (2)
the offset of the length field corresponding to the head of the object,
(3) the offset of the elastic buffer corresponding to the object head if
the pointer referring the elastic buffer and the length field share the
same object, (4) the sites where the kernel allocates the object, (5)
the leaking anchor(s), and (6) conclusive capability inferred through
the paths toward the corresponding leaking anchor(s).
With the information in hand, given a vulnerability, we could
use the following approach to pair that vulnerability with elastic
objects accordingly. First, we utilize a debugging tool (GDB [65])
to track the execution of a PoC program triggering the vulnera-
bility but not necessarily performing actual exploitation. Based
on our observation from the debugging tool, we then identify the
cache where the vulnerability corrupts data. Besides, we manually
summarize, to which specific memory locations in that cache, the
vulnerability gives an attacker the ability to overwrite data. At each
location, what value range could be under an attacker’s control.
For example, as is shown in Figure 3, through our manual analysis
against an out-of-bound vulnerability, we can discover that the vul-
nerability overflows a vulnerable object in the cache kmalloc-128
and corrupts data in it adjacent spot. Recall that we can allocate an
elastic object at that adjacent spot by using the technique proposed
in [11, 12]. Therefore, we can manually summarize the region under
corruption is the first and the third 8 bytes of that elastic object,
and the values put into these two regions have to be greater than
128 and equal to 1024, respectively.
In this work, we deem these summarized results as the capa-
bility of a vulnerability and utilize a list of 2-tuples [(VCache1,
Cap1), . . . , (VCachen, Capm)] to model such a capability.
Here, VCachei indicates the cache the vulnerability could corrupt,
and Capj represents the range of unauthorized memory region at
which vulnerability could overwrite data. Considering that, in one
particular cache, a vulnerability might have the ability to modify
data at multiple memory regions, we represent the Capj as a list
of assertions [(Rj1|Opj1|Vj1), . . . , (Rjx |Opjx |Vjx )]. In this
assertion list, the notation Rjk indicates the unauthorized memory
area where, through the corresponding vulnerability, an attacker
could manipulate. The notations Opjk and Vjk altogether specify
the attacker’s control over that region. To illustrate this, we again
take, for example, the case shown in Figure 3. Using the represen-
tation above, we could write the capability of that vulnerability
as (kmalloc-128, [([0, 8)⩾128), ([8, 16)=1024)]). Here,
kmalloc-128 denotes the cache the vulnerability could corrupt. [0,
8)⩾128 and [8, 16)=1024 indicate the ranges of values that an
adversary could put into the corresponding memory regions.
By using the modeling approach above to describe the capability
of a vulnerability, we can automatically pair a vulnerability with
those elastic objects useful for exploitation. To be specific, given a
vulnerability, we first filter out all the elastic objects, if the caches or
zones they tie to (indicated by the notation OCache1 · · · OCacheh)
happen to have an overlap with the caches associated with the
vulnerability (i.e., ∃i ∈ [1 , n], ∃j ∈ [1 , h] | (VCachei = OCachej)).
For each elastic objects filtered out, we then examine whether the
vul obj081624kmalloc-128[0, 8)>=128   [8, 16)=1024multiple objects / slotsptrptr+kbufferptr+1024Nregion under the  control of attacker original sizeNkmalloc-192memory regions under manipulation cover its length field4. With
this examination, we can preserve the elastic objects with their
length field covered and thus narrow down the elastic objects useful
for exploitation further. For the elastic kernel objects preserved, last
but not least, we check if an adversary could use his overwriting
ability to manipulate the length field and thus go over the boundary
of the elastic buffer. Take the vulnerability capability mentioned
above, for example. Assume the length field of an elastic object is
at the third 8 bytes, and the object contains a pointer referencing a
buffer in an object located at the cache kmalloc-192. Given part
of the vulnerability capability ([16, 24)=1024), we can conclude
the attacker could change the size of the elastic buffer to 1024 and
thus overread the buffer and access the data in its entire adjacent
slot (see Figure 3). With this ability, we can further conclude the
attacker could potentially forge heap cookies and bypass KASLR
because he/she could keep that slot adjacent to the buffer either
unoccupied or occupied with an object enclosing a function pointer.
In this work, to determine the overread ability and thus conclude
corresponding exploitability, we utilize the following strategies.
For the elastic buffer on the heap, we check whether the newly
manipulated buffer size is at least twice as large as the cache (at
which the buffer is located). With this, regardless of the position of
the buffer in an object, we can always guarantee to overread the
entire adjacent slot or kernel object and thus potentially give an
adversary the ability to bypass KASLR or forge a legitimate heap
cookie. For the elastic buffer on the stack, we compute the stack
frame where the elastic buffer is located and then examine whether
the newly manipulated buffer size is larger than the frame size.
With this, we can ensure an adversary could always have access
to the stack canary and the return address. It should be noted that
the restriction we impose upon the process of determining possible
exploitability is very tight. Even if some of them do not hold, it is
still possible to bypass corresponding mitigation. In this work, we
impose universal, tight restrictions. First, it is because the design
eases our process in finding elastic kernel objects and concluding
exploitability. Second, it is because the tight restriction represents
the lower bound of a concluded exploitability.
Through the series of examinations above, for any individual
vulnerability, we can easily track down the corresponding elastic
objects friendly for exploitation. However, this does not imply that
the vulnerability could automatically inherit the security implica-
tion tied to the elastic objects. On the paths toward the leakage
sites after the manipulation of an elastic object, the kernel might
use the manipulated fields as branch predictors. With an improper
modification on some of the fields, the kernel execution might be
detoured, and the kernel would no longer invoke the critical func-
tions like copy_to_user(). In some situations, the kernel may even
accidentally touch invalid or non-permitted memory regions and
thus trigger general page fault (GPF) and even kernel panic. As a
result, before concluding the process of pairing vulnerabilities with
elastic objects, we perform further analysis as follows.
Given a vulnerability and one of its corresponding elastic objects
identified through the method mentioned above, we first retrieve all
4Note that we also examine the manipulable memory region covers the elastic buffer if
both the pointer referring the elastic buffer and the length field share the same object.
In this work, we record the elastic object with this property because this indicates the
object could potentially offer the capability of arbitrary read.
Figure 4: The illustration of constraint extraction from two
paths. ELOISE preserves only the constraints pertaining to
the manipulated fields in elastic object obj (i.e., C1 & C2).
its paths towards leaking anchors (see Figure 4). Along each path,
we first extract all the pointer dereferences. Then, we refine the set
of branching constraints that must hold in order to reach out to the
leakage site. For each of the dereferenced pointers, we ensure the
pointer references a legit memory area if memory manipulation
inevitably touches its original value. For the constraint set, we pay
particular attention to the constraints in which the manipulated
fields in the elastic object are enclosed or has data dependency with
the variable involved. For example, as is illustrated in Figure 4, after
the manipulation of an elastic kernel object, manipulated values
fill the length field N and one of its adjacent fields f. By performing
the analysis above, we can first identify two distinct paths through
which an attacker could potentially disclose data through an elastic
buffer. Then, we can filter out all the constraints pertaining to the
length field and its adjacent field (e.g., C1=obj.f>0; C2=obj.N 0 = [0, 8) > 0C2 = obj.N B->len, B is the actual elastic object that encloses
the length field. As a result, to avoid mistakenly taking A as the
elastic object, ELOISE taints only one LoadInst backward if a multi-
layer dereference involves at the leaking anchor. As is mentioned
in Section 3.2, we also need to determine which memory region
the corresponding function arguments refer to (e.g., stack, heap,
or global). In our implementation, ELOISE distinguishes memory
regions by following the rules below. If the memory region is from
AllocaInst instructions which allocate memory on stack, we deem
the region as part of the stack. If the memory region is represented
by a global/static variable, we assign it to a global area. Otherwise,
we conservatively treat it as a memory region on the heap.
Critical constraint set extraction. As is described in Section 3.3,
before pairing a vulnerability with elastic objects, we need to collect
the constraint sets from the paths that lead kernel execution to the
leaking anchor but not detour it to other sites or trigger accidental
execution termination. To do this, ELOISE analyzes LLVM IR to
determine the usage of object fields in each path towards leaking
anchors based on the semantics of instructions. For example, if
a field in an object is used in the instruction CmpInst, ELOISE first
interprets the comparison by its Predicate (e.g., ICMP_ULT means the
greater relationship “>”). Then, it checks which branch can reach
the corresponding anchor. In this example, we keep the “>” operator
if only the TRUE branch can reach the anchor. We flip the the operator
into “≤” if only the FALSE branch reaches the anchor or the length
argument can be updated in TRUE branch. Otherwise, we discard this