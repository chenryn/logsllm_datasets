title:How to Model Link Failures: A Perception-Based Fault Model
author:Ulrich Schmid
How to Model Link Failures: A Perception-based Fault Model 
ULRICH SCHMID 
Technische Universitat Wien 
Department of Automation 
TreitlstraRe I ,  A- 1040 Vienna 
Email: PI:EMAIL 
Phone: ++43- 1-58801- 18325, FAX: ++43- 1-58801-18391 
Abstract 
We propose a new hybrid fault model for clock synchro- 
nization and single-round (approximate) agreement in syn- 
chronous distributed  systems’, which accurately  captures 
both  node  and  link faults.  Unlike conventional  “global” 
fault  models,  which  rest  upon  the  total  number of faulty 
nodes in the system, it solely relies upon the number offaults 
in any two non-faulty nodes’ “perceptions” -conveyed  by 
the  messages from  all  other  nodes-  of  the  system.  This 
way,  arbitrary  node  and  communication faults,  including 
receiver-caused omission and timehalue faults, can be mod- 
eled properly. As an example2, we show that the consistent 
broadcast primitive  -and  hence the clock synchronization 
algorithms-  of  Srikanth  &  Toueg  can be  analyzed  under 
this model. As far as link faults are concerned, our analysis 
reveals that as few as 4 f t a  + 2 fes  + 2 feO + 1 nodes are suf- 
ficient for tolerating at most fea,  fes,  and feO  asymmetric, 
syninietric, and omission link faults at any receiving node. 
Keywords:  Fault-tolerant distributed  systems, fault mod- 
els,  link failures,  consistent  broadcasting,  clock  synchro- 
nization. 
1  Motivation 
One of the most important abstractions facilitating a co- 
herent view of the huge literature on distributed algorithms 
-and  hence books like Lynch’s 181- 
is the “deterministic” 
fault model: To be able to reason deterministically about the 
execution of a distributed algorithm, it is usually  assumed 
that  at  most f of the n nodes  in  the system may  be faulty 
at any time.  Apart from being simple and  easy to handle, 
this model also captures both  node and sender-caused link 
faults adequately. 
‘This  research  has  been  conducted  in  our  SynUTC-project  (see 
U T U )  supported  by  the  Aus- 
http:/~r.~r~~.unriru.ru~~ieri.uc.ur/Pr~jects/S~ri 
trian  START programme Y41-MAT. 
?Lacking space did not allow us to include the analysis of convergence- 
function-based algorithms  in this  paper;  consult  [ 131 for a more compre- 
hensive treatment. 
Still,  a  link consists  of  the  sender’s network  interface, 
the channel, and finally the receiver’s network interface. As 
the  latter unites  messages  from  all  other  nodes,  it  is  par- 
ticularly  susceptible  to  faults:  Omission  failures in  mod- 
ern wireline  and, most notably, wireless networks are typ- 
ically caused by  receiver overruns (run out of buffers), un- 
recognized packets (synchronization errors), and CRC er- 
rors (data reception problems).  Since any arriving message 
- e v e n  several  consecutive  ones- 
could  be  affected, the 
resulting receive omissions cannot be attributed to the “in- 
nocent” sending nodes. 
Another example are receiver-caused  timing failures  in 
applications that  disseminate time-dependent information, 
as  in  clock  synchronization  [20,  171.  Since  the  received 
information varies  with  the experienced end-to-end trans- 
mission delay here, excessive delays can easily produce in- 
correct --even inconsistent,  i.e.,  Byzantine- 
information 
at the receiving end(s).  The major sources of excessive de- 
lays, however, are network controller receive-FIFOs and de- 
vice driver in-bound queues, see e.g.  [16].  Again, blaming 
the sending nodes for those receiver-caused link faults is in- 
appropriate. 
Such link  faults’  must obviously be ascribed to  the re- 
ceiving nodes, and considered independent of each other at 
different receivers.  Like node faults, they should be classi- 
fied according to a hybrid fault model to ensure maximum 
fault-tolerance under realistic operating conditions. Unfor- 
tunately, however, there is no obvious way to accommodate 
link faults in a global fault model for synchronous‘  systems 
at all. 
The major  contribution  of  this  paper  is  an  alternative 
perception-based hybrid fault model for clock synchroniza- 
tion and single-round agreement algorithms, which provides 
all the required features.  It has been stimulated by the fault 
model utilized for our analysis of interval-based  clock syn- 
3Since sender-caused link faults can be counted as node faults, we will 
use the term lirikfuulr exclusively  for receiver-caused  ones. 
.‘Note  that  it  is  relatively  easy  to  handle  link  faults  in  asynchronous 
systems satisfying the “fair loss” property: If sending an infinite number of 
messages over a link causes an infinite number of messages to be received, 
a perfect link can be simulated by suitable retransmission schemes, see e.g. 
[ I ,  261. Clearly, this approach cannot be used in synchronous systems. 
0-7695-1101-5/01 $10.00 0 2001 IEEE 
57 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:59:22 UTC from IEEE Xplore.  Restrictions apply. 
chronization [ 14,  181.  Following  an  informal introduction 
in  Section 2  and  its formalization  in  Section 3, we  show 
in Section 4 that a properly  adapted implementation of the 
consistent broadcast  primitive -and 
hence the clock syn- 
chronization algorithm-  of Srikanth & Toueg  [21] can be 
analyzed under this model.  Some conclusions in Section 5 
eventually round off the paper. 
2  Informal Overview 
We consider synchronous distributed systems consisting 
of n nodes, which are interconnected by  a fully connected 
point-to-point or broadcast-type network. The basic assump- 
tions are the following: 
(a)  Each receiving  node can reliably  identify  the sender 
of a message, 
(b)  Flooding or jamming  “foreign”  links / the broadcast 
network is impossible. 
Nodes and links may fail according to various fault mod- 
els, ranging from a simple fail-stop model up to a Byzantine 
one, where faulty  nodesninks can  take  arbitrary steps and 
transmit (and “receive”) any number of arbitrary messages. 
Conventional fault models, like the  one that  at  most  f 
nodes may behave Byzantine at any time, usually rest upon 
the total number of faults in the entire system. The usual as- 
sumption of entire nodes as fault containment regions, how- 
ever, makes it difficult to accommodate link faults in  such 
models:  In [5], for example, link faults are simply mapped 
to sender node  faults.  If  we  grant each receiving node i, 
1 5 i  5  n, just  a single independent receive omission, it 
may  e.g. be the  case that  each node i  > 2  (resp. node  1) 
drops the message from sender i - 1 (resp. sender n), see 
Figure I.  Hence, all n nodes must be considered faulty in 
this particular execution. 
One might of  course argue that  the scenario portrayed 
in  Figure  1  is  a  quite unlikely  one.  Still,  receiver-caused 
link errors often affect multiple messages, which means that 
even less “exotic” fault patterns could lead to the above sit- 
uation.  In  any  case, we cannot rule out the possibility  of 
executions where any  reasonable f < n is exceeded in  a 
conventional global fault model.  This observation suggests 
that  approximate agreement algorithms cannot be  used  in 
presence of link faults. 
However, for single round agreement algorithms, there 
is in fact no need for relying upon the total number faults in 
the system:  Showing (approximate) agreement of all non- 
faulty  nodes  amounts to  showing,  in  a  pairwise  manner, 
that  any  two  non-faulty  nodes  achieve (almost)  the  same 
result.  For example, the usual clock synchronization condi- 
tion just requires that any two non-faulty  nodes’ clocks sat- 
isfy ICp(t) - Cq(t)l < K, without regard to the other nodes 
in  the  system.  Hence,  only  non-faulty receiving nodes p 
. .  
.
.
.
.
.
.
Figure 1. Systeni-wide broadcast with fe  = 1 receive 
oniissiotis per receiver: Any node niust be considered 
faulty in a conventional fault niodel here. 
and q need to be considered, and their sets of received mes- 
sages can be considered in  isolation.  Global fault assump- 
the one that &I receivers perceive a certain fault 
tions -like 
consistently- 
are indeed not required here. 
It  is hence quite natural  to move  to a perception-based 
fault model  as introduced in  our analysis of  interval-based 
clock synchronization [17,  14, 12,  181,  where the number 
of faults in any two non-faulty receivers’ perception vectors 
V, = (vi,. . . , v:)  resp. V, = (V:, . . . , V;)  --containing 
p’s resp.  q’s local perceptions V:  resp. V:  of node s,  1 5 
s  5 n, as conveyed by its messages- 
is considered. Apart 
from disposing of  the  system-wide number  of  faults, this 
approach also facilitates refined fault containment regions, 
namely, basic nodes (computation and emission), links, and 
node receiving units, since the  respective  faults are easily 
mapped to faulty perceptions. As shown in Figure 2, a node 
fault of sender s usually  affects the corresponding percep- 
tion V t  at all receiving nodes T  in a correlated fashion, al- 
though probably inconsistently  in case of a Byzantine fault. 
On the other hand, a link fault hitting the link from node s 
t o p  affects V i  in p’s perception  vector only, see Figure 3. 
Consequently, recalling the  above example of  fe  =  1 
receive omissions per node, it  is  obvious that  any  two  lo- 
cal  views can differ only  in  at most  2 f t   = 2  perceptions, 
namely, the ones where either receiving  node experienced 
its omission.  Moreover, only at  most fe  = 1 of  the non- 
faulty  perceptions present at some non-faulty  node can  be 
missing at any other non-faulty node. 
58 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:59:22 UTC from IEEE Xplore.  Restrictions apply. 
VI  = (V;, ..., y , .  . .,V?) 
v1  = (q1.. 
.  V;., . . . , V;) 
\  w 
v, =  , ,”., vp” ,..’, Vd”) 
AJ 
Node p 0 
---L  Node 4 0 
. .  V,“, . . . , V,“) 
I rrcvJ 
(rrcv) 
v n  = ( V A .  , V,.,  . . . , V,n) 
...  faulty 
Node n 
...  faulty 
IrrrvJ 
Figure 2. Effect of a node fault of sender s upon the 
perception vectors of all receivers r. AI1 perceptions 
V,S are usually faulty here, although probably incon- 
sistently affected in case of an arbitrary fault. 
Figure 3.  Effect  of  a  link fault  between  sender  s 
and receiver p  upon the perception vectors of all  re- 
ceivers r. Only Vp” is faulty here. 
In  sharp contrast to the pessimistic perspective derived 
from the global fault model, this suggests that approximate 
agreement algorithms should work well in presence of link 
faults.  And indeed, the result of Rushby’s formal verifica- 
tion  of the Interactive Convergence Algorithm  (ICA) [ 1 I] 
shows that  as  few  as n  2 2fe  + 1 nodes  are sufficient 
for ICA to cope with the scenario of Figure  1.  Note that, 
apart from our work  on  interval-based clock synchroniza- 
tion [ 17, 14, 12, 181, this paper seems to be the first and only 
one where something like a  perception-based  fault model 
has been employed before.  Still, it considers only  locally 
detectable (“manifest”) link faults, which do not cover more 
severe incidents like timing faults.  Our paper incorporates 
arbitrary link  faults and  shows that  algorithms  other  than 
ICA can be analyzed in this framework. 
Some recent papers [ 13, 191 reveal that other distributed 
algorithms also have fault-tolerance capabilities that are bet- 
ter than traditional analysis suggests. It is important to note, 
though, that improving the fault-tolerance w.r.t.  node faults 
is impossible:  After all, a global fault assumption like  “at 
most f nodes may appear Byzantine” also implies “at most 
f pairs of perceptions may appear Byzantine”, for any pair 
of  non-faulty  receiving  nodes.  A  perception-based  fault 
model thus “preserves” the corresponding global one, which 
means that classic impossibility results  like  [4, 31  remain 
valid. 
3 
Formal Framework 
In  order to formalize our perception-based fault model, 
we  assume that  all  nodes  s,  1 5  s  5  n, are  somehow 
provided  with  a (virtual) event V”[t“] that occurs at some 
event  generation  time  t S  specified  in  any  suitable  global 
time scale. Besides its pure occurrence, Vs[t“] may or may 
not carry additional information, given by its value V s .  Note 
that V“ is often used as an abbreviation for V s [ t s ]  when the 
event generation time t S  is clear from the context. 
V s [ t s ]  is a virtual event in the sense that it does not usu- 
ally correspond to a physical event at node s. Rather, it  is 
just  the hypothesized trigger  of the local execution of the 
particular distributed algorithm at node s, which eventually 