---
author: Marty Kalin
category: 软件开发
comments_data: []
count:
  commentnum: 0
  favtimes: 0
  likes: 0
  sharetimes: 0
  viewnum: 5076
date: '2021-05-22 16:53:46'
editorchoice: false
excerpt: 软件库是重复使用代码的一种简单而合理的方式。
fromurl: https://opensource.com/article/21/2/linux-software-libraries
id: 13413
islctt: true
largepic: /data/attachment/album/202105/22/165307u0n970uivji7kiim.jpg
permalink: /article-13413-1.html
pic: /data/attachment/album/202105/22/165307u0n970uivji7kiim.jpg.thumb.jpg
related: []
reviewer: wxy
selector: lujun9972
summary: 软件库是重复使用代码的一种简单而合理的方式。
tags:
- 软件库
- C语言
thumb: false
title: 用 C 语言理解 Linux 软件库
titlepic: true
translator: mengxinayan
updated: '2021-05-22 16:53:46'
---
> 
> 软件库是重复使用代码的一种简单而合理的方式。
> 
> 
> 
![](/data/attachment/album/202105/22/165307u0n970uivji7kiim.jpg "5 pengiuns floating on iceburg")
软件库是一种是一直以来长期存在的、简单合理的复用代码的方式。这篇文章解释了如何从头开始构建库并使得其可用。尽管这两个示例库都以 Linux 为例，但创建、发布和使用这些库的步骤也可以应用于其它类 Unix 系统。
这些示例库使用 C 语言编写，非常适合该任务。Linux 内核大部分由 C 语言和少量汇编语言编写（Windows 和 Linux 的表亲如 macOS 也是如此）。用于输入/输出、网络、字符串处理、数学、安全、数据编码等的标准系统库等主要由 C 语言编写。所以使用 C 语言编写库就是使用 Linux 的原生语言来编写。除此之外，C 语言的性能也在一众高级语言中鹤立鸡群。
还有两个来访问这些库的示例 客户程序   client （一个使用 C，另一个使用 Python）。毫无疑问可以使用 C 语言客户程序来访问 C 语言编写的库，但是 Python 客户程序示例说明了一个由 C 语言编写的库也可以服务于其他编程语言。
### 静态库和动态库对比
Linux 系统存在两种类型库：
* **静态库（也被称为归档库）**：在编译过程中的链接阶段，静态库会被编译进程序（例如 C 或 Rust）中。每个客户程序都有属于自己的一份库的拷贝。静态库有一个显而易见的缺点 —— 当库需要进行一定改动时（例如修复一个 bug），静态库必须重新链接一次。接下来要介绍的动态库避免了这一缺点。
* **动态库（也被称为共享库）**：动态库首先会在程序编译中的链接阶段被标记，但是客户程序和库代码在运行之前仍然没有联系，且库代码不会进入到客户程序中。系统的动态加载器会把一个共享库和正在运行的客户程序进行连接，无论该客户程序是由静态编译语言（如 C）编写，还是由动态解释语言（如 Python）编写。因此，动态库不需要麻烦客户程序便可以进行更新。最后，多个客户程序可以共享同一个动态库的单一副本。
通常来说，动态库优于静态库，尽管其复杂性较高而性能较低。下面是两种类型的库如何创建和发布：
1. 库的源代码会被编译成一个或多个目标模块，目标模块是二进制文件，可以被包含在库中并且链接到可执行的二进制中。
2. 目标模块会会被打包成一个文件。对于静态库，标准的文件拓展名是 `.a` 意为“ 归档   archive ”；对于动态库，标准的文件拓展名是 `.so` 意为“ 共享目标   shared object ”。对于这两个相同功能的示例库，分别发布为 `libprimes.a` （静态库）和 `libshprimes.so` （动态库）。两种库的文件名都使用前缀 `lib` 进行标识。
3. 库文件被复制到标准目录下，使得客户程序可以轻松地访问到库。无论是静态库还是动态库，典型的位置是 `/usr/lib` 或者 `/usr/local/lib`，当然其他位置也是可以的。
构建和发布每种库的具体步骤会在下面详细介绍。首先我将介绍两种库里涉及到的 C 函数。
### 示例库函数
这两个示例库都是由五个相同的 C 函数构建而成的，其中四个函数可供客户程序使用。第五个函数是其他四个函数的一个工具函数，它显示了 C 语言怎么隐藏信息。每个函数的源代码都很短，可以将这些函数放在单个源文件中，尽管也可以放在多个源文件中（如四个公布的函数都有一个文件）。
这些库函数是基本的处理函数，以多种方式来处理质数。所有的函数接收无符号（即非负）整数值作为参数：
* `is_prime` 函数测试其单个参数是否为质数。
* `are_coprimes` 函数检查了其两个参数的 最大公约数   greatest common divisor （gcd）是否为 1，即是否为互质数。
* `prime_factors`：函数列出其参数的质因数。
* `glodbach`：函数接收一个大于等于 4 的偶数，列出其可以分解为两个质数的和。它也许存在多个符合条件的数对。该函数是以 18 世纪数学家    克里斯蒂安·哥德巴赫    Christian Goldbach  命名的，他的猜想是任意一个大于 2 的偶数可以分解为两个质数之和，这依旧是数论里最古老的未被解决的问题。
工具函数 `gcd` 留在已部署的库文件中，但是在没有包含这个函数的文件无法访问此函数。因此，一个使用库的客户程序无法调用 `gcd` 函数。仔细观察 C 函数可以明白这一点。
### 更多关于 C 函数的内容
每个在 C 语言中的函数都有一个存储类，它决定了函数的范围。对于函数，有两种选择。
* 函数默认的存储类是 `extern`，它给了函数一个全局域。一个客户程序可以调用在示例库中用 `extern` 修饰的任意函数。下面是一个带有显式 `extern` 声明的 `are_coprimes` 函数定义：
```
extern unsigned are_coprimes(unsigned n1, unsigned n2) {
  ...
}
```
* 存储类 `static` 将一个函数的的范围限制到函数被定义的文件中。在示例库中，工具函数 `gcd` 是静态的（`static`）：
```
static unsigned gcd(unsigned n1, unsigned n2) {
  ...
}
```
只有在 `primes.c` 文件中的函数可以调用 `gcd`，而只有 `are_coprimes` 函数会调用它。当静态库和动态库被构建和发布后，其他的程序可以调用外部的（`extern`）函数，如 `are_coprimes` ，但是不可以调用静态（`static`）函数 `gcd`。静态（`static`）存储类通过将函数范围限制在其他库函数内，进而实现了对库的客户程序隐藏 `gcd` 函数。
在 `primes.c` 文件中除了 `gcd` 函数外，其他函数并没有指明存储类，默认将会设置为外部的（`extern`）。然而，在库中显式注明 `extern` 更加常见。
C 语言区分了函数的 定义   definition 和 声明   declaration ，这对库来说很重要。接下来让我们开始了解定义。C 语言仅允许命名函数不允许匿名函数，并且每个函数需要定义以下内容：
* 一个唯一的名字。一个程序不允许存在两个同名的函数。
* 一个可以为空的参数列表。参数需要指明类型。
* 一个返回值类型（例如：`int` 代表 32 位有符号整数），当没有返回值时设置为空类型（`void`）。
* 用一对花括号包围起来的函数主体部分。在一个特制的示例中，函数主体部分可以为空。
程序中的每个函数必须要被定义一次。
下面是库函数 `are_coprimes` 的完整定义：
```
extern unsigned are_coprimes(unsigned n1, unsigned n2) { /* 定义 */
  return 1 == gcd(n1, n2); /* 最大公约数是否为 1? */
}
```
函数返回一个布尔值（`0` 代表假，`1` 代表真），取决于两个整数参数值的最大公约数是否为 1。工具函数 `gcd` 计算两个整数参数 `n1` 和 `n2` 的最大公约数。
函数声明不同于定义，其不需要主体部分：
```
extern unsigned are_coprimes(unsigned n1, unsigned n2); /* 声明 */
```
声明在参数列表后用一个分号代表结束，它没有被花括号包围起来的主体部分。程序中的函数可以被多次声明。
为什么需要声明？在 C 语言中，一个被调用的函数必须对其调用者可见。有多种方式可以提供这样的可见性，具体依赖于编译器如何实现。一个必然可行的方式就是当它们二者位于同一个文件中时，将被调用的函数定义在在它的调用者之前。
```
void f() {...}     /* f 定义在其被调用前 */
void g() { f(); }  /* ok */
```
当函数 `f` 被在调用前声明，此时函数 `f` 的定义可以移动到函数 `g` 的下方。
```
void f();         /* 声明使得函数 f 对调用者可见 */
void g() { f(); } /* ok */
void f() {...}    /* 相较于前一种方式，此方式显得更简洁 */
```
但是当如果一个被调用的函数和调用它的函数不在同一个文件中时呢？因为前文提到一个函数在一个程序中需要被定义一次，那么如何使得让一个文件中被定义的函数在另一个文件中可见？
这个问题会影响库，无论是静态库还是动态库。例如在这两个质数库中函数被定义在源文件 `primes.c` 中，每个库中都有该函数的二进制副本，但是这些定义的函数必须要对使用库的 C 程序可见，该 C 程序有其自身的源文件。
函数声明可以帮助提供跨文件的可见性。对于上述的“质数”例子，它有一个名为 `primes.h` 的头文件，其声明了四个函数使得它们对使用库的 C 程序可见。
```
/** 头文件 primes.h：函数声明 **/
extern unsigned is_prime(unsigned);
extern void prime_factors(unsigned);
extern unsigned are_coprimes(unsigned, unsigned);
extern void goldbach(unsigned);
```
这些声明通过为每个函数指定其调用语法来作为接口。
为了客户程序的便利性，头文件 `primes.h` 应该存储在 C 编译器查找路径下的目录中。典型的位置有 `/usr/include` 和 `/usr/local/include`。一个 C 语言客户程序应使用 `#include` 包含这个头文件，并尽可能将这条语句其程序源代码的首部（头文件将会被导入另一个源文件的“头”部）。C 语言头文件可以被导入其他语言（如 Rust 语言）中的 `bindgen`，使其它语言的客户程序可以访问 C 语言的库。
总之，一个库函数只可以被定义一次，但可以在任何需要它的地方进行声明，任一使用 C 语言库的程序都需要该声明。头文件可以包含函数声明，但不能包含函数定义。如果头文件包含了函数定义，那么该文件可能会在一个 C 语言程序中被多次包含，从而破坏了一个函数在 C 语言程序中必须被精确定义一次的规则。