5.手动签名apk包
（1）使用keytool和jarsigner来进行签名
当然，在正式签名处release包的时候，需要创建一个自己的keystore文件，如图12-3和图12-4所示。
图12-3 导出签名apk
图12-4 导出签名apk
这里可以对keystore文件起自己的名字，而且后缀名也是无关紧要的。创建完文件之后，也会生成MD5和SHA1值，这个值可以不用记录的，可以通过命令查看keystore文件的MD5和SHA1的值：keytool-list-keystore debug.keystore，如下所示：
这里看到用Eclipse自动签名和生成一个keystore文件，也可以使用keytool工具生成一个keystore文件。这个方法网上有，就不做太多的介绍了。然后可以使用jarsign来对apk包进行签名了。可以手动生成一个keystore文件：
这个命令有点长，有几个重要的参数需要说明：
·-alias是定义别名，这里是debug。
·-keyalg是规定签名算法，这里是DSA，这里的算法直接关系到后面apk中签名文件的后缀名，到后面会详细说明。
再用jarsigner工具进行签名，如下所示：
这样就成功地对apk进行签名了。
签名的过程中遇到的问题：
1）证书链找不到的问题，如下所示：
这是因为最后一个参数alias是keystore的别名输错了。
2）生成keystore文件的时候提示密码错误，如下所示：
这个原因是因为在当前目录已经有debug.ketystore了，再生成一个debug.keystore的话，就会报错。
3）找不到别名的问题，如下所示：
这个问题的原因是使用keytool生成keystore的时候，起了debug的别名，这个问题困扰了我很久，最后做了很多例子才发现的，只要keystore文件的别名是debug的话，就会报这样的错误。这个应该和系统默认的签名debug.keystore中的别名是debug有关系。
注意：Android中是允许使用多个keystore对apk进行签名的，这里就不再粘贴命令了，创建了几个keystore对apk进行签名，如图12-5所示。
图12-5 签名文件目录
这里把签名之后的apk进行解压之后，发现有三个签名文件和证书（.SF/.DSA）。也可以注意到，签名时用的是DSA算法，这里的文件后缀名就是DSA，而且文件名是keystore的别名，这里算是理清了如何使用keytool产生keystore，以及用jarsigner来进行签名。
（2）用signapk来进行签名
下面再来看看signapk工具进行签名：
这里需要两个文件.pk8和.x509.pem：
·pk8是私钥文件。
·x509.pem是含有公钥的文件。
需要注意的是：signapk签名之后的apk，META-INF文件夹中的三个文件的名字，如图12-6所示。
图12-6 签名文件
因为signapk在前面的时候不像jarsigner会自动使用别名来命名文件，就是写死了是CERT的名字，不过文件名不影响的，后面分析Android中的apk校验过程中会说道，只会通过后缀名来查找文件。
（3）两种的签名方式有什么区别
jarsigner签名时用的是keystore文件，signapk签名时用的是pk8和x509.pem文件，而且都是给apk进行签名的，那么keystore文件和pk8、x509.pem之间是不是有什么联系呢？答案是肯定的，网上搜了一下，果然它们之间是可以转化的，这里就不再分析如何进行转化的，网上的例子很多，有专门的工具可以进行转化。
12.2 Android中签名流程
下面开始从源码中去分析Android中的签名机制和原理流程。因为网上没有找到jarsigner的源码，但是找到了signapk的源码，下面就来看看signapk的源码：源码位置是com/android/signapk/sign.java。
通过上面的签名可以看到，Android签名apk之后，会有一个META-INF目录，这里有三个文件：
·MANIFEST.MF
·CERT.SF
·CERT.RSA
下面来看看这三个文件到底是干啥的。
1.MANIFEST.MF文件
这个文件主要包括apk文件中所有文件的数据摘要内容，如下所示：
下面来看看源码：
在main函数中，需要输入四个参数，然后开始写MANIFEST.MF文件内容：
进入方法manifest.write（outputJar）：
代码逻辑很简单，主要看那个循环的意思：除了三个文件（MANIFEST.MF、CERT.RSA、CERT.SF）之外都会对其他文件内容做一次SHA1算法，就是计算出文件的摘要信息，然后用Base64进行编码即可，下面用工具来做个案例看看是不是这样：首先安装工具：HashTab，这个工具网上有，可以自行搜索下载。然后网上搜索在线计算Base64。
下面就开始验证工作吧。验证一下AndroidManifest.xml文件，首先在MANIFEST.MF文件中找到这个条目，记录SHA1的值，如下所示：
安装HashTab之后，找到AndroidManifest.xml文件，右击，选择Hashtab，如图12-7所示。
复制SHA-1的值：9C64812DE7373B201C294101473636A3697FD73C，到上面的那个Base64转化网站，转化一下，如图12-8所示。
图12-7 查看文件的SHA-1值
图12-8 SHA-1值转化
nGSBLec3OyAcKUEBRzY2o2l/1zw=和MANIFEST.MF中的条目内容一模一样。
那么从上面的分析就知道了，其实MANIFEST.MF中存储的是这样的内容：逐一遍历里面所有条目，如果是目录就跳过，如果是一个文件，就用SHA1（或者SHA256）消息摘要算法提取出该文件的摘要然后进行BASE64编码后，作为“SHA1-Digest”属性的值写入到MANIFEST.MF文件中的一个块中。该块还有一个“Name”属性，其值就是该文件在apk包中的路径。
2.CERT.SF文件
这个文件主要是前面MANIFEST.MF文件的每个块内容的数据摘要信息，如下所示：
这里的内容感觉和MANIFEST.MF的内容差不多，来看看代码吧：
进入到writeSignatureFile方法中：
首先可以看到，需要对之前的MANIFEST.MF文件整个内容做一个SHA1放到SHA1-Digest-Manifest字段中。
看看manifest变量就是刚刚写入了MANIFEST.MF文件的，这个可以验证一下，如图12-9所示。
然后转化一下，如图12-10所示。
图12-9 查看文件的SHA-1值
图12-10 SHA-1值转化成Base64
看到了吧，和文件中的值是一样的，如下所示：
下面继续看代码，有一个循环：
这里还是用到了刚刚传入的mainfest变量，遍历它的条目内容，然后进行SHA算法计算，再用Base64计算一下。其实就是对MANIFEST.MF文件中的每个条目内容做一次SHA，再保存一下即可。
做个例子验证一下：用AndroidManifest.xml为例，把MANIFEST.MF文件中的条目拷贝保存到txt文档中，如图12-11所示。
图12-11 签名文件格式
这里需要注意的是，保存之后，需要添加两个换行，可以在代码中看到逻辑如下所示：
然后计算txt文档的SHA值，如图12-12和图12-13所示。
图12-12 查看文件签名
图12-13 Base64转码
看到了吧，这里计算的值是一样的，如下所示：
到这里就知道CERT.SF文件做了什么，如下所示：
1）计算MANIFEST.MF文件的整体SHA1值，再经过BASE64编码后，记录在CERT.SF主属性块（在文件头上）的“SHA1-Digest-Manifest”属性值值下。
2）逐条计算MANIFEST.MF文件中每一个块的SHA1，并经过BASE64编码后，记录在CERT.SF中的同名块中，属性的名字是“SHA1-Digest”。
3.CERT.RSA文件
这个文件就是对前面CERT.SF文件做签名操作之后的结果，也就是前面提到的签名文件，如下所示：
看到都是二进制文件，因为RSA文件加密了，所以需要用openssl命令才能查看其内容，如下所示：
关于这些信息，可以参考图12-14的解释。
来看一下代码：
图12-14 rsa文件格式说明
这里会把之前生成的CERT.SF文件用私钥计算出签名，然后将签名以及包含公钥信息的数字证书一同写入CERT.RSA保存。CERT.RSA是一个满足PKCS7格式的文件。
12.3 Android中为何采用这种签名机制
本节总结一下Android中为何要用这种方式进行加密签名，如果apk文件被篡改后会发生什么。
首先，如果改变了apk包中的任何文件，那么在apk安装校验时，改变后的文件摘要信息与MANIFEST.MF的检验信息不同，于是验证失败，程序就不能成功安装。其次，如果对更改过的文件算出新的摘要值，然后更改MANIFEST.MF文件里面对应的属性值，那么必定与CERT.SF文件中算出的摘要值不一样，照样验证失败。最后，如果你还不死心，继续计算MANIFEST.MF的摘要值，相应地更改CERT.SF里面的值，那么数字签名值必定与CERT.RSA文件中记录的不一样，还是失败。
那么能不能继续伪造数字签名呢？不可能，因为没有数字证书对应的私钥。所以，如果要重新打包后的应用程序能在Android设备上安装，必须对其进行重签名。
从上面的分析可以得出，只要修改了apk中的任何内容，就必须重新签名，不然会提示安装失败。
在分析了签名技术之后，无意中发现一个问题，就是CERT.SF和MANIFEST.MF这两个文件中内容的name字段都是apk中的资源名，那么就有一个问题了，如果资源名很长，而且apk中的资源很多，那么这两个文件就会很大，这里是不是可以优化呢？确实是可以的。这里不多详细解析，感兴趣的同学可以去看一下开源框架AndResGuard。
12.4 本章小结
本章主要介绍了Android中的apk签名机制知识点，有了这套签名机制，可以做到应用防止被重新打包二次签名的风险。
第13章 Android应用加固原理
本章介绍Android中对apk进行加固的原理。现阶段Android中的反编译工作越来越容易操作，开发者辛苦地开发出一个apk，结果被人反编译了，那心情真心不舒服。虽然加入混淆，做到native层，但是这都是治标不治本的办法。反编译的技术在更新，那么保护apk的技术就不能停止。现在网上有很多apk加固的第三方平台，例如爱加密和梆梆等。有些人认为加固技术很高深，其实不然，加固技术就是对源apk进行加密，然后再套上一层壳即可。当然还有一些细节需要处理，这就是本章需要介绍的内容。
13.1 加固原理解析
下面就来看一下Android中加固的原理，如图13-1所示。
图13-1 加固结构图
在加固的过程中需要三个对象：
·需要加密的apk（源apk）
·自己的壳程序apk（负责解密apk工作）
·加密工具（将源apk进行加密和壳dex合并成新的dex）
加固的主要步骤：拿到需要加密的apk（源apk）和自己的壳程序apk，然后用加密算法对源apk进行加密，再将壳apk进行合并得到新的dex文件，最后替换壳程序中的dex文件即可，得到新的apk，那么这个新的apk也叫作脱壳程序apk。它已经不是一个完整意义上的apk程序了，它的主要工作是：负责解密源apk，然后加载apk，让其正常运行起来。
在这个过程中可能需要了解的一个知识是：如何将源apk和壳apk进行合并成新的dex。这就需要了解dex文件的格式了。在第7章中已经详细介绍了dex文件格式了，下面就来简单回顾一下dex文件的格式。
主要来看一下dex文件的头部信息，其实dex文件和class文件的格式分析原理都是一样的，它们都有固定的格式，现在反编译的一些工具如下所示：
·jd-gui：可以查看jar中的类，其实它就是解析class文件，只要了解class文件的格式就可以。
·dex2jar：将dex文件转化成jar，原理也是一样的，只要知道dex文件的格式，能够解析出dex文件中的类信息就可以了。
当然在分析这个文件的时候，最重要的还是头部信息，它是一个文件的开始部分，也是索引部分，内部信息很重要，如图13-2所示。
图13-2 dex文件头部结构图