encompasses the case where ğ‘¦1 = ğ‘¦2 and ğ‘¥1 â‰  ğ‘¥2, which is
impossible in the real world. From this case, we can define
the following simplified bad transcript description:
Bad2: There are two entries (prim, ğ‘¥, ğ‘¦, Â·) and (enc, ğ‘–, ğ‘ ,
ğ´ğ·, ğ‘€, ğ¶âˆ¥ğ‘‡ , ğ‘‰0âˆ¥ Â· Â· Â· âˆ¥ğ‘‰â„“) such that ğ‘¦ âˆˆ {ğ‘‰0 (32)âˆ’ (ğ‘âˆ¥ğ¾ğ‘–âˆ¥0âˆ¥ğ‘),
. . . , ğ‘‰â„“
(32)âˆ’ (ğ‘âˆ¥ğ¾ğ‘–âˆ¥â„“âˆ¥ğ‘)}.
Case 3 (ğ‘¥1, ğ‘¦1), (ğ‘¥2, ğ‘¦2) âˆˆ ğ‘†2(ğœ) where ğ‘¥1 = ğ‘¥2. In this case, in the
real world, two calls are made to the ideal permutation on
the same input, through one or two encryption queries.
This case also encompasses the case where ğ‘¥1 = ğ‘¥2 and
ğ‘¦1 â‰  ğ‘¦2, which is impossible in the real world. From this
case, we can define the following simplified bad transcript
description:
Bad3: There are two entries (enc, ğ‘–, ğ‘ , ğ´ğ·, ğ‘€, ğ¶âˆ¥ğ‘‡ , ğ‘‰) and
(enc, ğ‘—, ğ‘ â€², ğ´ğ·â€², ğ‘€â€², ğ¶â€²âˆ¥ğ‘‡ â€², ğ‘‰ â€²) with ğ‘ = ğ‘ â€² (block counter
values do not overlap across different nonces), ğ‘– â‰  ğ‘— (be-
cause nonce reuse is not allowed for the same user) and
ğ¾ğ‘– = ğ¾ğ‘—.
Case 4 (ğ‘¥1, ğ‘¦1), (ğ‘¥2, ğ‘¦2) âˆˆ ğ‘†2(ğœ) where ğ‘¦1 = ğ‘¦2. In this case, in the
real world, two calls with the same output are made to the
ideal permutation, through one or two encryption queries.
The case where ğ‘¦1 = ğ‘¦2 and ğ‘¥1 = ğ‘¥2 being already con-
sidered in the previous point, we can restrict this case to
ğ‘¦1 = ğ‘¦2 and ğ‘¥1 â‰  ğ‘¥2, which in fact is impossible in the real
world. From this case, we can define the following simpli-
fied bad transcript description:
Bad4: There are two entries (enc, ğ‘–, ğ‘ , ğ´ğ·, ğ‘€, ğ¶âˆ¥ğ‘‡ , ğ‘‰0âˆ¥ Â· Â· Â·
âˆ¥ğ‘‰â„“) and (enc, ğ‘—, ğ‘ â€², ğ´ğ·â€², ğ‘€â€², ğ¶â€²âˆ¥ğ‘‡ â€², ğ‘‰ â€²
â„“â€²) such that
(ğ¾ğ‘–, ğ‘ , ğ‘) â‰  (ğ¾ğ‘— , ğ‘¡, ğ‘ â€²) andğ‘‰ğ‘ 
(32)âˆ’(ğ‘âˆ¥ğ¾ğ‘— âˆ¥
ğ‘¡âˆ¥ğ‘ â€²) for 0 â‰¤ ğ‘  â‰¤ â„“ and 0 â‰¤ ğ‘¡ â‰¤ â„“â€².
0 âˆ¥ Â· Â· Â· âˆ¥ğ‘‰ â€²
(32)âˆ’(ğ‘âˆ¥ğ¾ğ‘–âˆ¥ğ‘ âˆ¥ğ‘) = ğ‘‰ â€²
ğ‘¡
Case 5 (ğ‘¥, ğ‘¦) âˆˆ ğ‘†1(ğœ) and (vf, ğ‘–, ğ‘ , ğ´ğ·, ğ¶âˆ¥ğ‘‡ , false) âˆˆ ğœ where ğ‘¥ =
(ğ‘âˆ¥ğ¾ğ‘–âˆ¥0âˆ¥ğ‘) and âˆƒğ‘Ÿ âˆˆ {0, 1}ğ‘¡ ,ğ‘Š âˆˆ {0, 1}ğ‘›âˆ’2ğ‘¡ such that
(32)+ğ‘¥ = (ğ‘Ÿâˆ¥(ğ‘‡ (ğ‘¡)âˆ’ğ»ğ‘Ÿ (ğ´ğ·, ğ¶))âˆ¥ğ‘Š ). This case corresponds to an
ğ‘¦
impossible transcript in the real world. As in the real world
ğœ‹(ğ‘¥) = ğ‘¦ and from this case we obtain ğœ‹(ğ‘âˆ¥ğ¾ğ‘–âˆ¥0âˆ¥ğ‘) (32)+
(ğ‘âˆ¥ğ¾ğ‘–âˆ¥0âˆ¥ğ‘) = (ğ‘Ÿâˆ¥(ğ‘‡ (ğ‘¡)âˆ’ ğ»ğ‘Ÿ (ğ´ğ·, ğ¶))âˆ¥ğ‘Š ). Therefore, trunc(
CC_block(ğ¾ğ‘–, ğ‘ , 0), 2ğ‘¡) = ğ‘Ÿâˆ¥(ğ‘‡ (ğ‘¡)âˆ’ğ»ğ‘Ÿ (ğ´ğ·, ğ¶)). Thus (ğ‘ , ğ´ğ·,
ğ¶âˆ¥ğ‘‡) is a valid nonce/AD/ciphertext triplet under key ğ‘–, and
in the real world, the verification query considered would
have returned true. From this case, we can define the fol-
lowing simplified bad transcript description:
Bad5: There are two entries (vf, ğ‘–, ğ‘ , ğ´ğ·, ğ¶âˆ¥ğ‘‡ , false) and
(prim, ğ‘¥, ğ‘¦, Â·) such that ğ‘¥ = (ğ‘âˆ¥ğ¾âˆ¥0âˆ¥ğ‘), ğ¾ğ‘– = ğ¾ and âˆƒğ‘Ÿ âˆˆ
{0, 1}ğ‘¡ ,ğ‘Š âˆˆ {0, 1}ğ‘›âˆ’2ğ‘¡ such that ğ‘¦
(32)+ğ‘¥ = (ğ‘Ÿâˆ¥(ğ‘‡ (ğ‘¡)âˆ’ğ»ğ‘Ÿ (ğ´ğ·, ğ¶))
âˆ¥ğ‘Š ).
Case 6 (ğ‘¥, ğ‘¦) âˆˆ ğ‘†2(ğœ) and (vf, ğ‘–, ğ‘ , ğ´ğ·, ğ¶âˆ¥ğ‘‡ , false) âˆˆ ğœ where ğ‘¥ =
(ğ‘âˆ¥ğ¾ğ‘–âˆ¥0âˆ¥ğ‘) and âˆƒğ‘Ÿ âˆˆ {0, 1}ğ‘¡ ,ğ‘Š âˆˆ {0, 1}ğ‘›âˆ’2ğ‘¡ such that
(32)+ ğ‘¥ = (ğ‘Ÿâˆ¥(ğ‘‡ (ğ‘¡)âˆ’ ğ»ğ‘Ÿ (ğ´ğ·, ğ¶))âˆ¥ğ‘Š ). This case corresponds
ğ‘¦
to an impossible transcript in the real world, for a similar
reason as the previous case, i.e., in the real world, the veri-
fication query considered would have returned true. From
this case, we can define the following simplified bad tran-
script description:
Bad6: There are two entries (vf, ğ‘–, ğ‘ , ğ´ğ·, ğ¶âˆ¥ğ‘‡ , false) and
(enc, ğ‘—, ğ‘ , ğ´ğ·â€², ğ‘€â€², ğ¶â€²âˆ¥ğ‘‡ â€², ğ‘‰ â€²
ğ‘¢) such that ğ¾ğ‘— = ğ¾ğ‘–
and âˆƒğ‘Ÿ âˆˆ {0, 1}ğ‘¡ ,ğ‘Š âˆˆ {0, 1}ğ‘›âˆ’2ğ‘¡ such that ğ‘‰ â€²
0 = (ğ‘Ÿâˆ¥(ğ‘‡ (ğ‘¡)âˆ’
ğ»ğ‘Ÿ (ğ´ğ·, ğ¶))âˆ¥ğ‘Š ).
0 âˆ¥ Â· Â· Â· âˆ¥ğ‘‰ â€²
Then ğ‘‡bad =6
For ğ‘— âˆˆ {1, . . . , 6}, let Badğ‘— be the set of attainable transcripts satis-
fying the ğ‘—-th simplified bad transcript description defined above.
ğ‘—=1 Badğ‘—. Note that Bad1, Bad2, and Bad3 contain
attainable transcripts calling more than one time the ideal permu-
tation on the same input-output during primitive and encryption
queries, and Bad4, Bad5, and Bad6 contain attainable transcripts
impossible in the real world.
6.4 Good Transcript Ratio (H-Coefficient)
An attainable transcript that is not in ğ‘‡bad is called good, and the
set of all good transcripts is denoted by ğ‘‡good. In the H-coefficient
technique, we need to bound the probability ratio of a good tran-
script being generated in the real world with respect to that of it
being generated in the ideal world.
Anomalous transcripts that result in a weak H-coefficient or that
make it hard to evaluate have been weeded out as bad transcripts in
the previous section. Roughly, these were transcripts that resulted
in different multi-set cardinalities across the two worlds and tran-
scripts with a real-world probability of zero. Consequently, we can
now easily bound the H-Coefficient (of good transcripts) through
a simple counting argument which yields the bound specified in
Proposition 6.2. Its proof can be found in Appendix B.1.
Proposition 6.2 (Probability of good transcripts). For any
good transcript ğœ âˆˆ ğ‘‡good it holds that:
Preal(ğœ)
Pideal(ğœ) â‰¥ 1 âˆ’ 2ğ‘ğ‘£
2ğ‘¡ .
6.5 Bad Transcript Probabilities
We now bound the probability that Tideal âˆˆ ğ‘‡bad, i.e., the probability
that a transcript generated in the ideal world is bad.
The probabilities of events Tideal âˆˆ Badğ‘—, for ğ‘— âˆˆ {1, . . . , 6} are
bounded in Lemmas B.2â€“B.7, the proofs of which can be found in
Appendix B.2. The corresponding bounds are reproduced below
as inequalities (1)â€“(6). Proposition 6.3 is then obtained by a direct
application of the union bound and substituting terms through
inequalities (1)â€“(6). We notably use our improved balls-into-bins
theorem to obtain the inequalities (2), (5), and (6).
Session 6D: Authentication and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1989.
+ 1
2ğ‘›âˆ’ğ‘˜
.
Pr[Tideal âˆˆ Bad1] â‰¤ ğ‘ğ‘‘
2ğ‘˜
Pr[Tideal âˆˆ Bad2] â‰¤ ğ‘ Â· 2(ğ‘› âˆ’ ğ‘˜) ğœğ‘’
2ğ‘˜
Pr[Tideal âˆˆ Bad3] â‰¤ ğ‘ğ‘’(ğ‘‘ âˆ’ 1)
Pr[Tideal âˆˆ Bad4] â‰¤ (ğœğ‘’ + ğ‘ğ‘’)2
2ğ‘›+1
Pr[Tideal âˆˆ Bad5] â‰¤ ğ‘ğ‘£ Â· 2(cid:16)(ğ‘› âˆ’ ğ‘˜) ğ‘ + 2ğ‘¡ ğ‘(cid:17)
2ğ‘˜
.
.
2ğ‘˜
(1)
(2)
(3)
(4)
+
1
2ğ‘›âˆ’ğ‘˜âˆ’1 +
1
22ğ‘¡âˆ’1 .
(5)
2ğ‘¡ + ğ‘ğ‘£ Â· ğ‘ Â· â„“ğ‘š
Pr[Tideal âˆˆ Bad6] â‰¤ ğ‘ğ‘£
(6)
Proposition 6.3 (Probability of bad transcripts). Let Tideal
be the random variable representing the transcript generated by A in
the ideal game. It then holds that:
+ ğ‘ğ‘£ Â· 2 Â· 2ğ‘¡ ğ‘‘
+ 1
22ğ‘¡
2ğ‘˜
2ğ‘¡
.
2ğ‘¡
2ğ‘˜
2ğ‘˜
1
Pr[Tideal âˆˆ ğ‘‡bad] â‰¤ ğ‘ğ‘£ Â· (ğ‘ Â· â„“ğ‘š + 1)
+ ğ‘ğ‘£ Â· 2(cid:16)(ğ‘› âˆ’ ğ‘˜) ğ‘ + 2ğ‘¡ ğ‘ + 2ğ‘¡ ğ‘‘(cid:17)
+ ğ‘‘(ğ‘ + ğ‘ğ‘’)
2ğ‘˜
+ (ğœğ‘’ + ğ‘ğ‘’)2
(cid:108)
+ 1
22ğ‘¡âˆ’2 +
2ğ‘›+1
again using the shorthand notation ğ‘– ğ‘
max(1,ğ‘–âˆ’log2(2ğ‘))
ğ‘–
+ 2 Â· ğ‘(ğ‘› âˆ’ ğ‘˜) ğœğ‘’
(cid:109)
= 0, for any ğ‘–, ğ‘ âˆˆ N.
Theorem 6.1 is obtained by combining Propositions 6.2 and 6.3
with Theorem 2.2, where Proposition 6.2 yields ğœ–1 and Proposi-
tion 6.3 yields ğœ–2.
2ğ‘›âˆ’ğ‘˜âˆ’2 ,
and
=
0
ğ‘–
7 IMPLICATIONS OF THE MAIN RESULT
In this section, we give some properties and implications of our
multi-user security theorem from Section 6. Succinctly, we prove
the tightness of the bound and extend the security result to the
nonce-randomized setting. Then we explain how our bounds im-
prove over previous results and how they compare and contrast
with the security profile of GCM. We further discuss the security
limits of ChaCha20-Poly1305 induced by the dominant term in our
bound and propose a potential variant scheme that overcomes these
limitations.
7.1 Tightness
We establish the tightness of the bound in Theorem 6.1 by provid-
ing several attacks matching the theorem bounds via the Proposi-
tions 7.1â€“7.6 below. To the best of our knowledge, the attacks in
Propositions 7.1 and 7.6 are new in this context and do not seem
to be covered elsewhere in the literature. For space reasons, their
details are deferred to Appendix C. Details for the other attacks
establishing the stated propositions can be found in the full version
of the paper.
Note that all our attacks are valid against the original multi-user
game and not only against the augmented version used in the proof.
Moreover, for all our attacks except the one in Proposition 7.6,
we only need the underlying ChaCha20 permutation ğœ‹ to be a
permutation over {0, 1}ğ‘› and not necessarily an ideal permutation.
Hash key recovery / forgery attack. The main idea of the following
attack is to retrieve the hash key of Poly1305_Mac and create a
forgery, in a similar way as was done for GCM [1, 27]. For this, the
attacker tests a set of â„“ğ‘š possible hash keys through each verifica-
tion query; if the correct hash key is in this set, the forgery attempt
will be valid, distinguishing the real from the ideal game.
The attack is described in the multi-user setting but is also valid
in the single-user setting as it queries only one user. The main
difference with forgery attacks on GCM is that in Poly1305_Mac,
128-bit messages/ciphertexts blocks are encoded (padded with 1)
before being transformed into coefficients of a polynomial modulo
2130 âˆ’ 5, preventing us from accessing the full range of coefficients.
We use here the technique from [17] as a workaround, reducing the
coefficients of our forgery polynomial by looking for the shortest
vector of a carefully constructed lattice.
Proposition 7.1. Let ğ‘¡ be the tag size of Poly1305_Mac and ğ»
its associated ğ‘-almost Î”-universal hash function. Let â„“ğ‘š â‰¥ 5 be the
maximal number of ğ‘¡-bit input blocks in an encryption or verification
query to the ChaCha20-Poly1305 AEAD scheme. There exists an ad-
versary A making one encryption query and ğ‘ğ‘£ verification queries
such that:
muAE
ChaCha20-Poly1305[ğœ‹](A) â‰¥ ğ‘ğ‘£ Â· ğ‘ Â· (â„“ğ‘š âˆ’ 5)
2ğ‘¡+4
.
Adv
For simplicity, we queried only one user for a specific encryption
query in our attack. The approach can be extended to an attack
querying multiple users, which then requires at least one encryption
query per user. Moreover, the encryption query we use, in fact, only
authenticates the associated data ğ´ğ· = 0ğ‘¡Â·(â„“ğ‘šâˆ’1); the message ğ‘€
queried is empty. The attack should be extendable to arbitrary
values ğ´ğ· and ğ‘€ of maximum length â„“ğ‘š by considering a closest
vector (CVP) algorithm rather than a shortest vector (SVP) one.
Key recovery attack. The main idea of the two following attacks
is to use offline computations (via the permutation oracle in our
model) to try to recover one of the user keys. For this, the attacker
makes ğ‘‘ encryption queries on the same input (ğ‘ , ğ‘€, ğ´ğ·) across
ğ‘‘ different users. It then makes ğ‘ permutation queries on guessed
keys to construct corresponding ciphertext for that input, checking
if any ciphertexts match.
Proposition 7.2. Let
the
ChaCha20-Poly1305 AEAD scheme. There exists a ğ‘‘-repeating ad-
versary A, that makes ğ‘ permutation queries and ğ‘‘ â‰¤ 2ğ‘˜
ğ‘ encryption