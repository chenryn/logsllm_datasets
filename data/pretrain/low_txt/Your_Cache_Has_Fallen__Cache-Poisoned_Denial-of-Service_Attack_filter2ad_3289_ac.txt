### 4.1 缓存错误响应

当客户端请求一个不存在的资源（例如 `/index.html`），Web 框架通常会返回一个错误消息，如状态码 404 Not Found 或 405 Method Not Allowed。共享缓存会将这个带有错误码的响应分配给针对 `http://example.org/index.html` 的 GET 请求。根据 HTTP 缓存 RFC 7231 规定，状态码 404 Not Found 和 405 Method Not Allowed 是可缓存的（见表 1），因此缓存系统会存储并重用这些错误响应。每个随后对 `http://example.org/index.html` 发起 GET 请求的良性客户端都会收到缓存中的错误消息，而不是合法的 Web 应用程序的首页。

### 4.2 HTTP 头超大 (HHO) 攻击

HTTP 标准没有定义请求头的大小限制，因此中间系统、Web 服务器和 Web 框架自行设定其限制。大多数 Web 服务器和代理缓存提供大约 8,000 字节的请求头限制，以避免诸如请求头溢出 [26] 或 ReDoS [38] 等安全威胁。然而，也有一些中间系统设定了更大的限制，例如 Amazon CloudFront CDN 允许最多 24,713 字节。在一项探索性研究中，我们收集了各种 HTTP 引擎和缓存系统的默认 HTTP 请求头限制（见表 3）。

这种不同请求头大小限制之间的语义差距可以被用来进行 CPDoS 攻击。要执行 HTTP 头超大 (HHO) 攻击，恶意客户端需要发送一个包含比源服务器限制大但比缓存系统限制小的头的 GET 请求。攻击者有两种选择：第一种是构造一个包含多个恶意头的请求头；另一种是包含一个具有超大键或值的单个头（见图 4）。

Web 缓存系统会将此包含超大头的请求转发到端点，因为该头的大小在中间件的限制范围内。然而，Web 服务器会阻止此请求并返回一个错误页面，因为请求超过了头大小限制。这个返回的错误页面会被存储，并将在后续等效请求中被重用。

### 4.3 HTTP 元字符 (HMC) 攻击

HTTP 元字符 (HMC) 攻击的工作原理类似于 HHO 攻击。不同的是，这种攻击试图通过发送包含有害元字符的请求头来绕过缓存。元字符可以是控制字符，如换行符/回车符 (`\n`)、换行符 (`\r`) 或其他 Unicode 控制字符。由于 `\n` 和 `\r` 字符被用于响应拆分攻击以毒化缓存，一些 HTTP 实现会阻止包含这些符号的请求。

那些丢弃这些字符的 HTTP 实现通常会返回一个错误消息，表明它们无法解析此请求。然而，有些缓存中间件并不关心某些控制字符，它们只是将包含元字符的请求转发到源服务器，源服务器会返回一个错误码。生成的错误页面随后会被缓存并重用。恶意客户端可以利用这种配置来进行另一种形式的 CPDoS 攻击。我们将这种漏洞称为 HTTP 元字符 (HMC) 攻击。为此，攻击者构造一个包含元字符（如 `\n`）的请求（见图 5）。此示例攻击的目标是使源服务器误认为它受到了响应拆分请求的攻击。与前面介绍的漏洞一样，HMC 请求会顺利通过缓存。一旦请求到达端点，它会被阻止，并返回一个相应的错误页面，因为 Web 服务器意识到可疑字符（如 `\n`）的潜在影响。这个错误消息随后会被相应的 Web 缓存系统存储并重用。

### 5. CPDoS 攻击的实际可行性

为了探索 CPDoS 漏洞在实际环境中的存在情况，我们进行了一系列实验。CPDoS 漏洞的一个关键前提是 Web 缓存系统会存储并重用源服务器生成的错误页面。表 1 显示 Varnish、Apache TS、Akamai、Azure、CDN77、Cloudflare、CloudFront 和 Fastly 都具备这一特性。基于这些发现，我们进行了三项实验——每项实验对应一种 CPDoS 变体——以检查这些中间系统是否容易受到 CPDoS 攻击。

#### 5.1 实验设置

分析 CPDoS 漏洞是否存在实际环境中的第一步是找出作为源服务器使用的易受攻击的 HTTP 实现。源服务器上的 HTTP 实现可以包括反向代理、Web 服务器、Web 框架、云服务或其他中间系统以及另一个缓存。

在我们的第一个实验中，我们分析了 Web 框架中的方法覆盖头支持。此外，我们还评估了当发送一个包含未实现 HTTP 方法的方法覆盖头时返回的错误页面。基于表 1 中我们知道哪些错误页面由哪些 Web 缓存系统存储的信息，我们推断出哪些 Web 框架与哪些 Web 缓存系统可能容易受到 HMO 攻击。在这项实证分析中，我们选择了 13 个基于 IEEE Spectrum [17] 最流行编程语言的 Web 框架。分析的 Web 框架集合包括 ASP.NET v2.2、BeeGo v1.10.0、Django v2.1.7、Express.js v.4.16.4、Flask v1.0.2、Gin v1.3.0、Laravel v5.7、Meteor.js v1.8、Rails v5.2.2、Play Framework 1 (Play 1) v1.5.1、Play Framework 2 (Play 2) v2.7、Spring Boot v2.1.2 和 Symfony v4.2。

第二个实验调查了表 1 中 Web 缓存系统的请求头大小限制以及 13 个 Web 框架。由于 ASP.NET 和 Spring Boot 在生产模式下部署需要底层 Web 服务器，我们还评估了 Microsoft Internet Information Services (IIS) v10.0.17763.1 和 Tomcat v9.0.14 的请求头限制。此外，我们还评估了流行的云服务，包括 Amazon S3、Github Pages、Gitlab Pages、Google Storage 和 Heroku。与第一个实验类似，我们也测试了当请求头大小限制超过时返回的错误码。通过这些发现，我们确定了哪些 HTTP 实现与哪些 Web 缓存系统可能容易受到 HHO 攻击。

最后一个实验评估了 HMC 攻击的可行性。在这里，我们评估了所有提到的 Web 缓存系统、Web 框架、Web 服务器和云服务对元字符的处理。为了测试尽可能多的元字符，我们收集了一个包含 520 个潜在干扰字符串的列表。这个集合包括控制字符、特殊字符、国际字符和其他 Unicode 字符，以及包含跨站脚本 (XSS)、SQL 注入和远程执行攻击的字符串。这项研究的目标是分析哪些字符和字符串被阻止、清理或无问题地处理。此外，我们还评估了当某个字符或字符串被阻止时触发的错误页面。基于我们的发现，我们能够得出结论，需要发送哪些字符和符号到哪些 HTTP 引擎和 Web 缓存系统的组合才能引发 HMC 攻击。

#### 5.2 HMO 攻击的可行性

表 2 显示了第一个实验的结果。它突出显示 Symfony、Laravel 和 Play 1 默认支持方法覆盖头。Django 和 Express.js 默认不考虑方法覆盖头，但提供了插件来添加此功能。Flask 不提供任何插件来集成方法覆盖头，但提供了官方教程说明如何启用它 [14]。表 2 还指出，当 Web 框架接收到一个包含未实现的操作的方法覆盖头时，返回什么错误码。

尽管支持方法覆盖头的 Web 框架返回可缓存的错误码，但我们观察到只有 Play 1 和 Flask 容易受到 HMO CPDoS 攻击。然而，这两种 Web 框架只有在使用 Fastly、Akamai、Cloudflare、CloudFront、CDN77 和 Varnish 作为中间缓存时才会受到影响。原因是 Play 1 和 Flask 在存在 HTTP 方法覆盖头的情况下，会为 GET 和 POST 请求执行 HTTP 方法更改。Laravel、Symfony 以及 Django 和 Express.js 的插件不受 HMO CPDoS 影响，因为它们忽略 GET 请求中的 HTTP 方法覆盖头，并仅限于将方法转换为 POST 请求。攻击者无法通过 POST 请求毒化测试的 Web 缓存系统，因为这些系统不会存储对 POST 请求的响应。

恶意客户端可以通过发送一个包含方法覆盖头（例如 POST 作为值）的 GET 请求来攻击使用 Play 1 实现的 Web 应用程序。如果相应的资源端点未实现任何 POST 功能，则 Web 框架会返回 404 Not Found 错误码。Akamai、Fastly、CDN77、Cloudflare、CloudFront 和 Varnish 默认会缓存此状态码（见表 1）。Flask 也容易受到 HMO CPDoS 攻击，如果按照 Web 框架网站上的官方教程实现了 HTTP 方法覆盖头的支持。然而，HMO 攻击只有在使用 Akamai 和 CloudFront 作为 CDN 时才有可能，因为 Flask 返回 405 Method Not Allowed 错误码。Akamai 和 CloudFront 是唯一分析的 Web 缓存系统，它们会存储并重用带有此代码的错误页面。