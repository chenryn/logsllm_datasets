# Table 4: Public Exploits Hardened by Q
Table 4 lists public exploits that have been hardened by Q. For each exploit, we record the time taken for the trace and analysis components to run. We also report whether Q produced hardened exploits that call:
1. A linked function.
2. System or WinExec.

## 9. Related Work

### Return-Oriented Programming (ROP)
Krahmer was the first to propose using borrowed code chunks from the program text to perform meaningful actions [25]. Shacham later demonstrated in his seminal paper [41] that a set of Turing-complete gadgets can be created using the program text of libc. He developed an algorithm to put instruction sequences into trie form, aiding manual selection of useful instruction sequences.

Since then, several researchers have explored how to fully automate ROP [16, 21, 38]. Dullien and Kornau [16, 24] automatically found gadgets in mobile support libraries (approximately 1,000KB), while Roemer [38] showed it was possible to automatically discover gadgets in libc (1,300KB). Hund [21] used gadgets from ntoskrnl.exe (3,700KB) and win32k.sys (2,200KB). In contrast, our techniques often only have 20KB of binary code to create gadgets from, as small code modules are typically unrandomized in user-mode exploitation contexts. Previous work focusing on such small code bases was mostly or entirely manual; for example, Checkoway et al. manually crafted a Turing-complete set of gadgets from 16KB of Z80 BIOS [9].

### Automatic Exploitation
Our exploit hardening system (Section 5) is related to existing automatic exploitation research [2, 5, 20, 26]. The goal of automatic exploitation is to automatically find an exploit for a bug when given some starting information, such as a patch [5], guiding input [20, 26], or program precondition [2]. Some automatic exploitation research focuses on creating an input that triggers a particular vulnerability [5, 18, 26], but does not focus on control flow exploitation, which is one of the focuses of our work. Our techniques can use the inputs produced by these projects as an input exploit and harden them to bypass W⊕X and ASLR.

We are aware of one other project that considers creating an exploit given another exploit [20]; in this case, the input exploit only causes a crash. Our work uses symbolic execution to reason about other inputs that take the same path as the input exploit. In contrast, Heelan [20] tracks data dependencies between the desired payload bytes and the input bytes but does not ensure that control flow will stay the same and preserve the observed data dependencies. As a result, his approach is heuristic in nature but is likely to be faster than ours.

### Related Attacks
Other researchers have previously used simple ROP gadgets in the .text section of binaries to calculate the address of functions in libc [39]. Unfortunately, this is insufficient to make arbitrary function calls when ASLR is enabled, as many functions require pointers to data. Recall from Section 2 that all modern operating systems except Mac OS X randomize the stack and heap, making it difficult for an attacker to introduce argument data and know a pointer to its address. QooL (Section 4.3.1) allows target programs to write payloads to known addresses, typically in the .data segment, which eliminates this problem.

A recent attack developed concurrently with Q [27] can also write data to known constant memory locations, enabling arbitrary function calls in the W⊕X and ASLR setting. This attack uses repeated strcpy return-to-libc calls to copy data from the binary itself to a specified location. In contrast, our attack uses ROP gadgets discovered by Q.

There are specialized attacks against W⊕X and ASLR that are only applicable inside a browser, such as JIT spraying [4, 43]. However, they are not applicable to all programs.

### Related Defenses
The most natural way to defeat ROP is to randomize all executable code. For instance, we are not able to deterministically attack position-independent executables in Linux because we do not know where any instruction sequences will be in memory. Operating systems have chosen not to randomize all code in the past due to performance and compatibility issues. These reasons should now be reevaluated considering the new evidence that allowing even small amounts of unrandomized code can enable an attacker to use ROP payloads.

Other defenses against ROP exist. One defense is to dynamically instrument running programs and look for sequences of instructions that contain returns with few instructions spaced between [10, 12]. The assumption is that normal code will generally execute non-trivial amounts of code between ret instructions, whereas ROP code will not.

A similar defense is to ensure that the call chain of a program respects the stack semantics, i.e., that a ret will only transfer control to a program location that previously executed a call instruction. Such techniques [13, 37] are implemented using a shadow stack maintained outside of normal memory space. Both of these defenses assume that ROP must be performed using the ret instruction.

Unfortunately for defenders, researchers [8] have recently shown that it is possible to perform ROP on x86 without using ret instructions at all, which is enough to bypass these schemes without modifications. However, the proof-of-concept techniques required access to large libraries, which are randomized in modern operating systems. It remains an open question whether such attacks are possible in modern user-mode exploitation contexts when little unrandomized code is available.

## 10. Conclusion
We developed return-oriented programming (ROP) techniques that work on small, unrandomized code bases as found in modern systems. We demonstrated that it is possible to synthesize ROP payloads for 80% of programs larger than 20KB, implying that even a small amount of unrandomized code is harmful. We also built an end-to-end exploit hardening system, Q, that reads as input an exploit that does not bypass defenses and automatically hardens it to one that bypasses ASLR and W⊕X.

Our techniques and experiments demonstrate that current ASLR and W⊕X implementations, which allow small amounts of code to be unrandomized, continue to allow ROP attacks. Operating system designers should weigh the dangers of such attacks against the performance and compatibility penalties imposed by randomizing all code by default.

## References
[1] A. Appel. Modern Compiler Implementation in ML. Cambridge University Press, 1998.
[2] T. Avgerinos, S. K. Cha, B. L. T. Hao, and D. Brumley. AEG: Automatic exploit generation. In Proceedings of the Network and Distributed System Security Symposium, Feb. 2011.
[3] Binary Analysis Platform (BAP). http://bap.ece.cmu.edu.
[4] D. Blazakis. Interpreter exploitation. In Proceedings of the USENIX Workshop on Offensive Technologies, 2010.
[5] D. Brumley, P. Poosankam, D. Song, and J. Zheng. Automatic patch-based exploit generation is possible: Techniques and implications. In Proceedings of the IEEE Symposium on Security and Privacy, May 2008.
[6] E. Buchanan, R. Roemer, H. Shacham, and S. Savage. When good instructions go bad: Generalizing return-oriented programming to RISC. In Proceedings of the ACM Conference on Computer and Communications Security, pages 27–38, 2008.
[7] C. Cadar, D. Dunbar, and D. Engler. Klee: Unassisted and automatic generation of high-coverage tests for complex systems programs. In Proceedings of the USENIX Symposium on Operating System Design and Implementation, 2008.
[8] S. Checkoway, L. Davi, A. Dmitrienko, A.-R. Sadeghi, H. Shacham, and M. Winandy. Return-oriented programming without returns. In Proceedings of the ACM Conference on Computer and Communications Security, 2010.
[9] S. Checkoway, J. A. Halderman, U. Michigan, A. J. Feldman, E. W. Felten, B. Kantor, and H. Shacham. Can DREs provide long-lasting security? The case of return-oriented programming and the AVC advantage. In Proceedings of the Electronic Voting Technology Workshop/Workshop on Trustworthy Elections, Aug. 2009.
[10] P. Chen, H. Xiao, X. Shen, X. Yin, B. Mao, and L. Xie. DROP: Detecting return-oriented programming malicious code. In Proceedings of the Information Systems Security Conference, 2009.
[11] J. Clause, W. Li, and A. Orso. Dytan: a generic dynamic taint analysis framework. In International Symposium on Software Testing and Analysis, pages 196–206, New York, NY, USA, 2007. ACM.
[12] L. Davi, A.-R. Sadeghi, and M. Winandy. Dynamic integrity measurement and attestation: towards defense against return-oriented programming attacks. In Proceedings of the ACM workshop on Scalable Trusted Computing, 2009.
[13] L. Davi, A.-R. Sadeghi, and M. Winandy. ROPdefender: a detection tool to defend against return-oriented programming attacks. In Proceedings of the ACM Symposium on Information, Computer, and Communication Security, 2011.
[14] Debian Developers. Debian hardening. http://wiki.debian.org/Hardening?action=recall&rev=34. Accessed: August 8th, 2010.
[15] E. Dijkstra. A Discipline of Programming. Prentice Hall, Englewood Cliffs, NJ, 1976.
[16] T. Dullien and T. Kornau. A framework for automated architecture-independent gadget search. In Proceedings of the USENIX Workshop on Offensive Technologies, Aug. 2010.
[17] C. Flanagan and J. Saxe. Avoiding exponential explosion: Generating compact verification conditions. In Proceedings of the Symposium on Principles of Programming Languages, 2001.
[18] V. Ganapathy, S. A. Seshia, S. Jha, T. W. Reps, and R. E. Bryant. Automatic discovery of API-level exploits. In Proceedings of the International Conference on Software Engineering (ICSE), May 2005.
[19] V. Ganesh and D. L. Dill. A decision procedure for bit-vectors and arrays. In Proceedings of the Conference on Computer Aided Verification, pages 524–536, July 2007.
[20] S. Heelan. Automatic generation of control flow hijacking exploits for software vulnerabilities. Master’s thesis, University of Oxford, 2009.
[21] R. Hund, T. Holz, and F. C. Freiling. Return-oriented rootkits: Bypassing kernel code integrity protection mechanisms. In Proceedings of the USENIX Security Symposium, 2009.
[22] Intel Corporation. Intel 64 and IA-32 architectures software developer’s manual – volume 3A: System programming guide, part 1. Document number 253668, 2010.
[23] I. Jager and D. Brumley. Efficient directionless weakest preconditions. Technical Report CMU-CyLab-10-002, Carnegie Mellon University, CyLab, Feb. 2010.
[24] T. Kornau. Return oriented programming for the ARM architecture. Master’s thesis, Ruhr-Universität Bochum, 2009.
[25] S. Krahmer. x86-64 buffer overflow exploits and the borrowed code chunks exploitation technique. http://www.suse.de/~krahmer/no-nx.pdf, 2005.
[26] Z. Lin, X. Zhang, and D. Xu. Convicting exploitable software vulnerabilities: An efficient input provenance based approach. In International Conference on Dependable Systems and Networks, 2008.
[27] L. D. Long. Payload already inside: Data reuse for ROP exploits. Technical report, Blackhat, 2010.
[28] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney, S. Wallace, V. J. Reddi, and K. Hazelwood. Pin: Building customized program analysis tools with dynamic instrumentation. In Proceedings of the ACM Conference on Programming Language Design and Implementation, June 2005.
[29] Microsoft Software Developer Network. Windows Vista ISV security. http://msdn.microsoft.com/en-us/library/bb430720.aspx.
[30] Microsoft Support. A detailed description of the data execution prevention (DEP) feature in Windows XP Service Pack 2, Windows XP Tablet PC Edition 2005, and Windows Server 2003. http://support.microsoft.com/kb/875352/EN-US/.
[31] I. Molnar. Exec-shield Linux patch. http://people.redhat.com/mingo/exec-shield/.
[32] T. Müller. ASLR smack & laugh reference. Technical report, RWTH-Aachen University, 2008. http://www-users.rwth-aachen.de/Tilo.Mueller/ASLRpaper.pdf.
[33] J. Newsome and D. Song. Dynamic taint analysis for automatic detection, analysis, and signature generation of exploits on commodity software. In Proceedings of the Network and Distributed System Security Symposium, Feb. 2005.
[34] PaX Team. PaX Address Space Layout Randomization (ASLR). http://pax.grsecurity.net/docs/aslr.txt.
[35] PaX Team. PaX Non-Executable Stack (NX). http://pax.grsecurity.net/docs/noexec.txt.
[36] A. R. Pop. DEP/ASLR implementation progress in popular third-party Windows applications. http://secunia.com/gfx/pdf/DEP_ASLR_2010_paper.pdf, 2010. Secunia.
[37] M. Prasad and T. Tucker Chiueh. A binary rewriting defense against stack-based buffer overflow attacks. In Proceedings of the USENIX Annual Technical Conference, 2003.
[38] R. G. Roemer. Finding the bad in good code: Automated return-oriented programming exploit discovery. Master’s thesis, University of California, San Diego, 2009.
[39] G. F. Roglia, L. Martignoni, R. Paleari, and D. Bruschi. Surgically returning to randomized lib(c). In Proceedings of the Annual Computer Security Applications Conference, pages 60–69, 2009.
[40] E. J. Schwartz, T. Avgerinos, and D. Brumley. All you ever wanted to know about dynamic taint analysis and forward symbolic execution (but might have been afraid to ask). In Proceedings of the IEEE Symposium on Security and Privacy, pages 317–331, May 2010.
[41] H. Shacham. The geometry of innocent flesh on the bone: Return-into-libc without function calls (on the x86). In Proceedings of the ACM Conference on Computer and Communications Security, 2007.
[42] H. Shacham, M. Page, B. Pfaff, E.-J. Goh, N. Modadugu, and D. Boneh. On the effectiveness of address-space randomization. In Proceedings of the ACM Conference on Computer and Communications Security, pages 298–307, 2004.
[43] A. Sotirov and M. Dowd. Bypassing browser memory protections. Technical report, Blackhat, 2008. http://taossa.com/archive/bh08sotirovdowd.pdf.
[44] Ubuntu Developers. Ubuntu security/features. https://wiki.ubuntu.com/Security/Features?action=recall&rev=52. Accessed: August 8th, 2010.