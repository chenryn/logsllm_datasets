### Security Proof and Adversarial Data Owner

**Theorem 5.** Let \( L \) be a leakage function defined as \( L(\bar{w}) = av(\bar{w}) \). The OSPIR-SSE scheme, instantiated with the Hashed Diffie-Hellman OPRF, is \( L \)-semantically-secure against a malicious data owner.

**Proof.** See full version [20].

In this context, a malicious data owner \( D \) learns nothing about the client's query \( \bar{w} = (w_1, \ldots, w_n) \) except for the vector of attributes \( av(\bar{w}) = (I(w_1), \ldots, I(w_n)) \).

### Detailed Explanation

In the instantiation of the OSPIR-OXT scheme using the Hashed Diffie-Hellman OPRF (as shown in Figure 3), the values \( a_1, \ldots, a_n \) are formed as \( a_j \leftarrow H(w_j)^{r_j} \) for random \( r_j \) in \( \mathbb{Z}_p^* \). Additionally, \( a_1 \) is set to a specific value. Since \( G \) is a cyclic group of prime order \( p \) generated by an element \( g \), every non-identity element in \( G \) is a generator. Thus, each \( a_j \) is uniformly distributed in \( G \). Consequently, the view of the GenToken protocol from the perspective of \( D \) can be trivially simulated from \( L(\bar{w}) = av(\bar{w}) \).

### Extensions: Reducing Leakage to \( D \)

In the full version [20], we demonstrate how to adapt the OSPIR-OXT scheme to a setting where a third party, called a policy manager, authorizes queries. In this setting, \( D \) can enforce these queries without learning the policy, the boolean expression, or the queried attributes; only the number of such attributes is learned by \( D \). This setup is ideal for implementing searches authorized by a warrant while keeping the searched information hidden from all parties except the authorized searcher.

Additionally, the OSPIR-OXT scheme can be extended (even without introducing a policy manager) to further limit the leakage of queried attributes to \( D \). Specifically, the leakage can be reduced to the minimum necessary for making policy decisions. For example, \( D \) may not need to know the exact attributes in a query but only the attribute classes they belong to.

### Acknowledgment

This work was supported by the Intelligence Advanced Research Projects Activity (IARPA) via the Department of Interior National Business Center (DoI/NBC) contract number D11PC20201. The U.S. Government is authorized to reproduce and distribute reprints for governmental purposes, notwithstanding any copyright annotation thereon. Disclaimer: The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of IARPA, DoI/NBC, or the U.S. Government.

### References

[1] M. Abdalla, M. Bellare, D. Catalano, E. Kiltz, T. Kohno, T. Lange, J. Malone-Lee, G. Neven, P. Paillier, and H. Shi. Searchable encryption revisited: Consistency properties, relation to anonymous IBE, and extensions. In V. Shoup, editor, CRYPTO 2005, volume 3621 of LNCS, pages 205–222. Springer, Aug. 2005.

[2] L. Ballard, S. Kamara, and F. Monrose. Achieving efficient conjunctive keyword searches over encrypted data. In S. Qing, W. Mao, J. López, and G. Wang, editors, ICICS 05, volume 3783 of LNCS, pages 414–426. Springer, Dec. 2005.

[3] M. Bellare, A. Boldyreva, and A. O’Neill. Deterministic and efficiently searchable encryption. In A. Menezes, editor, CRYPTO 2007, volume 4622 of LNCS, pages 535–552. Springer, Aug. 2007.

[4] D. J. Bernstein. Faster square roots in annoying finite fields. http://cr.yp.to/papers/sqroot.pdf, 2001.

[5] D. Boneh, G. Di Crescenzo, R. Ostrovsky, and G. Persiano. Public key encryption with keyword search. In C. Cachin and J. Camenisch, editors, EUROCRYPT 2004, volume 3027 of LNCS, pages 506–522. Springer, May 2004.

[6] D. Boneh and B. Waters. Conjunctive, subset, and range queries on encrypted data. In S. P. Vadhan, editor, TCC 2007, volume 4392 of LNCS, pages 535–554. Springer, Feb. 2007.

[7] J. W. Byun, D. H. Lee, and J. Lim. Efficient conjunctive keyword search on encrypted data storage system. In EuroPKI, pages 184–196, 2006.

[8] D. Cash, J. Jaeger, S. Jarecki, C. Jutla, H. Krawczyk, M.-C. Roşu, and M. Steiner. Dynamic Searchable Encryption in Very Large Databases: Data Structures and Implementation. Manuscript, 2013.

[9] D. Cash, S. Jarecki, C. Jutla, H. Krawczyk, M. Rosu, and M. Steiner. Highly-scalable searchable symmetric encryption with support for boolean queries. Crypto'2013. Cryptology ePrint Archive, Report 2013/169, Mar. 2013. http://eprint.iacr.org/2013/169.

[10] Y.-C. Chang and M. Mitzenmacher. Privacy preserving keyword searches on remote encrypted data. In J. Ioannidis, A. Keromytis, and M. Yung, editors, ACNS 05, volume 3531 of LNCS, pages 442–455. Springer, June 2005.

[20] S. Jarecki, C. Jutla, H. Krawczyk, M. C. Rosu, and M. Steiner. Outsourced symmetric private information retrieval. http://eprint.iacr.org/2013/.

[21] S. Jarecki and X. Liu. Efficient oblivious pseudorandom function with applications to adaptive OT and secure computation of set intersection. In O. Reingold, editor, TCC 2009, volume 5444 of LNCS, pages 577–594. Springer, Mar. 2009.

[22] S. Jarecki and X. Liu. Fast secure computation of set intersection. In SCN 10, LNCS, pages 418–435. Springer, 2010.

[23] S. Kamara and K. Lauter. Cryptographic cloud storage. In Financial Cryptography Workshops, pages 136–149, 2010.

[24] S. Kamara, C. Papamanthou, and T. Roeder. Dynamic searchable symmetric encryption. In Proc. of CCS'2012, 2012.

[25] K. Kurosawa and Y. Ohtaki. UC-secure searchable symmetric encryption. In Financial Cryptography, page 285, 2012.

[11] M. Chase and S. Kamara. Structured encryption and controlled disclosure. In ASIACRYPT 2010, LNCS, pages 577–594. Springer, Dec. 2010.

[26] M. Naor and O. Reingold. Number-theoretic constructions of efficient pseudo-random functions. In 38th FOCS, pages 458–467. IEEE Computer Society Press, Oct. 1997.

[27] V. Pappas, B. Vo, F. Krell, S. G. Choi, V. Kolesnikov, A. Keromytis, and T. Malkin. Blind Seer: A Scalable Private DBMS. Manuscript, 2013.

[28] E. Shi, J. Bethencourt, H. T.-H. Chan, D. X. Song, and A. Perrig. Multi-dimensional range query over encrypted data. In 2007 IEEE Symposium on Security and Privacy, pages 350–364. IEEE Computer Society Press, May 2007.

[29] D. X. Song, D. Wagner, and A. Perrig. Practical techniques for searches on encrypted data. In 2000 IEEE Symposium on Security and Privacy, pages 44–55. IEEE Computer Society Press, May 2000.

[30] P. van Liesdonk, S. Sedhi, J. Doumen, P. H. Hartel, and W. Jonker. Computationally efficient searchable symmetric encryption. In Proc. Workshop on Secure Data Management (SDM), pages 87–100, 2010.

[31] B. R. Waters, D. Balfanz, G. Durfee, and D. K. Smetters. Building an encrypted and searchable audit log. In NDSS 2004. The Internet Society, Feb. 2004.

[32] WSJ. U.S. Terrorism Agency to Tap a Vast Database of Citizens. Wall Street Journal 12/13/12. http://alturl.com/ot72x.

[12] E. D. Cristofaro, Y. Lu, and G. Tsudik. Efficient techniques for privacy-preserving sharing of sensitive information. In J. M. McCune, B. Balacheff, A. Perrig, A.-R. Sadeghi, A. Sasse, and Y. Beres, editors, TRUST, volume 6740 of Lecture Notes in Computer Science, pages 239–253. Springer, 2011.

[13] R. Curtmola, J. A. Garay, S. Kamara, and R. Ostrovsky. Searchable symmetric encryption: improved definitions and efficient constructions. In A. Juels, R. N. Wright, and S. Vimercati, editors, ACM CCS 06, pages 79–88. ACM Press, Oct. / Nov. 2006.

[14] M. J. Freedman, Y. Ishai, B. Pinkas, and O. Reingold. Keyword search and oblivious pseudorandom functions. In J. Kilian, editor, TCC 2005, volume 3378 of LNCS, pages 303–324. Springer, Feb. 2005.

[15] E.-J. Goh. Secure indexes. Cryptology ePrint Archive, Report 2003/216, 2003. http://eprint.iacr.org/.

[16] P. Golle, J. Staddon, and B. R. Waters. Secure conjunctive keyword search over encrypted data. In M. Jakobsson, M. Yung, and J. Zhou, editors, ACNS 04, volume 3089 of LNCS, pages 31–45. Springer, June 2004.

[17] Y. Huang and I. Goldberg. Outsourced private information retrieval with pricing and access control. Technical Report 2013-11, Centre for Applied Cryptographic Research (CACR), University of Waterloo, Feb. 2013.

[18] IARPA. Security and Privacy Assurance Research (SPAR) Program - BAA, 2011. http://www.iarpa.gov/solicitations_spar.html/.

[19] M. Islam, M. Kuzu, and M. Kantarcioglu. Access pattern disclosure on searchable encryption: Ramification, attack and mitigation. In Proceedings of the Symposium on Network and Distributed Systems Security (NDSS 2012), San Diego, CA, Feb. 2012. Internet Society.

### Group Operations and Key Generation

- **Group Operations:** \( G \) is a cyclic group of prime order \( p \) generated by an element \( g \). \( H \) is a hash function with a range in \( G \setminus \{1\} \).
- **EDBSetup(DB, RDK):**
  - **Key Generation:** 
    - \( D \) picks key \( KS \) and two vectors of elements \( KT = (k_1, \ldots, k_m) \) and \( KX = (e_1, \ldots, e_m) \) at random in \( \mathbb{Z}_p^* \) (where \( m \) is the number of attributes).
    - Key \( KI \) for PRF \( F_p \); and key \( KM \) for a symmetric authenticated encryption \( AuthEnc \).
    - \( F_p \) and \( F_\tau \) are PRFs that output strings in \( \mathbb{Z}_p^* \) and \( \{0, 1\}^\tau \), respectively, where \( \tau \) is a security parameter.
  - **Initialization:**
    - Initialize \( XSet \) to an empty set, and initialize \( T \) to an empty array indexed by group elements in \( G \).
  - **For each \( w = (i, val) \in W \):**
    - Build the tuple list \( t \) and add elements to \( XSet \) as follows:
      - Initialize \( t \) to an empty list.
      - Set \( strap \leftarrow (H(w))^{KS} \).
      - Set \( stag \leftarrow (H(w))^{KT[i]} \).
      - Initialize \( c \leftarrow 0 \); then for all \( ind \) in \( DB(w) \) in random order:
        - Set \( (K_z, K_e) \leftarrow (F_\tau(strap, 1), F_\tau(strap, 2)) \).
        - Set \( rdk \leftarrow RDK(ind) \), \( e \leftarrow Enc(K_e, (ind | rdk)) \), \( x_{ind} \leftarrow F_p(KI, ind) \).
        - Set \( c \leftarrow c + 1 \), \( z_c \leftarrow F_p(K_z, c) \), \( y \leftarrow x_{ind} \cdot z_c^{-1} \).
        - Set \( xtag \leftarrow H(w)^{KX[i]} \cdot x_{ind} \) and add \( xtag \) to \( XSet \).
        - Append \( (e, y) \) to \( t \).
      - Set \( T[stag] \leftarrow t \).
  - **Create \( TSet \leftarrow TSetSetup0(T) \), and output key \( K = (KS, KX, KT, KI, KM) \) and EDB = (TSet, XSet, KM) \).

### GenToken Protocol

- **Client \( C \) on input a conjunctive query \( \bar{w} = (w_1, \ldots, w_n) \), where \( w_1 \) is chosen as the s-term, proceeds as follows:**
  - Pick \( r_1, \ldots, r_n \leftarrow \mathbb{Z}_p^* \) and set \( a_j \leftarrow (H(w_j))^{r_j} \) for \( j = 1, \ldots, n \).
  - Send to \( D \) the blinded queries \( a_1, \ldots, a_n \) and the attribute sequence \( av = (I(w_1), \ldots, I(w_n)) \).
- **Data Owner \( D \) on input policy \( P \) and key \( K \) proceeds as follows:**
  - Abort if \( av \notin P \). Otherwise, set \( av \) as a local output. Pick \( \rho_1, \ldots, \rho_n \leftarrow \mathbb{Z}_p^* \).
  - Set \( strap0 \leftarrow (a_1)^s \), \( bstag0 \leftarrow (a_1)^{k_{i1} \cdot \rho_1} \), and \( bxtrap0_j \leftarrow (a_j)^{e_{ij} \cdot \rho_j} \) for \( j = 2, \ldots, n \).
  - Reply to \( C \) with \( (strap0, bstag0, bxtrap0_2, \ldots, bxtrap0_n) \) and \( env = AuthEnc_{KM}(\rho_1, \ldots, \rho_n) \).
- **Client \( C \) sets:**
  - \( strap \leftarrow (strap0)^{r_1^{-1}} \); \( bstag \leftarrow (bstag0)^{r_1^{-1}} \); \( bxtrap_j \leftarrow (bxtrap0_j)^{r_j^{-1}} \) for \( j = 2, \ldots, n \).
  - \( token \leftarrow (env, strap, bstag, bxtrap_2, \ldots, bxtrap_n) \).

### Search Protocol

- **Client \( C \) on input \( token \) proceeds as follows:**
  - Set \( (K_z, K_e) \leftarrow (F_\tau(strap, 1), F_\tau(strap, 2)) \), and send to \( E \) the message \( (env, bstag, bxtoken[1], bxtoken[2], \ldots) \) defined as follows:
    - For \( c = 1, 2, \ldots \), until \( E \) sends stop:
      - Set \( z_c \leftarrow F_p(K_z, c) \) and set \( bxtoken[c, i] \leftarrow (bxtrapi)^{z_c} \) for \( i = 2, \ldots, n \).
      - Set \( bxtoken[c] \leftarrow (bxtoken[c, 2], \ldots, bxtoken[c, n]) \).
- **Server \( E \) on input \( EDB = (TSet, XSet, KM) \) responds as follows:**
  - Upon receiving \( env, bstag \) from \( C \), decrypt/verify \( env \); if verification fails, return "no results" and stop.
  - Set \( stag \leftarrow (bstag)^{1/\rho_1} \) and retrieve \( t \leftarrow TSetRetrieve(TSet, stag) \) from \( TSet \).
  - For \( c = 1, \ldots, |t| \) do:
    - Receive \( bxtoken[c] \) from \( C \) and retrieve value \( (e, y) \) from the \( c \)-th tuple in \( t \).
    - Check if \( bxtoken[c, i]^y / \rho_i \in XSet \) for all \( i = 2, \ldots, n \). If so, send \( e \) to \( C \) (else, nothing is returned for this tuple).
    - When the last tuple in \( t \) is reached, send stop to \( C \) and halt.
- **For each received \( e \), client \( C \) computes \( (ind | rdk) \leftarrow Dec(K_e, e) \) and outputs \( (ind, rdk) \).**

### Figure 3: OSPIR-OXT Instantiated for Conjunctive Queries with the Hashed Diffie-Hellman OPRF

887