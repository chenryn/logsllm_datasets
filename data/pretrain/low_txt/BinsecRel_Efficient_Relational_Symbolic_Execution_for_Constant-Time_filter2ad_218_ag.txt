以下是经过优化后的参考文献列表，使其更加清晰、连贯和专业：

1. [41] Q. H. Do, R. Bubel, and R. Hähnle, “Exploit generation for information flow leaks in object-oriented programs,” in *SEC*, 2015.
2. [42] D. Milushev, W. Beck, and D. Clarke, “Noninterference in Formal Techniques for Distributed Systems via symbolic execution,” in *Distributed Systems*, 2012.
3. [43] P. Subramanyan, S. Malik, H. Khattri, A. Maiti, and J. M. Fung, “Verifying information flow properties of firmware using symbolic execution,” in *DATE*, 2016.
4. [44] N. Benton, “Simple relational correctness proofs for static analyses and program transformations,” in *POPL*, 2004.
5. [45] G. Barthe, J. M. Crespo, and C. Kunz, “Relational verification using product programs,” in *FM*, 2011.
6. [46] T. H. Austin and C. Flanagan, “Multiple facets for dynamic information flow,” in *POPL*, 2012.
7. [47] M. Ngo, N. Bielova, C. Flanagan, T. Rezk, A. Russo, and T. Schmitz, “A better facet of dynamic information flow control,” in *WWW (Companion Volume)*, 2018.
8. [48] H. Palikareva, T. Kuchta, and C. Cadar, “Shadow of a doubt: Testing for divergences between software versions,” in *ICSE*, 2016.
9. [49] G. P. Farina, S. Chong, and M. Gaboardi, “Relational symbolic execution,” in *PPDP*, 2019.
10. [50] N. J. AlFardan and K. G. Paterson, “Lucky thirteen: Breaking the TLS and DTLS record protocols,” in *S&P*, 2013.
11. [51] C. Cadar, D. Dunbar, and D. R. Engler, “KLEE: Unassisted and automatic generation of high-coverage tests for complex systems programs,” in *OSDI*, 2008.
12. [52] T. Avgerinos, D. Brumley, J. Davis, R. Goulden, T. Nighswander, A. Rebert, and N. Williamson, “The Mayhem cyber reasoning system,” *IEEE Security & Privacy*, vol. 16, no. 2, 2018.
13. [53] V. Chipounov, V. Kuznetsov, and G. Candea, “The S2E platform: Design, implementation, and applications,” *ACM Trans. Comput. Syst.*, vol. 30, no. 1, 2012.
14. [54] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino, A. Dutcher, J. Grosen, S. Feng, C. Hauser, C. Kruegel, and G. Vigna, “SOK: (State of) The Art of War: Offensive techniques in binary analysis,” in *S&P*, 2016.
15. [55] R. David, S. Bardin, T. D. Ta, L. Mounier, J. Feist, M. Potet, and J. Marion, “BINSEC/SE: A dynamic symbolic execution toolkit for binary-level analysis,” in *SANER*, 2016.
16. [56] J. C. King, “Symbolic execution and program testing,” *Commun. ACM*, vol. 19, no. 7, 1976.
17. [57] J. Vanegue and S. Heelan, “SMT solvers in software security,” in *WOOT*, 2012.
18. [58] T. Avgerinos, S. K. Cha, B. L. T. Hao, and D. Brumley, “AEG: Automatic exploit generation,” in *NDSS*, 2011.
19. [59] E. J. Schwartz, T. Avgerinos, and D. Brumley, “Q: Exploit hardening made easy,” in *USENIX*, 2011.
20. [60] B. Yadegari, B. Johannesmeyer, B. Whitely, and S. Debray, “A generic approach to automatic deobfuscation of executable code,” in *S&P*, 2015.
21. [61] S. Bardin, R. David, and J. Marion, “Backward-bounded targeting infeasibility questions on obfuscated codes,” in *S&P*, 2017.
22. [62] J. Salwan, S. Bardin, and M. Potet, “Symbolic deobfuscation: From virtualized code back to the original,” in *DIMVA*, 2018.
23. [63] C. Barrett, P. Fontaine, and C. Tinelli, “The SMT-LIB Standard: Version 2.6,” Department of Computer Science, The University of Iowa, Tech. Rep., 2017.
24. [64] FixedSizeBitVectors Theory, SMT-LIB. [Online]. Available: http://smtlib.cs.uiowa.edu/theories-FixedSizeBitVectors.shtml (visited on 04/02/2019).
25. [65] ArraysEx Theory, SMT-LIB. [Online]. Available: http://smtlib.cs.uiowa.edu/theories-ArraysEx.shtml (visited on 04/02/2019).
26. [66] B. Farinier, R. David, S. Bardin, and M. Lemerre, “Arrays made simpler: An efficient, scalable and thorough preprocessing,” in *LPAR*, 2018.
27. [67] D. J. Bernstein, “Curve25519: New Diffie-Hellman speed records,” in *Public Key Cryptography*, 2006.
28. [68] S. Bardin, P. Herrmann, J. Leroux, O. Ly, R. Tabary, and A. Vincent, “The BINCOA framework for binary code analysis,” in *CAV*, 2011.
29. [69] G. Barthe, B. Grégoire, and V. Laporte, “Secure compilation of side-channel countermeasures: The case of cryptographic 'constant-time',” in *CSF*, 2018.
30. [70] A. Niemetz, M. Preiner, and A. Biere, “Boolector 2.0 system description,” *Journal on Satisfiability, Boolean Modeling and Computation*, vol. 9, 2014.
31. [71] SMT-COMP. [Online]. Available: https://smt-comp.github.io/2019/results.html (visited on 10/11/2019).
32. [72] Imdea-software/verifying-constant-time. [Online]. Available: https://github.com/imdea-software/verifying-constant-time (visited on 10/13/2019).
33. [73] D. J. Wheeler and R. M. Needham, “TEA, a tiny encryption algorithm,” in *FSE*, 1994.
34. [74] F. Recoules, S. Bardin, R. B. Bonichon, L. Mounier, and M.-L. Potet, “Get rid of inline assembly through verification-oriented lifting,” in *ASE*, 2019.
35. [75] B. Farinier, S. Bardin, R. Bonichon, and M. Potet, “Model generation for quantified formulas: A taint-based approach,” in *CAV (2)*, 2018.
36. [76] R. David, S. Bardin, J. Feist, L. Mounier, M. Potet, T. D. Ta, and J. Marion, “Specification of concretization and symbolization policies in symbolic execution,” in *ISSTA*, 2016.
37. [77] M. Jung, S. Kim, H. Han, J. Choi, and S. K. Cha, “B2R2: Building an efficient front-end for binary analysis,” in *The BAR Workshop, Internet Society*, 2019.
38. [78] C. Cadar and H. Palikareva, “Shadow symbolic execution for better testing of evolving software,” in *ICSE*, 2014.
39. [79] J. Agat, “Transforming out timing leaks,” in *POPL*, 2000.
40. [80] D. Molnar, M. Piotrowski, D. Schultz, and D. A. Wagner, “The program counter security model: Automatic detection and removal of control-flow side channel attacks,” in *ICISC*, 2005.
41. [81] B. Rodrigues, F. M. Q. Pereira, and D. F. Aranha, “Sparse representation of implicit flows with applications to side-channel detection,” in *CC*, 2016.
42. [82] S. Chattopadhyay and A. Roychoudhury, “Symbolic verification of cache side-channel freedom,” *IEEE Trans. on CAD of Integrated Circuits and Systems*, vol. 37, no. 11, 2018.
43. [83] M. Wu, S. Guo, P. Schaumont, and C. Wang, “Eliminating timing side-channel leaks using program repair,” in *ISSTA*, 2018.
44. [84] O. Reparaz, J. Balasch, and I. Verbauwhede, “Dude, is my code constant time?” in *DATE*, 2017.

### 附录

#### A. 符号评估 - 完整规则集
符号评估的完整规则集见图7。

#### B. 证明
令 \( c_k \) 和 \( c'_k \) 为具体配置，\( s_k \) 为符号配置。归纳假设成立，即 \( s_0 \vdash s_k \) 且 \( c_k \sim_l s_k \) 以及 \( c'_k \sim_r s_k \)。对于每个具体步骤 \( c_k \xrightarrow{t} c_{k+1} \) 和 \( c'_k \xrightarrow{t'} c'_{k+1} \)，若 \( t = t' \)，我们需要证明可以在符号执行中进行一步 \( s_k \rightarrow s_{k+1} \)，并且 \( c_{k+1} \sim_l s_{k+1} \) 以及 \( c'_{k+1} \sim_r s_{k+1} \) 成立。

符号执行不会陷入僵局，除非存在不安全的情况。因此，从 \( t = t' \) 可以推导出存在一个符号配置 \( s_{k+1} \) 使得 \( s_k \vdash s_{k+1} \)。现在需要证明 \( c_{k+1} \sim_l s_{k+1} \) 以及 \( c'_{k+1} \sim_r s_{k+1} \) 成立。给定归纳假设 \( c_k \sim_l s_k \) 以及 \( c'_k \sim_r s_k \)，可以证明每条符号规则都保持了关系在下一步中的不变性。

以下是一些具体的规则示例：
- **Expr**
  - **BINOP**：二元操作
  - **LOAD**：加载
- **Instr**
  - **D_JUMP**：直接跳转
  - **S_JUMP**：条件跳转
  - **UNOP**：一元操作
  - **CST**：常量
  - **VAR**：变量
  - **ITE-TRUE**：条件语句（真）

这些规则确保了符号执行与具体执行之间的关系保持一致。