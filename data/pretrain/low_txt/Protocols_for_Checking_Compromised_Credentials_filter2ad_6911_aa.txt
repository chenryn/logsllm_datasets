# Title: Protocols for Checking Compromised Credentials

## Authors:
- Lucy Li
- Bijeeta Pal
- Junade Ali
- Nick Sullivan
- Rahul Chatterjee
- Thomas Ristenpart

## Abstract
To prevent credential stuffing attacks, it is now an industry best practice to proactively check if user credentials are present in known data breaches. Recently, services like HaveIBeenPwned (HIBP) and Google Password Checkup (GPC) have started providing APIs to check for breached passwords. We refer to such services as compromised credential checking (C3) services. This paper provides the first formal description of C3 services, detailing different settings and operational requirements, and outlines relevant threat models.

One key security requirement is the secrecy of a user’s password being checked. Current widely deployed C3 services use a small prefix of a hash computed over the user’s password. We provide a framework for empirically analyzing the leakage of such protocols, showing that in some contexts, knowing the hash prefixes can lead to a 12x increase in the efficacy of remote guessing attacks. We propose two new protocols that provide stronger protection for users’ passwords, implement them, and show experimentally that they remain practical to deploy.

## 1. Introduction
Password database breaches have become routine [9]. Such breaches enable credential stuffing attacks, where attackers try to compromise accounts by submitting one or more passwords leaked from another website. To counter credential stuffing, companies and organizations have begun checking if their users’ passwords appear in breaches, and if so, deploying further protections (e.g., resetting the user’s password or warning the user). Information on what usernames and passwords have appeared in breaches is gathered either from public sources or from third-party services. The latter democratizes access to leaked credentials, making it easy for others to help their customers gain confidence that they are not using exposed passwords. We refer to such services as compromised credential checking services, or C3 services.

Two prominent C3 services already operate. HaveIBeenPwned (HIBP) [46] was deployed by Troy Hunt and CloudFlare in 2018 and is used by many web services, including Firefox [14], EVE Online [10], and 1Password [5]. Google released a Chrome extension called Password Checkup (GPC) [44, 45] in 2019, which allows users to check if their username-password pairs appear in a compromised dataset. Both services work by having the user share with the C3 server a prefix of the hash of their password or of the hash of their username-password pair. This leaks some information about user passwords, which is problematic should the C3 server be compromised or otherwise malicious. Until now, there has been no thorough investigation into the damage from the leakage of current C3 services or suggestions for protocols that provide better privacy.

We provide the first formal treatment of C3 services for different settings, including an exploration of their security guarantees. A C3 service must provide secrecy of client credentials and ideally preserve the secrecy of the leaked datasets held by the C3 server. The computational and bandwidth overhead for the client and especially the server should also be low. The server might hold billions of leaked records, precluding the use of existing cryptographic protocols for private set intersection (PSI) [29, 36], which would use a prohibitive amount of bandwidth at this scale.

Current industry-deployed C3 services reduce bandwidth requirements by dividing the leaked dataset into buckets before executing a PSI protocol. The client shares with the C3 server the identifier of the bucket where their credentials would be found, if present in the leak dataset. Then, the client and the server engage in a protocol between the bucket held by the server and the credential held by the client to determine if their credential is indeed in the leak. In current schemes, the prefix of the hash of the user credential is used as the bucket identifier. The client shares the hash prefix (bucket identifier) of their credentials with the C3 server.

Revealing hash prefixes of credentials may be dangerous. We outline an attack scenario against such prefix-revealing C3 services. In particular, we consider a conservative setting where the C3 server attempts to guess the password while knowing the username and the hash prefix associated with the queried credential. We rigorously evaluate the security of HIBP and GPC under this threat model via a mixture of formal and empirical analysis.

We start by considering users with a password appearing in some leak and show how to adapt a recent state-of-the-art credential tweaking attack [40] to take advantage of the knowledge of hash prefixes. In a credential tweaking attack, one uses the leaked password to determine likely guesses (usually, small tweaks on the leaked password). Via simulation, we show that our variant of credential tweaking successfully compromises 83% of such accounts with 1,000 or fewer attempts, given the transcript of a query made to the HIBP server. Without knowledge of the transcript, only 56% of these accounts can be compromised within 1,000 guesses.

We also consider user accounts not present in a leak. Here we found that the leakage from the hash prefix disproportionately affects security compared to the previous case. For these user accounts, obtaining the query to HIBP enables the attacker to guess 71% of passwords within 1,000 attempts, which is a 12x increase over the success with no hash prefix information. Similarly, for GPC, our simulation shows 33% of user passwords can be guessed in 10 or fewer attempts (and 60% in 1,000 attempts), should the attacker learn the hash prefix shared with the GPC server.

The attack scenarios described are conservative because they assume the attacker can infer which queries to the C3 server are associated with which usernames. This may not always be possible. Nevertheless, caution dictates that we would prefer schemes that leak less. We therefore present two new C3 protocols, one that checks for leaked passwords (like HIBP) and one that checks for leaked username-password pairs (like GPC). Like GPC and HIBP, we partition the password space before performing PSI, but we do so in a way that significantly reduces leakage.

Our first scheme works when only passwords are queried to the C3 server. It utilizes a novel approach that we call frequency-smoothing bucketization (FSB). The key idea is to use an estimate of the distribution of human-chosen passwords to assign passwords to buckets in a way that flattens the distribution of accessed buckets. We show how to obtain good estimates (using leaked data), and, via simulation, that FSB reduces leakage significantly (compared to HIBP). In many cases, the best attack given the information leaked by the C3 protocol works no better than having no information at all. While the benefits come with some added computational complexity and bandwidth, we show via experimentation that the operational overhead for the FSB C3 server or client is comparable with the overhead from GPC, while also leaking much less information than hash-prefix-based C3 protocols.

We also describe a more secure bucketizing scheme that provides a better privacy/bandwidth trade-off for C3 servers that store username-password pairs. This scheme was also independently proposed in [45], and Google states that they plan to transition to using it in their Chrome extension. It is a simple modification of their current protocol. We refer to it as IDB, ID-based bucketization, as it uses the hash prefix of only the user identifier for bucketization (instead of the hash prefix of the username-password pair, as currently used by GPC). Not having password information in the bucket identifier hides the user’s password perfectly from an attacker who obtains the client queries (assuming that passwords are independent of usernames). We implement IDB and show that the average bucket size in this setting for a hash prefix of 16 bits is similar to that of GPC (average 16,122 entries per bucket, which leads to a bandwidth of 1,066 KB).

### Contributions
In summary, the main contributions of this paper are the following:
- We provide a formalization of C3 protocols and detail the security goals for such services.
- We discuss various threat models for C3 services and analyze the security of two widely deployed C3 protocols. We show that an attacker who learns the queries from a client can severely damage the security of the client’s passwords, should they also know the client’s username.
- We give a new C3 protocol (FSB) for checking only leaked passwords that utilizes knowledge of the human-chosen password distribution to reduce leakage.
- We give a new C3 protocol for checking leaked username-password pairs (IDB) that bucketizes using only usernames.
- We analyze the performance and security of both new C3 protocols to show feasibility in practice.

We will release as public, open-source code our server and client implementations of FSB and IDB.

## 2. Overview
We investigate approaches to checking credentials present in previous breaches. Several third-party services provide credential checking, enabling users and companies to mitigate credential stuffing and credential tweaking attacks [24, 40, 47], an increasingly daunting problem for account security.

To date, such C3 services have not received in-depth security analyses. We start by describing the architecture of such services and then detail relevant threat models.

### C3 Settings
We provide a diagrammatic summary of the abstract architecture of C3 services in Figure 1. A C3 server has access to a breach database \(\tilde{S}\). We can think of \(\tilde{S}\) as a set of size \(N\), which consists of either a set of passwords \(\{w_1, \ldots, w_N\}\) or username-password pairs \(\{(u_1, w_1), \ldots, (u_N, w_N)\}\). This corresponds to two types of C3 services: password-only C3 services and username-password C3 services. For example, HIBP [6] is a password-only C3 service, and Google’s service GPC [44] is an example of a username-password C3 service.

A client has as input a credential \(s = (u, w)\) and wants to determine if \(s\) is at risk due to exposure. The client and server therefore engage in a set membership protocol to determine if \(s \in \tilde{S}\). Here, clients can be users themselves (querying the C3 service using, say, a browser extension), or other web services can query the C3 service on behalf of their users. Clients may make multiple queries to the C3 service, though the number of queries might be rate-limited.

The ubiquity of breaches means that, nowadays, the breach database \(\tilde{S}\) will be quite large. A recently leaked compilation of previous breached data contains 1.4 billion username-password pairs [21]. The HIBP database has 501 million unique passwords [6]. Google’s blog specifies that there are 4 billion username-password pairs in their database of leaked credentials [44].

C3 protocols should be able to scale to handle set membership requests for these huge datasets for millions of requests a day. HIBP reported serving around 600,000 requests per day on average [7]. The design of a C3 protocol should therefore not be expensive for the server. Some clients may have limited computational power, so the C3 protocol should also not be expensive on the client-side. The number of network round trips required must be low, and we restrict attention to protocols that can be completed with a single HTTPS request. Finally, we will want to minimize bandwidth usage.

### Threat Model
We consider the security of C3 protocols relative to two distinct threat models: (1) a malicious client that wants to learn a different user’s password; and (2) an honest-but-curious C3 server that aims to learn the password corresponding to a C3 query. We discuss each in turn.

A malicious client may want to use the C3 server to discover another user’s password. The malicious client may know the target’s username and has the ability to query the C3 server. The C3 server’s database \(\tilde{S}\) should therefore be considered confidential, and our security goal here is that each query to the C3 server can at most reveal whether a particular \(w\) or \((u, w)\) is found within the breach database, for password-only and username-password services, respectively. Without some way of authenticating ownership of usernames, this seems the best possible way to limit knowledge gained from queries. We note that most breach data is in fact publicly available, so we should assume that dedicated adversaries in this threat model can find (a substantial fraction of) any C3 service’s dataset. For such adversaries, there is little value in attempting to exploit the C3 service via queries. Nevertheless, deployments should rate-limit clients via IP-address-based query throttling as well as via slow-to-compute hash functions such as Argon2 [2].

The trickier threat model to handle is (2), and this will consume most of our attention in this work. Here, the C3 server may be compromised or otherwise malicious, and it attempts to exploit a client’s queries to help it learn that client’s password for some other target website. We assume the adversary can submit password guesses to the target website and that it knows the client’s username. We refer to this setting as a known-username attack (KUA). We conservatively assume the adversary has access to the full breach dataset and thus can take advantage of both leaked passwords available in the breach dataset and information leaked about the client’s password from C3 queries. Looking ahead, for our protocols, the information potentially leaked from C3 queries is the bucket identifier.

It is context-dependent whether a compromised C3 server will be able to mount KUAs. For example, in deployments where a web server issues queries on behalf of their users, queries associated with many usernames may be intermingled. In some cases, however, an adversary may be able to link usernames to queries by observing metadata corresponding to a query (e.g., IP address of the querying user or the timing of a request). One can imagine cross-site scripting attacks that somehow trigger requests to the C3 service, or the adversary might send tracking emails to leaked email addresses to infer an IP address associated with a username [27]. We therefore conservatively assume the malicious server’s ability to know the correct username for a query.

In our KUA model, we focus on online attack settings, where the attacker tries to impersonate the target user by making remote login attempts at another web service, using guessed passwords. These are easy to launch and are one of the most prevalent forms of attacks [16, 28]. However, in an online setting, the web service typically implements defenses such as rate limiting and account lockouts, which can mitigate the effectiveness of such attacks.