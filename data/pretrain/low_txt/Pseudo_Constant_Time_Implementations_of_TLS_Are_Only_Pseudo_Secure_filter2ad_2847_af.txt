### Table 3: Cache Hit Probabilities for mbed TLS Attack

| Hash Algorithm | Cache Line Access Probability (Aligned) | Cache Line Access Probability (Not Aligned) |
|----------------|----------------------------------------|--------------------------------------------|
| SHA-256        | ≈ 0.002                                | ≈ 0.998                                    |
| SHA-384        | ≈ 0.028                                | ≈ 0.999                                    |

**Note:**
- **1 − 72**: Range of bytes in the cache line that are not accessed.
- **73 − 128**: Range of bytes in the cache line that are accessed.
- **1 − 32**: Range of bytes in the cache line that are not accessed.
- **32 − 64**: Range of bytes in the cache line that are accessed.
- **1 − 104**: Range of bytes in the cache line that are not accessed.
- **105 − 128**: Range of bytes in the cache line that are accessed.
- **1 − 64**: Range of bytes in the cache line that are not accessed.

### 7.6 Proof of Concept

We implemented a proof-of-concept (PoC) to verify the presence of the cache side-channel attack. The PoC was executed on an Intel(R) Core(TM) i7-7500U CPU @ 2.70GHz running Ubuntu 17.10. We used the version 2.7 code from the `mbedtls-2.7` branch of the official git repository, with the commit hash `be97c9cc`, and compiled it using the provided makefiles and GCC version 7.2.0. The target was the HMAC function call sequence used in the `ssl_decrypt_buf` function (see Listing 1.8 in Appendix A). This HMAC code is the latest pseudo-constant-time version, designed to protect against previous timing and cache attacks.

We ran the code multiple times with different lengths for the decrypted TLS record. We primed the memory before the HMAC execution and probed it afterward. We tested both the SHA-384 and SHA-256 implementations, with the hash padding array both aligned and not aligned (i.e., with a 32-byte offset) relative to the cache line. The experimentally obtained cache hit probabilities are given in Table 3. Due to the differing probabilities, we obtained reliable hash padding length oracles for three out of the four combinations, with the exception being when SHA-256 is combined with a cache-aligned padding array.

### 7.7 Analysis of the Proof of Concept

As described in Section 7.5, our full cache attack targets a cache line that contains data stored just after the hash padding array. For this attack to work, the data after the array must not be accessed by the targeted code (otherwise, we will always get a cache hit). Analyzing the PoC results, we found that this requirement is indeed fulfilled, except for the case of SHA-256 with a cache-aligned array. By examining the compiled program in this case, we discovered that the data the compiler stores just after the array is an array of round constants used in the SHA-256/SHA-384 compression function. This function is called in the finalization of the hash calculation just after accessing the hash padding array. In theory, our attack should not work on this specific build of the code.

To better understand this, we analyzed the compiled assembly code of the compression function, taken from the mbed TLS server example program `ssl_server2` (see Listing 1.9 in Appendix A). In both the SHA-384 and SHA-256 code, the programmer unrolled the first 8 rounds of the compression function. To optimize performance, the GCC compiler uses hard-coded assembly `movabs` commands to push the first 8 round constants into registers. For the remaining rounds, the code uses the constants stored in the array. Although the first 8 round constants are stored in the array, they are never accessed. Since SHA-384 constants are 64 bits each, storing the first 8 round constants requires 64 bytes. Therefore, the 64 bytes after the hash padding array are never accessed, and the cache line we target is only accessed due to the hash padding array, making the attack feasible regardless of the array alignment.

However, in the SHA-256 case, the round constants are only 32 bits long. Storing the first 8 constants requires just 32 bytes. The attack works when the hash padding array has a 32-byte offset to the cache line. In this case, the targeted cache line holds the end of the hash padding array and the first 8 round constants, and the cache line is only accessed due to the hash padding array, allowing our attack to succeed. In the other case, where the hash padding array is aligned with the cache line, the targeted cache line holds the first 16 round constants. Since the constants of rounds 9 to 16 are accessed by the compression function, this cache line is always accessed, and our attack fails.

### 7.8 Creating the Padding Oracle

Combining the results from Table 3 and equations 1 and 2, we obtain a CBC-mode padding oracle in the mbed TLS implementation of the form `PadLen > 4 + 16k mod 128` for any `k` (mod 64 for SHA-256). We use this padding oracle with the attack described in Section 6.3 to achieve a more robust attack. Using the same calculations as in Appendix 5.3, we get an expected total number of cache attack executions (and TLS connections) of 384 per byte for SHA-256.

### 8 Conclusion

We have conducted an in-depth analysis of the security of pseudo-constant-time countermeasures to the Lucky 13 attack on CBC-mode in TLS. We examined a representative set of implementations and found them all to be vulnerable to cache timing attacks. We developed three new techniques for exploiting leakage from cache timing and access patterns, and a novel variant of Lucky 13 with increased timing differences. These ideas may be applicable in attacking other cryptographic schemes. We produced PoCs for most of the attacks and evaluated the number of iterations of the basic cache timing step (and consequently the number of TLS connections) needed for the attacks to succeed. The requirements of the attacks are modest, especially in view of our novel greedy algorithm for selecting which mask value to use at each stage.

The main takeaway from our work is encapsulated in the title of our paper: pseudo-constant-time protections only provide "pseudo-security." CBC-mode in TLS seems destined to stay with us for some years to come, despite the growth in usage of AES-GCM and the impending arrival of TLS 1.3, due to the need to support legacy code and devices. The "Encrypt-then-MAC" countermeasure from RFC 7366 is supported in mbed TLS and GnuTLS but requires client-side support and has seen little uptake elsewhere (e.g., neither Firefox nor Chrome supports the EtM extension). We suggest that all pseudo-constant-time implementations should seriously consider adopting a fully constant-time, constant-memory-access approach to defending against Lucky 13 and its variants—only this can provide robust security across a broad range of deployment (and thereby attack) scenarios.

The paper opens up several avenues for future work. Our greedy algorithm for selecting masks has good performance (coming close to the information-theoretic lower bound in some cases), but it would be of interest to seek optimal algorithms. These may be of independent interest in other areas of cryptanalysis. We use only a single oracle condition, whereas we can often obtain multiple conditions by carefully varying the length of ciphertexts. It may be possible to exploit the availability of multiple conditions to further reduce the number of TLS connections needed. Our results with a single condition in combination with our greedy algorithm already illustrate the dangers of settling for pseudo-constant-time code. Finally, when considering the recovery of multiple plaintext bytes, we used a simple byte-by-byte analysis to estimate plaintext recovery rates. A more sophisticated approach would be to design attacks that produce likelihood values for each plaintext byte candidate and then combine these across multiple bytes using enumeration techniques from the side-channel literature [34, 7, 26, 25, 11].

### 9 Acknowledgments

The authors would like to thank Yuval Yarom for his helpful comments and insights. The authors would also like to thank the anonymous reviewers for their constructive suggestions that helped us improve the paper.

### References

1. Icsi certificate notary (2017), https://notary.icsi.berkeley.edu/
2. Albrecht, M.R., Paterson, K.G.: Lucky microseconds: A timing attack on Amazon’s s2n implementation of TLS. In: Fischlin, M., Coron, J.S. (eds.) Advances in Cryptology – EUROCRYPT 2016, Part I. Lecture Notes in Computer Science, vol. 9665, pp. 622–643. Springer, Heidelberg (May 2016)
3. AlFardan, N.J., Paterson, K.G.: Lucky thirteen: Breaking the TLS and DTLS record protocols. In: 2013 IEEE Symposium on Security and Privacy. pp. 526–540. IEEE Computer Society Press (May 2013)
4. Almeida, J.B., Barbosa, M., Barthe, G., Dupressoir, F.: Verifiable side-channel security of cryptographic implementations: Constant-time MEE-CBC. In: Peyrin, T. (ed.) Fast Software Encryption - 23rd International Conference, FSE 2016, Bochum, Germany, March 20-23, 2016, Revised Selected Papers. Lecture Notes in Computer Science, vol. 9783, pp. 163–184. Springer (2016), https://doi.org/10.1007/978-3-662-52993-5_9
5. Apecechea, G.I., Inci, M.S., Eisenbarth, T., Sunar, B.: Lucky 13 strikes back. In: Bao, F., Miller, S., Zhou, J., Ahn, G.J. (eds.) ASIACCS 15: 10th ACM Symposium on Information, Computer and Communications Security. pp. 85–96. ACM Press (Apr 2015)
6. Benger, N., van de Pol, J., Smart, N.P., Yarom, Y.: “ooh aah... just a little bit”: A small amount of side channel can go a long way. In: Batina, L., Robshaw, M. (eds.) Cryptographic Hardware and Embedded Systems – CHES 2014. Lecture Notes in Computer Science, vol. 8731, pp. 75–92. Springer, Heidelberg (Sep 2014)
7. Bogdanov, A., Kizhvatov, I., Manzoor, K., Tischhauser, E., Witteman, M.: Fast and memory-efficient key recovery in side-channel attacks. In: Dunkelman, O., Keliher, L. (eds.) SAC 2015: 22nd Annual International Workshop on Selected Areas in Cryptography. Lecture Notes in Computer Science, vol. 9566, pp. 310–327. Springer, Heidelberg (Aug 2016)
8. Bruinderink, L.G., Hulsing, A., Lange, T., Yarom, Y.: Flush, gauss, and reload - A cache attack on the BLISS lattice-based signature scheme. In: Gierlichs, B., Poschmann, A.Y. (eds.) Cryptographic Hardware and Embedded Systems – CHES 2016. Lecture Notes in Computer Science, vol. 9813, pp. 323–345. Springer, Heidelberg (Aug 2016)
9. Canvel, B., Hiltgen, A.P., Vaudenay, S., Vuagnoux, M.: Password interception in a SSL/TLS channel. In: Boneh, D. (ed.) Advances in Cryptology – CRYPTO 2003. Lecture Notes in Computer Science, vol. 2729, pp. 583–599. Springer, Heidelberg (Aug 2003)
10. Chudnov, A., Collins, N., Cook, B., Dodds, J., Huffman, B., MacCarthaigh, C., Magill, S., Mertens, E., Mullen, E., Tasiran, S., Tomb, A., Westbrook, E.: Continuous formal verification of Amazon s2n. In: Chockler, H., Weissenbacher, G. (eds.) Computer Aided Verification - 30th International Conference, CAV 2018, Held as Part of the Federated Logic Conference, FloC 2018, Oxford, UK, July 14-17, 2018, Proceedings, Part II. Lecture Notes in Computer Science, vol. 10982, pp. 430–446. Springer (2018), https://doi.org/10.1007/978-3-319-96142-2_26
11. David, L., Wool, A.: A bounded-space near-optimal key enumeration algorithm for multi-subkey side-channel attacks. In: Handschuh, H. (ed.) Topics in Cryptology – CT-RSA 2017. Lecture Notes in Computer Science, vol. 10159, pp. 311–327. Springer, Heidelberg (Feb 2017)
12. Dierks, T., Rescorla, E.: The Transport Layer Security (TLS) Protocol Version 1.2. RFC 5246 (Proposed Standard) (Aug 2008), https://www.rfc-editor.org/rfc/rfc5246.txt, updated by RFCs 5746, 5878, 6176, 7465, 7507, 7568, 7627, 7685, 7905, 7919
13. Dodds, J.: Verifying s2n HMAC with SAW (2016), https://galois.com/blog/2016/09/verifying-s2n-hmac-with-saw/
14. Duong, T., Rizzo, J.: Here come the ⊕ Ninjas. Unpublished manuscript (2011)
15. Genkin, D., Valenta, L., Yarom, Y.: May the fourth be with you: A microarchitectural side channel attack on several real-world applications of Curve25519. In: Thuraisingham, B.M., Evans, D., Malkin, T., Xu, D. (eds.) ACM CCS 17: 24th Conference on Computer and Communications Security. pp. 845–858. ACM Press (Oct / Nov 2017)
16. Gruss, D., Maurice, C., Wagner, K., Mangard, S.: Flush+flush: A fast and stealthy cache attack. In: Caballero, J., Zurutuza, U., Rodriguez, R.J. (eds.) Detection of Intrusions and Malware, and Vulnerability Assessment - 13th International Conference, DIMVA 2016, San Sebastian, Spain, July 7-8, 2016, Proceedings. Lecture Notes in Computer Science, vol. 9721, pp. 279–299. Springer (2016), https://doi.org/10.1007/978-3-319-40667-1_14
17. Gullasch, D., Bangerter, E., Krenn, S.: Cache games - bringing access-based cache attacks on AES to practice. In: 2011 IEEE Symposium on Security and Privacy. pp. 490–505. IEEE Computer Society Press (May 2011)
18. Gutmann, P.: Encrypt-then-MAC for Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS). RFC 7366 (Proposed Standard) (Sep 2014), https://www.rfc-editor.org/rfc/rfc7366.txt
19. Inci, M.S., Gulmezoglu, B., Irazoqui, G., Eisenbarth, T., Sunar, B.: Cache attacks enable bulk key recovery on the cloud. In: Gierlichs, B., Poschmann, A.Y. (eds.) Cryptographic Hardware and Embedded Systems – CHES 2016. Lecture Notes in Computer Science, vol. 9813, pp. 368–388. Springer, Heidelberg (Aug 2016)
20. Kocher, P., Horn, J., Fogh, A., Genkin, D., Gruss, D., Haas, W., Hamburg, M., Lipp, M., Mangard, S., Prescher, T., Schwarz, M., Yarom, Y.: Spectre attacks: Exploiting speculative execution. In: 40th IEEE Symposium on Security and Privacy (S&P’19) (2019)
21. Lipp, M., Gruss, D., Spreitzer, R., Maurice, C., Mangard, S.: Armageddon: Cache attacks on mobile devices. In: Holz, T., Savage, S. (eds.) 25th USENIX Security Symposium, USENIX Security 16, Austin, TX, USA, August 10-12, 2016. pp. 549–564. USENIX Association (2016), https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/lipp
22. Lipp, M., Schwarz, M., Gruss, D., Prescher, T., Haas, W., Fogh, A., Horn, J., Mangard, S., Kocher, P., Genkin, D., Yarom, Y., Hamburg, M.: Meltdown: Reading kernel memory from user space. In: 27th USENIX Security Symposium (USENIX Security 18) (2018)
23. Liu, F., Yarom, Y., Ge, Q., Heiser, G., Lee, R.B.: Last-level cache side-channel attacks are practical. In: 2015 IEEE Symposium on Security and Privacy. pp. 605–622. IEEE Computer Society Press (May 2015)
24. MacCarthaigh, C.: AWS security blog - s2n and Lucky 13 (2015), https://aws.amazon.com/blogs/security/s2n-and-lucky-13/
25. Martin, D.P., Mather, L., Oswald, E., Stam, M.: Characterisation and estimation of the key rank distribution in the context of side channel evaluations. In: Cheon, J.H., Takagi, T. (eds.) Advances in Cryptology – ASIACRYPT 2016, Part I. Lecture Notes in Computer Science, vol. 10031, pp. 548–572. Springer, Heidelberg (Dec 2016)
26. Martin, D.P., O’Connell, J.F., Oswald, E., Stam, M.: Counting keys in parallel after a side channel attack. In: Iwata, T., Cheon, J.H. (eds.) Advances in Cryptology – ASIACRYPT 2015, Part II. Lecture Notes in Computer Science, vol. 9453, pp. 313–337. Springer, Heidelberg (Nov / Dec 2015)
27. Mavrogiannopoulos, N.: Time is money (in CBC ciphersuites) (2013), https://nikmav.blogspot.co.uk/2013/02/time-is-money-for-cbc-ciphersuites.html
28. Merkle, R.C., Charles, R., et al.: Secrecy, authentication, and public key systems (1979)
29. Moller, B., Duong, T., Kotowicz, K.: This POODLE bites: Exploiting the SSL 3.0 fallback (September 2014), https://www.openssl.org/~bodo/ssl-poodle.pdf
30. Osvik, D.A., Shamir, A., Tromer, E.: Cache attacks and countermeasures: The case of AES. In: Pointcheval, D. (ed.) Topics in Cryptology – CT-RSA 2006. Lecture Notes in Computer Science, vol. 3860, pp. 1–20. Springer, Heidelberg (Feb 2006)
31. Schmidt, S.: AWS security blog - S3