### Optimized Text

The diagnostic programs often contain a significant amount of information that is not relevant to all diagnostic scenarios. The Server's algorithm scales linearly with the number of nodes in the branching program, which is as efficient as one can realistically expect.

The scaling behavior of the User’s algorithm is illustrated in Figures 4 and 5. Similar to the Server, the User’s online computation time increases linearly with the size of the branching program but remains independent of the number of attributes in the attribute vector. However, the User’s offline computation time and bandwidth requirements are dependent on the number of attributes. This is because the User must encrypt the entire attribute vector offline and then transmit it as part of the protocol.

We also evaluated our prototype implementation on several real-world applications, as shown in Table 3. These benchmarks were chosen because they are commonly used programs that either contain security vulnerabilities that would be revealed by the diagnostic program (e.g., `gzprintf`) or report misleading error messages (or none at all) for non-exotic error conditions, thus benefiting significantly from remote diagnosis. For our diagnostic programs, we used classification trees generated by Clarify [9, 17], with 32-bit invocation counters for each function of the application serving as the attribute vectors.

**Diagnostic Branching Program for the `mpg321` Benchmark:**
- **Root Node:** Distinguishes between three failure modes and normal execution:
  - **WAV Error:** Attempting to play a WAV file as if it were an MP3.
  - **Corrupted Tag:** Issues with MP3 metadata stored in ID3 format tags.
  - **Corrupted MP3 Frame Data:** Problems with the audio frame data.

- **Discriminative Information:**
  - The `mad_layer_III` function provides almost perfect discriminative information for the WAV error class. Since `mpg321` does not support the WAV format, the `libmad` library will never call `mad_layer_III` when attempting to decode a WAV file.
  - The `id3_tag_delete` routine differentiates between corrupted tags and other classes. If tag parsing fails, the memory for the tag is not allocated, and `id3_tag_delete` is never called, making its absence discriminative for the corrupted tag class.
  - The `error_default` function, which is the default error handler in the `libmad` audio library, indicates corrupted audio frames if present, and its absence indicates corrupted ID3 tags.
  - The `III_freqinver` function, which performs subband frequency inversion for odd sample lines, is called frequently during normal decoding. When there are corrupted frames, this function is called less frequently, and the decision tree algorithm finds an appropriate threshold value to separate the normal from the corrupted case.

**Performance Evaluation:**
- We evaluated our prototype using PCs with an Intel Pentium D 3 GHz processor, 2 GB of RAM, and 2 MB cache. This setup approximates what a typical User might use, while the Server is expected to maintain a more powerful dedicated server for processing remote diagnostics requests.
- In our analysis of scaling behavior, we created artificial datasets with varying numbers of nodes and attributes, measuring the offline and online times separately. Offline time includes all calculations that can be performed independently of the other party.

**Figures and Tables:**
- **Figure 2:** Shows the Server's algorithm scaling with the number of attributes.
- **Figure 3:** Shows the Server's algorithm scaling with the size of the diagnostic program.
- **Figure 4:** Shows the User's algorithm scaling with the number of attributes.
- **Figure 5:** Shows the User's algorithm scaling with the size of the diagnostic program.
- **Table 2:** Lists the parameters of diagnostic programs for several benchmark applications.

**Conclusion:**
- We presented a practical, provably secure protocol that allows a User to evaluate the Server’s branching program on their local data without revealing any information except the diagnostic label. Our prototype was applied to several realistic benchmarks, demonstrating acceptable performance in many practical scenarios.
- Future research could explore the application of our techniques for oblivious evaluation of branching programs to other problems in privacy-preserving computation.

**Acknowledgements:**
- This work was supported by the National Science Foundation under grants CNS-0509033, IIS-0534198, and CNS-0615104, and the ARO grant W911NF-06-1-0316.

**References:**
- [1] R. Agrawal and R. Srikant. Privacy-preserving data mining. In Proc. ACM SIGMOD International Conference on Management of Data, pages 439–450. ACM, 2000.
- [2] D. Beaver. Foundations of secure interactive computing. In Proc. Advances in Cryptology - CRYPTO 1991, volume 576 of LNCS, pages 377–391. Springer, 1992.
- [3] I. Blake and V. Kolesnikov. Strong conditional oblivious transfer and computing on intervals. In Proc. Advances in Cryptology - ASIACRYPT 2004, volume 3329 of LNCS, pages 515–529. Springer, 2004.
- [4] A. Blum, C. Dwork, F. McSherry, and K. Nissim. Practical privacy: the SuLQ framework. In Proc. 24th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems (PODS), pages 128–138. ACM, 2005.
- [5] P. Broadwell, M. Harren, and N. Sastry. Scrash: A system for generating secure crash information. In Proc. 12th USENIX Security Symposium, pages 273–284. USENIX, 2003.
- [6] J. Camenisch and V. Shoup. Practical verifiable encryption and decryption of discrete logarithms. In Proc. Advances in Cryptology - CRYPTO 2003, volume 2729 of LNCS, pages 126–144. Springer, 2003.
- [7] R. Canetti. Security and composition of multiparty cryptographic protocols. J. Cryptology, 13(1):143–202, 2000.
- [8] R. Canetti, Y. Ishai, R. Kumar, M. Reiter, R. Rubinfeld, and R. Wright. Selective private function evaluation with applications to private statistics. In Proc. 20th ACM Symposium on Principles of Distributed Computing (PODC), pages 293–304. ACM, 2001.
- [9] J. Davis, J. Ha, C. Rossbach, H. Ramadan, and E. Witchel. Cost-sensitive decision tree learning for forensic classification. In Proc. 17th European Conference on Machine Learning (ECML), volume 4212 of LNCS, pages 622–629. Springer, 2006.
- [10] J. Feigenbaum, Y. Ishai, T. Malkin, K. Nissim, M. Strauss, and R. Wright. Secure multiparty computation of approximations. In Proc. 28th International Colloquium on Automata, Languages and Programming (ICALP), volume 2076 of LNCS, pages 927–938. Springer, 2001.
- [11] J. Feigenbaum, B. Pinkas, R. Ryger, and F. Saint-Jean. Secure computation of surveys. In Proc. EU Workshop on Secure Multiparty Protocols, 2004.
- [12] M. Freedman, K. Nissim, and B. Pinkas. Efficient private matching and set intersection. In Proc. Advances in Cryptology - EUROCRYPT 2004, volume 3027 of LNCS, pages 1–19. Springer, 2004.
- [13] Gateway. System management services agreement. http://www.gateway.com/about/legal/warranties/20461r10.pdf, 1999.
- [14] E. Goh, L. Kruger, D. Boneh, and S. Jha. Secure function evaluation with ordered binary decision diagrams. In Proc. 13th ACM Conference on Computer and Communications Security (CCS), pages 410–420. ACM, 2006.
- [15] O. Goldreich. Foundations of Cryptography: Volume II (Basic Applications). Cambridge University Press, 2004.
- [16] O. Goldreich, S. Micali, and A. Wigderson. How to play any mental game. In Proc. 19th Annual ACM Symposium on Theory of Computing (STOC), pages 218–229. ACM, 1987.
- [17] J. Ha, C. Rossbach, J. Davis, I. Roy, H. Ramadan, D. Porter, D. Chen, and E. Witchel. Improved error reporting for software that uses black box components. In Proc. ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), pages 101–111. ACM, 2007.
- [18] Q. Huang, D. Jao, and H. Wang. Applications of secure electronic voting to automated privacy-preserving troubleshooting. In Proc. 12th ACM Conference on Computer and Communications Security (CCS), pages 68–80. ACM, 2005.
- [19] Y. Ishai and A. Paskin. Evaluating branching programs on encrypted data. In Proc. 4th Theory of Cryptography Conference (TCC), volume 4392 of LNCS, pages 575–594. Springer, 2007.
- [20] S. Jarecki and V. Shmatikov. Efficient two-party secure computation on committed inputs. In Proc. Advances in Cryptology - EUROCRYPT 2007, volume 4515 of LNCS, pages 97–114. Springer, 2007.
- [23] Y. Lindell and B. Pinkas. A proof of Yao’s protocol for secure two-party computation. http://eprint.iacr.org/2004/175, 2004.
- [24] D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella. Fairplay – a secure two-party computation system. In Proc. 13th USENIX Security Symposium, pages 287–302. USENIX, 2004.
- [25] G. McGraw and J. Viega. Making your software behave: Security by obscurity. http://www.ibm.com/developerworks/java/library/s-obs.html, 2000.
- [26] Microsoft. Privacy statement for the Microsoft error reporting service. http://oca.microsoft.com/en/dcp20.asp, 2006.
- [27] Microsoft. Reporting and solving computer problems. http://windowshelp.microsoft.com/Windows/en-US/Help/d97ba15e-9806-4ff3-8ead-71b8d62123fe1033.mspx, 2006.
- [28] Microsoft. How to: Configure Microsoft error reporting. http://msdn2.microsoft.com/en-us/library/bb219076.aspx, 2007.
- [29] M. Naor and K. Nissim. Communication preserving protocols for secure function evaluation. In Proc. 33rd ACM Symposium on Theory of Computing (STOC), pages 590–599. ACM, 2001.
- [30] M. Naor and B. Pinkas. Efficient oblivious transfer protocols. In Proc. 12th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), pages 448–457. SIAM, 2001.
- [31] M. Naor, B. Pinkas, and R. Sumner. Privacy preserving auctions and mechanism design. In Proc. 1st ACM Conference on Electronic Commerce, pages 129–139. ACM, 1999.
- [32] R. Naraine. Dr. Watson’s Longhorn makeover raises eyebrows. http://www.eweek.com/article2/0,1759,1822142,00.asp, 2005.
- [33] Oracle. Oracle sues SAP. http://www.oracle.com/sapsuit/index.html, 2007.
- [34] P. Paillier. Public-key cryptosystems based on composite degree residuosity classes. In Proc. Advances in Cryptology - EUROCRYPT 1999, volume 1592 of LNCS, pages 223–238. Springer, 1999.
- [35] M. Rabin. How to exchange secrets by oblivious transfer. Technical Report TR-81, Aiken Computation Laboratory, Harvard University, 1981.
- [36] T. Sander, A. Young, and M. Yung. Non-interactive CryptoComputing for NC1. In Proc. 40th Annual IEEE Symposium on Foundations of Computer Science (FOCS), pages 554–566. IEEE, 1999.
- [37] B. Stone. A lively market, legal and not, for software bugs. New York Times, Jan 30 2007.
- [38] H. Wang, Y.-C. Hu, C. Yuan, Z. Zhang, and Y.-M. Wang. Friends troubleshooting network: Towards privacy-preserving, automatic troubleshooting. In 3rd International Workshop on Peer-to-Peer Systems (IPTPS), volume 3279 of LNCS, pages 184–194. Springer, 2004.
- [21] J. Kilian. Founding cryptography on oblivious transfer. In Proc. 20th Annual ACM Symposium on Theory of Computing (STOC), pages 20–31. ACM, 1988.
- [39] J. Weideman. Automated problem reports. https://wiki.ubuntu.com/AutomatedProblemReports, 2006.
- [40] A. Yao. How to generate and exchange secrets. In Proc. 27th Annual IEEE Symposium on Foundations of Computer Science (FOCS), pages 162–167. IEEE, 1986.
- [22] Y. Lindell and B. Pinkas. Privacy preserving data mining. J. Cryptology, 15(3):177–206, 2002.