### 优化后的文本

#### 字段定义示例
- **字段ID**: `year_to`
  - **类型**: `u2le`
- **字段ID**: `zero_2`
  - **大小**: `0x28`
- **字段ID**: `unk_4`
  - **属性**: `size-eos: true`

这个示例非常简单，因为研究的目的是确定每个字段的具体含义。在更复杂的情况下，需要假设字段类型和长度，并搜索不同表之间的交叉引用。本文的重点是数据库的逆向工程，而不是文件格式的逆向工程，因此不会对其他单独的文件进行详细分析。我们关注的是这些文件之间的关系。

**[2.7] 研究并描述表示数据库入口点的文件格式**

该数据库入口点是明确的：没有发现对其他结构的依赖，并且已经获得了足够的信息以继续进一步的研究。

**研究交叉引用**

可以通过以下两种方法继续进行逆向工程：
1. **根据已知信息搜索所需信息**：例如，获取`vehicle_id`、`vl_code_1`、`vl_code_2`、`cat_code`等字段值，并在其他文件中搜索它们。如果找到匹配项，则表明`catalogue`文件与这些文件之间存在关联。
2. **搜索所需信息并了解其与已知信息的交互方式**：通过关键字查找包含所需信息的文件，对其进行逆向工程，并显示这些文件与`catalogue`文件之间的交叉引用。

这两种方法可以结合使用。首先，定义所需信息。根据“入口点选择”部分的图，下一个待研究的结构是车辆零件。目前还不适合研究零件图，因为它们通过零件与车辆相互关联（假设为真）。接下来，看看程序如何提供对车辆零件的访问。

#### 部件树
- **第一级部件树**
- **第二级部件树**
- **带有标记详细信息的零件图**

选择车辆后，会显示一个部件列表（例如“10 WHEELS & RELATED PARTS”、“20 BRAKE SYSTEM”等）。选择其中一个列表时，会显示第二个部件列表（例如“10 WHEELS AND WHEEL COVERS WHEELS 1980–1980 [P10853]”等）。选择相应的条目后，将显示零件列表，其中包含以零件编号命名的超链接，单击该超链接则会弹出包含零件列表的底部菜单。我们的目标是“接触”零件列表。

车辆和零件通过两个部件列表绑定在一起，称为部件树。部件树有两个级别，分别命名为“Alpha Index—Major”和“Alpha Index—Minor”，简化为第一级和第二级。根据其他车辆数据库的经验，假设部件树和部件本身位于不同的数据结构或不同的文件中。因此，我们需要调整目标路线：从车辆出发到达第一级部件树，然后从第一级部件树到达第二级部件树，最后到达零件级别。

#### 进度条

如何实现这一目标？如果在文件中搜索第一级部件树中的相关名称（如“10 WHEELS＆RELATED PARTS”），那么在包含所有本地化字符串的`FEULex.dat`文件中只会找到一个匹配项。我们可以据此计算出到达字符串的偏移量，并再次在文件中以little-endian字节顺序进行搜索，但这次要偏移四个字节。然而，这种方法在这个例子中不起作用，因为`FEULex.dat`被偏移引用而不是从文件开头。

下面介绍另一种强大的技术，这种技术还非常简便。基于[2.1]方法，将程序视为DBMS是非常有意义的。由于它是DBMS，肯定会向DB发送请求，即从文件中读取数据。为了高效运行，它不会在启动时就将所有文件读入内存。因此，当用户通过单击某些菜单、按钮等方式发出请求时，程序会访问相应的文件。这样，我们可以判断出用户操作期间程序访问了哪些文件。

#### 监视文件访问

要监视文件访问操作，可以使用打过补丁的ProcMon。该补丁的作用是将Detail列中的十进制数改为十六进制数。启动ProcMon并设置过滤器：“Process Name is ntvdm.exe”和“Operation is ReadFile”。启动程序，选择车辆，再次使用ProcMon启动监视器，然后单击车辆数据加载按钮。

在读取第一级部件树时，程序引用的文件有`MCData.idx`、`MCData.dat`、`XGROUPS.idx`、`FEULex.dat`和`LexInd.idx`。前两个文件是我们需要搜索的内容。

**[2.8] 当程序要加载您感兴趣的数据时，监视它们对文件所执行的访问操作。**

从现在开始，剩下的就是繁琐的逆向分析工作。这里不详细介绍这些文件的具体研究过程，因为每一个文件的分析都值得单独一篇文章。我花了一个多月的时间来理解它们，并研究了其他一些文件。

- **文件名**: `MCData.idx`
  - **大小**: 5.5 MB
  - **格式**: 二进制
  - **表数量**: 4（2个头 + 2个数据表）
  - **用途**: 将车辆（`vehicle_id`）绑定到第一级部件树（`ai_major_id`），第一级到第二级（`ai_minor_id`），第二级到`MCData.dat`中的零件列表（`part_list_offset`）和`MCImage.dat`及`MCImage2.dat`中的零件图（`image_offset`）

- **文件名**: `MCData.dat`
  - **大小**: 1.5 GB
  - **格式**: 加密文本
  - **用途**: 包含每个树的零件列表（`part_list_offset`）

通过使用ProcMon监控获得另外两个发现，可以加深对文件内部机制的理解：
- **块偏移和块大小**：程序每次执行读取操作时的块偏移和块大小。
- **块读取顺序**：程序读取块的顺序。

知道块偏移量和块大小，可以确定第一个表记录、表记录大小、表记录的数量以及表的数量。了解块读取顺序可以帮助规划文件的研究过程。有时，块读取顺序的知识还能帮助理解程序的实现算法。

**[2.9] 借助监视期间收集的块偏移、块大小和块读取顺序等知识来研究文件。**

#### 小结

我们弄清楚了车辆结构、部件树和零件信息存放在哪些文件中，以及这些文件的结构和它们之间的交叉引用。用图形展示如下：

- **数据库架构**

本文的主要目标是向读者介绍如何使用自己开发的方法对数据库进行逆向分析。从两个层面加以阐释：一是独立于任何数据库内部的原则，二是将这些原则应用于实际的数据库研究，以证明它们的可行性和实用性。

在下一部分中，我们将使用代码重用方法来访问零件图，探索数据库的内部运行机制。届时，我们将开始与反汇编程序和调试程序打交道。

**参考资料**
- DGTEFF — XentaxWiki
- How to crack a Binary File Format
- BFF: A grammar for Binary File Formats
- File format reverse engineering, an introduction. — Nada Labs
- Reverse Engineering/File Formats — Wikibooks, open books for an open world
- Reverse Engineering a file format — Matthew Ekenstedt
- Reverse Engineering Design File Formats | Details | Hackaday.io
- Reverse engineering visual novels 101
- Reverse engineering visual novels 101, part 2
- Experimentation with Reverse Engineering — Trails in the Sky (FC / SC) Extracting Sprite Data w/ Unix Tools & Kaitai Struct
- Kaitai Struct

**主要方法清单**

**第一种数据库逆向分析方法**
- [2.1] 将使用DB的程序视为DBMS。

**初步分析**
- [2.2] 对待处理的数据和代码进行初步分析。对于在审查期间找到的关键字，可以通过互联网进行搜索，尽量挖掘更多的信息。
- [2.3] 审查各个程序模块，查找可重用代码。在数据库逆向分析的过程中，需要定期应用该方法。
- [2.4] 代码重用的复杂性与黑盒子的数量成正比，与其执行的动作数量成反比。

**研究入口点**
- [2.5] 选择数据库入口点：离初始入口点越近，需要预先研究的结构就越少。理想情况下，所需的入口点正好就是初始入口点。
- [2.6] 考察代表数据库入口点的文件。
- [2.7] 研究并描述表示数据库入口点的文件格式。

**研究交叉引用**
- [2.8] 当程序要加载您感兴趣的数据时，监视它们对文件所执行的访问操作。
- [2.9] 借助监视期间收集的块偏移、块大小和块读取顺序等知识来研究文件。

（未完待续）