# Fuzzing for Software Security Testing and Quality Assurance
## Second Edition

### Book Details
- **Title:** Fuzzing for Software Security Testing and Quality Assurance
- **Edition:** Second Edition
- **Authors:**
  - Ari Takanen
  - Jared DeMott
  - Charlie Miller
  - Atte Kettunen
- **Publisher:** Artech House
- **ISBN 13:** 978-1-60807-850-9
- **Cover Design:** John Gomes
- **Copyright:** © 2018 Artech House
- **Library of Congress Cataloging-in-Publication Data:** Available from the U.S. Library of Congress
- **British Library Cataloguing in Publication Data:** Available from the British Library

### Dedication
This book is dedicated to our families and friends, as well as to all quality assurance specialists and security experts who are willing to share their knowledge and expertise to enable others to learn and improve their skills.

### Contents
1. **Foreword from the First Edition** (xv)
2. **Foreword to the Second Edition** (xix)
3. **Preface from the First Edition** (xxiii)
4. **Preface to the Second Edition** (xxv)
5. **Chapter 1: Introduction** (1)
   - 1.1 Software Security (2)
     - 1.1.1 Security Incident (4)
     - 1.1.2 Disclosure Processes (5)
     - 1.1.3 Attack Surfaces and Attack Vectors (6)
     - 1.1.4 Reasons Behind Security Mistakes (9)
     - 1.1.5 Proactive Security (10)
     - 1.1.6 Security Requirements (12)
   - 1.2 Software Quality (13)
     - 1.2.1 Cost-Benefit of Quality (14)
     - 1.2.2 Target of Test (16)
     - 1.2.3 Testing Purposes and Test Verdicts (16)
     - 1.2.4 Structural Testing (20)
     - 1.2.5 Functional Testing (21)
     - 1.2.6 Code Auditing (21)
   - 1.3 Introduction to Fuzzing (22)
     - 1.3.1 Brief History of Fuzzing (22)
     - 1.3.2 Fuzzing Overview (26)
     - 1.3.3 Vulnerabilities Found with Fuzzing (27)
     - 1.3.4 Fuzzer Types (28)
     - 1.3.5 Logical Structure of a Fuzzer (31)
     - 1.3.6 Fuzzing Process (32)
     - 1.3.7 Fuzzing Frameworks and Test Suites (33)
     - 1.3.8 Fuzzing and the Enterprise (34)
   - 1.4 Book Goals and Layout (35)

6. **Chapter 2: Software Vulnerability Analysis** (37)
   - 2.1 Purpose of Vulnerability Analysis (38)
     - 2.1.1 Security and Vulnerability Scanners (38)
   - 2.2 People Conducting Vulnerability Analysis (40)
     - 2.2.1 Hackers (42)
     - 2.2.2 Vulnerability Analysts or Security Researchers (42)
     - 2.2.3 Penetration Testers (43)
     - 2.2.4 Software Security Testers (43)
     - 2.2.5 IT Security Engineers (43)
   - 2.3 Target Software (44)
   - 2.4 Basic Bug Categories (44)
     - 2.4.1 Memory Corruption Errors (44)
     - 2.4.2 Web Applications (52)
     - 2.4.3 Brute Force Login (55)
     - 2.4.4 Race Condition (55)
     - 2.4.5 Denial of Service (56)
     - 2.4.6 Session Hijacking (56)
     - 2.4.7 Man in the Middle (56)
     - 2.4.8 Cryptographic Attacks (57)
   - 2.5 Bug Hunting Techniques (57)
     - 2.5.1 Reverse Engineering (57)
     - 2.5.2 Source Code Auditing (60)
   - 2.6 Fuzzing (61)
     - 2.6.1 Basic Terms (62)
     - 2.6.2 Hostile Data (62)
     - 2.6.3 Number of Tests (64)
   - 2.7 Defenses (64)
     - 2.7.1 Why Fuzzing Works (65)
     - 2.7.2 Defensive Coding (65)
     - 2.7.3 Input Verification (66)
     - 2.7.4 Hardware Overflow Protection (67)
     - 2.7.5 Software Overflow Protection (68)
   - 2.8 Summary (71)

7. **Chapter 3: Quality Assurance and Testing** (73)
   - 3.1 Quality Assurance and Security (73)
     - 3.1.1 Security in Software Development (74)
     - 3.1.2 Security Defects (75)
   - 3.2 Measuring Quality (75)
     - 3.2.1 Quality Is About Validation of Features (75)
     - 3.2.2 Quality Is About Finding Defects (78)
     - 3.2.3 Quality Is a Feedback Loop to Development (78)
     - 3.2.4 Quality Brings Visibility to the Development Process (79)
     - 3.2.5 End Users’ Perspective (79)
   - 3.3 Testing for Quality (79)
     - 3.3.1 V-Model (79)
     - 3.3.2 Testing on the Developer’s Desktop (80)
     - 3.3.3 Testing the Design (81)
   - 3.4 Main Categories of Testing (81)
     - 3.4.1 Validation Testing versus Defect Testing (81)
     - 3.4.2 Structural versus Functional Testing (81)
   - 3.5 White-Box Testing (82)
     - 3.5.1 Making the Code Readable (82)
     - 3.5.2 Inspections and Reviews (82)
     - 3.5.3 Code Auditing (82)
   - 3.6 Black-Box Testing (85)
     - 3.6.1 Software Interfaces (85)
     - 3.6.2 Test Targets (86)
     - 3.6.3 Fuzz Testing as a Profession (86)
   - 3.7 Purposes of Black-Box Testing (88)
     - 3.7.1 Conformance Testing (89)
     - 3.7.2 Functional Security Testing (89)
     - 3.7.3 Functional Safety Testing (89)
     - 3.7.4 Interoperability Testing (90)
     - 3.7.5 Performance Testing (90)
     - 3.7.6 Robustness Testing (90)
   - 3.8 Testing Metrics (91)
     - 3.8.1 Specification Coverage (91)
     - 3.8.2 Input Space Coverage (91)
     - 3.8.3 Interface Coverage (91)
     - 3.8.4 Code Coverage (92)
   - 3.9 Black-Box Testing Techniques for Security (92)
     - 3.9.1 Load Testing (92)
     - 3.9.2 Stress Testing (92)
     - 3.9.3 Security Scanners (93)
     - 3.9.4 Unit Testing (93)
     - 3.9.5 Fault Injection (93)
     - 3.9.6 Syntax Testing (94)
     - 3.9.7 Negative Testing (96)
     - 3.9.8 Regression Testing (98)
   - 3.10 Testing in Continuous Integration (99)
   - 3.11 Summary (100)

8. **Chapter 4: Fuzzing Metrics** (101)
   - 4.1 Threat Analysis and Risk-Based Testing (103)
     - 4.1.1 Threat Trees (104)
     - 4.1.2 Threat Databases (105)
     - 4.1.3 Ad Hoc Threat Analysis (105)
   - 4.2 Transition to Proactive Security (107)
     - 4.2.1 Cost of Discovery (108)
     - 4.2.2 Cost of Remediation (114)
     - 4.2.3 Cost of Security Compromises (115)
     - 4.2.4 Cost of Patch Deployment (117)
   - 4.3 Defect Metrics and Security (119)
     - 4.3.1 Coverage of Previous Vulnerabilities (121)
     - 4.3.2 Expected Defect Count Metrics (124)
     - 4.3.3 Vulnerability Risk Metrics (124)
     - 4.3.4 Interface Coverage Metrics (127)
     - 4.3.5 Input Space Coverage Metrics (127)
     - 4.3.6 Code Coverage Metrics (130)
     - 4.3.7 Process Metrics (132)
   - 4.4 Test Automation for Security (133)
   - 4.5 Summary (134)

9. **Chapter 5: Building and Classifying Fuzzers** (137)
   - 5.1 Fuzzing Methods (137)
     - 5.1.1 Paradigm Split: Random or Deterministic Fuzzing (138)
     - 5.1.2 Source of Fuzz Data (139)
     - 5.1.3 Fuzzing Vectors (141)
     - 5.1.4 Intelligent Fuzzing (142)
     - 5.1.5 Intelligent versus Dumb (Nonintelligent) Fuzzers (144)
     - 5.1.6 White-Box, Black-Box, and Gray-Box Fuzzing (144)
   - 5.2 Detailed View of Fuzzer Types (145)
     - 5.2.1 Single-Use Fuzzers (145)
     - 5.2.2 Fuzzing Frameworks (146)
     - 5.2.3 Using Prebuilt Protocol-Specific Fuzzers (149)
     - 5.2.4 Generic Fuzzers (151)
     - 5.2.5 Capture-Replay (152)
     - 5.2.6 In-Memory Fuzzing (161)
   - 5.3 Fuzzer Classification via Interface (162)
     - 5.3.1 Local Program (162)
     - 5.3.2 Network Interfaces (162)
     - 5.3.3 Files (162)
     - 5.3.4 APIs (163)
     - 5.3.5 Web Fuzzing (164)
     - 5.3.6 Client-Side Fuzzers (164)
     - 5.3.7 Layer 2 Through 7 Fuzzing (164)
   - 5.4 Summary (165)

10. **Chapter 6: Target Monitoring** (167)
    - 6.1 What Can Go Wrong and What Does It Look Like (167)
      - 6.1.1 Denial of Service (167)
      - 6.1.2 File System-Related Problems (168)
      - 6.1.3 Metadata Injection Vulnerabilities (168)
      - 6.1.4 Memory-Related Vulnerabilities (169)
    - 6.2 Methods of Monitoring (170)
      - 6.2.1 Valid Case Instrumentation (170)
      - 6.2.2 System Monitoring (171)
      - 6.2.3 Remote Monitoring (175)
      - 6.2.4 Commercial Fuzzer Monitoring Solutions (176)
      - 6.2.5 Application Monitoring (176)
    - 6.3 Advanced Methods (180)
      - 6.3.1 Library Interception (180)
      - 6.3.2 Binary Simulation (182)
      - 6.3.3 Source Code Transformation (183)
      - 6.3.4 Compiler Instrumentation (183)
      - 6.3.5 Virtualization (184)
    - 6.4 Monitoring Overview (184)
    - 6.5 Deduplication (185)
      - 6.5.1 Test Case Generator Information (185)
      - 6.5.2 Operating System Logs (185)
      - 6.5.3 Stack Traces (186)
      - 6.5.4 Advanced Tools (187)
    - 6.6 Test Program (187)
      - 6.6.1 The Program (187)
      - 6.6.2 Test Cases (188)
      - 6.6.3 Guard Malloc (190)
      - 6.6.4 Valgrind (191)
      - 6.6.5 Insure++ (192)
      - 6.6.6 AddressSanitizer (193)
    - 6.7 Case Study: PCRE (196)
      - 6.7.1 Guard Malloc (197)
      - 6.7.2 Valgrind (198)
      - 6.7.3 Insure++ (199)
      - 6.7.4 AddressSanitizer (199)
    - 6.8 Summary (201)

11. **Chapter 7: Advanced Fuzzing** (203)
    - 7.1 Automatic Protocol Discovery (203)
    - 7.2 Automatic Generation of a Model-Based Fuzzer (204)
      - 7.2.1 Defensics SDK with Suite Wizard (205)
      - 7.2.2 Example Project Created with Suite Wizard (205)
      - 7.2.3 Fuzzer Modeling (208)
      - 7.2.4 Adding Rules to the Fuzzer (209)
      - 7.2.5 Settings to Configure the Fuzzer (209)
      - 7.2.6 Fuzzer Input and Output (209)
      - 7.2.7 Building and Packing the Fuzzer (209)
      - 7.2.8 Conclusions (210)
    - 7.3 Symbolic Execution with SAGE (210)
    - 7.4 Code Coverage in Fuzzing (212)
      - 7.4.1 Code Coverage Guided Fuzzing: American Fuzzy Lop (213)
      - 7.4.2 Code Coverage Guided Fuzzing: libFuzzer (216)
    - 7.5 Evolutionary Fuzzing (219)
    - 7.6 Evolutionary Fuzzing: EFS (221)
      - 7.6.1 EFS Overview (221)
      - 7.6.2 GPF + PaiMei + Jpgraph = EFS (223)
      - 7.6.3 EFS Data Structures (223)
      - 7.6.4 EFS Initialization (224)
      - 7.6.5 Session Crossover (224)
      - 7.6.6 Session Mutation (225)
      - 7.6.7 Pool Crossover (226)
      - 7.6.8 Pool Mutation (227)
      - 7.6.9 Running EFS (228)

For a listing of recent titles in the Artech House Information Security and Privacy Library, please refer to the back of this book.

### Legal Notices
- All rights reserved. Printed and bound in the United States of America.
- No part of this book may be reproduced or utilized in any form or by any means, electronic or mechanical, including photocopying, recording, or by any information storage and retrieval system, without permission in writing from the publisher.
- All terms mentioned in this book that are known to be trademarks or service marks have been appropriately capitalized. Artech House cannot attest to the accuracy of this information. Use of a term in this book should not be regarded as affecting the validity of any trademark or service mark.