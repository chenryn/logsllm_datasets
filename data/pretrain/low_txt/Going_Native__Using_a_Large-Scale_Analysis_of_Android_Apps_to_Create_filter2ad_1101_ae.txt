### B. Native Code Coverage

While code coverage of Java methods provides insights into the high-level code coverage of our dynamic analysis system, it does not address a key concern: how much of an app's native code is actually executed by the dynamic analysis? To answer this question, we modified both the Android emulator and the Android framework to support measuring function coverage of the native code.

One technical challenge is that the native code coverage must not only identify which native libraries are loaded by an app but also determine which parts of these libraries are executed. Therefore, we need to:
1. Trace the executed native functions.
2. Statically determine the total number of native functions.

This will allow us to calculate the function coverage of the native code. To the best of our knowledge, there is no previously released tool to trace the execution of an app's native code.

The Android Open Source Project (AOSP) includes a tracing mechanism since version 4.4, implemented using a kernel device called `qemutrace` in the goldfish kernel. This mechanism sends information to the emulator to trace the execution, such as the PID of the running process during context switches and notifications for `fork` or `execve` calls. However, this tracing system significantly slows down the emulator's performance and is too general; we are interested only in the execution of the native code of a specific app. We need to trace only the functions of the loaded libraries of the app under analysis.

To limit the tracing to the relevant parts, we created two approaches:
1. **UID-based Tracing**: We trace processes with a specific UID because each app in Android runs with its own unique UID.
2. **Memory Mapping**: We focus on the portions of the executable memory where the native libraries are loaded.

To inform the emulator about the UID of the currently executing process, we leverage the existing `qemutrace` device and add the UID to the message sent for each context switch. For memory mapping, we cannot use `qemutrace` as it can only pass 32-bit integers. Instead, we instrumented the Android framework to intercept library loading operations via the `java.lang.Runtime.doLoad` function. Our hook inside `doLoad` blocks the loading while syncing the gathered data to the external emulator. The memory map and PID are read from `/proc/self/`, and the path of the loaded library is one of the parameters of the `doLoad` function. When `doLoad` returns, the emulator knows the address space reserved for the new library and the content of the native library.

After dynamic execution, we compute the code coverage using all the data gathered. We use IDA Pro to find the boundaries of all functions in the libraries and then translate the virtual addresses traced by the emulator. We flag all functions whose boundaries include at least one address from the trace, and the code coverage is calculated.

Our tracing system slows down the execution of the apps by approximately 10 times. Therefore, we analyzed only a small subset of 177 apps. The code coverage for most libraries was less than 1%, while some small libraries were covered by 100%. The average coverage was 7%. More details about the executed libraries and coverage can be seen in Figure 3.

### VIII. Threats to Validity

Our study has several limitations, which we discuss here. An intrinsic limitation of automatically-generated security policies is that they are based on dynamic analysis, which is known to be incomplete and affected by code coverage issues. Dynamic analysis does not ensure that all native code is exercised, and for apps that use native code, it may not cover all code paths. Consequently, the policies generated by our tool might not be complete, could block more applications when adopted at large-scale, and the performance overhead of isolating native code could be higher. However, using a more sophisticated instrumentation tool or deploying the policies in a native sandbox with reporting mode could improve the observed behavior.

Nonetheless, we believe this work is a significant first step in an important direction. To the best of our knowledge, this is the first, largest, and most comprehensive study on how real-world applications use native code. Our results demonstrate that a completely restrictive sandboxing policy is infeasible. We propose a system to automatically generate a native code sandboxing policy using a data-driven approach, which could be used by large organizations. The completeness issues could be addressed by increasing the fidelity of the dynamic analysis or by instrumenting real-world Android devices.

Another limitation is that our approach restricts access to permissions from native code but still allows the native code to invoke some Java methods. This makes Java-only analysis more precise but not entirely sound, as a malicious application could introduce hidden execution paths by invoking a native method, which, in turn, could invoke a Java method. However, our automatically-generated policy only allows native code to invoke a very narrow subset of Java methods defined in the Android framework, making it virtually impossible to perform any security-sensitive operation. Thus, although not perfect, our policy would drastically reduce the possibility of introducing malicious behaviors.

Lastly, we consider all the apps obtained from Google Play as benign, but we cannot be certain that there are no malicious apps among them. The presence of malicious apps in our dataset could cause our policies to allow some malicious actions.

### IX. Related Work

In this section, we relate our work to the extensive research published in the field of Android security.

**Large Measurement Studies**: Several works have analyzed large datasets of Android apps, but with different goals. Viennot et al. [37] conducted a large measurement study on 1,100,000 applications from the Google Play store, collecting metadata and statistics. Lindorfer et al. [27] analyzed 1,000,000 apps, of which 40% were malware, using Andrubis, a publicly-available analysis system combining static and dynamic analysis. Our work extends their studies by focusing specifically on native code usage.

**Application Analysis Systems**: Various systems have been proposed for behavioral analysis of Android applications based on dynamic analysis [13], [14], [30], [31], [36], [41]. Other works have focused on identifying malicious Android apps [4], [9], [23]. Our analysis complements these efforts by performing a large-scale study specifically focused on native code usage.

**Protection Systems**: Fedler et al. [15] proposed a protection system from root exploits by preventing apps from giving execution permission for custom executable files and introducing a permission related to the System class. PREC [24] is a framework to protect Android systems from root exploits, using a learning and enforcement phase. Our work generates policies applicable to all apps, whereas PREC generates per-app models, making our results more general. Our analysis also monitors system calls, JNI function calls, Binder transactions, and calls from Java to native methods.

**Native Code Isolation**: Isolating native code components used by managed languages has been extensively studied. Klinkoff et al. [26] focused on .NET applications, and Robusta [33] on Java applications. Recently, NativeGuard [35] proposed a similar mechanism for Android. Our work is complementary to these sandboxing mechanisms and fills the knowledge gap necessary to define security policies for the execution of native code in Android that are both usable in real-world applications and effective in blocking malicious behavior of native components.

### X. Conclusion

While allowing developers to mix Java code and native code enables them to fully harness the computing power of mobile devices, we believe that, in the current state, this feature does more harm than good. Native code sandboxing is the correct approach to properly limit its potentially malicious side effects. However, a native code sandboxing mechanism without a proper policy will never be feasible. We hope that, in addition to shedding light on the previously unknown native code usage of Android apps, this paper demonstrates an approach to automatically generate an effective and practical native code sandboxing policy.

### Acknowledgment

This material is based upon work supported by CAPES Foundation under Award No. BEX 12269/13-1, by NSF under Award No. CNS-1408632, by DHS under Award No. 2009-ST-061-CI0001, and by Secure Business Austria. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the authors and do not necessarily reflect the views of CAPES Foundation, NSF, DHS, or Secure Business Austria.

This material is also based on research sponsored by DARPA under agreement number FA8750-12-2-0101. The U.S. Government is authorized to reproduce and distribute reprints for governmental purposes notwithstanding any copyright notation thereon. The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of DARPA or the U.S. Government.

### References

[1] V. Afonso, A. Bianchi, Y. Fratantonio, A. Doupé, M. Polino, P. de Geus, C. Kruegel, and G. Vigna, “Full version of Tables 5, 6, 7, 8, and 11.” [Online] Available: https://github.com/ucsb-seclab/android going native.
[2] AppBrain, “Number of Available Android Applications,” [Online] Available: http://www.appbrain.com/stats/number-of-android-apps.
[3] A. Apvrille and R. Nigam, “Obfuscation in Android Malware, and How to Fight Back,” in Virus Bulletin, 2014.
[4] D. Arp, M. Spreitzenbarth, M. Hübner, H. Gascon, and K. Rieck, “DREBIN: Effective and Explainable Detection of Android Malware in Your Pocket,” in Proceedings of the 21st Annual Network and Distributed System Security Symposium (NDSS), 2014.
[5] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein, Y. Le Traon, D. Octeau, and P. McDaniel, “FlowDroid: Precise Context, Flow, Field, Object-sensitive and Lifecycle-aware Taint Analysis for Android Apps,” in Proceedings of the 35th annual ACM SIGPLAN conference on Programming Language Design and Implementation (PLDI), 2014.
[6] K. W. Y. Au, Y. F. Zhou, Z. Huang, and D. Lie, “Pscout: Analyzing the Android Permission Specification,” in Proceedings of the 2012 ACM conference on Computer and Communications Security (CCS), 2012.
[7] L. Batyuk, M. Herpich, S. A. Camtepe, K. Raddatz, A.-D. Schmidt, and S. Albayrak, “Using Static Analysis for Automatic Assessment and Mitigation of Unwanted and Malicious Activities Within Android Applications,” in Proceedings of the 2011 6th International Conference on Malicious and Unwanted Software (MALWARE), 2011.
[8] A. Bittau, P. Marchenko, M. Handley, and B. Karp, “Wedge: Splitting Applications into Reduced-Privilege Compartments,” in Proceedings of the 5th USENIX Symposium on Networked Systems Design and Implementation (NSDI), 2008.
[9] I. Burguera, U. Zurutuza, and S. Nadjm-Tehrani, “Crowdroid: Behavior-based Malware Detection System for Android,” in Proceedings of the 1st ACM workshop on Security and privacy in smartphones and mobile devices (SPSM), 2011.
[10] V. Chebyshev and R. Unuchek, “Mobile Malware Evolution: 2013,” [Online] Available: http://securelist.com/analysis/kaspersky-security-bulletin/58335/mobile-malware-evolution-2013/, Feb. 2014.
[11] E. Chin, A. P. Felt, K. Greenwood, and D. Wagner, “Analyzing Inter-Application Communication in Android,” in Proceedings of the 9th international conference on Mobile systems, applications, and services (MobiSys), 2011.
[12] A. Desnos, “Androguard: Reverse Engineering, Malware and Goodware Analysis of Android Applications... and More (Ninja!),” [Online] Available: https://code.google.com/p/androguard/.
[13] Droidbox, “Android Application Sandbox,” [Online] Available: https://code.google.com/p/droidbox/.
[14] W. Enck, P. Gilbert, B. Chun, L. Cox, J. Jung, P. McDaniel, and A. Sheth, “TaintDroid: an Information-flow Tracking System for Realtime Privacy Monitoring on Smartphones,” in Proceedings of the 9th USENIX Symposium on Operating Systems Design and Implementation (OSDI), 2010.
[15] R. Fedler, M. Kulicke, and J. Schütte, “Native Code Execution Control for Attack Mitigation on Android,” in Proceedings of the Third ACM workshop on Security and privacy in smartphones & mobile devices (SPSM), 2013.
[16] A. P. Felt, E. Chin, S. Hanna, D. Song, and D. Wagner, “Android Permissions Demystified,” in Proceedings of the 18th ACM conference on Computer and Communications Security (CCS), 2011.
[17] A. P. Fuchs, A. Chaudhuri, and J. S. Foster, “SCanDroid: Automated Security Certification of Android Applications,” Manuscript, Univ. of Maryland, http://www.cs.umd.edu/~avik/projects/scandroidascaa, 2009.
[18] C. Gibler, J. Crussel, J. Erickson, and H. Chen, “AndroidLeaks: Detecting Privacy Leaks in Android Applications,” Tech. rep., UC Davis, Tech. Rep., 2011.
[19] Google, “Android NDK,” [Online] Available: https://developer.android.com/tools/sdk/ndk/index.html.
[20] ——, “UI/Application Exerciser Monkey — Android Developers,” [Online] Available: http://developer.android.com/tools/help/monkey.html.
[21] R. Gordon, Essential JNI: Java Native Interface. Prentice-Hall, Inc., 1998.
[22] M. Grace, Y. Zhou, Z. Wang, and X. Jiang, “Systematic Detection of Capability Leaks in Stock Android Smartphones,” in Proceedings of the 19th Annual Network and Distributed System Security Symposium (NDSS), 2012.
[23] M. Grace, Y. Zhou, Q. Zhang, S. Zou, and X. Jiang, “Riskranker: Scalable and Accurate Zero-Day Android Malware Detection,” in Proceedings of the 10th international conference on Mobile systems, applications, and services (MobiSys), 2012.
[24] T.-H. Ho, D. Dean, X. Gu, and W. Enck, “PREC: Practical Root Exploit Containment for Android Devices,” in Proceedings of the 4th ACM conference on Data and application security and privacy (CODASPY), 2014.
[25] IDC Corporate, “IDC: Smartphone OS Market Share 2014, 2013, 2012, and 2011,” [Online] Available: http://www.idc.com/prodserv/smartphone-os-market-share.jsp.
[26] P. Klinkoff, E. Kirda, C. Kruegel, and G. Vigna, “Extending .NET Security to Unmanaged Code,” International Journal of Information Security, 2007.
[27] M. Lindorfer, M. Neugschwandtner, L. Weichselbaum, Y. Fratantonio, V. van der Veen, and C. Platzer, “Andrubis - 1,000,000 Apps Later: A View on Current Android Malware Behaviors,” in Proceedings of the 3rd International Workshop on Building Analysis Datasets and Gathering Experience Returns for Security (BADGERS), 2014.
[28] L. Lu, Z. Li, Z. Wu, W. Lee, and G. Jiang, “CHEX: Statically Vetting Android Apps for Component Hijacking Vulnerabilities,” in Proceedings of the 2012 ACM Conference on Computer and Communications Security (CCS), 2012.
[29] C. Mann and A. Starostin, “A Framework for Static Detection of Privacy Leaks in Android Applications,” in Proceedings of the 27th Annual ACM Symposium on Applied Computing (SAC), 2012.
[30] G. Portokalidis, P. Homburg, K. Anagnostakis, and H. Bos, “Paranoid Android: Versatile Protection for Smartphones,” in Proceedings of the 26th Annual Computer Security Applications Conference (ACSAC), 2010, pp. 347–356.
[31] C. Qian, X. Luo, Y. Shao, and A. T. Chan, “On Tracking Information Flows through JNI in Android Applications,” in Proceedings of the 44th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN), 2014.
[32] V. Rastogi, Y. Chen, and W. Enck, “AppsPlayground: Automatic Security Analysis of Smartphone Applications,” in Proceedings of the third ACM conference on Data and application security and privacy (CODASPY), 2013.
[33] J. Siefers, G. Tan, and G. Morrisett, “Robusta: Taming the Native Beast of the JVM,” in Proceedings of the 17th ACM conference on Computer and Communications Security (CCS), 2010.
[34] A. D. Space, “Local Root Vulnerability in Android 4.4.2,” [Online] Available: http://blog.cassidiancybersecurity.com/post/2014/06/Android-4.4.3,-or-fixing-an-old-local-root.
[35] M. Sun and G. Tan, “NativeGuard: Protecting Android Applications from Third-Party Native Libraries,” in Proceedings of the 2014 ACM conference on Security and privacy in wireless & mobile networks (WiSec), 2014.
[36] K. Tam, S. J. Khan, A. Fattori, and L. Cavallaro, “CopperDroid: Automatic Reconstruction of Android Malware Behaviors,” in Proceedings of the 22nd Annual Network and Distributed System Security Symposium (NDSS), 2015.
[37] N. Viennot, E. Garcia, and J. Nieh, “A Measurement Study of Google Play,” in Proceedings of the 2014 ACM SIGMETRICS International Conference on Measurement and Modeling of Computer Systems (SIGMETRICS), 2014.
[38] C. Warren, “Google Play Hits 1 Million Apps,” [Online] Available: http://mashable.com/2013/07/24/google-play-1-million/, Jul. 2013.
[39] F. Wei, S. Roy, X. Ou et al., “Amandroid: A Precise and General Inter-component Data Flow Analysis Framework for Security Vetting of Android Apps,” in Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security (CCS), 2014.
[40] L. Weichselbaum, M. Neugschwandtner, M. Lindorfer, Y. Fratantonio, V. van der Veen, and C. Platzer, “ANDRUBIS: Android Malware Under The Magnifying Glass,” Vienna University of Technology, Tech. Rep. TR-ISECLAB-0414-001, 2014.
[41] L. K. Yan and H. Yin, “Droidscope: Seamlessly reconstructing the OS and Dalvik semantic views for dynamic Android malware analysis,” in Proceedings of the 21st USENIX Security Symposium, 2012.
[42] Z. Yang and M. Yang, “Leakminer: Detect Information Leakage on Android with Static Taint Analysis,” in Proceedings of the 2012 Third World Congress on Software Engineering (WCSE), 2012.
[43] Z. Zhao and F. C. C. Osono, “TrustDroidTM: Preventing the Use of SmartPhones for Information Leaking in Corporate Networks Through the Use of Static Analysis Taint Tracking,” in Proceedings of the 2012 7th International Conference on Malicious and Unwanted Software (MALWARE), 2012.
[44] Y. Zhou, Z. Wang, W. Zhou, and X. Jiang, “Hey, You, Get Off of My Market: Detecting Malicious Apps in Official and Alternative Android Markets,” in Proceedings of the 19th Annual Network and Distributed System Security Symposium (NDSS), 2012.
[45] Y. Zhou and X. Jiang, “Detecting Passive Content Leaks and Pollution in Android Applications,” in Proceedings of the 20th Annual Network and Distributed System Security Symposium (NDSS), 2013.