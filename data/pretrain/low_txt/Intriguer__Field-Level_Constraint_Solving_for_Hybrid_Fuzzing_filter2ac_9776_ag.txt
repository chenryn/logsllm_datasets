### References

1. **Chen, H., Xue, Y., Li, Y., Chen, B., Xie, X., Wu, X., & Liu, Y. (2018).** *Hawkeye: Towards a Desired Directed Grey-box Fuzzer.* In Proceedings of the ACM SIGSAC Conference on Computer and Communications Security (CCS), 2095–2108. ACM.
2. **Chen, P., & Hao, C. (2018).** *Angora: Efficient Fuzzing by Principled Search.* In Proceedings of the IEEE Symposium on Security and Privacy (S&P). IEEE.
3. **Comparetti, P. M., Wondracek, G., Kruegel, C., & Kirda, E. (2009).** *Prospex: Protocol Specification Extraction.* In Proceedings of the IEEE Symposium on Security and Privacy (S&P), 110–125. IEEE.
4. **Cui, W., Peinado, M., Chen, K., Wang, H. J., & Irun-Briz, L. (2008).** *Tupni: Automatic Reverse Engineering of Input Formats.* In Proceedings of the ACM SIGSAC Conference on Computer and Communications Security (CCS), 391–402. ACM.
5. **Dolan-Gavitt, B., Hulin, P., Kirda, E., Leek, T., Mambretti, A., Robertson, W., Ulrich, F., & Whelan, R. (2016).** *Lava: Large-scale Automated Vulnerability Addition.* In Proceedings of the IEEE Symposium on Security and Privacy (S&P), 110–121. IEEE.
6. **Gan, S., Zhang, C., Qin, X., Tu, X., Li, K., Pei, Z., & Chen, Z. (2018).** *CollAFL: Path Sensitive Fuzzing.* In Proceedings of the IEEE Symposium on Security and Privacy (S&P), 679–696. IEEE.
7. **Ganesh, V., Leek, T., & Rinard, M. (2009).** *Taint-based Directed Whitebox Fuzzing.* In Proceedings of the International Conference on Software Engineering (ICSE), 474–484.
8. **Godefroid, P., Levin, M. Y., Molnar, D. A., et al. (2008).** *Automated Whitebox Fuzz Testing.* In Proceedings of the Network and Distributed System Security Symposium (NDSS), Vol. 8, 151–166.
9. **Haller, I., Slowinska, A., Neugschwandtner, M., & Bos, H. (2013).** *Dowsing for Overflows: A Guided Fuzzer to Find Buffer Boundary Violations.* In Proceedings of the USENIX Security Symposium (SEC), 49–64. USENIX Association.
10. **Kemerlis, V. P., Portokalidis, G., Jee, K., & Keromytis, A. D. (2012).** *libdft: Practical Dynamic Data Flow Tracking for Commodity Systems.* In ACM SIGPLAN Notices, Vol. 47, 121–132. ACM.
11. **Klees, G., Ruef, A., Cooper, B., Wei, S., & Hicks, M. (2018).** *Evaluating Fuzz Testing.* In Proceedings of the ACM SIGSAC Conference on Computer and Communications Security (CCS), 2123–2138. ACM.
12. **Leffler, S. (1999).** *LibTIFF–TIFF Library and Utilities.* Available at: http://www.libtiff.org/
13. **Li, Y., Chen, B., Chandramohan, M., Lin, S.-W., Liu, Y., & Tiu, A. (2017).** *Steelix: Program-state Based Binary Fuzzing.* In Proceedings of the Joint Meeting on Foundations of Software Engineering (FSE), 627–637. ACM.
14. **Majumdar, R., & Sen, K. (2007).** *Hybrid Concolic Testing.* In Proceedings of the International Conference on Software Engineering (ICSE), 416–426. IEEE.
15. **Miller, B. P., Fredriksen, L., & So, B. (1990).** *An Empirical Study of the Reliability of UNIX Utilities.* Communications of the ACM, 33(12), 32–44.
16. **Ming, J., Wu, D., Xiao, G., Wang, J., & Liu, P. (2015).** *TaintPipe: Pipelined Symbolic Taint Analysis.* In Proceedings of the USENIX Security Symposium (SEC), 65–80. USENIX Association.
17. **Molnar, D., Li, X. C., & Wagner, D. (2009).** *Dynamic Test Generation to Find Integer Bugs in x86 Binary Linux Programs.* In Proceedings of the USENIX Security Symposium. USENIX Association.
18. **Nagy, S., & Hicks, M. (2019).** *Full-speed Fuzzing: Reducing Fuzzing Overhead through Coverage-guided Tracing.* In Proceedings of the IEEE Symposium on Security and Privacy (S&P). IEEE.
19. **Pak, B. S. (2012).** *Hybrid Fuzz testing: Discovering Software Bugs via Fuzzing and Symbolic Execution.* School of Computer Science, Carnegie Mellon University.
20. **Peng, H., Shoshitaishvili, Y., & Payer, M. (2018).** *T-Fuzz: fuzzing by program transformation.* In Proceedings of the IEEE Symposium on Security and Privacy (S&P), 697–710. IEEE.
21. **Rawat, S., Jain, V., Kumar, A., Cojocar, L., Giuffrida, C., & Bos, H. (2017).** *VUzzer: Application-aware Evolutionary Fuzzing.* In Proceedings of the Network and Distributed System Security Symposium (NDSS).
22. **Serebryany, K. (2017).** *OSS-Fuzz: Google’s continuous fuzzing service for open source software.*
23. **Stephens, N., Grosen, J., Salls, C., Dutcher, A., Wang, R., Corbetta, J., Shoshitaishvili, Y., Kruegel, C., & Vigna, G. (2016).** *Driller: Augmenting Fuzzing Through Selective Symbolic Execution.* In Proceedings of the Network and Distributed System Security Symposium (NDSS).
24. **Wang, T., Wei, T., Gu, G., & Zou, W. (2010).** *TaintScope: A Checksum-Aware Directed Fuzzing Tool for Automatic Software Vulnerability Detection.* In Proceedings of the IEEE Symposium on Security and Privacy (S&P), 497–512. IEEE.
25. **Wang, T., Wei, T., Lin, Z., & Zou, W. (2009).** *IntScope: Automatically Detecting Integer Overflow Vulnerability in X86 Binary Using Symbolic Execution.* In Proceedings of the Network and Distributed System Security Symposium (NDSS).
26. **Wang, Z., Jiang, X., Cui, W., Wang, X., & Grace, M. (2009).** *ReFormat: Automatic Reverse Engineering of Encrypted Messages.* In European Symposium on Research in Computer Security (ESORICS), 200–215.
27. **Yun, I., Lee, S., Xu, M., Jang, Y., & Kim, T. (2018).** *QSYM: A Practical Concolic Execution Engine Tailored for Hybrid Fuzzing.* In Proceedings of the USENIX Security Symposium (SEC), 745–761. USENIX Association.
28. **Zalewski, M. (2014).** *American fuzzy lop.* Available at: http://lcamtuf.coredump.cx/afl/

### Appendices

#### A. Emulation Time of MOV-like Instructions

To evaluate the effectiveness of eliminating MOV-like instructions for performance improvement, we conducted a micro-evaluation. Figure 12 illustrates the symbolic emulation time for each program, with a focus on the proportion of time incurred by MOV-like instructions. In real-world programs such as `objdump`, `ffmpeg10`, and `tiff2pdf`, MOV-like instructions accounted for a significant portion of the emulation time. This is because MOV-like instructions do not introduce new symbolic expressions but instead incur a copy of existing symbolic expressions per execution. Additionally, QSYM occasionally uses a solver to concretize memory addresses during the emulation of MOV-like instructions, leading to additional overhead.

In contrast, the program `who` from the LAVA-M dataset exhibited a smaller proportion of emulation time for MOV-like instructions. This is due to its smaller size and fewer input-related instructions, resulting in less complex constraints and faster copying of symbolic expressions.

Our evaluation results indicate that removing MOV-like instructions in advance can significantly improve performance in hybrid fuzzing.

*Note: ffmpeg terminated with "Pin is out of memory" error before its complete execution.*

#### B. Performance Gain by Eliminating Uncomplicated Constraint Solving

To assess the effectiveness of eliminating uncomplicated constraints in a symbolic solver for hybrid fuzzing, we performed another micro-evaluation. Table 17 shows that Intriguer's strategy of directly solving uncomplicated constraints (D(U)) outperforms the previous strategy of always using a symbolic solver (S(C, U)) in terms of both symbolic emulation time and solving time. The performance gain, calculated as \((1 - \Delta(S(C), D(U))/\Delta(S(C, U))) \times 100\), demonstrates that this approach is efficient. Notably, the emulation time has a more significant impact on performance than the solving time.

#### C. Special Cases in Taint Propagation

Certain instructions, such as `MUL`, `IMUL`, `DIV`, and `IDIV`, can affect registers that are not explicitly listed as operands. For example, `MUL` multiplies the value received by the operand with `EAX` and stores the result in `EDX:EAX`, even if `EDX` is not used as an operand. Therefore, taint propagation must be applied to these registers as well.

The `XOR` instruction is often used to initialize operand values to zero. For instance, `XOR EAX, EAX` sets the value of `EAX` to zero, and the operand used is removed from the tainted memory list. Similarly, the `AND` instruction is used to mask data, and unused offset data are removed from the tainted memory list. The `REP` prefix and related repeat mnemonics, when added to string instructions, cause repetition up to the value stored in the counter register. These cases have been discussed in previous studies on taint analysis [16, 22].

#### D. C++ Source Code for Binary Seed

```cpp
#include <iostream>
using namespace std;

class example {
    int var1, var2;
public:
    void set_request(int a, int b);
    int sum() { return (var1 + var2); }
} class_obj;

void example::set_request(int a, int b) {
    var1 = a;
    var2 = b;
}

int main(void) {
    class_obj.set_request(1, 4);
    cout << "\n The sum is " << class_obj.sum() << "\n";
    return 0;
}
```

#### E. LAVA-M Results

Table 16 presents the number of bugs found by state-of-the-art fuzzers in 5-hour fuzzing sessions on LAVA-M binaries. The middle columns report numbers from each paper, while the last three columns show our experimental results. Note that only the number of "listed" bugs is shown in Table 16 (and also in Table 8), but Intriguer also discovered "unlisted" bugs. For example, Intriguer found all 2,136 listed bugs in `who`, plus 328 unlisted bugs, totaling 2,464 bugs discovered in `who` (5 hours).

**Session 3A: Fuzzing: Methods and Applications**
*CCS '19, November 11–15, 2019, London, United Kingdom*