### Optimized Text

To guide the system to load the initialization function in a malicious module, styxË† proposes a similar approach in the latest issue 68 of Phrack [4]. This method is applicable to kernel versions 2.6.x and 3.0.x, where it redirects the `init_module` function to load a malicious `evil` function instead of the original `init` function. To enable the malicious modules to invoke the original `init` function, the symbol binding of `init` is updated from local to global. Both methods achieve equivalent results, but we chose the former to inject the DR rootkit into an E1000 NIC driver as our target.

The DR rootkit employs a debug register-based hooking engine, which does not require modifications to the system call table, to perform traditional rootkit behaviors such as hiding processes, sockets, and files. Specifically, it determines the name of a file (in this case, "AAA") and hides its presence in the file system by modifying the file listing result in the directory. When executing this file, the rootkit escalates the privilege of "AAA" to root, hides all created sockets, and prevents other processes from opening files owned by "AAA."

The trojaned driver combines the functionality of a benign E1000 NIC driver with a malicious kernel rootkit. We use DRIP to neutralize the malicious behavior while retaining the benign NIC driver functionality. Test cases are selected and synthesized from LTP (Linux Test Project) [15], Linux utility programs, and Iperf to cover the benign functionalities of the E1000 NIC driver and ensure the overall system reliability. We have validated that the purified driver behaves identically to a benign E1000 NIC driver, with the malicious operations of the DR rootkit eliminated.

**Case Study II: E1000 NIC Driver with Kernel Function Redirection under Linux**

From Case Study I, we learned that we can implant malicious code inside the initialization function to install system call hooks. In fact, when the driver code invokes a kernel function, we can intercept and redirect any function invocation to a malicious function first. The malicious function acts as a proxy, invoking the original function and returning the result to the original invocation. This kernel function redirection technique is proposed in the libkernsh of ERESI [8].

We prepared an interposition kernel module containing malicious functions from the KBeast rootkit and linked it with the E1000 NIC driver to generate a trojaned driver. The relocation table of the new driver contains all the addresses of code/data that need to be fixed up during loading. We scanned this table to find the function invocations we wanted to hijack and modified them to detour to the malicious function in the interposition module. The payload, KBeast, is a new kernel rootkit based on well-known rootkits, supporting the latest Linux kernel versions. It includes traditional rootkit functionalities such as process hiding, file hiding, keystroke logging, and local root escalation. The basic idea is to patch the system call table and detour system calls to fake functions crafted by the attacker. Since system calls are hijacked, KBeast can easily manipulate intermediate results and return fake results to the user. We used similar test cases as in Case Study I to build our test suite, ensuring the system's reliability and the core benign functionalities of the E1000 NIC driver. After purification, we validated that KBeast's cloaking effects were eliminated, and the E1000 driver's original functionalities were preserved.

**Case Study III: Kbdevents under Linux**

Kprobes [23] is a lightweight debugging mechanism in the Linux kernel that allows developers to intercept kernel routines at runtime to collect debugging information. Kbdevents [24] is a Linux kernel module based on Kprobes to intercept keyboard events. It can be used as a debugging tool to verify the correctness of the keyboard driver. On every key press, Kbdevents has additional functionality to launch user scripts from kernel space, such as a keylogger to dump keystrokes into a file, printscr to take screenshots, and typewriter to imitate typewriter sounds. These supplementary capabilities are not necessary for debugging. Therefore, we performed purification on Kbdevents to minimize it to only include the debugging functionality. We built a special test suite to simulate keystrokes out of VM, i.e., generating keyboard interrupts from QEMU, and captured them in the guest VM to verify the correctness of Kbdevents' debugging functionality. After purification, we found that all kernel API invocations related to launching user scripts from the kernel (e.g., `call_usermodehelper_setup`, `call_usermodehelper_exec`) were removed from the driver. The purified driver can still intercept keystrokes to debug the Linux keyboard driver.

**Case Study IV: Infected Kbdclass Driver by DaMouse under Windows**

DaMouse [6] is a PE driver infection technique under Windows. It implants existing malicious code into a Windows device driver in the system. It uses a virus coding technique called Entry-Point Obscuring (EPO) to patch API invocations inside the device driver. When the patched API is invoked, it installs a permanent System Service Dispatch Table (SSDT) hook to redirect the system call to the hook function inside the driver. The hook function contains malicious code to filter the results and eventually completes the procedure by invoking the original system call.

In this case study, we used DaMouse to infect `kbdclass.sys`, the keyboard class driver in Windows. DaMouse patches the Kbdclass driver and installs the SSDT hook at `NtOpenProcess`. System calls to `NtOpenProcess` are redirected to the hook function called `NewNtOpenProcess`. The filter code in the hook function determines whether the target process is `iexplorer.exe`, which belongs to Internet Explorer. If so, the `NtOpenProcess` request is denied. The noticeable symptom to the user is that they cannot open a new web page in Internet Explorer. For other processes, the malicious code extracts the `NtOpenProcess` arguments, such as PID and name, of the calling process and dumps the result through `DbgPrint`. We built the test suite for Kbdclass by sending keystrokes from QEMU into the VM, similar to Case Study III, and verified them in the test program within the VM. After purification, we retained the keyboard driver's functionality, and Internet Explorer could open new tabs successfully without any process information leakage.

**Case Study V: Beep Driver Infected with klog as Payload under Windows**

In previous case studies, we applied DRIP to purify drivers infected by existing binary infection tools. In this case study, we aimed to prove the generality of DRIP by purifying trojaned drivers generated by a binary transformation tool developed in our research. This technique enables transplanting binary functional modules extracted from one binary into another. We extracted the malicious functions, i.e., keyboard attaching and keystrokes dumping, from klog, a well-known Windows keyboard sniffer. We then used our binary transformation technique to implant these functions into the beep driver of Windows. To check if the beep driver works properly, we added functionality-checking logic in the emulated PC speaker in QEMU to verify beep events. After purification, we loaded the purified beep driver into the production environment, and it worked as expected, with the keyboard no longer dumping sniffed keystrokes to a file.

### Performance Evaluation

The time it takes for DRIP to purify a specific driver depends on the driver's code complexity, test suite coverage, and hardware configuration. Table II presents the complete performance statistics for each trojaned driver, showing the ratio of "Removed Function Invocations" to "Recorded Function Invocations," the purification time, and the number of testing cycles. Our results indicate that DRIP is suitable for offline driver purification.

We next measured the system performance overhead with the purified driver and compared it with the system performance with the trojaned driver. We used SPECINT 2000 under Windows and UnixBench under Linux to measure CPU performance. We normalized the performance results and presented them in Figure 5. The left bars indicate the normalized performance scores (the higher the better) after loading the original trojaned driver. The right bars show the normalized performance scores after loading the purified driver. In the experiments with trojaned E1000+KBeast/E1000+Redir, the system crashed when executing the test case file copy in UnixBench. The reason is that the KBeast rootkit cannot handle the workload of the test case file copy in UnixBench, and both trojaned drivers contain KBeast's code. After purification, both drivers supported the benchmark successfully because the KBeast functionality was eliminated. For the other experiments, the purified drivers improved benchmark performance by 1% to 45% compared to the trojaned drivers.

### Limitations and Future Work

**Limitations:**

1. **Memory Deallocation Invocations:** Some memory deallocation invocations may be removed, which might not impact the execution of the test suite over a short period but can cause memory leaks and affect long-term system performance. We can add test cases to prevent these invocations from being removed, such as measuring the driver's memory usage and reporting failure if it exceeds a threshold. Another solution is to add well-known functions with specific functionalities to a whitelist and skip them during profiling.

2. **Self-contained Malicious Code:** Some malicious code can jeopardize the kernel without invoking any kernel APIs, such as directly modifying kernel memory. Such self-contained malicious code can evade DRIP's purification since we monitor at the granularity of API invocations. However, their functionalities are limited, and they are difficult to adapt to new kernel versions. We plan to improve DRIP to monitor at the level of memory operations during the profiling phase to address this problem in the future.

3. **Testing Environment Limitations:** Our testing environment is based on QEMU, which supports kernel drivers that extend core kernel functionalities. For device drivers controlling real hardware devices, we can only support those whose devices are emulated by QEMU. In the DDT research effort [14], the authors propose symbolic devices, which present themselves as virtual devices to facilitate symbolic execution of driver code. This technique can complement DRIP to address the problem of some devices not being emulated by QEMU. We consider integrating symbolic devices in our future work.

### Related Work

**Online Device Driver Isolation:**

- **Nooks [9]:** Uses a shadow driver mechanism to conceal driver failures from applications by monitoring the state of real drivers during normal operation. It inserts itself when a failure occurs, improving the reliability of the overall system.
- **SafeDrive [25]:** Improves kernel extension reliability by adding type-based checking to driver code and enforcing runtime memory safety.
- **Microdriver [26]:** Partitions an existing driver into a kernel-level driver handling performance-critical tasks and a user-level driver processing low-performance issues.
- **Nexus [27]:** Moves the device driver to user space and leverages device-specific reference monitors to validate interactions between drivers and devices.
- **SUD [10]:** Leverages recent hardware support to confine operations of devices and allows unmodified Linux device drivers to run safely.

These techniques aim to enhance the reliability and security of device drivers in various ways, complementing the goals of DRIP.