### Capweave Policies for Security Enhancements

#### bzip2 and gzip
We defined a capweave policy that strictly limits the capabilities of an attacker who compromises bzip2 or gzip. The policy restricts these utilities to execute with only the capability to read from the source file containing uncompressed data and write to the file opened to store the compressed output. An attacker who compromises a version of bzip2 or gzip that adheres to this policy can compromise the integrity of the output files, but cannot perform other malicious actions, such as overwriting arbitrary files. Our capweave policies for bzip2 and gzip were inspired by previous work on manually writing programs for Capsicum [10], [21].

#### php-cgi
Executing programs written in web scripting languages, such as PHP, raises multiple security issues. First, analyzing, monitoring, and restricting the behavior of a script is inherently difficult. Second, a maliciously crafted web program can potentially compromise the interpreter that executes it, allowing the attacker to perform any action permitted for the user who launched the interpreter [5].

We defined a capweave policy for the PHP CGI interpreter (php-cgi) that allows the interpreter to only read from and write to files defined by a small set of simple, easily-audited checking functions. This policy strictly limits the file I/O of php-cgi itself, and thus indirectly limits the I/O of any PHP script executed by the interpreter. We developed this policy in collaboration with a group of researchers from MIT Lincoln Laboratory.

#### tar
The tar archiving utility archives sets of files into a single file. Unfortunately, past versions of tar have contained vulnerabilities that allow an attacker who controls the inputs to tar to run injected code with the privileges of the user who invoked tar [6], [7].

We defined a capweave policy that strictly limits the abilities of an attacker who compromises tar. The policy restricts tar to execute vulnerable functions without ambient authority. An attacker who compromises a version of tar that adheres to this policy can compromise the integrity of the output files, but cannot carry out other malicious actions.

#### tcpdump
Tcpdump is a widely-used network-facing application that has historically been the target of many exploits. Tcpdump takes as input a Berkeley Packet Filter (BPF) and a device from which to read packets. In a correct execution, it reads packets from the device, matches them against the BPF, and if the packet matches, prints the packet to standard output. Unfortunately, the packet-matching code in tcpdump is complex; in previous versions, an attacker who controls the network input could craft a packet to take control of the process executing tcpdump [1].

We defined a capweave policy for tcpdump that strictly limits the power of an attacker who can compromise tcpdump. In previous work on Capsicum [10], the developers instrumented tcpdump so that it could only read from its input network device and write to standard output. However, this instrumentation did not allow tcpdump to resolve network addresses in a packet. The developers revised the instrumentation so that only a small, trusted DNS resolver could open files. The capweave policy for tcpdump describes the policy that the revised instrumentation satisfies.

#### wget
The wget downloader, along with its vulnerabilities and capweave policy, was discussed in §II. Our policy for wget was inspired by discussions on the Capsicum-developer mailing list and known vulnerabilities of wget [2], [13].

### Experimental Procedure

For each benchmark program and policy described in §IV-A1, we defined the benchmark's policy in the capweave policy language and applied capweave to the program and policy. We also obtained a version of each program that was manually modified to satisfy the policy. In previous work, the Capsicum developers manually rewrote bzip2, gzip, and tcpdump to satisfy informal versions of the policies described in §IV-A1. We recompiled these versions with the LLVM compiler to compare their runtime overhead with the programs woven by capweave. We manually instrumented the other three benchmarks to satisfy their respective policies. Both the woven and manually instrumented programs were compiled with the default optimization of each benchmark ("-O2" for each program). Capweave was applied to optimized LLVM bitcode.

We ran bzip2, gzip, php-cgi, tcpdump, and wget on the test workloads included in the source distribution of each program. We ran tar to archive its own source directory. We ran each original benchmark, woven benchmark, and manually rewritten benchmark on the benchmark's test suite and compared the executions. Specifically, we counted the number of tests each benchmark program passed and measured the runtime performance overhead of the rewritten programs compared to the original benchmark. Since the total time taken by each benchmark on the test workloads was often less than a second, we also measured performance on larger, more realistic workloads.

To validate that the woven programs mitigated attacks according to their policy, we introduced a "backdoor" into each program that attempted to carry out an attack disallowed by the program's policy. We then ran the woven program on an input that triggered the backdoor and observed that the goal of the attack was not achieved.

### Analysis of Results

The results of our experiments are given in Table I. (The performance numbers reported in Table I are from the test workloads included in the source distribution of each program. Performance on larger, more realistic workloads is discussed below.) For each benchmark, Table I contains three groups of measurements of our experience weaving the benchmark.

- **Policy Complexity (Columns 3–5):** Measures the complexity of the policy for which the benchmark was woven. It includes the number of lines of code in which each policy is represented in our policy language and the size of the policy DFA constructed by capweave. The number of lines of policy-language code indicates that the policy language supported by capweave can express practical policies concisely.

- **Capweave Performance (Columns 6–7):** Measures the performance of capweave, including the time and peak memory used. Each benchmark was woven on a server with sixteen 2.4 GHz cores and 32 GB of memory, although the capweave implementation executes sequentially. The running time and peak memory indicate that capweave can be included in the edit-compile-run toolchain of many small-to-medium-sized programs and in the nightly build system of large programs. The performance of capweave is strongly determined by the size of the policy, particularly the size of the policy-automaton alphabet, more than the size of the input program.

- **Woven Program Performance (Columns 8–15):** Measures the performance of programs rewritten by capweave. It includes the number of reference tests that the unwoven (i.e., baseline) program passed, the number of tests passed by the woven version, the number of program points at which capweave added instrumentation, the number of functions that the benchmark executes in a synchronous fork, the runtime of the baseline program, the runtime of the woven program expressed as a multiple of the baseline, the runtime of the hand-woven program as a multiple of the baseline, and the percentage overhead of the runtime of the woven program over the hand-woven program. The geometric mean of all "capweave/Hand" values is 1.298 (i.e., capweave overhead is 29.8%). Each benchmark was run on a host machine with eight 2.2 GHz processors and 6 GB of memory, in a Capsicum virtual machine with one processor and 2 GB of memory.

Each woven program behaved identically to its corresponding hand-woven program on each test and to its corresponding unwoven program, except for some tests included with tcpdump and php-cgi. The woven tcpdump failed tests that provided a filepath to a file containing a secret key for decrypting IPsec ESP packets, instead of giving the secret key directly on the command line. The tcpdump policy specified that the woven tcpdump should not be able to open any file except for the input network device, and hence could not open the file containing the secret key. The woven php-cgi failed tests because no weaving of php-cgi can simultaneously satisfy the policy specified by the MITLL group and pass all tests. For example, the MITLL policy does not allow a PHP program to create a new file in its current directory. The woven php-cgi thus failed any test in which a program tried to create a file for output in its current directory.

These examples illustrate a key aspect of capweave: it allows a programmer to specify the capabilities a program should hold throughout an execution and automatically obtain a program that holds the specified capabilities. However, the programmer must still determine manually whether the capabilities specified by a particular policy strike an acceptable balance between security and functionality.