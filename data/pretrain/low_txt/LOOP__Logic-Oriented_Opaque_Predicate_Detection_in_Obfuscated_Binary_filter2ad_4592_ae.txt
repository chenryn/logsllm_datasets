### Instructions and Related Numerics Library API Calls
Instructions and related numerics library API calls (e.g., `log`, `exp`, and `sqrt`) are rarely seen in malicious code.

### Two-Way Opaque Predicates
Figure 10 illustrates a subtle case of an opaque predicate, where two possible execution paths may be taken, and instructions `I1` and `I2` are executed in any case. The predicate `P` does not fit into the categories summarized in Section 2, making it difficult to determine if `P` is an opaque predicate from a single trace. One method to detect such cases is to check the semantic equivalence of `P`'s two jump targets [49].

### Unsolved Conjectures
Recently, Wang et al. [48] proposed a more stealthy obfuscation scheme by incorporating linear unsolved conjectures, which appear to be correct but lack formal proof. Figure 11 provides an example of embedding the well-known 3x+1 conjecture into a program. This conjecture asserts that for any positive integer `y`, the loop will always terminate. In principle, we can treat the conjunction of branch conditions derived from the unrolled loop as a single opaque predicate, which always evaluates to true for any positive integer. However, unlike dynamic opaque predicates, the number of conditions varies with different inputs, and the conditions themselves are not correlated. To detect such unsolved conjectures, we observe that all examples [48] eventually converge to a fixed value regardless of the initial value. We could automatically generate test cases to explore different paths and observe whether multiple inputs cover the same value when the conjecture loop ends. This remains an area for future work.

### Related Work
In this section, we first present previous work on opaque predicate detection, which is closely related to our research. We then introduce related work on concolic testing, a hybrid approach to perform symbolic execution. Our trace-oriented detection is also a hybrid approach that applies symbolic execution in de-obfuscation. Finally, we discuss previous work on infeasible path identification, which is relevant because LOOP can be used to detect infeasible paths in binary code.

#### Opaque Predicate Detection
The concept of opaque predicates was first introduced by Collberg et al. [17] to prevent malicious reverse engineering attempts. They also provided some ad-hoc detection methods, including "statistical analysis," where a predicate that consistently produces the same result over many test cases is likely an opaque predicate. However, statistical analysis can lead to high false positive rates due to limited input sets. Preda et al. [42] proposed detecting opaque predicates using abstract interpretation, but their approach only identifies specific invariant opaque predicates. Madou [33] first identifies branches that never change at runtime and verifies these predicates using fuzz testing, though with a high error rate. Udupa et al. [45] use static path feasibility analysis to determine if an execution path is feasible, but their method struggles with highly obfuscated binaries, especially those with complex opaque predicates based on pointer aliasing. OptiCode [43] uses a theorem prover to decide if a branch is always true or false, but it is limited to invariant opaque predicates. Our work differs in that LOOP is both general and accurate, capable of detecting previously unknown opaque predicates in obfuscated binaries, including contextual and dynamic ones.

#### Concolic Testing
Our logic-based approach is inspired by the active research in concolic testing [13, 12, 24, 25], a hybrid software verification method combining concrete and symbolic execution. Similar to SAGE [25], LOOP maps symbols to inputs and collects constraints along recorded execution traces. However, our primary goal is not path exploration; instead, we construct formulas representing the characteristics of opaque predicates and solve these with a constraint solver. Concolic testing has been applied to discover deviations in binary [6], software debugging with golden implementations [4], and alleviating under-tainting problems [27]. Our approach adopts part of the concolic testing idea for software de-obfuscation and malware analysis.

#### Infeasible Path Identification
Opaque predicates obfuscate control flow graphs with infeasible paths. In software testing, eliminating infeasible paths saves effort by reducing redundant test cases. Previous work has identified infeasible paths in source code through branch correlation analysis [5], pattern matching [40], or monitoring the search for test data [11]. However, these methods cannot directly detect opaque predicates in an adversary environment where the source code is typically absent. Therefore, LOOP has compelling applications in identifying infeasible paths in binary code.

### Conclusion
Opaque predicates are widely used in software protection and malicious programs to obfuscate program control flow. Existing efforts to detect opaque predicates are either heuristic-based or limited to specific categories. In this paper, we present LOOP, a program logic-based and obfuscation-resilient approach to detect opaque predicates in binary code. Our approach represents the characteristics of various opaque predicates with logical formulas and verifies them using a constraint solver. LOOP detects not only simple invariant opaque predicates but also advanced contextual and dynamic ones. Experimental results show that LOOP is effective in detecting opaque predicates in a range of benign and obfuscated binary programs. By diagnosing culprit branches derived from opaque predicates in execution traces, LOOP aids analysts in further de-obfuscation. The experiment of speeding up code normalization for matching metamorphic malware variants confirms the value of LOOP in malware defenses.

### Acknowledgments
We thank the ACM CCS 2015 anonymous reviewers and Bill Harris for their valuable feedback. This research was supported in part by the National Science Foundation (NSF) grants CNS-1223710 and CCF-1320605, and the Office of Naval Research (ONR) grant N00014-13-1-0175.

### References
[1] H. Agrawal and J. R. Horgan. Dynamic program slicing. ACM SIGPLAN Notices, 25(6):246–256, 1990.
[2] B. Anckaert, M. Madou, B. D. Sutter, B. D. Bus, K. D. Bosschere, and B. Preneel. Program obfuscation: a quantitative approach. In Proceedings of the 2007 ACM workshop on Quality of Protection (QoP’07), 2007.
[3] G. Arboit. A method for watermarking Java programs via opaque predicates. In Proceedings of 5th International Conference on Electronic Commerce Research (ICECR-5), 2002.
[4] A. Banerjee, A. Roychoudhury, J. A. Harlie, and Z. Liang. Golden implementation driven software debugging. In Proceedings of the 18th ACM SIGSOFT International Symposium on Foundations of Software Engineering (FSE’10), 2010.
[5] R. Bodík, R. Gupta, and M. L. Soffa. Refining data flow information using infeasible paths. In Proceedings of the 5th ACM SIGSOFT International Symposium on Foundations of Software Engineering (FSE’97), 1997.
[6] D. Brumley, J. Caballero, Z. Liang, J. Newsome, and D. Song. Towards automatic discovery of deviations in binary implementations with applications to error detection and fingerprint generation. In Proceedings of 16th USENIX Security Symposium, 2007.
[7] D. Brumley, I. Jager, T. Avgerinos, and E. J. Schwartz. BAP: A binary analysis platform. In Proceedings of the 23rd international conference on computer aided verification (CAV’11), 2011.
[8] D. Brumley and J. Newsome. Alias analysis for assembly. Technical Report CMU-CS-06-180R, School of Computer Science, Carnegie Mellon University, 2006.
[9] D. Bruschi, L. Martignoni, and M. Monga. Detecting self-mutating malware using control-flow graph matching. In Proceedings of Detection of Intrusions and Malware & Vulnerability Assessment (DIMVA’06), 2006.
[10] D. Bruschi, L. Martignoni, and M. Monga. Code normalization for self-mutating malware. IEEE Security and Privacy, 5(2), 2007.
[11] P. M. S. Bueno and M. Jino. Identification of potentially infeasible program paths by monitoring the search for test data. In Proceedings of the 15th IEEE International Conference on Automated Software Engineering (ASE’00), 2000.
[12] C. Cadar, D. Dunbar, and D. Engler. KLEE: Unassisted and automatic generation of high-coverage tests for complex systems programs. In Proceedings of the 2008 USENIX Symposium on Operating Systems Design and Implementation (OSDI’08), 2008.
[13] C. Cadar, V. Ganesh, P. Pawlowski, D. Dill, and D. Engler. EXE: Automatically generating inputs of death. In Proceedings of the 2006 ACM Conference on Computer and Communications Security (CCS’06), 2006.
[14] J. Cappaert and B. Preneel. A general model for hiding control flow. In Proceedings of the 10th Annual ACM Workshop on Digital Rights Management (DRM’10), 2010.
[15] H. Chen, L. Yuan, X. Wu, B. Zang, B. Huang, and P.-c. Yew. Control flow obfuscation with information flow tracking. In Proceedings of the 42nd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO 42), 2009.
[16] C. Collberg, G. Myles, and A. Huntwork. Sandmark–a tool for software protection research. IEEE Security and Privacy, 1(4):40–49, July 2003.
[17] C. Collberg, C. Thomborson, and D. Low. A taxonomy of obfuscating transformations. Technical report, The University of Auckland, 1997.
[18] K. Coogan, G. Lu, and S. Debray. Deobfuscation of virtualization-obfuscated software. In Proceedings of the 18th ACM Conference on Computer and Communications Security (CCS’11), 2011.
[19] B. Coppens, B. De Sutter, and J. Maebe. Feedback-driven binary code diversification. ACM Transactions on Architecture and Code Optimization (TACO), 9(4), Jan. 2013.
[20] L. Cordella, P. Foggia, C. Sansone, and M. Vento. A (sub)graph isomorphism algorithm for matching large graphs. IEEE Transactions on Pattern Analysis and Machine Intelligence, 26(10):1367–1372, 2004.
[21] DefenseCode. Diving into recent 0day JavaScript obfuscations. http://blog.defensecode.com/2012/10/diving-into-recent-0day-javascript.html, last reviewed, 04/27/2015.
[22] S. Drape. Intellectual property protection using obfuscation. Technical Report RR-10-02, Oxford University Computing Laboratory, 2010.
[23] V. Ganesh and D. L. Dill. A decision procedure for bit-vectors and arrays. In Proceedings of the 2007 International Conference in Computer Aided Verification (CAV’07), 2007.
[24] P. Godefroid, N. Klarlund, and K. Sen. DART: Directed automated random testing. In Proceedings of the 2005 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI’05), 2005.
[25] P. Godefroid, M. Y. Levin, and D. Molnar. Automated whitebox fuzz testing. In Proceedings of the 15th Annual Network and Distributed System Security Symposium (NDSS’08), 2008.
[26] P. Junod, J. Rinaldini, J. Wehrli, and J. Michielin. Obfuscator-LLVM - software protection for the masses. In Proceedings of the 1st International Workshop on Software PROtection (SPRO’15), 2015.
[27] M. G. Kang, S. McCamant, P. Poosankam, and D. Song. DTA++: Dynamic taint analysis with targeted control-flow propagation. In Proceedings of the 18th Annual Network and Distributed System Security Symposium (NDSS’11), 2011.
[28] A. Kovacheva. Efficient code obfuscation for Android. Master’s thesis, University of Luxembourg, 2013.
[29] P. Larsen, A. Homescu, S. Brunthaler, and M. Franz. SoK: Automated software diversity. In Proceedings of the 2014 IEEE Symposium on Security and Privacy (SP’14), 2014.
[30] C. Linn and S. Debray. Obfuscation of executable code to improve resistance to static disassembly. In Proceedings of the 10th ACM Conference on Computer and Communications Security (CCS’03), 2003.
[31] L. Liu, J. Ming, Z. Wang, D. Gao, and C. Jia. Denial-of-service attacks on host-based generic unpackers. In Proceedings of the 11th International Conference on Information and Communications Security (ICICS’09), 2009.
[32] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney, S. Wallace, V. J. Reddi, and K. Hazelwood. Pin: building customized program analysis tools with dynamic instrumentation. In Proceedings of the 2005 ACM SIGPLAN conference on Programming language design and implementation (PLDI’05), 2005.
[33] M. Madou. Application Security through Program Obfuscation. PhD thesis, Ghent University, 2007.
[34] M. Madou, L. Van Put, and K. De Bosschere. LOCO: An interactive code (de)obfuscation tool. In Proceedings of the 2006 ACM SIGPLAN Symposium on Partial Evaluation and Semantics-based Program Manipulation (PEPM’06), 2006.
[35] A. Majumdar and C. Thomborson. Securing mobile agents control flow using opaque predicates. In Proceedings of the 9th International Conference on Knowledge-Based Intelligent Information and Engineering Systems (KES’05), 2005.
[36] J. Ming, M. Pan, and D. Gao. iBinHunt: Binary hunting with inter-procedural control flow. In Proceedings of the 15th Annual International Conference on Information Security and Cryptology (ICISC’12), 2012.
[37] A. Moser, C. Kruegel, and E. Kirda. Limits of static analysis for malware detection. In Proceedings of the 23th Annual Computer Security Applications Conference (ACSAC’07), December 2007.
[38] L. D. Moura and N. Bjørner. Z3: an efficient SMT solver. In Proceedings of the 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems, 2008.
[39] G. Myles and C. Collberg. Software watermarking via opaque predicates: Implementation, analysis, and attacks. Electronic Commerce Research, 6(2):155 – 171, April 2006.
[40] M. N. Ngo and H. B. K. Tan. Detecting large number of infeasible paths through recognizing their patterns. In Proceedings of the 6th Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering (ESEC-FSE’07), 2007.
[41] J. Palsberg, S. Krishnaswamy, M. Kwon, D. Ma, Q. Shao, and Y. Zhang. Experience with software watermarking. In Proceedings of the 16th Annual Computer Security Applications Conference (ACSAC’00), 2000.
[42] M. D. Preda, M. Madou, K. D. Bosschere, and R. Giacobazzi. Opaque predicate detection by abstract interpretation. In Proceedings of 11th International Conference on Algebriac Methodology and Software Technology (AMAST’06), 2006.
[43] N. A. Quyn. OptiCode: Machine code deobfuscation for malware analysis. In Proceedings of the 2013 SyScan, 2013.
[44] P. Szor. The Art of Computer Virus Research and Defense. Addison-Wesley Professional, February 2005.
[45] S. K. Udupa, S. K. Debray, and M. Madou. Deobfuscation: Reverse engineering obfuscated code. In Proceedings of the 12th Working Conference on Reverse Engineering (WCRE’05), 2005.
[46] C. Wang, J. Hill, J. C. Knight, and J. W. Davidson. Protection of software-based survivability mechanisms. In Proceedings of the 2001 International Conference on Dependable Systems and Networks (DSN’01), 2001.
[47] S. Wang, P. Wang, and D. Wu. Reassembleable disassembling. In Proceedings of the 24th USENIX Security Symposium (USENIX Security’15), 2015.
[48] Z. Wang, J. Ming, C. Jia, and D. Gao. Linear obfuscation to combat symbolic execution. In Proceedings of the 2011 European Symposium on Research in Computer Security (ESORICS’11), 2011.
[49] F. Zhang, D. Wu, P. Liu, and S. Zhu. Program logic based software plagiarism detection. In Proceedings of the 25th IEEE International Symposium on Software Reliability Engineering (ISSRE’14), 2014.