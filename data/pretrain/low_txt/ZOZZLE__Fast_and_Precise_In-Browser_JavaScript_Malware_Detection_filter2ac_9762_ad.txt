### Classification Time and Performance

As the number of features increases, the average classification time grows significantly, albeit linearly. Specifically, the time increases from approximately 1.6 ms for 30 features to over 7 ms for about 1,300 features. These numbers are based on our unoptimized implementation, but we believe that ZOZZLE's static detector has substantial potential for fast, real-time malware identification.

### False Negative Rate

The false negative rate for ZOZZLE, as listed in Figure 14, is derived from our cross-validation experiment shown in Figure 12.

### Classification Time as a Function of JavaScript File Size

Figure 15 illustrates the classification time as a function of JavaScript file size. The x-axis represents the file size in bytes, while the y-axis shows the classification time in milliseconds.

### Adaptation and Improvement

ZOZZLE's effectiveness can be enhanced in two ways: improving its ability to reason about malware and adapting the feature set used for detection as malware evolves. To enhance ZOZZLE's detection capability, it needs to incorporate more semantic information about the JavaScript it analyzes. For instance, as described in Section 3, feature flow could help ZOZZLE identify attempts to obfuscate the use of APIs necessary for malware to succeed. Adapting ZOZZLE’s feature set requires continuous retraining based on collecting malware samples detected by other detectors such as NOZZLE. With such adaptation, ZOZZLE would dramatically reduce the effectiveness of copy-and-pasted attacks, which make up the majority of JavaScript malware today. In combination with complementary detection techniques like NOZZLE, an updated feature set can be generated frequently without human intervention.

### Defense-in-Depth Strategy

Similar to anti-virus software, ZOZZLE is one of several measures that can be used as part of a defense-in-depth strategy. Our experience suggests that attackers are often slow to adapt to the changing landscape. Despite the wide availability of obfuscation tools, many sites in our NOZZLE detection experiments do not use any form of obfuscation. We also observe little diversity in the collected exploits; for example, the top five malicious scripts account for 75% of the detected malware.

### Deployment Strategy

The most attractive deployment strategy for ZOZZLE is in-browser deployment. ZOZZLE is designed to require only occasional offline re-training, allowing classifier updates to be shipped to the browser every few days or weeks. Figure 17 outlines a proposed workflow for ZOZZLE in-browser deployment. The in-browser detector code does not need to change; only the list of features and weights needs to be updated, similar to updating signatures in an anti-virus product. Our detector is designed to integrate tightly into the JavaScript parser, making the malware "scoring" part of the overall parsing process. This integration will likely further reduce the incremental overhead of ZOZZLE processing.

### Limitations and Evasion

All classifier-based malware detection tools, including ZOZZLE, will fail to detect some attacks, such as those that do not contain any of the features present in the training examples. Attackers with access to ZOZZLE can devise variants of malware that evade detection. For example, they might rename variables, encode strings, or substitute different APIs. Evasion is made somewhat more difficult because any exploit using a known CVE must eventually make the necessary JavaScript runtime calls to trigger the exploit. If ZOZZLE can statically detect such calls, it will identify the attempted exploit. To avoid detection, attackers might change the context in which these calls appear by creating local variables that reference the desired runtime function, a technique already employed by some collected exploits.

### Future Adaptability

For ZOZZLE to remain effective, it must adapt to evasion attempts. This involves continuous retraining and updating the feature set based on new malware samples.

### Comparison with Related Work

Several recent papers focus on static detection techniques for JavaScript malware. ZOZZLE is unique in integrating malware classification with JavaScript execution in a browser. A quantitative comparison with closely related techniques (Figure 18) shows that ZOZZLE is optimized for an extremely low false positive rate—about one in a quarter million. ZOZZLE is generally faster than other tools because the only runtime activity it performs is capturing JavaScript URL in blacklist scans.

### Conclusion

This paper presents ZOZZLE, a highly precise, mostly static detector for JavaScript malware. ZOZZLE is suitable for deployment in a commercial browser, complementing more costly runtime detectors like NOZZLE. Designing an effective in-browser malware detector requires overcoming technical challenges, including achieving high performance, generating precise results, and overcoming obfuscation. ZOZZLE's novelty lies in its ability to hook into the JavaScript engine to get the final, expanded version of JavaScript code, addressing deobfuscation. Compared to other classifier-based tools, ZOZZLE uses contextual information available in the program abstract syntax tree (AST) to perform fast, scalable, and precise malware detection.

### Evaluation

We evaluated ZOZZLE in terms of performance and malware detection rates using over 1.2 million pre-categorized code samples. ZOZZLE has an extremely low false positive rate of 0.0003%, or less than one in a quarter million. Despite this high accuracy, the ZOZZLE classifier is fast, with a throughput of over one megabyte of JavaScript code per second.

### Acknowledgments

We thank Sarmad Fayyaz, David Felstead, Michael Gamon, Darren Gehring, Rick Gutierrez, Engin Kirda, Jay Stokes, and Ramarathnam Venkatesan for their contributions. Special thanks to Rick Bhardwaj for working closely with malware samples to help us understand their properties in the wild.

### References

[1] M. Abadi, M. Budiu, Úlfar Erlingsson, and J. Ligatti. Control-flow integrity. In Proceedings of the Conference on Computer and Communications Security, 2005.

[2] P. Akritidis, E. P. Markatos, M. Polychronakis, and K. G. Anagnostakis. STRIDE: Polymorphic sled detection through instruction sequence analysis. In Proceedings of Security and Privacy in the Age of Ubiquitous Computing, 2005.

[3] A. Buescher, M. Meier, and R. Benzmueller. Monkey-Wrench - boesartige webseiten in die zange genommen. In Deutscher IT-Sicherheitskongress, Bonn, 2009.

[4] D. Canali, M. Cova, G. Vigna, and C. Krügel. Prophiler: A fast filter for the large-scale detection of malicious web pages. In Proceedings of the International World Wide Web Conference, Mar. 2011.

[5] M. Castro, M. Costa, and T. Harris. Securing software by enforcing data-flow integrity. In Proceedings of the Symposium on Operating Systems Design and Implementation, 2006.

[6] M. Cova, C. Krügel, and G. Vigna. Detection and analysis of drive-by-download attacks and malicious JavaScript code. In Proceedings of the International World Wide Web Conference, April 2010.

[7] C. Cowan, C. Pu, D. Maier, H. Hinton, J. Walpole, P. Bakke, S. Beattie, A. Grier, P. Wagle, and Q. Zhang. StackGuard: Automatic adaptive detection and prevention of buffer-overflow attacks. In Proceedings of the USENIX Security Symposium, January 1998.

[8] Y. Ding, T. Wei, T. Wang, Z. Liang, and W. Zou. Heap Taichi: Exploiting memory allocation granularity in heap-spraying attacks. In Proceedings of Annual Computer Security Applications Conference, 2010.

[9] M. Egele, P. Wurzinger, C. Krügel, and E. Kirda. Defending browsers against drive-by downloads: Mitigating heap-spraying code injection attacks. In Proceedings of the Conference on Detection of Intrusions and Malware, and Vulnerability Assessment, 2009.

[10] B. Feinstein and D. Peck. Caffeine Monkey: Automated collection, detection, and analysis of malicious JavaScript. In Proceedings of Black Hat USA, 2007.

[11] F. Howard. Malware with your mocha: Obfuscation and anti-emulation tricks in malicious JavaScript. http://www.sophos.com/security/technical-papers/malware_with_your_mocha.pdf, Sept. 2010.

[12] M. Howard. Address space layout randomization in Windows Vista. https://blogs.msdn.microsoft.com/michael_howard/archive/2006/05/