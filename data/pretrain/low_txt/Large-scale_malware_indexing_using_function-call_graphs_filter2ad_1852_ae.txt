### 6.5.2 Query Response Time of SMIT

To evaluate the query response time of SMIT, we conducted a series of K-NN queries against the entire test database, with \( N \) set to 2 and \( K \) set to 5. We randomly selected over 500 malware files and used them as queries. The response times for these queries and their cumulative distribution function are illustrated in Figure 7.

- **Figure 7: Query Response Time**
  - **X-axis (left figure):** Number of graph-distance computations required for each query.
  - **Y-axis (left figure):** Response time in seconds for each query.
  - **Right figure:** Cumulative distribution function of the response times.

From the right figure, it is evident that for over 95% of all queries, the response time is less than 100 seconds. However, several queries, particularly those involving very large malware files, experienced significantly longer delays, which skewed the overall average response time. Specifically, each 5-NN query required, on average, 112 graph-distance computations (median: 78, maximum: 918). The query response time ranged from 0.015 seconds to 872 seconds, with an average of 21 seconds and a median of 0.5 seconds. This result demonstrates that SMIT's performance is adequate for day-to-day use, even with relatively large malware databases.

### 7. Limitations and Improvements

We now discuss several limitations of the current SMIT prototype that may affect its classification effectiveness, along with potential improvements to address these issues.

#### 7.1 Evasion by Packing/Protecting Malware

One method for malware authors to evade SMIT's classification is to apply packers or protectors to their malware files, preventing SMIT from extracting useful features. If SMIT cannot successfully unpack packed malware files, its classification accuracy will degrade significantly. To counter this, the current SMIT prototype employs several packer detection tools (e.g., PEiD, TrID) and unpacking tools (e.g., SymPack). However, these tools are not foolproof. For example, PEiD can be misled by simple modifications to a PE file's entry point, and most existing unpacking tools fail to handle sophisticated packers like Armadillo [1] and VMProtect [33].

To improve SMIT's unpacking capabilities, we plan to incorporate generic unpackers such as OmniUnpack [22] and Justin [12], which execute malware samples, detect the end of unpacking, and then dump the process image at that instant. While this approach introduces additional performance overhead, it is necessary to enhance SMIT's ability to handle packed malware.

#### 7.2 Susceptibility to Obfuscation Techniques

SMIT analyzes malware samples at the level of individual instructions and function calls, making it potentially vulnerable to advanced obfuscation techniques. Attackers can circumvent SMIT's function matching by employing various obfuscation methods, such as instruction reordering, equivalent instruction substitution, import table modification, and function-call graph alterations (e.g., inserting useless functions, breaking functions into smaller ones, inlining certain functions).

Although SMIT cannot completely handle all types of obfuscation, it uses the edit distance between mnemonic sequences to evaluate inter-function similarity, which makes it relatively resilient to simple code obfuscation and relocation. To combat more sophisticated obfuscation, SMIT could preprocess malware files with advanced deobfuscation techniques [26]. Additionally, since SMIT relies on structural similarity to match function-call graphs, changes to a few nodes in the graphs are unlikely to significantly influence the matching results.

#### 7.3 Function Identification Issues

SMIT extracts function-call graphs using IDA Pro, which may occasionally fail to identify all the functions in a malware binary. IDA Pro identifies function-start addresses by traversing direct function calls or recognizing function prologues. Consequently, if functions are indirectly referenced or have non-standard prologues, IDA Pro may miss their starting points. A more thorough approach [13] that uses a new function model based on a multi-entry control flow graph could mitigate this problem.

#### 7.4 False Positives in Dominant Family Metric

The dominant family metric used in SMIT may lead to false positives. SMIT assumes that the query malware sample belongs to the same family as the majority of its nearest neighbors in the database. However, this assumption is not always valid, and a false positive may occur if the distance between an input malware sample and its dominant family neighbors is too large. One way to address this is to apply a distance threshold in the classification process, classifying an input sample into a malware family only if it is sufficiently close to the returned nearest neighbors. The optimal threshold could be chosen based on the average inter-member distance within a malware family and the inter-family distance between the centroids of adjacent families.

### 8. Conclusion

In recent years, the number of malware samples has increased exponentially, making the automation of malware processing workflows crucial for commercial anti-virus companies like Symantec. A critical step in this workflow is determining whether an incoming sample is malicious. The common approach of using multiple commercial Anti-Virus scanners is useful but not sufficient, as a significant percentage of new samples remain unknown to existing scanners.

This paper describes the design, implementation, and evaluation of SMIT, a malware database management system that determines the maliciousness of a new binary sample by locating its nearest neighbors in the malware database. SMIT converts each malware program into its function-call graph representation and performs nearest neighbor search based on this graph. To efficiently capture the similarity among malware variants, SMIT supports an approximate graph-edit distance metric. To support accurate and scalable nearest neighbor search, SMIT features a multi-resolution indexing scheme combining a B+ tree based on high-level summary features and a vantage-point tree based on the graph-distance metric.

With these techniques, SMIT can detect malware samples at a speed and accuracy level that keeps up with the current malware submission rate. The main contributions of this work include:
1. An efficient graph-distance computation algorithm that closely approximates the ideal graph-edit distance metric.
2. A multi-resolution indexing scheme that supports efficient pruning through a combination of exact indexing based on summary features and nearest-neighbor indexing based on graph-edit distance.
3. A fully working SMIT prototype and a comprehensive performance study demonstrating its efficacy and scalability with a 100,000-malware database.

### 9. References

[1] Armadillo. http://www.siliconrealms.com/armadillo.htm, 2008.
[2] Peid 0.95. http://www.peid.info/, 2008.
[3] Trid v2.02. http://mark0.net/soft-trid-e.html, 2008.
[4] M. Bailey, J. Oberheide, J. Andersen, Z. M. Mao, F. Jahanian, and J. Nazario. Automated classification and analysis of internet malware. In RAID, pages 178–197, 2007.
[5] U. Bayer, P. Milani Comparetti, C. Hlauscheck, C. Kruegel, and E. Kirda. Scalable, Behavior-Based Malware Clustering. In 16th Symposium on Network and Distributed System Security, 2009.
[6] T. Bozkaya and M. Ozsoyoglu. Distance-based indexing for high-dimensional metric spaces. In In Proc. ACM SIGMOD International Conference on Management of Data, 1997.
[7] I. Briones and A. Gomez. Graphs, entropy and grid computing: Automatic comparison of malware. In Proceedings of the 2004 Virus Bulletin Conference, 2004.
[8] E. Carrera and G. Erdelyi. Digital genome mapping ˛ał advanced binary malware analysis. In Proceedings of the 2004 Virus Bulletin Conference, 2004.
[9] T.-c. Chiueh. Content-based image indexing. In VLDB ’94: Proceedings of the 20th International Conference on Very Large Data Bases, pages 582–593, 1994.
[10] S. Das, A. Mistry, D. Negoescu, G. Reed, and S. K. Singh. A graph matching problem. Techical report, IPAM Research in Industrial Projects for Students (RIPS), 2008.
[11] M. R. Garey and D. S. Johnson. Computers and Intractability : A Guide to the Theory of NP-Completeness. W. H. Freeman, 1979.
[12] F. Guo, P. Ferrie, and T.-C. Chiueh. A study of the packer problem and its solutions. In RAID ’08, pages 98–115, 2008.
[13] L. C. Harris and B. P. Miller. Practical analysis of stripped binary code. SIGARCH Comput. Archit. News, 33(5):63–68, 2005.
[14] H. He and A. K. Singh. Closure-tree: An index structure for graph queries. In ICDE ’06: Proceedings of the 22nd International Conference on Data Engineering, page 38, 2006.
[15] Hex-rays. The IDA Pro Disassembler and Debugger. http://www.hexrays.com/idapro/, 2008.
[16] X. Hu, T. cker Chiueh, and K. G. Shin. Large-scale malware indexing using function-call graphs (extended). Technical Report, Department of Computer Sicence, University of Michigan, 2009.
[17] Ilfak Guilfanov. Fast Library Identiﬁcation and Recognition Technology. http://www.hex-rays.com/idapro/ﬂirt.htm, 1997.
[18] D. Justice. A binary linear programming formulation of the graph edit distance. IEEE Trans. Pattern Anal. Mach. Intell., 28(8):1200–1214, 2006. Fellow-Hero„ Alfred.
[19] J. Z. Kolter and M. A. Maloof. Learning to detect and classify malicious executables in the wild. J. Mach. Learn. Res., 7:2721–2744, 2006.
[20] C. Kruegel, E. Kirda, D. Mutz, W. Robertson, and G. Vigna. Polymorphic worm detection using structural information of executables. In In RAID, pages 207–226. Springer-Verlag, 2005.
[21] H. W. Kuhn. The hungarian method for the assignment problem. Naval Research Logistics Quarterly, 1955.
[22] L. Martignoni, M. Christodorescu, and S. Jha. Omniunpack: Fast, generic, and safe unpacking of malware. In In Proceedings of the Annual Computer Security Applications Conference (ACSAC, 2007.
[23] R. Myers, R. C. Wilson, and E. R. Hancock. Bayesian graph edit distance. IEEE Trans. Pattern Anal. Mach. Intell., 22(6), 2000.
[24] M. Neuhaus and H. Bunke. An error-tolerant approximate matching algorithm for attributed planar graphs and its application to fingerprint classification. In SSPR/SPR, pages 180–189, 2004.
[25] M. Pietrek. An In-Depth Look into the Win32 PE File Format. http://msdn.microsoft.com/en-us/magazine/cc301805.aspx, 2002.
[26] J. Raber and E. Laspe. Deobfuscator: An automated approach to the identification and removal of code obfuscation. Reverse Engineering, Working Conference on, 0:275–276, 2007.
[27] K. Rieck, T. Holz, C. Willems, P. Düssel, and P. Laskov. Learning and classification of malware behavior. In DIMVA ’08, pages 108–125, 2008.
[28] K. Riesen, M. Neuhaus, and H. Bunke. Bipartite graph matching for computing the edit distance of graphs. In Graph-Based Representations in Pattern Recognition, volume 4538, 2007.
[29] D. Shasha, Jason, and R. Giugno. Algorithmics and applications of tree and graph searching. In Symposium on Principles of Database Systems, pages 39–52, 2002.
[30] Symantec Corp. Symantec Global Internet Security Threat Report. Volume XII. http://www.symantec.com/, April 2008.
[31] Y. Tian and J. M. Patel. Tale: A tool for approximate large graph matching. In ICDE, pages 963–972, 2008.
[32] T.Lee and J.J.Mody. Behavioral classification. http://www.microsoft.com/downloads/details.aspx?FamilyID=7b5d8cc8-b336-4091-abb5-2cc500a6c41a&displaylang=en, 2006.
[33] VMProtect. Vmprotect. http://www.vmprotect.ru/, 2008.
[34] X. Yan, P. S. Yu, and J. Han. Substructure similarity search in graph databases. In SIGMOD ’05: Proceedings of the 2005 ACM SIGMOD international conference on Management of data, 2005.
[35] P. N. Yianilos. Data structures and algorithms for nearest neighbor search in general metric spaces. In SODA: ACM-SIAM Symposium on Discrete Algorithms, 1993.
[36] P. Zezula, G. Amato, V. Dohnal, and M. Batko. Similarity Search: The Metric Space Approach. Springer, 2006.
[37] P. Zezula, P. Ciaccia, and F. Rabitti. M-tree: A dynamic index for similarity queries in multimedia databases. Technical Report 7, HERMES ESPRIT LTR Project, 1996.
[38] K. Zhang and D. Shasha. Simple fast algorithms for the editing distance between trees and related problems. SIAM J. Comput., 18(6):1245–1262, 1989.
[39] P. Zhao, J. X. Yu, and P. S. Yu. Graph indexing: tree + delta ≤ graph. In VLDB ’07: Proceedings of the 33rd international conference on Very large data bases, pages 938–949, 2007.