### References

1. **Cachin, C., Kursawe, K., Lysyanskaya, A., & Strobl, R. (2002).** Asynchronous verifiable secret sharing and proactive cryptosystems. In *Proceedings of the 9th ACM Conference on Computer and Communications Security (CCS '02)*, pages 88–97, New York, NY, USA. ACM.

2. **Chor, B., Goldwasser, S., Micali, S., & Awerbuch, B. (1985).** Verifiable secret sharing and achieving simultaneity in the presence of faults. In *26th Annual Symposium on Foundations of Computer Science (sfcs 1985)*, pages 383–395, October 1985.

3. **Cortier, V., Dragan, C. C., Dupressoir, F., & Warinschi, B. (2018).** Machine-checked proofs for electronic voting: privacy and verifiability for Belenios. In *2018 IEEE 31st Computer Security Foundations Symposium (CSF)*, pages 298–312. IEEE.

4. **Dahl, M., & Damgård, I. (2014).** Universally composable symbolic analysis for two-party protocols based on homomorphic encryption. In *EUROCRYPT*.

5. **Damgård, I., Damgård, K., Nielsen, K., Nordholt, P. S., & Toft, T. (2016).** Confidential benchmarking based on multiparty computation. In *Proceedings of the 20th International Conference on Financial Cryptography and Data Security*, pages 169–187. Springer.

6. **Demmler, D., Schneider, T., & Zohner, M. (2015).** ABY - A framework for efficient mixed-protocol secure two-party computation. In *22nd Annual Network and Distributed System Security Symposium (NDSS 2015)*, San Diego, California, USA, February 8-11, 2015.

7. **Dolev, S., Eldefrawy, K., Lampkins, J., Ostrovsky, R., & Yung, M. (2016).** Proactive secret sharing with a dishonest majority. In *Security and Cryptography for Networks*, edited by V. Zikas and R. De Prisco, pages 529–548, Cham. Springer International Publishing.

8. **Ejgenberg, Y., Farbstein, M., Levy, M., & Lindell, Y. (2012).** SCAPI: The secure computation application programming interface. *Cryptology ePrint Archive, Report 2012/629*. [Link](https://eprint.iacr.org/2012/629).

9. **Eldefrawy, K., Ostrovsky, R., Park, S., & Yung, M. (2018).** Proactive secure multiparty computation with a dishonest majority. In *Proceedings of the Eleventh Conference on Security and Cryptography for Networks*, pages 200–215.

10. **Eldefrawy, K., & Pereira, V. (2019).** A high-assurance evaluator for machine-checked secure multiparty computation. *Cryptology ePrint Archive, Report 2019/922*. [Link](https://eprint.iacr.org/2019/922).

11. **Feldman, P. (1987).** A practical scheme for non-interactive verifiable secret sharing. In *28th Annual Symposium on Foundations of Computer Science (sfcs 1987)*, pages 427–438, October 1987.

12. **Filliâtre, J.-C. (2013).** One logic to use them all. In *24th International Conference on Automated Deduction (CADE-24)*, volume 7898 of *Lecture Notes in Artificial Intelligence*, pages 1–20, Lake Placid, USA. Springer.

13. **Filliâtre, J.-C., & Paskevich, A. (2013).** Why3 — where programs meet provers. In *Proceedings of the 22nd European Symposium on Programming*, volume 7792 of *Lecture Notes in Computer Science*, pages 125–128. Springer.

14. **Fitzi, M., Garay, J., Gollakota, S., Rangan, C. P., & Srinathan, K. (2006).** Round-optimal and efficient verifiable secret sharing. In *Theory of Cryptography*, edited by S. Halevi and T. Rabin, pages 329–342, Berlin, Heidelberg. Springer Berlin Heidelberg.

15. **Fournet, C., Kohlweiss, M., & Strub, P.-Y. (2011).** Modular code-based cryptographic verification. In *ACM CCS*.

16. **Franklin, M., & Yung, M. (1992).** Communication complexity of secure computation (extended abstract). In *Proceedings of the Twenty-fourth Annual ACM Symposium on Theory of Computing (STOC '92)*, pages 699–710, New York, NY, USA. ACM.

17. **Gennaro, R., Ishai, Y., Kushilevitz, E., & Rabin, T. (2001).** The round complexity of verifiable secret sharing and secure multicast. In *Proceedings of the Thirty-third Annual ACM Symposium on Theory of Computing (STOC '01)*, pages 580–589, New York, NY, USA. ACM.

18. **Gennaro, R., Rabin, M. O., & Rabin, T. (1998).** Simplified VSS and fast-track multiparty computations with applications to threshold cryptography. In *Proceedings of the Seventeenth Annual ACM Symposium on Principles of Distributed Computing (PODC '98)*, pages 101–111, New York, NY, USA. ACM.

19. **Goldreich, O., Micali, S., & Wigderson, A. (1987).** How to play any mental game or a completeness theorem for protocols with honest majority. In *STOC*, pages 218–229.

20. **Haagh, H., Karbyshev, A., Oechsner, S., Spitters, B., & Strub, P.-Y. (2018).** Computer-aided proofs for multiparty computation with active security. In *31st IEEE Computer Security Foundations Symposium (CSF 2018)*, Oxford, United Kingdom, July 9-12, 2018, pages 119–131. IEEE Computer Society.

21. **Henecka, W., Kögl, S., Sadeghi, A.-R., Schneider, T., & Wehrenberg, I. (2010).** TASTY: Tool for automating secure two-party computations. In *Proceedings of the 17th ACM Conference on Computer and Communications Security (CCS '10)*, pages 451–462, New York, NY, USA. ACM.

22. **Herzberg, A., Jarecki, S., Krawczyk, H., & Yung, M. (1995).** Proactive secret sharing or: How to cope with perpetual leakage. In *Advances in Cryptology — CRYPTO '95*, edited by D. Coppersmith, pages 339–352, Berlin, Heidelberg. Springer Berlin Heidelberg.

23. **Hirt, M., Lucas, C., & Maurer, U. (2013).** A dynamic tradeoff between active and passive corruptions in secure multi-party computation. In *CRYPTO (2)*, volume 8043 of *LNCS*, pages 203–219. Springer.

24. **Katz, J., Koo, C.-Y., & Kumaresan, R. (2008).** Improving the round complexity of VSS in point-to-point networks. In *Automata, Languages and Programming*, edited by L. Aceto, I. Damgård, L. A. Goldberg, M. M. Halldórsson, A. Ingólfsdóttir, and I. Walukiewicz, pages 499–510, Berlin, Heidelberg. Springer Berlin Heidelberg.

25. **Krawczyk, H. (2001).** The order of encryption and authentication for protecting communications (or: How secure is SSL?). In *Advances in Cryptology — CRYPTO 2001*, edited by J. Kilian, pages 310–331, Berlin, Heidelberg. Springer Berlin Heidelberg.

26. **Kumaresan, R., Patra, A., & Rangan, C. P. (2010).** The round complexity of verifiable secret sharing: The statistical case. In *Advances in Cryptology - ASIACRYPT 2010*, edited by M. Abe, pages 431–447, Berlin, Heidelberg. Springer Berlin Heidelberg.

27. **Li, B., & Micciancio, D. (2018).** Symbolic security of garbled circuits. Pages 147–161.

28. **Malkhi, D., Nisan, N., Pinkas, B., & Sella, Y. (2004).** Fairplay - secure two-party computation system. In *Proceedings of the 13th USENIX Security Symposium*, August 9-13, 2004, San Diego, CA, USA, pages 287–302. USENIX.

29. **Maurer, U. M. (2006).** Secure multi-party computation made simple. *Discrete Applied Mathematics*, 154(2):370–381.

30. **Ostrovsky, R., & Yung, M. (1991).** How to withstand mobile virus attacks (extended abstract). In *PODC*, pages 51–59. ACM.

31. **Pereira, M. J. P. (2018).** Tools and Techniques for the Verification of Modular Stateful Code. PhD thesis, Paris Saclay.

32. **Patra, A., Choudhary, A., Rabin, T., & Rangan, C. P. (2009).** The round complexity of verifiable secret sharing revisited. In *Advances in Cryptology - CRYPTO 2009*, edited by S. Halevi, pages 487–504, Berlin, Heidelberg. Springer Berlin Heidelberg.

33. **Pedersen, T. P. (1991).** A threshold cryptosystem without a trusted party. In *Proceedings of the 10th Annual International Conference on Theory and Application of Cryptographic Techniques (EUROCRYPT'91)*, pages 522–526, Berlin, Heidelberg. Springer-Verlag.

34. **Pedersen, T. P. (1992).** Non-interactive and information-theoretic secure verifiable secret sharing. In *Advances in Cryptology — CRYPTO '91*, edited by J. Feigenbaum, pages 129–140, Berlin, Heidelberg. Springer Berlin Heidelberg.

35. **Rastogi, A., Swamy, N., & Hicks, M. (2017).** Wys*: A verified language extension for secure multi-party computations. *CoRR, abs/1711.06467*.

36. **Schultz, D. (2007).** Mobile Proactive Secret Sharing. PhD thesis, Massachusetts Institute of Technology.

37. **Shamir, A. (1979).** How to share a secret. *Communications of the ACM*, 22(11):612–613.

38. **Stoughton, A., & Varia, M. (2017).** Mechanizing the proof of adaptive, information-theoretic security of cryptographic protocols in the random oracle model. In *30th IEEE Computer Security Foundations Symposium (CSF 2017)*, Santa Barbara, CA, USA, August 21-25, 2017, pages 83–99. IEEE Computer Society.

39. **Wang, X., Malozemoff, A. J., & Katz, J. (2017).** Faster secure two-party computation in the single-execution setting. In *Advances in Cryptology - EUROCRYPT 2017 - 36th Annual International Conference on the Theory and Applications of Cryptographic Techniques*, Paris, France, April 30 - May 4, 2017, Proceedings, Part III, volume 10212 of *Lecture Notes in Computer Science*, pages 399–424.

40. **Wang, X., Ranellucci, S., & Katz, J. (2017).** Global-scale secure multiparty computation. In *Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security (CCS 2017)*, Dallas, TX, USA, October 30 - November 03, 2017, pages 39–56. ACM.

41. **Wong, T. M., Wang, C., & Wing, J. M. (2002).** Verifiable secret redistribution for archive systems. In *IEEE Security in Storage Workshop*, pages 94–106. IEEE Computer Society.

42. **Yao, A. C.-C. (1982).** Protocols for secure computations (extended abstract). In *FOCS*, pages 160–164. IEEE Computer Society.

43. **Zhou, L., Schneider, F. B., & van Renesse, R. (2005).** APSS: Proactive secret sharing in asynchronous systems. *ACM Transactions on Information and System Security (TISSEC)*, 8(3):259–286.

### Appendix A: Reasoning About Polynomials

To formalize a verified library for reasoning about polynomials, we developed a general polynomial library that can be reused to define multiple instances of polynomials. This was a critical step in our proofs, as it allowed us to avoid using a non-verified polynomial library, which would have increased our trusted code base.

#### Abstract Polynomial Definition

We started by defining an abstract definition for polynomials, providing an interface for concrete realizations. This interface defines the coefficient type, polynomial evaluation, zero and one polynomials, polynomial degree, addition, multiplication, unary minus, and interpolation. We fixed the type of the polynomials to be a list of monomials, which induces a possible equality class to be the equality between lists. However, this equality class is too strong and would force the definition of complicated operators for addition and multiplication, leading to a significant performance penalty. Therefore, we fixed the equality class to be the equality of the evaluation of two polynomials at the same points, and used this equality class to define the subsequent axioms and lemmas around polynomial operations.

#### Finite Field Polynomials

We then instantiated the type of the coefficients to be the same type of elements in a finite field and defined all polynomial operations in the expected, classical way. Properties such as commutativity and associativity of polynomial addition and multiplication were easily proven by relying on the same properties verified in finite field operations. We also provided a formalization for polynomial interpolation based on the Lagrange interpolation, which makes use of a linear combination of Lagrange basis polynomials. Polynomial interpolation is important in our work, as it allows secret reconstruction inside the reconstruct protocol and also helps in recovering parties to successfully recover shares.

#### Polynomial Type Definition

We used EasyCrypt’s record system to define polynomials as lists of monomials, where each monomial is a record with two fields: a coefficient (an element of a finite field) and an exponent (an integer).

```plaintext
type coefficient = t.
type exponent = int.
type monomial = {
    coef : coefficient;
    expo : exponent
}.
type polynomial = monomial list.
```

#### Polynomial Evaluation and Equality

We defined evaluation functions for both monomials and polynomials. Polynomial evaluation defines our equality class. Additionally, we included a polynomial membership test: a point is on the polynomial if the evaluation of the polynomial at the abscissa is equal to the value of the ordinate.

```plaintext
op meval (x:coefficient) (m : monomial) = m.‘coef * (x ^ m.‘expo).
op eval (x:coefficient) p =
    with p = [] => F.zero
    with p = m :: p’ => meval x m + (eval x p’).
op (==) p1 p2 = forall x, eval x p1 = eval x p2.
op mem (pt : (coefficient * coefficient)) p = eval (fst pt) p = (snd pt).
```

#### Zero and One Polynomials

We defined zero and one polynomials, which are essential for defining algebraic properties around polynomial operations.

```plaintext
op mzero = {| coef = F.zero; expo = 1 |}.
op zero : polynomial = [].
op mone = {| coef = F.one; expo = 0 |}.
op one = [mone].
```

#### Polynomial Arithmetic

Every arithmetic operation is defined in a mechanical way:
1. Define the operation in terms of monomials.
2. Define it in terms of a monomial and a polynomial.
3. Define the polynomial operation based on the previous two.

This approach simplifies proofs, as properties related to monomial operations are easier to prove than those applied to polynomials. Since polynomial operations are defined based on the monomials' ones, it is easy to propagate results obtained at the monomial level to polynomials.

```plaintext
op madd m1 m2 = {| coef = m1.‘coef + m2.‘coef; expo = m1.‘expo |}.
op mpadd (m : monomial) p =
    with p = [] => [m]
    with p = m’ :: p’ =>
        if m.‘expo = m’.‘expo then madd m m’ :: p’
        else
            if m’.‘expo < m.‘expo then m :: p
            else m’ :: mpadd m p’.
op add p1 p2 =
    with p1 = [], p2 = [] => []
    with p1 = m1 :: p1’, p2 = [] => p1
    with p1 = [], p2 = m2 :: p2’ => p2
    with p1 = m1 :: p1’, p2 = m2 :: p2’ =>
        if m1.‘expo = m2.‘expo then madd m1 m2 :: add p1’ p2’
        else
            if m1.‘expo < m2.‘expo then m1 :: add p1’ p2
            else m2 :: add p1 p2’.

op mmul m1 m2 = {| coef = m1.‘coef * m2.‘coef; expo = m1.‘expo + m2.‘expo |}.
op mpmul (m : monomial) p =
    with p = [] => []
    with p = m’ :: p’ => mpadd (mmul m m’) (mpmul m p’).
op mul p1 p2 =
    with p1 = [] => []
    with p1 = m :: p1’ => add (mpmul m p2) (mul p1’ p2).

op mumin m = {| coef = - m.‘coef; expo = m.‘expo |}.
op umin p =
    with p = [] => []
    with p = m :: p’ => mumin m :: umin p’.
```

#### Lagrange Interpolation

Lagrange interpolation allows the reconstruction of a \( d-1 \) degree polynomial based on \( d \) points. It works by computing bases based on the abscissa values, which are then multiplied by the ordinate values. We provide two different interpolation functions:
- `interpolate`: Takes a set of points and a value \( x \), and returns the evaluation of the interpolated polynomial at \( x \).
- `interpolate_poly`: Takes a set of points and returns the interpolated polynomial.

```plaintext
op interpolate (pts : (coefficient * coefficient) list) (x : coefficient) : coefficient.
op interpolate_poly (pts : (coefficient * coefficient) list) : polynomial.
```

### Appendix B: Secret Sharing Security Definitions

Figure 30 defines passive security for a secret sharing scheme. The theory `HBCSecretSharingSchemeSecurity` is parameterized by a secret sharing scheme, making it modular enough to be reused when representing security for multiple secret sharing schemes. It starts by defining an abstract random generator type that will be used to feed the explicit randomness needed to execute probabilistic algorithms such as share. This random generator is abstract because the secret sharing scheme is also abstract and thus there is no information about the type of randomness involved. The instantiation step will make it concrete.

Next, there is the definition of oracles. For the particular case of semi-honest security, we are only interested in providing the adversary with an oracle to corrupt parties. An adversary attacking the scheme (parameterized by the oracles) should, therefore, have two procedures:
- `choose`: Creates a query of two secrets.
- `guess`: Tries to guess which secret was the origin of the received shares.

The security experience follows naturally. The adversary chooses two secrets and tries to distinguish between the set of shares he receives. He wins the game if he is able to do so with probability 1.