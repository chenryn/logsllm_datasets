### Netgear Driver Code Analysis

For the Netgear driver in kernel versions 3.18.20 and 3.18.23, the C code spans 534 lines, with 180 lines of new code added. For the remaining 17 versions, the driver code is consistent, with 60 lines of new code added compared to version 3.18.20. It is important to note that the driver code for the transplanted peripherals does not need to be developed from scratch. Instead, we reuse existing open-source code. For example, the driver for the Vectored Interrupt Controller (PL190) is available as open-source [15]. We simply integrate this existing driver code into a single file and compile it to generate the ECMO driver. The entire process takes less than one person-hour.

### Functionalities of Transplanted Peripherals

We successfully booted the Linux kernel by transplanting designated peripherals, such as the Interrupt Controller (IC), Timer, and UART. While the original peripherals may not function properly due to the lack of emulation or transplantation in QEMU, the functionalities of the transplanted peripherals are guaranteed. With these transplanted peripherals, ECMO can provide the capability to introspect the runtime states of the Linux kernel, enabling the development of dynamic analysis applications. Without our system, it would be impossible to build such applications because the target Linux kernel cannot be booted in QEMU. The three applications used in our evaluation demonstrate the usage scenarios of our system. We plan to build or port more complex applications, such as dynamic taint analysis [60], to further evaluate our system.

### Support for Other Peripherals

Currently, ECMO is evaluated based on the transplantation of three early-boot peripherals (IC, Timer, and UART) required to boot a Linux kernel. In general, peripheral transplantation can be applied to various types of peripherals. The transplantation process depends on the identification of ECMO pointers. Fortunately, to support other peripherals, users can directly install kernel modules on the rehosted Linux kernel without the need to identify pointers. Our experiments show that the driver for an Ethernet device, which is relatively complex, can be successfully installed, and the network functionality is guaranteed.

### Support for Other Architectures

At present, ECMO supports only the ARM architecture, which is the most prevalent in embedded systems [17]. However, the technique of peripheral transplantation can be easily extended to other architectures as it does not rely on any specific architectural features. Developers need to implement the module for identifying ECMO pointers for the new architecture, which requires additional engineering efforts. Algorithm 1 provides guidance for this process.

### Related Work

#### Static Firmware Analysis
Researchers have applied static analysis techniques to analyze embedded firmware. For instance, Costin et al. [30] conducted a large-scale analysis of 32,000 firmware images, discovering many new vulnerabilities affecting 123 products. Code similarity is widely used to study security issues in embedded devices. Feng et al. proposed Genius [38], which can identify many vulnerabilities quickly. Xu et al. utilized a neural network-based approach to build Gemini [65], which can identify more vulnerable firmware images compared to Genius. Yaniv et al. introduced Firmup [32], which has a low false positive rate and can efficiently discover vulnerabilities by considering the relationship between procedures. Xueqiang et al. [63] applied cross-analysis of mobile apps to detect vulnerable devices, identifying 324 devices from 73 different vendors. Our system is used to dynamically analyze firmware images, complementing static analysis methods.

#### Dynamic Firmware Analysis
In addition to static analysis, researchers have proposed several methods for dynamic firmware analysis. Avatar [69] supports complex dynamic analysis by orchestrating the execution of an emulator and real hardware. Charm [62] uses a similar strategy, introducing remote device driver execution by forwarding MMIO operations to a real mobile device. Avatar2 [54] extends Avatar to support replay without real devices, but both suffer from scalability issues. Inception [29] applies symbolic execution based on KLEE [25] and a custom JTAG to improve testing embedded software, assuming the source code is available. IoTFuzzer [27] aims to fuzz firmware from the mobile side, but its code coverage and attack surface coverage are limited. Pretender [43] can automatically rehost tasks but relies on the debug interface of specific devices. Jetset [49] uses symbolic execution to infer the return values of device registers, but the functionality of the peripherals is not guaranteed, and the shell may not be obtained for further application development. Many researchers also use fuzzing techniques to detect security issues in embedded firmware. P2IM [37] learns peripheral models automatically, while DICE [52] focuses on DMA controllers and extends P2IM's analysis coverage. Halucinator [28] proposes a new methodology to rehost firmware by abstracting HAL functions. ECMO differs from these systems by transplanting peripherals into the target kernel rather than inferring peripheral models. These systems focus on bare-metal systems, which are less complex than the Linux kernel. Firmadyne [26] and FirmAE [50] target Linux-based firmware but focus on user-space programs rather than the Linux kernel.

#### Applications Based on QEMU
Many applications are built on QEMU. For example, researchers have developed new fuzzing systems [21, 51, 70] based on QEMU. KVM leverages the device emulation provided by QEMU or the virtio [58] framework for device virtualization. The idea of virtio is similar to ECMO, but virtio requires changes to the guest source code, whereas ECMO works with the Linux kernel binary. Virtual machine introspection tools [24, 33, 34, 39, 40, 64], which are useful for debugging and forensic analysis, use QEMU to introspect system states. Additionally, dynamic analysis frameworks use QEMU to analyze malware behavior [36, 53, 57, 66â€“68]. ECMO provides the capability to rehost Linux kernels, laying the foundation for applying these applications to embedded Linux kernels.

### Conclusion

In this work, we propose a novel technique called peripheral transplantation to rehost the Linux kernel of embedded devices in QEMU. This lays the foundation for applications that rely on the capability of runtime state introspection. We have implemented this technique in a prototype system called ECMO and applied it to 815 firmware images, consisting of 20 kernel versions and 37 device models. ECMO can successfully transplant peripherals for all Linux kernels in these images. Among them, 710 kernels (87.1% success rate) can be successfully rehosted, launching the user-space shell. We also successfully installed an Ethernet device driver (smc91x) on all rehosted Linux kernels, demonstrating ECMO's capability to support additional peripherals. We further built three applications to showcase the usage scenarios of ECMO.

### Acknowledgements

We would like to thank the anonymous reviewers for their valuable comments, which greatly improved the presentation of this paper. We also want to thank Andrew Baumann for shepherding our paper. This work was partially supported by the National Natural Science Foundation of China (Grant No. 61872438), the Fundamental Research Funds for the Central Universities (Zhejiang University NGICS Platform ZJUNGICS2021016, K20200019), the Leading Innovative and Entrepreneur Team Introduction Program of Zhejiang (No. 2018R01005), and the HK RGC Project (No. PolyU 152239/18E). Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the funding agencies.