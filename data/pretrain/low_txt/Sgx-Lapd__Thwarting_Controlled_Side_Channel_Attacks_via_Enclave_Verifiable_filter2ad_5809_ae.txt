### Instrumented Code Information and Patching
Sgx-Lapd Linker scans the instrumented code information to identify all direct control flow transfers (CFTs) for which verification code is unnecessary. It then patches these CFTs with an unconditional branch. The patch count for the NXD approach is higher. Currently, Sgx-Lapd does not instrument library code. Therefore, call-ret pairs cannot be used to check for page faults, and the verification code for CFTs to library calls must be skipped. However, this should not be a limitation of Sgx-Lapd, as in real applications, enclave code is typically built into a statically linked binary [1]. Sgx-Lapd can instrument all the enclave code.

### Runtime Performance
Sgx-Lapd introduces additional overhead by inserting page fault detection code before each cross-page CFT, which slows down program execution. We evaluated this slowdown using both SPEC2006 and our own SGX-nbench. For SPEC2006, we measured the execution time overhead for each benchmark by running the instrumented benchmarks on their reference data sets 10 times, with a maximum variance of 2%. In Figure 7, we present the execution time overhead for each SPEC2006 benchmark, shown as a percent increase over the normalized baseline performance of the non-instrumented version of each benchmark. Similar to space overhead, the NXD approach has a larger execution time overhead than NPD. Generally, benchmarks with a larger number of CFTs will have higher overhead. As shown in Table 1, most of the verification code in 483.xalancbmk cannot be skipped, which is why it has the largest overhead. On average, NPD introduces 120% overhead on SPEC2006, while NXD introduces 183% overhead.

For SGX-nbench, we used the performance results reported by the benchmark itself. Specifically, SGX-nbench runs its benchmarks multiple times, taking the mean and standard deviation until it reaches a confidence threshold such that the results are 95% statistically certain. In Figure 8, we present the execution time overhead for each SGX-nbench benchmark, shown as a percent increase over the normalized baseline of the non-instrumented version. The average overhead of SGX-nbench is only 60% with NPD and 42% with NXD, which is lower than that of SPEC2006. This is because Sgx-Lapd only instruments the code inside the enclave, leaving the host application code uninstrumented and without overhead. This demonstrates the true performance of Sgx-Lapd in real SGX programs.

### Discussion
Sgx-Lapd relies on the enclave code to detect page faults and verify whether the OS provides large pages. All code outside the enclave is untrusted, meaning both the user-level signal handler and the kernel-level system exception handler can be malicious. According to the detailed steps in exception handling described in Figure 3, an attacker could execute the eight-step exception handling instead of the three-step page fault handling to reset the GPRSGX.RIP to other instructions. However, this requires collaboration from the trusted enclave code, making such an attack impossible unless the enclave code is compromised.

Additionally, there might be a race condition where a malicious OS resets the EXITINFO.VECTOR right after entering the enclave, as illustrated in Figure 4. Specifically, a malicious OS can first launch a page fault attack, causing EXITINFO.VECTOR to be set. When control returns to the enclave but before our verification code, the malicious OS injects another interrupt (e.g., timer interrupt or other faults like GP) to make the enclave exit again, resetting EXITINFO.VECTOR and evading detection. Fortunately, such an attack is challenging to launch. Attackers would need to execute the enclave program using single-step execution, which is only possible in debugging mode, not in deployment mode. The timing window for such an attack is extremely short, just a few instructions.

There is also room for further improvement in Sgx-Lapd, particularly in where to instrument the detection code. Our current design inserts a lot of intra-page CFT page fault detection code in the enclave binary, although we have patched the binary to skip executing that code. While this design is acceptable for small enclave binaries, especially given that we already request 2 MB pages for the enclave code, we aim to eliminate this unnecessary code. This would require iterative processing and instruction relocation, which we plan to address in future work. Another avenue for improvement is to precisely identify input-dependent CFTs, reducing the need for excessive detection code. This, however, requires static input taint analysis, a non-trivial task for a compiler.

Finally, Sgx-Lapd only stops code page fault attacks; attackers can still trigger data page faults. As mentioned in Section 3.1, we leave the defense for data page fault attacks to future work. Practical controlled channel attacks often require two kinds of page fault patterns, as demonstrated by Xu et al. [31]. The first is the code page pattern, indicating the start or end of a specific function. The second can be either a code or data page fault pattern but depends critically on the first code page fault pattern to be effective. By removing only code page fault patterns, Sgx-Lapd can still make data page fault attacks much harder.

### Conclusion
We have presented Sgx-Lapd, a system that leverages enclave-verifiable large paging to defeat controlled page fault side channel attacks. A key contribution of Sgx-Lapd is a technique that explicitly verifies whether the OS has provided large pages by intentionally triggering a page fault at each cross-small page CFT and validating with the internal SGX data structure updated by the hardware. We implemented Sgx-Lapd with a modified LLVM compiler and an SGX Linux kernel module. Our evaluation with a ported real SGX benchmark, SGX-nbench, shows that while space and runtime overhead can be high, Sgx-Lapd is still an acceptable first-step solution, especially considering the challenges in fighting controlled side channel attacks. The source code of Sgx-Lapd is available at https://github.com/utds3lab/sgx-lapd, and the source code of SGX-nbench is available at https://github.com/utds3lab/sgx-nbench.

### Acknowledgment
We thank Mona Vij from Intel for assistance with the test on SGX-v2. We are also grateful to the anonymous reviewers for their insightful comments. This research was partially supported by AFOSR under grant FA9550-14-1-0119 and NSF awards CNS-1453011, CNS-1564112, and CNS-1629951. Any opinions, findings, conclusions, or recommendations expressed are those of the authors and do not necessarily reflect the views of AFOSR and NSF.

### References
1. Intel Software Guard Extensions (Intel SGX) SDK. https://software.intel.com/en-us/sgx-sdk
2. The Linux Kernel Archives. https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt
3. Intel 64 and IA-32 Architectures Software Developer's Manual (2015). http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf
4. Backes, M., Nürnberger, S.: Oxymoron: Making fine-grained memory randomization practical by allowing code sharing. In: USENIX Security Symposium (2014)
5. Bauman, E., Lin, Z.: A case for protecting computer games with SGX. In: Proceedings of the 1st Workshop on System Software for Trusted Execution, p. 4. ACM (2016)
6. Baumann, A., Peinado, M., Hunt, G.: Shielding applications from an untrusted cloud with Haven. In: Proceedings of the 11th Symposium on Operating Systems Design and Implementation (OSDI), Broomfield, pp. 267–283, October 2014
7. Chandra, S., Karande, V., Lin, Z., Khan, L., Kantarcioglu, M., Thuraisingham, B.: Securing data analytics on SGX with randomization. In: Proceedings of the 22nd European Symposium on Research in Computer Security, Oslo, September 2017
8. Checkoway, S., Shacham, H.: Iago attacks: Why the system call API is a bad untrusted RPC interface. In: Proceedings of the 18th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS), Houston, pp. 253–264, March 2013
9. Chen, X., Garfinkel, T., Lewis, E.C., Subrahmanyam, P., Waldspurger, C.A., Boneh, D., Dwoskin, J., Ports, D.R.: Overshadow: A virtualization-based approach to retrofitting protection in commodity operating systems. In: Proceedings of the 13th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS XIII), Seattle, pp. 2–13. ACM (2008)
10. Giuffrida, C., Kuijsten, A., Tanenbaum, A.S.: Enhanced operating system security through efficient and fine-grained address space randomization. In: USENIX Security Symposium, pp. 475–490 (2012)
11. Goldreich, O.: Towards a theory of software protection and simulation by oblivious RAMs. In: Proceedings of the Nineteenth Annual ACM Symposium on Theory of Computing, pp. 182–194. ACM (1987)
12. Hand, S.M.: Self-paging in the Nemesis operating system. In: OSDI, vol. 99, pp. 73–86 (1999)
13. Hoekstra, M., Lal, R., Pappachan, P., Phegade, V., Del Cuvillo, J.: Using innovative instructions to create trustworthy software solutions. In: Proceedings of the 2nd International Workshop on Hardware and Architectural Support for Security and Privacy (HASP), Tel-Aviv, pp. 1–8 (2013)
14. Intel: Intel Software Guard Extensions Programming Reference (Rev2), 329298-002US, October 2014
15. Karande, V., Bauman, E., Lin, Z., Khan, L.: Securing system logs with SGX. In: Proceedings of the 12th ACM Symposium on Information, Computer and Communications Security, Abu Dhabi, April 2017
16. Klein, G., Elphinstone, K., Heiser, G., Andronick, J., Cock, D., Derrin, P., Elkaduwe, D., Engelhardt, K., Kolanski, R., Norrish, M., Sewell, T., Tuch, H., Winwood, S.: seL4: Formal verification of an OS kernel. In: Proceedings of the ACM SIGOPS 22nd Symposium on Operating Systems Principles (SOSP 2009), pp. 207–220 (2009)
17. McCune, J.M., Parno, B.J., Perrig, A., Reiter, M.K., Isozaki, H.: Flicker: An execution infrastructure for TCB minimization. In: Proceedings of the ACM EuroSys Conference, Glasgow, pp. 315–328, March 2008
18. McKeen, F., Alexandrovich, I., Berenzon, A., Rozas, C.V., Shafi, H., Shanbhogue, V., Savagaonkar, U.R.: Innovative instructions and software model for isolated execution. In: Proceedings of the 2nd International Workshop on Hardware and Architectural Support for Security and Privacy (HASP), Tel-Aviv, pp. 1–8 (2013)
19. Ohrimenko, O., Schuster, F., Fournet, C., Mehta, A., Nowozin, S., Vaswani, K., Costa, M.: Oblivious multi-party machine learning on trusted processors. In: 25th USENIX Security Symposium (USENIX Security 2016), Austin, pp. 619–636. USENIX Association, August 2016
20. Perez, R., Sailer, R., van Doorn, L., et al.: vTPM: Virtualizing the Trusted Platform Module. In: Proceedings of the 15th USENIX Security Symposium (Security), Vancouver, pp. 305–320, July 2006
21. Pinkas, B., Reinman, T.: Oblivious RAM revisited. In: Rabin, T. (ed.) CRYPTO 2010. LNCS, vol. 6223, pp. 502–519. Springer, Heidelberg (2010). doi:10.1007/978-3-642-14623-7_27
22. Porter, D.E., Boyd-Wickizer, S., Howell, J., Olinsky, R., Hunt, G.C.: Rethinking the library OS from the top down. In: Proceedings of the 16th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS), Newport Beach, pp. 291–304, March 2011
23. Santos, N., Raj, H., Saroiu, S., Wolman, A.: Using ARM TrustZone to build a trusted language runtime for mobile applications. In: ACM SIGARCH Computer Architecture News, vol. 42, pp. 67–80. ACM (2014)
24. Schuster, F., Costa, M., Fournet, C., Gkantsidis, C., Peinado, M., Mainar-Ruiz, G., Russinovich, M.: VC3: Trustworthy data analytics in the cloud using SGX. In: Proceedings of the 2015 IEEE Symposium on Security and Privacy (2015)
25. Seshadri, A., Luk, M., Qu, N., Perrig, A.: SecVisor: A tiny hypervisor to provide lifetime kernel code integrity for commodity OSes. In: Proceedings of Twenty-First ACM SIGOPS Symposium on Operating Systems Principles (SOSP 2007), Stevenson, Washington, DC, pp. 335–350 (2007)
26. Shih, M.-W., Lee, S., Kim, T., Peinado, M.: T-SGX: Eradicating controlled-channel attacks against enclave programs. In: Proceedings of the 2017 Annual Network and Distributed System Security Symposium (NDSS), San Diego (2017)
27. Shinde, S., Chua, Z.L., Narayanan, V., Saxena, P.: Preventing your faults from telling your secrets: Defenses against pigeonhole attacks. arXiv preprint arXiv:1506.04832 (2015)
28. Sun, K., Wang, J., Zhang, F., Stavrou, A.: SecureSwitch: BIOS-assisted isolation and switch between trusted and untrusted commodity OSes. In: Proceedings of the 19th Annual Network and Distributed System Security Symposium (NDSS), San Diego, February 2012
29. PaX Team: PaX Address Space Layout Randomization (ASLR). http://pax.grsecurity.net/docs/aslr.txt
30. Wang, J., Stavrou, A., Ghosh, A.: HyperCheck: A hardware-assisted integrity monitor. In: Jha, S., Sommer, R., Kreibich, C. (eds.) RAID 2010. LNCS, vol. 6307, pp. 158–177. Springer, Heidelberg (2010). doi:10.1007/978-3-642-15512-3_9
31. Xu, Y., Cui, W., Peinado, M.: Controlled-channel attacks: Deterministic side channels for untrusted operating systems. In: Proceedings of the 2015 IEEE Symposium on Security and Privacy (2015)