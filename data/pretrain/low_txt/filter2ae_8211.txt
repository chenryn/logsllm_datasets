### 一、漏洞概述
2016年10月18日，黑客Phil Oester披露了一个隐藏长达9年的“脏牛漏洞”（Dirty COW），该漏洞编号为CVE-2016-5195。两天后，即2016年10月20日，Linux内核团队成员、Linux创始人Linus Torvalds修复了这个0day漏洞。此漏洞存在于Linux内核的内存子系统中，在处理写时拷贝（Copy-on-Write, COW）时存在条件竞争问题，导致攻击者可以破坏私有只读内存映射。通过获取低权限本地用户账户，黑客能够利用此漏洞获得对其他只读内存映射的写权限，从而进一步提升至root权限。

阿里云安全团队在第一时间对该漏洞进行了详细的技术分析，具体内容请参见第二章“漏洞分析”。

### 二、漏洞基本信息
**漏洞编号：** CVE-2016-5195  
**漏洞名称：** 脏牛（Dirty COW）  
**漏洞危害：** 本地提权  
黑客可以通过远程入侵获取低权限用户账户，然后在服务器操作系统上利用该漏洞实现本地提权，最终获取服务器的root权限。

**影响范围：** 自2007年起发布的所有Linux内核版本（>2.6.22）。  
**漏洞利用条件：** 黑客必须首先通过远程入侵或其他方式获取到低权限用户的访问权限，才能进一步在本地操作系统上利用该漏洞。

### 三、漏洞详细分析
从技术角度来看，该漏洞出现在`__get_user_pages()`函数中的一个条件竞争漏洞。通常情况下，分析此类漏洞需要关注以下三个关键点：
- **A) 竞争点**
- **B) 竞争条件**
- **C) 竞争方式**

根据最初的漏洞利用代码，作者使用两个线程分别调用`madvise`和`write`系统调用来创建竞争条件。

#### 3.1 `madvise` 实现分析
`madvise`系统调用允许用户态程序向内核提供关于其内存使用模式的信息，以优化性能。当使用`MADV_DONTNEED`参数调用`madvise`时，它会通知内核用户态程序在未来不太可能再使用指定的内存区域。内核实际执行的操作包括：
- `sys_madvise()`
- `madvise_vma()`
- `madvise_dontneed()`
- `zap_page_range()`
- ...
- `zap_pte_range()`
- `ptep_get_and_clear_full()`
- `ptep_get_and_clear()`（清零PTE）

这些操作最终会导致内核将指定内存区域在用户态程序页表中对应的页表项清空。

#### 3.2 `write()` 实现分析
`write`系统调用用于将数据写入指定的存储区域。在此次漏洞利用过程中，`write`系统调用被用来进入关键的竞争区域，实现逻辑控制。具体执行过程如下：
- `sys_write()`
- ...
- `__access_remote_vm()`
- `get_user_pages()`
- `__get_user_pages()`
- `retry:`
- `page = follow_page_mask();`
- `if !page { ret = faultin_page(); if ret == 0: goto retry }`

上述代码表明，当`page`为`NULL`且`ret`为`0`时，`get_user_pages`将陷入`retry`循环，反复调用`follow_page_mask()`和`faultin_page()`函数，直到满足退出条件为止。

`follow_page_mask()`函数用于获取指定内存区域对应的`struct page`结构，关键逻辑包括：
- `follow_page_mask()`
- `follow_page_pte()`（启用自旋锁）
- `if pte == 0: return NULL`（关闭自旋锁）

`faultin_page()`函数则处理`page`不存在的情况，确保内核上下文的正确性。如果需要分配新的`pte`及`page`结构体，该函数会完成并返回`0`；否则，返回其他值以退出`retry`循环。

因此，`follow_page_mask()`和`faultin_page()`函数应当被视为一个原子操作序列，但在实际执行中缺乏相应的保护机制，容易被打断。特别是当另一个执行流（如`madvise(MADV_DONTNEED)`）在`follow_page_mask()`和`faultin_page()`之间被调度时，可能会改变`faultin_page()`的执行效果，从而影响后续操作。

#### 3.3 竞争分析
在`madvise(MADV_DONTNEED)`的关键逻辑中，存在对页表项`pte`的清零操作。当`retry`循环中的`faultin_page()`完成后（分配新的`pte`），若此时`madvise(MADV_DONTNEED)`被调度执行，则`pte`会被清零。随后，`retry`循环重新获取执行资源时，`follow_page_mask()`将返回`NULL`，再次触发`faultin_page()`。这种情况下，如果内核开发者未预料到这种情况并且`faultin_page()`在全局资源或上下文语义上不是简单的可重入函数，就会产生不可预见的副作用。

### 四、漏洞分析总结
目前，Linux内核开发团队已经发布了修复补丁。出于性能和效率的考虑，该修复方案并未在`retry`循环中的`follow_page_mask()`和`faultin_page()`之间添加锁操作，而是取消了循环中的逻辑读写标志。尽管竞争点仍然存在，但`madvise`系统调用的页表项清零操作不再对`faultin_page()`函数的内核上下文产生负面影响。至于内核中是否存在其他适合的执行流能够影响`retry`循环，目前尚不清楚。

### 五、如何检测漏洞？
阿里云建议用户采用以下方法自查是否存在此漏洞：
- **自动检查：** 使用阿里云云盾安骑士提供的“安全基线检查 - 高危漏洞应急检查”功能进行自动检查。
- **手动检查：** 通过运行`uname -a`命令查看Linux系统的内核版本。例如：
  - `[Linux AYxxxx ]2.6.32-431.23.3.el6.x86_64 #1 SMP Thu Jul 31 17:20:51 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux`
    - 上述内核版本2.6.32-431.23.3.el6.x86_64受漏洞影响。
  - `[Linux AYxxxx ]2.6.18-308.el5 #1 SMP Tue Feb 21 20:06:06 EST 2012 x86_64 x86_64 x86_64 GNU/Linux`
    - 上述内核版本2.6.18-308.el5不受漏洞影响。

### 六、如何修复漏洞？
针对已发布补丁的Linux发行版，阿里云安全团队提供了详细的修复方案。用户可以参考官方链接进行修复。对于CentOS和AliyunOS操作系统，官方正在研发对应的系统补丁，待补丁发布后，将系统更新到最新版本即可修复漏洞。

**提示：** 由于涉及操作系统内核的升级，强烈建议您：
- 正确关闭正在运行的服务；
- 做好数据备份工作；
- 创建服务器磁盘快照，以避免修复失败造成不可逆的影响。

### 七、参考链接
[此处插入相关参考链接]