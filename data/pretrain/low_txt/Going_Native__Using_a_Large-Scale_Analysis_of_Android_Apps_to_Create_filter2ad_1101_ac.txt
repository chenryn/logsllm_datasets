To have greater control over the system, many users perform a process known as "rooting," which allows them to execute actions with "root" user privileges. During this process, an SUID (Set User ID) executable file called `su` is typically installed, along with a manager app that restricts which applications can use this binary to perform actions as root. This practice is so common that numerous apps provide functionality that can only be executed by the root user, such as changing system fonts or modifying DNS configurations.

Our analysis identified 1,137 apps that attempt to run `su`. Surprisingly, 28.23% (321) of these apps do not mention in their description or name that they require root privileges. Some of these apps use the `-c` argument of `su` to specify a command to be executed as root. Table VIII presents the top five most common types of actions that these apps tried to execute using `su`, along with the number of apps attempting each command and whether the app mentioned the need for root access. This table provides insights into what the apps are trying to accomplish as root. The most common action using the `-c` argument of `su` is calling a custom executable. Since apps cannot use `su` in the emulator, these actions did not work during dynamic analysis, preventing us from obtaining more detailed information about their behavior.

### D. JNI Calls Statistics

Understanding the JNI (Java Native Interface) functions called by native code can reveal how the native components of apps interact with the app and the Android framework. Table IX presents the types of JNI functions used by the apps and the number of apps that used them. The most relevant actions for security considerations in this table are: (1) calling Java methods and (2) modifying fields of objects. Calling methods in Java libraries from native code can be used to avoid detection by static analysis. Moreover, modifying fields of Java objects can change the execution of Java code in ways that static analysis cannot predict.

Calling Java methods, both from the Android framework and from the app, can be performed by some of the methods listed in Table II, specifically those whose names start with "Call." As Table IX shows, we identified 35,231 apps that have native code which calls Java methods. More specifically, 24,386 apps used these functions to call Java methods from the app, and 25,618 apps used them to call Java methods from the framework. Table X presents the groups of methods from the framework that were called, along with the number of apps that called methods in each group.

### E. Binder Transactions

1.64% (2,457) of the apps that reached native code during dynamic analysis performed Binder transactions. Table XI presents the top five most commonly invoked classes of the remote methods. The most common class remotely invoked by this process is `IServiceManager`, which can be used to list services, add a service, and get an object to a Binder interface. All apps that used this class obtained an object to a Binder interface, and two apps also used it to list services. This data shows that using Binder transactions from native code is not common. From a security perspective, this is positive, as the use of Binder transactions represents a way in which native code can perform critical actions while remaining undetected by static analysis.

### F. Usage of External Libraries

Understanding the libraries used by the apps in native code can help us comprehend their purpose. Table XII presents the top 10 most used system libraries, and Table XIII presents the top 10 most used custom libraries by apps in native code. It demonstrates that, apart from the bitmap manipulation library, which was used by 16.6% (24,942) of the apps that reached native code, no standard library was used by a large number of apps. On the other hand, several custom libraries were used by more than 7.5% of the apps that executed native code.

### V. Security Policy Generation

One step to limit the possible damage that native code can do is to isolate it from the Java code using the native code sandboxing mechanisms discussed in Section II-D. These mechanisms prevent native code from modifying Java code, allowing static analysis of the Java part to produce more reliable results. However, this is not enough, considering that the app can still perform dangerous actions by interacting with the Android framework/libraries and using system calls to execute root exploits.

Our goal here is to reduce the attack surface available to native code by restricting the system calls and Java methods that native code can access. In particular, we propose using our dynamic analysis system to generate security policies. A security policy represents the normal behavior, which can be seen as a sort of whitelist of the system calls and Java methods that are normally executed from within native code components of benign applications. These policies also implicitly identify which system calls and Java methods should be considered unusual or suspicious, such as those used to mount root exploits.

One aspect to consider is the action taken when an unusual system call is executed. Similar to the design choice adopted by SELinux, we envision two modes: permissive and enforcing. In permissive mode, the system would log and report the usage of unusual behavior, while in enforcing mode, the system would block the execution of such unusual behavior and stop the application. Depending on the context, it might make sense to use permissive or the more aggressive enforcing mode. As an alternative, one could selectively pick permissive or enforcing mode depending on whether the unusual system call is well-known to be used by root exploits. The policy generation process for system calls is described in Section V-A, while the one for Java methods is described in Section V-B. We discuss the possibilities and implications of this choice in Section VI.

It is worth noting that while this will not guarantee perfect protection from attacks, by applying the security principle of least privilege to the native code, we gain the dual security benefits of (1) increasing the precision of Java static analysis and (2) reducing the impact of malicious native code.

#### A. System Calls

Based on the system calls performed by the apps in native methods, in native activities, during libraries loading, and by programs executed by `Exec` methods, our system can automatically generate a security policy of allowed system calls. To compile this list, we first normalize the parameters of the system calls and then iterate over them, selecting the ones performed by most apps, until the list of selected system calls is comprehensive enough to allow at least a (variable threshold) percentage of the apps that executed native code to run properly. In Android, inter-process communication is done through Binder. Native code can directly use Binder transactions to call methods implemented by system services. At the system call level, these calls are performed using the `ioctl` system call. To consider these actions in our automatically generated whitelist, we substitute `ioctl` calls to Binder with the Binder transactions performed by the apps.

To understand the possible policies that could be generated, we performed this process using a threshold (the percentage of apps that use native code whose dynamically-executed behavior would function properly when enforcing this policy) of 99%. Table XIV presents the actions obtained by this procedure. The system call arguments that were normalized were replaced by symbols in the form `<symbol>` and `*` (meaning anything). Some of the arguments that are file descriptors were changed to a file path representation. All arguments that were not normalized represent a numeric value or a constant value that was converted by `strace` to a string representation. For the system calls that do not have the arguments next to them in the policies, the policy accepts calls with any arguments. Table XV presents more details about the symbols used.

To better understand which types of apps would be blocked by our example policy (when in enforcing mode), we studied them and manually analyzed a subset of them. The findings of this analysis are presented in Section VI.

The policies restrict the possible actions of native code, thus following the principle of least privilege and making it harder for malicious apps to function. Previously, malicious code could easily hide in native code to evade static analysis. With our example policies enforced by a sandboxing mechanism, the native code does not (depending on the exact threshold) have the ability to perform any malicious actions in native code, and therefore attackers will have to move the malicious behavior to the Java code, where it can be found by existing Java static analysis tools. Furthermore, the policies do not prevent the correct execution of the dynamically-executed behavior of many benign apps. Using the rules generated with the 99% threshold, only 1,483 apps (0.12% of the total apps in our dataset) would be affected. Of course, as the dynamic analysis performed by our system is incomplete (it cannot execute all possible app code), this number is a lower bound. This can be alleviated by an organization wishing to use our system in one of two ways: (1) increase the completeness of the dynamic analysis or (2) deploy the sandboxing enforcement mechanism in reporting mode. Both choices will reveal more app behaviors.

Another benefit of enforcing a native code sandboxing policy is that it would prevent the correct execution of several root exploits. For this work, we considered the 13 root exploits reported in Table XVI. These exploits require native code to be successful. Our example security policy would hinder the execution of 10 of them. This follows because the policies aim to reduce the attack surface of the OS for native code while maintaining backward compatibility. Table XVI presents which of the considered exploits are successfully blocked, along with which entry of the policy they violate.

The root exploits that are prevented by our example security policy are blocked due to rules related to four system calls, namely `socket`, `perf_event_open`, `symlink`, and `ioctl`. More precisely, two exploits need to create sockets with the `PF_NETLINK` domain and `NETLINK_KOBJECT_UEVENT` (15) protocol, but the rules only allow `PF_NETLINK` sockets with protocol 0. One of the exploits needs the `perf_event_open` system call, which is not allowed by the policy. Two exploits need to create symbolic links that target system files or directories, but the policy only allows symbolic links to target "USER-PATH," which means files or directories in the app's directory or on the SD Card. Finally, five exploits use `ioctl` to communicate with a device. One of the rules allows `ioctl` calls to any device, namely `ioctl(<device>, SNDCTL_TMR_TIMEBASE or TCGETS, *)`. However, this rule specifies the valid request value (the second parameter), whereas the exploits use different values, and thus they would be blocked.

The table also reports the details about the three exploits that would not be currently blocked. In one case (CVE-2011-1149), the exploit would still work because our example policy allows the invocation of the `mprotect` syscall, as it is used by benign applications. In the two remaining cases (RATC and Zimperlinch), the exploits rely on repeatedly invoking the `fork` syscall to exhaust the number of available processes. The `fork` syscall is allowed by our policy as some benign applications do use it. However, note that this kind of exploit could be blocked by a security policy that takes into account the frequency of invocations of a given syscall: No benign application would ever invoke the `fork` syscall so frequently. We believe that considering this additional aspect of native code behavior is a very interesting direction for future work.

Although our example security policy does not block all exploits, we believe the adoption of native sandboxing to be useful. It significantly reduces the attack surface available to native code components and is able to successfully prevent many root exploits.