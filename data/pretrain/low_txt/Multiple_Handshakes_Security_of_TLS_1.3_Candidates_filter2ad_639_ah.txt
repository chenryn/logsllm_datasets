### V. (IN)SECURITY ANALYSIS OF TLS 1.2

In this section, we discuss the triple handshake attack on TLS 1.2 within the context of the multiple handshakes security model. TLS 1.2 supports three primary handshake modes: full handshake (M1), session resumption (M2), and session renegotiation (M3). Session resumption is similar to the Pre-Shared Key (PSK) resumption in TLS 1.3, with minor differences. Session renegotiation follows the full handshake process but occurs over an encrypted TLS connection, allowing for client authentication without privacy leakage or ciphersuite upgrades. Additionally, TLS 1.2 involves dependencies between multiple runs of the handshake protocols.

As mentioned in the introduction, it is impossible to prove the security of the TLS 1.2 handshake protocol in any security model based on key indistinguishability, such as the multiple handshakes security model from Section III. This is because the encryption and MAC of the Finished messages provide a 'check value' that can be exploited by an adversary to determine the bit \( b_{\text{test}} \) chosen by the Test oracle. To address this, we consider a 'truncated TLS' protocol, as in [11], where the Finished messages are sent in plaintext. The truncated TLS full handshake has been proven to be a secure Authenticated Key Exchange (AKE) protocol.

Similar to TLS 1.3, we view TLS 1.2 as a multi-stage key exchange protocol. In the first stage, the master secret \( ms \) is derived, and in the second stage, the traffic key \( tk_{\text{hs}} \) is derived from \( ms \). The Multi-Level&Stage Security model can then be applied to the truncated TLS 1.2.

#### Triple Handshake Attack on TLS 1.2

The triple handshake attack on TLS 1.2, proposed by Bhargavan et al. in 2014 [5], involves a malicious server performing a man-in-the-middle attack on three successive handshakes (full handshake, session resumption, and renegotiation) between an honest client and server. The attack proceeds as follows:

**Step 1: Synchronizing RSA/DHE**
- The client \( C \) deliberately connects to a server \( A \), which maliciously connects to the legitimate server \( S \).
- Since only \( C \) contributes to the key exchange in RSA and DHE, the attacker can make \( C \) accept a group with a non-prime order.
- For example, in RSA, \( A \) takes the encrypted pre-master secret (pms) generated by \( C \) and re-encrypts it to \( S \).
- At the end of this stage, \( A \) completes both handshakes, obtaining two new sessions that share the same parameters (sid, ms).

**Step 2: Synchronizing Resumption**
- Once \( A \) has synchronized the two connections, if \( C \) attempts to resume the session with \( A \) on a new connection, \( A \) can resume its session with \( S \) on a new connection and forward the abbreviated handshake messages unchanged between \( C \) and \( S \).
- Since the abbreviated handshake relies only on the master secret for authentication and does not mention client or server identities, both handshakes complete successfully, resulting in the same session keys and finished messages.

**Step 3: Impersonating the Client**
- With the Renegotiation Indication extension [9] synchronized, if \( C \) or \( S \) initiates a client-authenticated TLS renegotiation, \( A \) can simply forward all messages between \( C \) and \( S \).
- If \( C \) accepts the new identity of the server, \( A \) will successfully impersonate \( C \) to \( S \), even though \( A \) has no knowledge of the connection key in the renegotiation.

This attack remains valid even if the finished messages are transmitted in plaintext.

Formally, this attack is captured in our security model for multiple handshakes protocols from Section III. We denote the composition of the full handshake, resumption handshake, and renegotiation handshake as \( \Pi \). Note that \( \Pi \) is a multiple handshakes protocol with three levels according to the model definition. During the attack, the client and server run handshake protocols labeled \( \text{label} \) and \( \text{label}' \), respectively. When \( \text{label.lev} = \text{label}'.\text{lev} = 1 \), \( \text{label.mode} = \text{label}'.\text{mode} = M1 \), \( \text{label.sid1} \neq \text{label}'.\text{sid1} \), and \( \text{label.sid2} \neq \text{label}'.\text{sid2} \), but \( \text{label.K1} = \text{label}'.\text{K1} \) and \( \text{label.K2} = \text{label}'.\text{K2} \). This means that sessions with different session identifiers at some stage hold the same session keys at that stage. Thus, TLS 1.2 without countermeasures is not a Multi-Level&Stage secure multiple handshakes protocol.

#### Countermeasure to the Triple Handshake Attack

The IETF TLS working group developed RFC 7627 [30] to provide a countermeasure against the triple handshake attack. This countermeasure contextually binds the master secret to the full handshake by including a hash of the handshake messages in the Pseudorandom Function (PRF) computation. By such binding, master secrets generated with different session identifiers cannot be the same, thereby preventing the triple handshake attack. Due to space constraints, the detailed security proof is omitted here.

### VI. CONCLUSION

Although TLS handshake protocols for establishing secure communications have been extensively studied and widely used in practice, this work is the first to consider the practical issue of multiple handshakes, where parties run successive TLS handshakes over multiple connections. The importance of correctly implementing multiple handshakes was highlighted by the triple handshake attack of Bhargavan et al. in 2014 [5].

We have developed a formal model for describing the security of multiple handshakes protocols, covering all kinds of compositional interactions between different TLS handshake modes and providing strong security guarantees. We have proven the security of multiple handshakes in TLS 1.3 candidates in a combinational running setting, further confirming the sound design of the TLS 1.3 handshake protocol. We have also analyzed the TLS 1.2 handshake protocol at a high level, identifying the triple handshake attack in our model and showing that their countermeasure offers good protection against multiple handshakes attacks.

Future work includes analyzing the compositional security of other key exchange protocols, such as SSH, under our multiple handshakes security model. Additionally, the overall security of TLS 1.3 still has many important open questions, including the security of multi-ciphersuites and the formal analysis of other complex functionalities like version negotiation.

### ACKNOWLEDGMENT

This work was supported by the National Grand Fundamental Research (973) Program of China under Grant 2013CB338003, and the National Natural Science Foundation of China (NSFC) under Grants U1536205, 61170279, and 61572485.

### REFERENCES

[1] T. Dierks and E. Rescorla, “The Transport Layer Security (TLS) Protocol Version 1.1,” IETF RFC 4346, April 2006.
[2] ——, “The Transport Layer Security (TLS) Protocol Version 1.2,” IETF RFC 5246, August 2008.
[3] N. J. AlFardan, D. J. Bernstein, K. G. Paterson, B. Poettering, and J. C. Schuldt, “On the Security of RC4 in TLS.” in USENIX Security. USENIX, 2013, pp. 305–320.
[4] N. J. Al Fardan and K. G. Paterson, “Lucky thirteen: Breaking the TLS and DTLS record protocols,” in IEEE S&P. IEEE, 2013, pp. 526–540.
[5] K. Bhargavan, A. D. Lavaud, C. Fournet, A. Pironti, and P. Y. Strub, “Triple handshakes and cookie cutters: Breaking and fixing authentication over TLS,” in IEEE S&P. IEEE, 2014, pp. 98–113.
[6] Codenomicon, “The Heartbleed Bug,” http://heartbleed.com, April 2014.
[7] E. Rescorla, “The Transport Layer Security (TLS) Protocol Version 1.3 - draft-ietf-tls-tls13-10,” https://tools.ietf.org/html/draft-ietf-tls-tls13-10, October 2015.
[8] M. Ray and S. Dispensa, “Renegotiating TLS,” http://extendedsubset.com/Renegotiating_TLS.pdf, November 2009.
[9] E. Rescorla, M. Ray, S. Dispensa, and N. Oskov, “Transport Layer Security (TLS) Renegotiation Indication Extension,” IETF RFC 5746, February 2010.
[10] K. Bhargavan, A. Delignat-Lavaud, and A. Pironti, “Verified Contributive Channel Bindings for Compound Authentication,” in NDSS, 2015.
[11] T. Jager, F. Kohlar, S. Schäge, and J. Schwenk, “On the security of TLS-DHE in the standard model,” in CRYPTO. Springer, 2012, pp. 273–293.
[12] F. Kohlar, S. Schäge, and J. Schwenk, “On the Security of TLS-DH and TLS-RSA in the Standard Model.” Cryptology ePrint Archive, Report 2013/367, 2013, https://eprint.iacr.org/2013/367.
[13] H. Krawczyk, K. G. Paterson, and H. Wee, “On the security of the TLS protocol: A systematic analysis,” in CRYPTO. Springer, 2013, pp. 429–448.
[14] F. Giesen, F. Kohlar, and D. Stebila, “On the security of TLS renegotiation,” in ACM CCS. ACM, 2013, pp. 387–398.
[15] Y. Li, S. Schäge, Z. Yang, F. Kohlar, and J. Schwenk, “On the Security of the Pre-shared Key Ciphersuites of TLS,” in PKC. Springer, 2014, pp. 669–684.
[16] K. Bhargavan, C. Fournet, M. Kohlweiss, A. Pironti, P.-Y. Strub, and S. Zanella-Béguelin, “Proving the TLS handshake secure (as it is),” in CRYPTO 2014. Springer, 2014, pp. 235–255.
[17] C. Fournet, M. Kohlweiss, and P.-Y. Strub, “Modular code-based cryptographic verification,” in ACM CCS. ACM, 2011, pp. 341–350.
[18] K. Bhargavan, C. Fournet, M. Kohlweiss, A. Pironti, and P. Strub, “Implementing TLS with verified cryptographic security,” in IEEE S&P. IEEE, 2013, pp. 445–459.
[19] B. Dowling, M. Fischlin, F. Günther, and D. Stebila, “A cryptographic analysis of the TLS 1.3 handshake protocol candidates,” in ACM CCS. ACM, 2015, pp. 1197–1210.
[20] E. Rescorla, “The Transport Layer Security (TLS) Protocol Version 1.3 - draft-ietf-tls-tls13-05,” https://tools.ietf.org/html/draft-ietf-tls-tls13-05, March 2015.
[21] ——, “The Transport Layer Security (TLS) Protocol Version 1.3-draft-ietf-tls-tls13-dh-based,” https://github.com/ekr/tls13-spec/blob/ietf92_materials/draft-ietf-tls-tls13-dh-based.txt, March 2015.
[22] M. Fischlin and F. Günther, “Multi-Stage Key Exchange and the Case of Google’s QUIC Protocol,” in ACM CCS. ACM, 2014, pp. 1193–1204.
[23] E. Rescorla, “The Transport Layer Security (TLS) Protocol Version 1.3 - draft-ietf-tls-tls13-07,” https://tools.ietf.org/html/draft-ietf-tls-tls13-07, July 2015.
[24] H. Krawczyk and H. Wee, “The OPTLS Protocol and TLS 1.3,” Cryptology ePrint Archive, Report 2015/978, 2015, https://eprint.iacr.org/2015/978.
[25] R. Canetti and H. Krawczyk, “Analysis of key-exchange protocols and their use for building secure channels,” in EUROCRYPT. Springer, 2001, pp. 453–474.
[26] A. Langley and W. Chang, “QUIC Crypto,” http://tinyurl.com/lrrjyjs, June 2013.
[27] R. Lychev, S. Jero, A. Boldyreva, and C. Nita-Rotaru, “How secure and quick is QUIC? Provable security and performance analyses,” in IEEE S&P. IEEE, 2015, pp. 214–231.
[28] M. Bellare and P. Rogaway, “Entity authentication and key distribution,” in CRYPTO. Springer, 1993, pp. 232–249.
[29] C. Brzuska, M. Fischlin, B. Warinschi, and S. C. Williams, “Composability of Bellare-Rogaway key exchange protocols,” in ACM CCS. ACM, 2011, pp. 51–62.
[30] K. Bhargavan, A. Delignat-Lavaud, A. Pironti, A. Langley, and M. Ray, “Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension,” IETF RFC 7627, September 2015.
[31] H. Krawczyk, “Cryptographic extraction and key derivation: The HKDF scheme,” in CRYPTO. Springer, 2010, pp. 631–648.
[32] H. Krawczyk and P. Eronen, “HMAC-based Extract-and-Expand Key Derivation Function (HKDF),” IETF RFC 5869, May 2010.
[33] R. Canetti and H. Krawczyk, “Security analysis of IKE’s signature-based key-exchange protocol,” in CRYPTO. Springer, 2002, pp. 143–161.
[34] C. Brzuska, “On the foundations of key exchange,” TU Darmstadt, 2013, http://tuprints.ulb.tu-darmstadt.de/3414/.

### APPENDIX

#### A. Proof of Lemma 3

To show that \( \Pi \) is Multi-Level&Stage-secure, we need to demonstrate the Key Secrecy of the added session label \( \text{label}' \). Before providing the detailed proof, we need to establish the relationship between \( \text{label}' \) and \( \text{label} \), where the session label is included in \( \Pi \) and \( \text{label}'.\text{prelid} = \text{label}.\text{lid} \).

To enable 0-RTT functionality for \( \text{label}' \), the TLS 1.3 draft suggests that the server sends a ServerConfiguration message containing the semi-static key \( g_s \) associated with a unique Configuration ID to the client. The client can use this shared key in the 0-RTT handshake. Additionally, the server sends its ServerCertificate and ServerCertificateVerify messages for authentication. During the 0-RTT handshake, the concatenation of the ServerConfiguration-1 and ServerCertificate-1 messages is included in the computation of the handshake hash. Therefore, we can confidently assert that only the authenticated server knows the secret \( s \) since the label is secure against Key Secrecy, unless the adversary makes a Corrupt query. 

We now focus on the security of \( \text{label}' \):

**Result for \( \text{label}' \)**: 0-RTT is secure against Key-Secrecy in a key-independent and stage-2-forward-secret manner with concurrent authentication properties AUTH = (unilateral, unauth, unilateral, unilateral, unilateral), (unilateral, unilateral, mutual, mutual, mutual) in the random oracle. Formally, for any efficient adversary \( A \) against the Key Secrecy, there exist efficient algorithms \( B_1, \ldots, B_{10} \) described in later games.

**Remark 3**: To prove the above result, we treat HKDF.Extract as the random oracle when computing SS and ES, which is a common assumption in security analyses. While it may not be appropriate in every case, the standard use of HKDF.Extract with fixed keys for the key derivation function here seems fine. In 0-RTT, it is important for the analysis that the first occurrence for SS is the random oracle. The second one for ES may satisfy a weaker notion, but we treat it as the random oracle for simplicity, similar to the QUIC security analysis [27].

**Part 1: Un-compromised \( s \)**