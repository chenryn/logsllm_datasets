### 5.4 Real-world Deployment

We have deployed Gene in two university networks, where it has been operational since November 25, 2009. In these deployments, Gene scans traffic between the internal network and the Internet, as well as traffic between selected internal subnets. As of April 17, 2010, Gene has detected 116,513 code injection attacks against both internal and external hosts in these two networks. Although we cannot determine how many of these attacks actually infected the targeted hosts, as many systems may have been previously patched, in all cases, the attacker was able to connect and send malicious input to potentially vulnerable services. Almost one-third of the attacks were launched from internal PCs, likely already infected by malware. Approximately 86% of the attacks targeted port 445, with additional attacks targeting ports 80, 135, 139, and 2967.

In both deployments, Gene utilizes the four new heuristics presented in this paper, as well as the GetPC heuristic used in existing polymorphic shellcode detectors, allowing us to compare the detection coverage of both approaches. The PEB heuristic matched in all of the attacks, supporting the fact that this is the most widely used technique for resolving `kernel32.dll`. However, the GetPC heuristic was triggered only by 85,144 attacks, meaning that 31,369 attacks (27%) did not use any form of self-decrypting shellcode. This indicates that Gene's ability to detect plain shellcode increased the detection coverage for server-side code injection attacks by 37% compared to existing polymorphic shellcode detection approaches. By statically analyzing the identified machine code, we confirmed that in all cases, it corresponds to actual shellcode, and so far, we have not encountered any false positives.

### 6. Discussion

The runtime heuristics presented in this paper enable Gene to detect a broad range of different shellcode classes. While we cannot exclude the possibility that there are other kinds of Windows shellcode or alternative techniques that may have escaped our attention or have not been publicly released yet, the architecture of Gene allows for the parallel evaluation of multiple heuristics. Thus, the detection engine can be easily extended with more heuristics for other shellcode types. For example, for our experimental evaluation, we have already implemented a fifth heuristic based on the widely used GetPC code technique used in existing polymorphic shellcode detectors. In our future work, we plan to implement heuristics for detecting the code required in a swarm attack, Linux-specific plain shellcode, and Windows shellcode that uses hard-coded addresses.

A well-known evasion technique against dynamic code analysis systems is the use of very long loops that force the detector to spend countless cycles before any signs of malicious behavior are shown. Gene uses infinite loop squashing to reduce the number of inputs that reach the execution threshold. According to the literature, the percentage of inputs with an instruction sequence that reaches the execution threshold ranges between 3-6%, which we also verified during our experiments. Since this is a small fraction of all inspected inputs, the endless loops in these sequences can potentially be analyzed further at a second stage using other techniques such as static analysis or symbolic execution.

Another inherent limitation of emulation-based shellcode detection is the lack of an accurate view of the system's state at the time the injected code would run on the victim system. This information includes the values of the CPU registers and the complete address space of the particular exploited process. Although register values can sometimes be inferred, and Gene augments the emulator with the complete address space of a typical Windows process, including the most common system DLLs used by Windows shellcode, the shellcode may perform memory accesses to application-specific DLLs that are not known in advance and thus cannot be followed by the emulator. Fortunately, when protecting specific services, exact memory images of each service can be used in place of the generic process image. However, as discussed, the linear addresses of DLLs change frequently across different systems, and due to the increasing adoption of address space layout randomization and DLL rebasing, the use of absolute addressing results in less reliable shellcode. On the other hand, when the emulator runs within the context of a protected application, such as the browser-embedded detector proposed by Egele et al., the emulator can have full access to the complete address space of the process.

Some of the operations matched by the heuristics, such as the registration of a custom exception handler, might also be found in legitimate executables. However, Gene is tailored for scanning inputs that should not contain executable IA-32 code. In the case of file uploads, Gene can be extended to identify and extract executable files by looking for executable headers in the inspected traffic and then passing them to a virus scanner.

### 7. Related Work

Recognizing the limitations of signature-based approaches in the face of polymorphic code and targeted attacks, several research efforts have turned to static binary code analysis for identifying the presence of shellcode in network streams. One of the first such approaches by Toth and Kruegel uses code disassembly on network streams to identify the NOP-sled that sometimes precedes the shellcode. Focusing on the shellcode itself, Anderson et al. propose scanning each input for multiple occurrences of instruction sequences that end with an `int 0x80` instruction to identify Linux shellcode, with the rationale that the shellcode will need to execute several system calls. Other detection methods that use static code analysis aim to detect previously unknown polymorphic shellcode based on the identification of structural similarities among different worm instances, control and data flow analysis, or neural networks.

However, methods based on static analysis can be easily evaded by malicious code that uses obfuscation methods such as indirect jumps and self-modifications, which are widely used by current malware packers and polymorphic shellcode engines. In contrast, emulation-based detection can correctly handle even extensively obfuscated malicious code. Polychronakis et al. propose the use of code emulation for the detection of self-decrypting shellcode at the network level. The detection algorithm is based on the identification of the GetPC code and the self-references that occur during the execution of the shellcode. Zhang et al. propose combining network-level emulation with static and data flow analysis to improve the runtime performance of the GetPC heuristic.

Libemu is an open-source x86 emulation library tailored for shellcode analysis and detection. Shellcode execution is identified using the GetPC heuristic. Libemu can also emulate the execution of Windows API calls by creating a minimalistic process environment that allows the user to install custom hooks to API functions. Although the actual execution of API functions can be used as an indication of shellcode execution, these actions will be observed only after `kernel32.dll` has been resolved and the required API functions have been located through the Export Address Table (EAT) or Import Address Table (IAT). Compared to the `kernel32.dll` resolution heuristics presented in Section 3.1, this technique would require the execution of a much larger number of instructions until the first API function is called, and also the emulation of the actual functionality of each API call thereafter. This means that the execution threshold of the detector should be set much higher, resulting in degraded runtime performance. For applications in which the emulator can spend more cycles on each input, both heuristics can coexist and operate in parallel, e.g., along with all other heuristics used in Gene, offering even better detection accuracy.

Besides the detection of code injection attacks against network services, emulation-based shellcode detection using the GetPC heuristic has been used for the detection of drive-by download attacks and malicious websites. Egele et al. propose a technique that uses a browser-embedded CPU emulator to identify JavaScript string buffers that contain shellcode. Wepawet is a service for web-based malware detection that scans and identifies malicious web pages based on various indications, including the presence of shellcode. The CPU emulator in both projects is based on libemu.

Shellcode analysis systems help analysts study and understand the structure and functionality of a shellcode sample. Ma et al. used code emulation to extract the actual runtime instruction sequence of shellcode samples captured in the wild. Spector uses symbolic execution to extract the sequence of library calls made by the shellcode, along with their arguments, and generates a low-level execution trace at the end of the execution. Yataglass improves the analysis capabilities of Spector by handling shellcode that uses memory-scanning attacks.

### 8. Conclusion

The increasing professionalism of cyber criminals and the vast number of malware variants and malicious websites make effective code injection attack detection a critical challenge. To this end, shellcode detection using payload execution offers important advantages, including generic detection without exploit or vulnerability-specific signatures, practically zero false positives, and effectiveness against targeted attacks.

In this paper, we present a comprehensive shellcode detection method based on code emulation. Our approach expands the range of malicious code types that can be detected by enabling the parallel evaluation of multiple runtime heuristics that match inherent low-level operations during the execution of different shellcode types. The runtime heuristics presented in this work enable the effective detection of plain and metamorphic shellcode, both of which are not identified by existing shellcode detectors. This is achieved regardless of the use of self-modifying code or dynamic code generation, on which existing emulation-based polymorphic shellcode detectors are exclusively based.

Our experimental evaluation shows that the proposed approach can effectively detect a broad range of diverse shellcode types and implementations, significantly increasing the detection coverage compared to existing emulation-based detectors, while extensive testing with a large set of benign data did not produce any false positives. Gene, our prototype implementation of the proposed technique for the detection of server-side code injection attacks, detected 116,513 attacks against production systems in a period of almost five months without false positives.

Although Gene currently operates at the network level, the proposed detection heuristics can be readily implemented in emulation-based systems in other domains, including host-level or application-specific detectors. As part of our future work, we plan to implement more heuristics to cover the detection of less widely used shellcode types, such as shellcode that uses hard-coded addresses, and explore the design of a description language that would expedite the development of new heuristics.

### Acknowledgments

We would like to thank Periklis Akritidis and Angelos Keromytis for their valuable feedback on earlier versions of this paper. This work was supported in part by the Marie Curie FP7-PEOPLE-2009-IOF project MALCODE and the FP7 project SysSec, funded by the European Commission under Grant Agreements No. 254116 and No. 257007, and by the project i-Code, funded by the Prevention, Preparedness, and Consequence Management of Terrorism and other Security-related Risks Programme of the European Commission—Directorate-General for Home Affairs under Grant Agreement No. JLS/2009/CIPS/AG/C2-050. This publication reflects the views only of the authors, and the Commission cannot be held responsible for any use that may be made of the information contained herein. Michalis Polychronakis is also with FORTH-ICS. Evangelos Markatos is also with the University of Crete.

### 9. References

[1] Goodfellas security research team. http://goodfellas.shellcode.com.ar/.
[2] The Metasploit Project. http://www.metasploit.com/.
[3] milw0rm. http://milw0rm.com/shellcode/win32/.
[4] Packet Storm. http://www.packetstormsecurity.org/.
[5] Win32 Assembly Components, Dec. 2002. http://lsd-pl.net.
[6] Common Shellcode Naming Initiative, 2009. http://nepenthes.carnivore.it/csni.
[7] Retrieving kernel32’s base address, June 2009. http://www.harmonysecurity.com/blog/2009/06/retrieving-kernel32s-base-address.html.
[8] S. Andersson, A. Clark, and G. Mohay. Network-based buffer overflow detection by exploit code analysis. In Proceedings of the Asia Pacific Information Technology Security Conference (AusCERT), 2004.
[9] P. Baecher and M. Koetter. libemu, 2009. http://libemu.carnivore.it/.
[10] P. Bania. Evading network-level emulation, 2009. http://piotrbania.com/all/articles/pbania-evading-nemu2009.pdf.
[11] K. Borders, A. Prakash, and M. Zielinski. Spector: Automatically analyzing shell code. In Proceedings of the Annual Computer Security Applications Conference (ACSAC), 2007.
[12] R. Chinchani and E. V. D. Berg. A fast static analysis approach to detect exploit code inside network flows. In Proceedings of the 8th International Symposium on Recent Advances in Intrusion Detection (RAID), Sept. 2005.
[13] S. P. Chung and A. K. Mok. Swarm attacks against network-level emulation/analysis. In Proceedings of the 11th International Symposium on Recent Advances in Intrusion Detection (RAID), September 2008.
[14] M. Egele, P. Wurzinger, C. Kruegel, and E. Kirda. Defending browsers against drive-by downloads: Mitigating heap-spraying code injection attacks. In Proceedings of the 6th international conference on Detection of Intrusions and Malware, & Vulnerability Assessment (DIMVA), 2009.
[15] S. Ford, M. Cova, C. Kruegel, and G. Vigna. Wepawet, 2009. http://wepawet.cs.ucsb.edu/.
[16] I)ruid. Context-keyed payload encoding. Uninformed, 9, Oct. 2007.
[17] C. Kruegel, E. Kirda, D. Mutz, W. Robertson, and G. Vigna. Polymorphic worm detection using structural information of executables. In Proceedings of the 8th International Symposium on Recent Advances in Intrusion Detection (RAID), Sept. 2005.
[18] J. Ma, J. Dunagan, H. J. Wang, S. Savage, and G. M. Voelker. Finding diversity in remote code injection exploits. In Proceedings of the 6th Internet Measurement Conference (IMC), 2006.
[19] J. Mason, S. Small, F. Monrose, and G. MacManus. English shellcode. In Proceedings of the 16th ACM conference on Computer and communications security (CCS), 2009.
[20] U. Payer, P. Teufl, and M. Lamberger. Hybrid engine for polymorphic shellcode detection. In Proceedings of the Conference on Detection of Intrusions and Malware & Vulnerability Assessment (DIMVA), pages 19–31, July 2005.
[21] M. Pietrek. A crash course on the depths of Win32TM structured exception handling, 1997. http://www.microsoft.com/msj/0197/exception/exception.aspx.
[22] M. Polychronakis, K. G. Anagnostakis, and E. P. Markatos. An empirical study of real-world polymorphic code injection attacks. In Proceedings of the 2nd USENIX Workshop on Large-scale Exploits and Emergent Threats (LEET), April 2009.
[23] M. Polychronakis, E. P. Markatos, and K. G. Anagnostakis. Network-level polymorphic shellcode detection using emulation. In Proceedings of the Third Conference on Detection of Intrusions and Malware & Vulnerability Assessment (DIMVA), July 2006.
[24] M. Polychronakis, E. P. Markatos, and K. G. Anagnostakis. Emulation-based detection of non-self-contained polymorphic shellcode. In Proceedings of the 10th International Symposium on Recent Advances in Intrusion Detection (RAID), September 2007.
[25] M. Shimamura and K. Kono. Yataglass: Network-level code emulation for analyzing memory-scanning attacks. In Proceedings of the 6th international conference on Detection of Intrusions and Malware, & Vulnerability Assessment (DIMVA), 2009.
[26] sk. History and advances in windows shellcode. Phrack, 11(62), July 2004.
[27] Skape. Understanding Windows shellcode, 2003. http://www.hick.org/code/skape/papers/win32-shellcode.pdf.
[28] Skape. Safely searching process virtual address space, 2004. http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf.
[29] SkyLined. Finding the base address of kernel32 in Windows 7. http://skypher.com/index.php/2009/07/22/shellcode-finding-kernel32-in-windows-7/.
[30] SkyLined. SEH GetPC (XP SP3), July 2009. http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/ALPHA3/x86/ASCII/Mixedcase/SEH_GetPC_(XP_sp3).
[31] Y. Song, M. E. Locasto, A. Stavrou, A. D. Keromytis, and S. J. Stolfo. On the infeasibility of modeling polymorphic shellcode. In Proceedings of the 14th ACM conference on Computer and communications security (CCS), 2007.
[32] P. Ször. The Art of Computer Virus Research and Defense. Addison-Wesley Professional, February 2005.
[33] T. Toth and C. Kruegel. Accurate buffer overflow detection via abstract payload execution. In Proceedings of the 5th Symposium on Recent Advances in Intrusion Detection (RAID), Oct. 2002.
[34] X. Wang, Y.-C. Jhi, S. Zhu, and P. Liu. Still: Exploit code detection via static taint and initialization analyses. In Proceedings of the Annual Computer Security Applications Conference (ACSAC), 2008.
[35] X. Wang, C.-C. Pan, P. Liu, and S. Zhu. Sigfree: A signature-free buffer overflow attack blocker. In Proceedings of the USENIX Security Symposium, Aug. 2006.
[36] B.-J. Wever. SEH Omelet Shellcode, 2009. http://code.google.com/p/w32-seh-omelet-shellcode/.
[37] G. Wicherski. Win32 egg search shellcode, 33 bytes. http://blog.oxff.net/2009/02/win32-egg-search-shellcode-33-bytes.html.
[38] Q. Zhang, D. S. Reeves, P. Ning, and S. P. Lyer. Analyzing network traffic to detect self-decrypting exploit code. In Proceedings of the 2nd ACM Symposium on Information, Computer and Communications Security (ASIACCS), 2007.