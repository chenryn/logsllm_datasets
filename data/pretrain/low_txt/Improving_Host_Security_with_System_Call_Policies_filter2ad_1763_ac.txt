### Systrace Functionality and Policy Management

**System Call Return Value Reporting:**
If requested, Systrace reports the return value of a system call to indicate whether it was successfully executed. For `execve`, a successful execution indicates that the monitored process is running a new program. The policy can specify whether to detach from the process or allow a different policy to take effect. After these changes, the process execution resumes.

**Filesystem Security Assumptions:**
The security of our system relies on the integrity of the filesystem, which we assume to be secure. If an adversary gains control over the filesystem, they could modify policies determining permissible operations for monitored applications or replace trusted programs with malicious code. However, this does not prevent faulty applications with improper error handling from misbehaving. In such cases, Systrace can help identify incorrect exception handling.

**Audit Trails:**
Audit trails can be generated by adding the log modifier to policy statements. For example, to create an audit trail of all commands a user executes, it is sufficient to monitor their shell and log all `execve` calls.

**Privilege Elevation:**
Privilege elevation reduces the privileges required by an application during its execution. Applications that previously required root privileges for their entire lifetime now execute specific system calls with elevated privileges, while other system calls are executed with the privileges of the invoking user. The semantics of `setuid` prevent users from debugging privileged applications via `ptrace`. We apply the same semantics when a policy elevates an application's privileges.

### Policy Generation

Policy generation is often overlooked but is crucial for a sandbox to function correctly. A well-crafted policy restricts an application to a minimal set of operations without breaking its functionality. Our policy language allows iterative improvement by appending new policy statements.

**Automatic Policy Generation:**
We can generate policies automatically by executing applications and recording their normal behavior. When a system call not covered by the existing policy is encountered, a new policy statement is appended to match the current system call. The resulting policy covers the executed code path of the application. For applications with randomized arguments, post-processing makes the policy independent of random components.

**Example:**
- Initial policy: `fswrite: filename eq "/tmp/confJ31A69" then permit`
- Post-processed policy: `fswrite: filename match "/tmp/conf*" then permit`

**Challenges and Solutions:**
Automatic policy generation and profiling normal application behavior face similar challenges, such as ensuring no abnormal behavior during training and exhausting all possible code paths. Interactive and automatic policy generation complement each other. A complete policy is not required to sandbox an application; if an operation is not covered, a policy decision can be requested from the user.

### Case Study: Monkey.org

Monkey.org, a Unix shell provider in Ann Arbor, uses Systrace to sandbox over two hundred users. They generated separate policies for approximately 250 applications. Analysis shows that applications typically use seventy-one different system calls on average. By limiting the system calls available to an adversary, we reduce their potential to cause damage.

**Policy Violations:**
At monkey.org, Systrace generated approximately 350,000 log entries for 142 users over two months. By correlating the number of programs executed with the number of policy violations, unusual behavior can be identified. For instance, the web server attempting to execute user-created CGI scripts generated the most policy violations.

### Limitations

While powerful, policy enforcement at the system call level has limitations. Monitoring system calls does not provide complete information about an application's internal state. For example, system services may change process privileges based on authentication success, which a system call-level sandboxing tool cannot account for. However, global restrictions, such as never allowing root to log in, can still be enforced.

**Enhanced Security:**
To increase the security of authentication services like SSH, a combination of privilege separation and system call policy enforcement can be used. With privilege separation, most of the application runs in an unprivileged context. Systrace can prevent the unprivileged process from executing unnecessary system calls.

### Performance

To determine Systrace's performance impact, we measured its overhead on single system calls and several applications, repeating measurements at least five times on a 1.14 GHz Pentium III running OpenBSD.

**Microbenchmarks:**
- **geteuid System Call:**
  - Normal: 0.35 ± 0.00 µsec
  - In-kernel: 0.46 ± 0.01 µsec (31% ± 3% increase)
  - User space: 37.71 ± 0.18 µsec (due to context switches)

- **open System Call:**
  - Normal: 5.52 ± 0.01 µsec
  - In-kernel: 5.88 ± 0.03 µsec (7% ± 0.6% increase)
  - User space: 139.20 ± 0.09 µsec (for one directory component)

- **read System Call:**
  - Normal: 37.61 ± 0.03 µsec
  - In-kernel: 37.61 ± 0.03 µsec (no measurable difference)

**Macrobenchmark:**
- **gzip Execution Time:**
  - No significant effect on execution time due to computational intensity and relatively few system calls.

- **Filesystem Access Benchmark:**
  - Similar to the Andrew benchmark, involving copying, untarring, configuring, compiling, and deleting files.
  - Approximately 137,000 system calls executed.
  - Most frequent system call: `break` for memory allocation.

Enforcing system call policies adds overhead, but the overall increase is small, on average.