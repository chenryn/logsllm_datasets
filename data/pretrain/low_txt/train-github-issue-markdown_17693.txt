The Ansible documentation for modules does not clearly differentiate between pure modules and those that have both a plugin and a module component. After the recent internal rewrite, where plugins are now derived from a base class instead of being associated with a runner object, this lack of distinction can be confusing.

An action plugin is derived from `ActionBase`, which includes the `_execute_module()` method. This method only calls the module part of a "module" (a term that could be more precise) and does not invoke the plugin part. This affects several plugins, such as the `unarchive` plugin, which has a `copy=yes/no` parameter to transfer files to a remote host. However, the file transfer logic is in the plugin part, not the module part. As a result, when the `unarchive` plugin is used in a playbook, it works as expected, but when invoked directly from another plugin, it fails with a "file failed to transfer" error. This means that the code in `unarchive` must be duplicated into the new plugin, which is illogical and frustrating.

Another example is the `stat` plugin, which has a `follow=yes/no` parameter to follow symbolic links. The logic for this parameter is in `module_utils/basic.py`, which is not invoked when the `stat` plugin is run in a plugin context. Consequently, the `follow` parameter does not function correctly within a plugin.

In Ansible V1, this issue was manageable because there were two ways to execute a module: the current method and `self.runner._executor_internal_inner()`, which would invoke a module as a plugin rather than a pure remote module. This second method is absent in V2, and no clear workaround has been found yet.

To resolve this, if it is intended to support plugin development in Ansible, it should be made clear to developers what functionality exists in a module that can be invoked from a plugin. The documentation should specify which parameters will not have any effect when running `_execute_module()`. Alternatively, there should be another method within `ActionBase` to invoke other plugins or a documented alternative approach. 

Maintaining the current state leads to frustration in troubleshooting and API paranoia, as developers are left wondering whether a function will behave as expected.