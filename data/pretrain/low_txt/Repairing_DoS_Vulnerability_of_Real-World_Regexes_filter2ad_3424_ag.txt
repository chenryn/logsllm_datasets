以下是优化后的参考文献列表，使其更加清晰、连贯和专业：

1. Y. Liu, M. Zhang, and W. Meng, “Revealer: Detecting and Exploiting Regular Expression Denial-of-Service Vulnerabilities,” in *2021 IEEE Symposium on Security and Privacy (SP)*, Los Alamitos, CA, USA: IEEE Computer Society, May 2021, pp. 1468–1484. [Online]. Available: https://doi.ieeecomputersociety.org/10.1109/SP40001.2021.00062

2. J. C. Davis, “The Impact of Regular Expression Denial of Service in Practice,” 2018. [Online; accessed 10-December-2021]. Available: https://infosecwriteups.com/introduction-redos-987fdc4c7b0

3. R. Alquézar and A. Sanfeliu, “Incremental Grammatical Inference from Positive and Negative Data Using Unbiased Finite State Automata,” in *Proceedings of the ACL'02 Workshop on Unsupervised Lexical Acquisition*, 1994, pp. 291–300.

4. M. Lee, S. So, and H. Oh, “Synthesizing Regular Expressions from Examples for Introductory Automata Assignments,” *ACM SIGPLAN Notices*, vol. 52, no. 3, pp. 70–80, Oct. 2016. [Online]. Available: https://doi.org/10.1145/3093335.2993244

5. A. Bartoli, G. Davanzo, A. D. Lorenzo, E. Medvet, and E. Sorio, “Automatic Synthesis of Regular Expressions from Examples,” *IEEE Computer*, vol. 47, no. 12, pp. 72–80, Dec. 2014.

6. R. Pan, Q. Hu, G. Xu, and L. D’Antoni, “Automatic Repair of Regular Expressions,” *Proceedings of the ACM on Programming Languages*, vol. 3, no. OOPSLA, Oct. 2019. [Online]. Available: https://doi.org/10.1145/3360565

7. Q. Chen, X. Wang, X. Ye, G. Durrett, and I. Dillig, “Multi-Modal Synthesis of Regular Expressions,” in *Proceedings of the 41st ACM SIGPLAN International Conference on Programming Language Design and Implementation (PLDI 2020)*, London, UK, June 15-20, 2020, A. F. Donaldson and E. Torlak, Eds. ACM, 2020, pp. 487–502. [Online]. Available: https://doi.org/10.1145/3385412.3385988

8. Y. Li, Z. Xu, J. Cao, H. Chen, T. Ge, S.-C. Cheung, and H. Zhao, “FlashRegex: Deducing Anti-Redos Regexes from Examples,” in *Proceedings of the 35th ACM/IEEE International Conference on Automated Software Engineering (ASE 2020)*, Virtual Event, Australia, September 21-25, 2020. [Online]. Available: https://doi.org/10.1145/3324884.3416556

9. J. E. F. Friedl, *Mastering Regular Expressions: Understand Your Data and Be More Productive* (3rd ed.). O’Reilly Media, 2006.

10. D. D. Freydenberger, “Extended Regular Expressions: Succinctness and Decidability,” *Theory of Computing Systems*, vol. 53, no. 2, pp. 159–193, 2013. [Online]. Available: https://doi.org/10.1007/s00224-012-9389-0

11. C. Koch and S. Scherzinger, “Attribute Grammars for Scalable Query Processing on XML Streams,” *The VLDB Journal*, vol. 16, no. 3, pp. 317–342, Jul. 2007. [Online]. Available: https://doi.org/10.1007/s00778-005-0169-1

12. A. Brüggemann-Klein and D. Wood, “One-Unambiguous Regular Languages,” *Information and Computation*, vol. 142, no. 2, pp. 182–206, 1998. [Online]. Available: http://www.sciencedirect.com/science/article/pii/S089054019792695X

13. A. Brüggemann-Klein, “Unambiguity of Extended Regular Expressions in SGML Document Grammars,” in *Algorithms—ESA '93*, T. Lengauer, Ed. Berlin, Heidelberg: Springer Berlin Heidelberg, 1993, pp. 73–84.

14. G. Tiwari, “HTML/XML Tag Parsing Using Regex in Java,” 2011. [Online; accessed 10-December-2021]. Available: http://blog.gtiwari333.com/2011/12/htmlxml-tag-parsing-using-regex-in-java.html

15. L. G. Michael, J. Donohue, J. C. Davis, D. Lee, and F. Servant, “Regexes Are Hard: Decision-Making, Difficulties, and Risks in Programming Regular Expressions,” in *2019 34th IEEE/ACM International Conference on Automated Software Engineering (ASE)*, Nov. 2019, pp. 415–426.

16. RegExLib, 2021. [Online]. Available: https://regexlib.com/

17. J. Goyvaerts and S. Levithan, *Regular Expressions Cookbook* (2nd ed.). O’Reilly Media, 2012.

18. S. Medeiros, F. Mascarenhas, and R. Ierusalimschy, “From Regexes to Parsing Expression Grammars,” *Science of Computer Programming*, vol. 93, pp. 3–18, 2014. [Online]. Available: https://doi.org/10.1016/j.scico.2012.11.006

19. K. Thompson, “Programming Techniques: Regular Expression Search Algorithm,” *Communications of the ACM*, vol. 11, no. 6, pp. 419–422, Jun. 1968. [Online]. Available: https://doi.org/10.1145/363347.363387

20. M. Sipser, *Introduction to the Theory of Computation*. PWS Publishing Company, 1997.

21. R. M. Karp, “Reducibility Among Combinatorial Problems,” in *Complexity of Computer Computations*, Boston, MA: Springer US, 1972, pp. 85–103. [Online]. Available: https://doi.org/10.1007/978-1-4684-2001-2_9

22. L. de Moura and N. Bjørner, “Z3: An Efficient SMT Solver,” in *Proceedings of the 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS'08/ETAPS'08)*, Berlin, Heidelberg: Springer-Verlag, 2008, pp. 337–340.

23. P. Wang and K. T. Stolee, “How Well Are Regular Expressions Tested in the Wild?” in *Proceedings of the 2018 26th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE 2018)*, New York, NY, USA: Association for Computing Machinery, 2018, pp. 668–678. [Online]. Available: https://doi.org/10.1145/3236024.3236072

24. T. Miyazaki and Y. Minamide, “Derivatives of Regular Expressions with Lookahead,” *Journal of Information Processing*, vol. 27, pp. 422–430, 2019. [Online]. Available: https://doi.org/10.2197/ipsjjip.27.422

25. B. van der Merwe, N. Weideman, and M. Berglund, “Turning Evil Regexes Harmless,” in *Proceedings of the South African Institute of Computer Scientists and Information Technologists (SAICSIT '17)*, New York, NY, USA: Association for Computing Machinery, 2017. [Online]. Available: https://doi.org/10.1145/3129416.3129440

26. REMEDY, 2022. [Online]. Available: https://github.com/NariyoshiChida/SP2022

27. J. C. Davis, L. G. Michael IV, C. A. Coghlan, F. Servant, and D. Lee, “Why Aren’t Regular Expressions a Lingua Franca? An Empirical Study on the Re-Use and Portability of Regular Expressions,” in *Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE 2019)*, New York, NY, USA: Association for Computing Machinery, 2019, pp. 443–454. [Online]. Available: https://doi.org/10.1145/3338906.3338909

28. B. Loring, D. Mitchell, and J. Kinder, “Sound Regular Expression Semantics for Dynamic Symbolic Execution of JavaScript,” in *Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2019)*, New York, NY, USA: Association for Computing Machinery, 2019, pp. 425–438. [Online]. Available: https://doi.org/10.1145/3314221.3314645

29. M. L. Schmid, “Characterising Regular Languages by Factor-Referencing,” *Information and Computation*, vol. 249, pp. 1–17, 2016. [Online]. Available: http://www.sciencedirect.com/science/article/pii/S0890540116000109

30. B. Cody-Kenny, M. Fenton, A. Ronayne, E. Considine, T. McGuire, and M. O’Neill, “A Search for Improved Performance in Regular Expressions,” in *Proceedings of the Genetic and Evolutionary Computation Conference (GECCO '17)*, New York, NY, USA: Association for Computing Machinery, 2017, pp. 1280–1287. [Online]. Available: https://doi.org/10.1145/3071178.3071196

31. J. C. Davis, F. Servant, and D. Lee, “Using Selective Memoization to Defeat Regular Expression Denial of Service (ReDoS),” in *2021 IEEE Symposium on Security and Privacy (SP)*, Los Alamitos, CA, USA: IEEE Computer Society, May 2021, pp. 543–559. [Online]. Available: https://doi.ieeecomputersociety.org/10.1109/SP40001.2021.00032

### 附录A：形式语义的完整规则
图11展示了推导匹配关系 (cid:59) 的完整规则。我们在第III节中未解释的纯正则表达式特性在此进行了描述。

- **字符集**：
  - 规则 ([C], w, p, Γ, φ) (cid:57)(cid:57)(cid:75) ({(p + 1, Γ, φ)}, /0) 表示如果字符串 w 在位置 p 处的字符 w[p] 属于字符集 C，则匹配成功，返回匹配结果 (p + 1, Γ)。
  - 否则，如果 w[p] 不属于 C 或者 p 已到达字符串末尾，则返回空集 /0，表示匹配失败。

- **空字符串**、**连接**、**并集** 和 **重复** 规则是自解释的。注意，在 **重复** 规则中，我们通过不在同一位置重复匹配来避免自循环。

### 附录B：生成与示例一致性的约束的完整规则
图12展示了生成与示例一致性的约束的完整规则。匹配失败的情况，即 (r, w, p, Γ, φ) (cid:57)(cid:57)(cid:75) (/0, {(⊥, ⊥, φ)}) 被省略。

### 附录C：定理IV.2的证明
我们首先回顾精确覆盖问题（Exact Cover）。

**定义C.1（精确覆盖）**：给定有限集合 U 和 S ⊂ P(U)，精确覆盖问题是决定是否存在 S' ⊆ S 使得对于每一个 i ∈ U，存在唯一的 S ∈ S' 使得 i ∈ S。

**证明**：我们将精确覆盖问题归约到修复问题。设 S = {S1, S2, ..., Sk}。我们创建以下（决策版本的）RWS1U 修复问题：

- 字母表 Σ = U；
- 正例集合 P = U；
- 负例集合 N = /0；
- 距离界限为 2k；
- 预修复表达式 r1 = r11r12，其中 r11 和 r12 定义如下：
  - r11 = ε(?=[S1])2k(ε)1[S1](ε)2 | ε(?=[S2])2k(ε)3[S2](ε)4 | ... | ε(?=[Sk])2k(ε)2k−1[Sk](ε)2k
  - r12 = ((?!\3)|(?=\3\4))2k...((?!\2k−1)|(?=\2k−1\2k))2k
  - 这里，r2k 是将 r 重复 2k 次得到的表达式。

显然，这是一个多项式时间归约，因为 r1 的构造可以在输入 EXACTCOVER 实例大小的三次时间内完成。此外，上述是一个有效的 RWS1U 修复问题实例，因为 P = U ⊆ L(r1) 并且 L(r1) ∩ N = /0。我们证明归约是正确的，即输入 EXACTCOVER 实例有解当且仅当存在 r2 满足条件 (1)-(3) 并且 D(r1, r2) ≤ 2k。

- **仅如果方向**：假设 S' ⊂ S 是 EXACTCOVER 实例的一个解。修复后的表达式 r2 = r21r22，其中 r22 = r12，r21 是 r11，但每个 i-th 头部 ε 在并集中被替换为 [/0] 如果 Si ∉ S'。注意到 D(r1, r2) = 2|S \ S'| ≤ 2k。同时，r2 满足 RWS1U 条件，因为对于每一个 a ∈ U，存在唯一的 Si ∈ S' 使得 a ∈ Si，即在任何以 a 开头的输入字符串上，我们确定性地移动到并集中的 i-th 选择（并且之后没有分支）。此外，r2 正确分类了示例。考虑任意 a ∈ P = U，那么 a 包含在某个 Si ∈ S' 中。因此，匹配通过 r21 部分，并在索引 2i−1 和 2i 处成功捕获，然后通过 r22 部分，因为负向前瞻 (?!\j) 成功。

希望这些优化后的文本能更好地满足您的需求。