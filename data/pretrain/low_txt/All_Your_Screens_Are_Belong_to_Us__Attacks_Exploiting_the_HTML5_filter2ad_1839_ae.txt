### CSRF Tokens and Screen Sharing Attacks

A CSRF (Cross-Site Request Forgery) token is a security measure that assumes an attacker cannot extract the session ID. This session ID can act as a random CSRF token. However, with the assistance of screen sharing, an attacker can easily read the page source and thus obtain the CSRF token. In such cases, using the double submit cookies technique not only fails to prevent CSRF attacks but also leads to session hijacking.

### Best Practices for Users

Users can mitigate screen sharing attacks in several ways:
- Use trusted screen sharing websites and share screens only with trusted users.
- Log out of important accounts before initiating a screen sharing session and log back in after it ends.

However, these measures can compromise usability, as users must repeatedly log in and out. Therefore, user-based approaches are less effective than browser-based or website-based solutions, which do not rely heavily on user actions.

### Related Work

#### CSRF Attacks and Defenses

Basic CSRF attacks have been known for several years. For sites already vulnerable to basic CSRF, the screen sharing API is not necessary to compromise the account. Our focus is on websites that implement popular CSRF defenses.

Previous studies have explored various methods to steal CSRF tokens, each with limitations:
- **E. Vela** [19] demonstrated a CSS-only attribute reader, but it is impractical for reading high-entropy CSRF tokens quickly.
- **Heiderich et al.** [20] proposed a CSS attack using web-fonts, CSS animations, and the CSS content property, requiring around 100 HTTP requests. This method is less efficient compared to screen sharing attacks, which can easily steal CSRF tokens.
- A recent CSRF attack against Facebook [21] involved framing unprotected pages and generating a captcha from the CSRF token, requiring multiple user interactions. In contrast, screen sharing attacks do not need such interactions.

Multiple CSRF defense mechanisms have been proposed:
- **SOMA** [22] and **App Isolation** [23] define valid entry points for websites, but whitelisting every entry point is infeasible.
- **Gazelle** [24] and **Tahoma** [25] provide cookie isolation, but strict isolation has usability issues.
- **Barth et al.** [14] studied current CSRF defenses, including CSRF tokens, Referer header validation, and custom headers, and proposed checking the origin of requests. While CSRF tokens are reliable if well-implemented, they fail during screen sharing as the attacker can directly read the token.
- **Mao et al.** [26] suggested inferring user intentions by checking the Source-set of a request, but this method is vulnerable to referer manipulation and raises privacy concerns.

#### Frame Busting

Rydstedt et al. [15] proposed best practices for frame busting in JavaScript. However, many frame busting techniques are unreliable and can be bypassed. Although 55% of the Alexa top 100 websites use X-Frame-Options, adding this option to all sensitive pages within a domain is challenging. Even with proper frame busting and X-Frame-Options, attackers can still use pop-up windows to open target sites and steal information during screen sharing.

#### XSS (Cross-Site Scripting)

XSS is a common method for stealing user information. Many XSS defenses [28][29][30] exist, but they are still vulnerable in the context of screen sharing, as the attacker can directly view user information on the screen.

#### History Sniffing

History sniffing attacks exploit the difference in rendered colors between visited and unvisited links. Browser vendors have fixed these vulnerabilities, but the screen sharing API allows attackers to observe link colors directly, bypassing these defenses.

#### Screen-Capture Attacks

Previous work on screen-capture attacks focused on stealing credentials, such as passwords entered through virtual keyboards [35]. Our study assumes that users will not input sensitive information while their screen is being shared, which is more realistic.

#### Vulnerabilities of Other HTML5 APIs

Other HTML5 APIs, such as the fullscreen API and the postMessage API, are also vulnerable:
- The **fullscreen API** can be used for phishing attacks with fake UIs.
- The **postMessage API** aims to provide secure cross-origin communication but is often misused due to its complexity [37].

### Conclusion

The new screen sharing API enables real-time media sharing but undermines the same-origin policy, creating a feedback loop from the user to the server. We analyzed the security concerns raised by this API, including the risk of viewing cross-origin content and the potential for attackers to manipulate sessions and view sensitive information. Browser vendors should assess the impact on user security before releasing this API. Users need to be aware of the security and privacy risks associated with screen sharing. Our study provides a new paradigm for understanding and defending against screen sharing attacks, encouraging further research to develop effective solutions.

### Acknowledgments

We thank the Google Chrome team members, Adam Barth, Justin Schuh, Adrienne Porter Felt, Mustafa Emre Acer, James Weatherall, Victoria Kirst, and Sergey Ulanov for their guidance. We also thank Sid Stamm and Daniel Veditz from Mozilla for their feedback. Additionally, we appreciate the suggestions from our colleagues and friends: Eric Y. Chen, David Liu, Emmanuel Owusu, Brian Ricks, and Mike Xie.

### References

[1] Google Inc, “Google voice and video chat,” 2013, https://www.google.com/chat/video.

[2] WebRTC, “Web real-time communications working group,” 2013, http://www.w3.org/2011/04/webrtc/.

[3] WebRTC, “Webrtc general overview,” 2013, http://www.webrtc.org/reference/architecture.

[4] WebRTC, “Webrtc interop notes,” 2013, http://www.webrtc.org/interop.

[5] V. Roth, K. Richter, and R. Freidinger, “A pin-entry method resilient against shoulder surfing,” in Proceedings of the 11th ACM conference on Computer and communications security. ACM, 2004, pp. 25–29.

[6] Google Chrome, “Chrome autofill forms,” 2013, http://support.google.com/chrome/bin/answer.py?hl=en&answer=142893.

[7] Google Inc, “Stable channel update,” 2013, http://googlechromereleases.blogspot.com/2013/07/stable-channel-update.html.

[8] E. Bidelman, “Chrome extension api with binary websocket,” 2012, http://www.html5rocks.com/en/tutorials/streaming/screenshare/#toc-method3.

[9] E. Bidelman, “Screensharing a browser tab in html5?” 2012, http://www.html5rocks.com/en/tutorials/streaming/screenshare.

[10] E. Bidelman, “Capturing audio & video in html5,” 2012, http://www.html5rocks.com/en/tutorials/getusermedia/intro/.

[11] J. Grossman, “Breaking browsers: Hacking auto-complete,” 2010, http://jeremiahgrossman.blogspot.com/2010/08/breaking-browsers-hacking-auto-complete.html.

[12] A. M. Lits, “Apple-sa-2010-07-28-1 safari 5.0.1 and safari 4.1.1,” 2010, http://lists.apple.com/archives/security-announce/2010//Jul/msg00001.html.

[13] Bugs@Mozilla, “Bug 527935 - (cve-2011-0067) untrusted events should not trigger autocomplete popup,” 2009, https://bugzilla.mozilla.org/show_bug.cgi?id=527935.

[14] A. Barth, C. Jackson, and J. C. Mitchell, “Robust defenses for cross-site request forgery,” in Proceedings of the 15th ACM Conference on Computer and Communications Security, 2008.

[15] G. Rydstedt, E. Bursztein, D. Boneh, and C. Jackson, “Busting frame busting: a study of clickjacking vulnerabilities on popular sites,” in Web 2.0 Security and Privacy, 2010.

[16] Bugzilla@Mozilla, “Bug 624883- iframe with src=”view-source...” should be treated as an unknown scheme,” 2014, https://bugzilla.mozilla.org/show_bug.cgi?id=624883.

[17] J. Grossman, “Proof-of-concept: Safari autofill attack,” 2010, http://ha.ckers.org/weird/safari_autofill.html.

[18] OWASP, “HTTP csrf cheat sheet,” 2013, https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet.

[19] E. Vela, “CSS attribute reader proof of concept,” 2011, http://eaea.sirdarckcat.net/cssar/v2/.

[20] M. Heiderich, M. Niemietz, F. Schuster, T. Holz, and J. Schwenk, “Scriptless attacks: stealing the pie without touching the sill,” in Proceedings of the 2012 ACM Conference on Computer and Communications Security. ACM, 2012, pp. 760–771.

[21] Crazyflx, “Own friends walls facebook of silently wall your to visitors your site,” 2013, http://www.blackhatworld.com/blackhat-seo/facebook/597969-own-facebook-exploit-silently-post-wall-friends-walls-visitors-your-site.html.

[22] T. Oda, G. Wurster, P. C. van Oorschot, and A. Somayaji, “SOMA: mutual approval for included content in web pages,” in Proceedings of the 15th ACM conference on Computer and Communications Security, 2008.

[23] E. Y. Chen, J. Bau, C. Reis, A. Barth, and C. Jackson, “App isolation: get the security of multiple browsers with just one,” in Proceedings of the 18th ACM Conference on Computer and Communications Security. ACM, 2011, pp. 227–238.

[24] H. J. Wang, C. Grier, A. Moshchuk, S. T. King, P. Choudhury, and H. Venter, “The multi-principal OS construction of the Gazelle web browser,” in USENIX Security Symposium, 2009, pp. 417–432.

[25] R. S. Cox, J. G. Hansen, S. D. Gribble, and H. M. Levy, “A safety-oriented platform for web applications,” in Security and Privacy, 2006 IEEE Symposium on. IEEE, 2006, pp. 15–pp.

[26] Z. Mao, N. Li, and I. Molloy, “Defeating cross-site request forgery attacks with browser-enforced authenticity protection,” in Financial Cryptography and Data Security. Springer, 2009, pp. 238–255.

[27] M. Jakobsson and S. Stamm, “Invasive browser sniffing and countermeasures,” in Proceedings of the 15th international conference on World Wide Web. ACM, 2006, pp. 523–532.

[28] P. Saxena, D. Molnar, and B. Livshits, “Scriptgard: Preventing script injection attacks in legacy web applications with automatic sanitization,” Citeseer, Tech. Rep., 2010.

[29] S. Stamm, B. Sterne, and G. Markham, “Reining in the web with content security policy,” in Proceedings of the 19th international conference on World wide web. ACM, 2010, pp. 921–930.

[30] J. Weinberger, P. Saxena, D. Akhawe, M. Finifter, R. Shin, and D. Song, “A systematic analysis of XSS sanitization in web application frameworks,” in Computer Security–ESORICS 2011. Springer, 2011, pp. 150–171.

[31] C. Jackson, A. Bortz, D. Boneh, and J. C. Mitchell, “Protecting browser state from web privacy attacks,” in Proceedings of the 15th international conference on World Wide Web. ACM, 2006, pp. 737–744.

[32] D. Jang, R. Jhala, S. Lerner, and H. Shacham, “An empirical study of privacy-violating information flows in JavaScript web applications,” in Proceedings of the 17th ACM conference on Computer and Communications Security. ACM, 2010, pp. 270–283.

[33] A. Janc and L. Olejnik, “Web browser history detection as a real-world privacy threat,” in Computer Security–ESORICS 2010. Springer, 2010, pp. 215–231.

[34] L. D. Baron, “Preventing attacks on a user’s history through CSS :visited selectors,” 2010, http://dbaron.org/mozilla/visited-privacy/.

[35] A. Parekh, A. Pawar, P. Munot, and P. Mantri, “Secure authentication using anti-screenshot virtual keyboard,” International Journal of Computer Science Issues(IJCSI), vol. 8, no. 5, 2011.

[36] Feross Aboukhadijeh, “Using the HTML5 fullscreen API for phishing attacks,” 2012, http://feross.org/html5-fullscreen-api-attack/.

[37] S. Hanna, R. Shin, D. Akhawe, A. Boehm, P. Saxena, and D. Song, “The emperor’s new APIs: On the (in)secure usage of new client-side primitives,” in Proceedings of the Web 2.0 Security and Privacy. IEEE, 2010.