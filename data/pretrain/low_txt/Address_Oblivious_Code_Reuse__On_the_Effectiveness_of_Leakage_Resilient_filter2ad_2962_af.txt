### Missing the Point(er): On the Effectiveness of Code Pointer Integrity
- **Conference**: 36th IEEE Symposium on Security and Privacy (S&P), 2015.

### Control Jujutsu: On the Weaknesses of Fine-Grained Control Flow Integrity
- **Authors**: I. Evans, F. Long, U. Otgonbaatar, H. Shrobe, M. Rinard, H. Okhravi, S. Sidiroglou-Douskos.
- **Conference**: ACM Conference on Computer and Communications Security (CCS), 2015.

### The Process File System and Process Model in Unix System V
- **Authors**: R. Faulkner, R. Gomes.
- **Conference**: USENIX Technical Conference (ATC), 1991.

### Enabling Client-Side Crash-Resistance to Overcome Diversification and Information Hiding
- **Authors**: R. Gawlik, B. Kollenda, P. Koppe, B. Garmany, T. Holz.
- **Conference**: 23rd Annual Network and Distributed System Security Symposium (NDSS), 2016.

### HideM: Protecting the Contents of Userspace Memory in the Face of Disclosure Vulnerabilities
- **Authors**: J. Gionta, W. Enck, P. Ning.
- **Conference**: 5th ACM Conference on Data and Application Security and Privacy (CODASPY), 2015.

### Enhanced Operating System Security through Efficient and Fine-Grained Address Space Randomization
- **Authors**: C. Giuffrida, A. Kuijsten, A. S. Tanenbaum.
- **Conference**: 21st USENIX Security Symposium (USENIX Sec), 2012.

### Undermining Information Hiding (and What to Do About It)
- **Authors**: E. Göktas, R. Gawlik, B. Kollenda, E. Athanasopoulos, G. Portokalidis, C. Giuffrida, H. Bos.
- **Conference**: 25th USENIX Security Symposium, 2016.

### ILR: Where’d My Gadgets Go?
- **Authors**: J. Hiser, A. Nguyen, M. Co, M. Hall, J. Davidson.
- **Conference**: 33rd IEEE Symposium on Security and Privacy (S&P), 2012.

### On the Challenges of Effective Movement
- **Authors**: T. Hobson, H. Okhravi, D. Bigelow, R. Rudd, W. Streilein.
- **Workshop**: ACM CCS Moving Target Defense (MTD) Workshop, Nov 2014.

### Large-Scale Automated Software Diversity—Program Evolution Redux
- **Authors**: A. Homescu, T. Jackson, S. Crane, S. Brunthaler, P. Larsen, M. Franz.
- **Journal**: IEEE Transactions on Dependable and Secure Computing, Pre-Print, 2015.

### Practical Timing Side Channel Attacks Against Kernel Space ASLR
- **Authors**: R. Hund, C. Willems, T. Holz.
- **Conference**: 34th IEEE Symposium on Security and Privacy (S&P), 2013.

### Intel 64 and IA-32 Architectures Software Developer’s Manual
- **Source**: Intel, Chapter 28, 2015.

### Memento: Learning Secrets from Process Footprints
- **Authors**: S. Jana, V. Shmatikov.
- **Conference**: 33rd IEEE Symposium on Security and Privacy (S&P), 2012.

### Address Space Layout Permutation (ASLP): Towards Fine-Grained Randomization of Commodity Software
- **Authors**: C. Kil, J. Jun, C. Bookholt, J. Xu, P. Ning.
- **Conference**: 22nd Annual Computer Security Applications Conference (ACSAC), 2006.

### Processes as Files
- **Author**: T. J. Killian.
- **Conference**: USENIX Association Software Tools Users Group Summer Conference (STUG), 1984.

### Code-Pointer Integrity
- **Authors**: V. Kuznetsov, L. Szekeres, M. Payer, G. Candea, R. Sekar, D. Song.
- **Conference**: 11th USENIX Symposium on Operating Systems Design and Implementation (OSDI), 2014.

### SoK: Automated Software Diversity
- **Authors**: P. Larsen, A. Homescu, S. Brunthaler, M. Franz.
- **Conference**: 35th IEEE Symposium on Security and Privacy (S&P), 2014.

### Losing Control: On the Effectiveness of Control-Flow Integrity Under Stack Attacks
- **Authors**: C. Liebchen, M. Negro, P. Larsen, L. Davi, A.-R. Sadeghi, S. Crane, M. Qunaibit, M. Franz, M. Conti.
- **Conference**: ACM Conference on Computer and Communications Security (CCS), 2015.

### Polymorphing Software by Randomizing Data Structure Layout
- **Authors**: Z. Lin, R. D. Riley, D. Xu.
- **Conference**: 6th International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment (DIMVA), 2009.

### How to Make ASLR Win the Clone Wars: Runtime Re-Randomization
- **Authors**: K. Lu, S. Nürnberger, M. Backes, W. Lee.
- **Conference**: 23rd Annual Network and Distributed System Security Symposium (NDSS), 2016.

### ASLR-Guard: Stopping Address Space Leakage for Code Reuse Attacks
- **Authors**: K. Lu, C. Song, B. Lee, S. P. Chung, T. Kim, W. Lee.
- **Conference**: ACM Conference on Computer and Communications Security (CCS), 2015.

### What Cannot Be Read, Cannot Be Leveraged? Revisiting Assumptions of JIT-ROP Defenses
- **Authors**: G. Maisuradze, M. Backes, C. Rossow.
- **Conference**: 25th USENIX Security Symposium (USENIX Sec), 2016.

### CCFI: Cryptographically Enforced Control Flow Integrity
- **Authors**: A. J. Mashtizadeh, A. Bittau, D. Boneh, D. Mazières.
- **Conference**: ACM Conference on Computer and Communications Security (CCS), 2015.

### SoftBound: Highly Compatible and Complete Spatial Memory Safety for C
- **Authors**: S. Nagarakatte, J. Zhao, M. M. Martin, S. Zdancewic.
- **Conference**: ACM Conference on Programming Language Design and Implementation (PLDI), 2009.

### Poking Holes in Information Hiding
- **Authors**: A. Oikonomopoulos, E. Athanasopoulos, H. Bos, C. Giuffrida.
- **Conference**: 25th USENIX Security Symposium (USENIX Sec), 2016.

### Finding Focus in the Blur of Moving-Target Techniques
- **Authors**: H. Okhravi, T. Hobson, D. Bigelow, W. Streilein.
- **Journal**: Security & Privacy, IEEE, 12(2):16–26, Mar 2014.

### Smashing the Stack for Fun and Profit
- **Author**: A. One.
- **Publication**: Phrack Magazine, 7, 1996.

### Smashing the Gadgets: Hindering Return-Oriented Programming Using In-Place Code Randomization
- **Authors**: V. Pappas, M. Polychronakis, A. D. Keromytis.
- **Conference**: 33rd IEEE Symposium on Security and Privacy (S&P), 2012.

### Flip Feng Shui: Hammering a Needle in the Software Stack
- **Authors**: K. Razavi, B. Gras, E. Bosman, B. Preneel, C. Giuffrida, H. Bos.
- **Conference**: 25th USENIX Security Symposium, 2016.

### Counterfeit Object-Oriented Programming: On the Difficulty of Preventing Code Reuse Attacks in C++ Applications
- **Authors**: F. Schuster, T. Tendyck, C. Liebchen, L. Davi, A.-R. Sadeghi, T. Holz.
- **Conference**: 36th IEEE Symposium on Security and Privacy (S&P), 2015.

### Information Leaks Without Memory Disclosures: Remote Side Channel Attacks on Diversified Code
- **Authors**: J. Seibert, H. Okhravi, E. Söderström.
- **Conference**: ACM Conference on Computer and Communications Security (CCS), 2014.

### CVE-2012-0769, the Case of the Perfect Info Leak
- **Author**: F. J. Serna.
- **Year**: 2012.

### The Geometry of Innocent Flesh on the Bone: Return-Into-LIBC Without Function Calls (on the x86)
- **Author**: H. Shacham.
- **Conference**: ACM Conference on Computer and Communications Security (CCS), 2007.

### On the Effectiveness of Address-Space Randomization
- **Authors**: H. Shacham, M. Page, B. Pfaff, E.-J. Goh, N. Modadugu, D. Boneh.
- **Conference**: Proc. of ACM CCS, pages 298–307, 2004.

### Systematic Analysis of Defenses Against Return-Oriented Programming
- **Authors**: R. Skowyra, K. Casteel, H. Okhravi, N. Zeldovich, W. Streilein.
- **Conference**: 16th International Symposium on Research in Attacks, Intrusions, and Defenses (RAID’13), LNCS, pages 82–102, Oct 2013.

### Just-in-Time Code Reuse: On the Effectiveness of Fine-Grained Address Space Layout Randomization
- **Authors**: K. Z. Snow, F. Monrose, L. Davi, A. Dmitrienko, C. Liebchen, A. Sadeghi.
- **Conference**: 34th IEEE Symposium on Security and Privacy (S&P), 2013.

### Return to the Zombie Gadgets: Undermining Destructive Code Reads via Code Inference Attacks
- **Authors**: K. Z. Snow, R. Rogowski, J. Werner, H. Koo, F. Monrose, M. Polychronakis.
- **Conference**: 37th IEEE Symposium on Security and Privacy, 2016.

### Grsecurity
- **Source**: B. Spengler.
- **URL**: http://grsecurity.net, 2015.

### Breaking the Memory Secrecy Assumption
- **Authors**: R. Strackx, Y. Younan, P. Philippaerts, F. Piessens, S. Lachmund, T. Walter.
- **Conference**: 2nd European Workshop on System Security (EUROSEC), 2009.

### SoK: Eternal War in Memory
- **Authors**: L. Szekeres, M. Payer, T. Wei, D. Song.
- **Conference**: IEEE Symposium on Security and Privacy, 2013.

### Heisenbyte: Thwarting Memory Disclosure Attacks Using Destructive Code Reads
- **Authors**: A. Tang, S. Sethumadhavan, S. Stolfo.
- **Conference**: ACM Conference on Computer and Communications Security (CCS), 2015.

### A Tough Call: Mitigating Advanced Code-Reuse Attacks at the Binary Level
- **Authors**: V. van der Veen, E. Göktas, M. Contag, A. Pawlowski, X. Chen, S. Rawat, H. Bos, T. Holz, E. Athanasopoulos, C. Giuffrida.
- **Conference**: 37th IEEE Symposium on Security and Privacy, 2016.

### Binary Stirring: Self-Randomizing Instruction Addresses of Legacy x86 Binary Code
- **Authors**: R. Wartell, V. Mohan, K. W. Hamlen, Z. Lin.
- **Conference**: ACM Conference on Computer and Communications Security (CCS), 2012.

### No-Execute-After-Read: Preventing Code Disclosure in Commodity Software
- **Authors**: J. Werner, G. Baltas, R. Dallara, N. Otternes, K. Snow, F. Monrose, M. Polychronakis.
- **Conference**: 11th ACM Symposium on Information, Computer and Communications Security (ASIACCS), 2016.

### Subverting the Xen Hypervisor
- **Author**: R. Wojtczuk.
- **Conference**: Blackhat USA (BH US), 2008.

### Mitigating Storage Side Channels Using Statistical Privacy Mechanisms
- **Authors**: Q. Xiao, M. K. Reiter, Y. Zhang.
- **Conference**: ACM Conference on Computer and Communications Security (CCS), 2015.

### Peeping Tom in the Neighborhood: Keystroke Eavesdropping on Multi-User Systems
- **Authors**: K. Zhang, X. Wang.
- **Conference**: 18th USENIX Security Symposium (USENIX Sec), 2009.

### Appendix

#### A. NGINX Attack 2 Details
Nginx's design employs a master process that handles signal processing and spawns worker processes to handle requests via `fork` calls. This processing loop is implemented by the `ngx_master_process_cycle` function, which is called from `main` after Nginx configures itself. The trampoline address of this function can be determined via profiling after causing a system call to hang. Since `ngx_master_process_cycle` forks, worker processes inherit the parent's current stack, including the return address trampoline of `ngx_master_process_cycle`.

Return addresses are replaced with a pointer to a trampoline whose code resembles the following:
```c
ngx_master_process_cycle
call
jmp callsite_main
```
The return address points to the `jmp` instruction. From this address, we can derive the location of the `call` instruction.

Identifying the relevant return address on the stack is straightforward, as Nginx's initial execution is predictable. The `ngx_master_process_cycle` frame will be near the base of the stack, immediately after the `main` stack frame.

Once the address of `ngx_master_process_cycle` is found, we can exploit a function pointer in the Nginx worker's log handler. The `log_error_core` function contains a pointer to a log handler function taking three arguments: `p = log->handler(log, p, last-p)`.

There are multiple system calls in the function prior to the pointer being dereferenced during a logging event, which enables us to hang the program via MTB and corrupt the handler to point instead at `ngx_master_process_cycle`. To prevent a program crash, we must also modify the first argument (log) to resemble the `ngx_cycle_t` expected by `ngx_master_process_cycle`. The parameter is not used in our attack, so any non-crashing value suffices.

To execute a reverse shell, we set `ngx_argv` as follows:
```c
ngx_argv[0] = "/usr/bin/python3"
ngx_argv[1] = "-c"
ngx_argv[2] = "import os,socket,subprocess; s=socket.socket(socket.AF_INET, socket.SOCK_STREAM); s.connect(('127.0.0.1', 1234)); [os.dup2(s.fileno(), i) for i in range(3)]; subprocess.call(['/bin/sh', '-i']);"
ngx_argv[3] = 0
```

Once we have pointed the log handler at `ngx_master_process_cycle`, we must ensure that the target function's execution causes an `exec` under our control. This can be achieved via the range of signals that Nginx can handle in `ngx_master_process_cycle`. Specifically, Nginx provides a `new_binary` signal for rolling updates without compromising availability. This signal handler is invoked when an integer variable named `ngx_change_binary` is non-zero. The path to the binary is stored in `ngx_argv`, another global variable. By corrupting the first global value, we ensure that an `exec` call will eventually be made when the log handler pointer is dereferenced. By corrupting the latter, we ensure that a binary of our choice is executed.

#### B. Apache Attack Details
Apache uses its own portable runtime libraries (APR and APR-Util) to maintain portability across operating systems. However, modules may call functions in these libraries that the base Apache process does not. The build process ensures that all APR functions and related utility libraries are linked during compilation, whether or not they are explicitly used in the base code. This is achieved via an `exports.c` file for each library, which contains function pointers to every function in that library.

One of these exported functions is `ap_get_exec_line` in Apache's server utility library (`httpd.h`), which takes three arguments: a pointer to a valid memory pool, a command to run, and the arguments to supply that command. We recover the trampoline for this function by profiling while hanging execution via MTB. The region of memory containing pointers from `exports.c` is easily identified, as it contains nothing but function pointers (with common higher-order bits) pointing to functions in one library. The order in which function pointers are declared in `exports.c` is deterministic, so recovering the pointer for `ap_get_exec_line` is straightforward.

Next, we corrupt a function pointer to point to the revealed address. When choosing the pointer, we must ensure that the parameters passed to `ap_get_exec_line` are passed correctly, as this attack does not rely on global variables like the Nginx variant. Additionally, our ability to modify memory is limited to the periods surrounding system calls. Only functions that pass parameters via pointers to memory addresses are viable. Given these criteria, we chose to corrupt the `errfn` pointer in `sed_reset_eval`, part of Apache’s `mod_sed`.

Finally, we set `errfn` to point to `ap_get_exec_line`. The first argument pointer is corrupted to point at a valid `apr_pool_t` object, which the attacker-controlled worker will likely already have. (APR pools are used to handle memory allocation in Apache.) The second pointer is made to point at a string containing the path to a binary of our choice. When the `errfn` pointer is dereferenced, the binary is executed.