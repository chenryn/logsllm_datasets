### 6.4.1 Sensitive Data Lifespan

A common defense against data-oriented attacks is to limit the lifespan of security-critical data [19, 20]. This case study highlights the challenges in implementing this correctly. In the SSHD implementation, the program explicitly zeros out sensitive data, such as RSA private keys, as soon as they are no longer needed. For password authentication on Linux, the `getspnam()` function from glibc is often used to obtain the password hash. Instead of using the password hash directly, SSHD makes a local copy of the hash on the stack for its use. Although the program does not explicitly clear this copy, the stack memory is eventually overwritten by subsequent function frames before it can be leaked. The developer uses `endspent()` [1] to deallocate the original hash value in glibc's internal data structures. However, glibc does not clear the deallocated memory after `endspent()` is called, allowing FLOWSTITCH to successfully leak the hash from the copy held by glibc. This case study underscores the importance of ensuring that sensitive information is not retained by the program after use and the difficulty of identifying all copies of sensitive data in memory at the source level.

### 6.4.2 Multi-edge Stitch – ghttpd CGI Directory

The ghttpd application is a lightweight web server that supports CGI. A stack buffer overflow vulnerability was reported in versions 1.4.0 to 1.4.3, allowing remote attackers to corrupt the stack of the vulnerable `Log()` function. During the identification of security-sensitive data, FLOWSTITCH detected that `execv()` is used to run an executable file, with one of its arguments being the address of the program path string. Controlling this argument allows attackers to execute arbitrary commands. FLOWSTITCH could not find a new data dependency edge using single-edge stitching because there was no security-sensitive data on the stack frame to corrupt. FLOWSTITCH then searched for a multi-edge stitch. For the program path parameter of `execv()`, FLOWSTITCH identified its flow, which includes the use of a series of stack frame-based pointers saved in memory. The temporal constraints of the memory error exploit only allowed the saved `%ebp` of the `Log()` function to be corrupted. Once the `Log()` function returns, the saved `%ebp` is used as a pointer, referring to all the local variables and parameters of the caller's stack frame. FLOWSTITCH corrupted the saved `%ebp` to change the variable for the CGI directory used in the `execv()` system call. This attack is a four-edge stitch, composed of two pointer stitches.

Chen et al. [19] discussed a data-oriented attack with the same vulnerability, which was a two-edge stitch. However, that attack no longer works in our experiment. The ghttpd program compiled on our Ubuntu 12.04 platform does not store the address of the command string on the stack frame of `Log()`. Only the four-edge stitching can be used to attack our ghttpd binary.

### 6.4.3 Bypassing ASLR – orzhttpd Attacks

The orzhttpd web server has a format string vulnerability that allows an attacker to control almost the entire memory space of the vulnerable program. FLOWSTITCH identifies the deterministic memory region and the randomized address on the stack under the `fprintf()` frame. The first attack bypasses ASLR and escalates privileges. This attack corrupts the web root directory using single-edge stitching and memory address reuse. The root directory string is stored on the heap, which is allocated at runtime. FLOWSTITCH identifies the address of the heap string from the stack and reuses it to change the string to `/` based on the predefined goal (Section 4.2). The second attack is an information leakage attack, which leaks randomized addresses in the `.got.plt` section. FLOWSTITCH identifies the deterministic memory region from the binary and performs a multi-edge stitch. The stitch involves modifying the pointer of an HTTP protocol string stored in a deterministic memory region. FLOWSTITCH changes the pointer value to the address of the `.got.plt` section, and a subsequent call to send the HTTP protocol string leaks the randomized addresses to the attacker.

### 6.4.4 Privilege Escalation – Nginx Root Directory

Nginx HTTP server versions 1.3.9-1.4.0 have a buffer overflow vulnerability [4]. FLOWSTITCH checks the local variables on the vulnerable stack and identifies two data pointers that can be used to perform arbitrary memory corruption. The memory influence of the overwriting is limited by the program logic. FLOWSTITCH identifies the web root directory string from the configuration data and attempts single-edge stitching to corrupt the root directory setting. The root directory string is within the memory influence of the arbitrary overwriting. FLOWSTITCH overwrites the value `0x002f` into the string location, changing the root directory to `/`. FLOWSTITCH verifies the attack by requesting the `/etc/passwd` file, and the server sends the file content back to the client.

### 6.4.5 Information Leakage – httpdx Password

The httpdx server has a format string vulnerability between versions 1.4 and 1.5 [3]. The vulnerable `tolog()` function records FTP commands and HTTP requests into a server-side log file. Direct exploitation of this vulnerability does not leak information. Using the error-exhibiting trace, FLOWSTITCH identifies the memory error instruction and determines that there is almost no limitation on the memory range affected by the attacker. From the httpdx binary, FLOWSTITCH finds a total of 102MB of deterministic memory addresses. From the benign trace, FLOWSTITCH generates data flows of the root user passwords, which are the secrets to be leaked. FLOWSTITCH generates the necessary data flow that reaches the `send()` system call automatically. Starting from the memory error instruction, FLOWSTITCH searches backward in the secret data flow and identifies vertices inside the deterministic memory region. FLOWSTITCH successfully finds two such memory locations containing the "admin" password: one is a buffer containing the whole configuration file, and the other contains only the password. Simultaneously, FLOWSTITCH searches forward in the output flow to find the vertices that affect the buffer argument of `send()`. The solver provides one possible input that triggers the attack. FLOWSTITCH confirms this attack by providing the attack input to the server and receiving the "admin" user password.

### 7 Related Work

**Data-Oriented Attack:** Several works [21, 32, 36, 38, 41, 43, 44] have improved the practicality of Control Flow Integrity (CFI), increasing the barrier to constructing control flow hijacking attacks. Data-oriented attacks are serious alternatives. These attacks have been conceptually known for a decade, and Chen et al. [19] constructed non-control-data exploits to demonstrate their realistic threat. However, no systematic method for developing data-oriented attacks was known until now. In this paper, we develop a systematic way to search for possible data-oriented attacks, efficiently and effectively searching within the candidate space.

**Automatic Exploit Generation:** Brumley et al. [17] described an automatic exploit generation technique based on program patches, identifying differences between patched and unpatched binaries and generating inputs to trigger these differences. Avgerinos et al. [13] discussed Automatic Exploit Generation (AEG) to generate real exploits resulting in a working shell. Felmetger et al. [24] discussed automatic exploit generation for web applications. Previous work focused on generating control flow hijacking exploits. FLOWSTITCH, on the other hand, generates data-oriented attacks that do not violate control flow integrity. To our knowledge, FLOWSTITCH is the first tool to systematically generate data-oriented attacks.

**Defenses against Data-Oriented Attacks:** Data-oriented attacks can be prevented by enforcing data-flow integrity (DFI). Existing work enforces DFI through dynamic information tracking [23, 39, 40] or legitimate memory modification instruction analysis [18, 42]. However, DFI defenses are not yet practical, requiring large overheads or manual declassification. An ultimate defense is to enforce memory safety to prevent attacks in their initial steps. Cyclone [27] and CCured [31] introduce a safe type system to the type-unsafe C language. SoftBound [29] with CETS [30] uses bound checking with fat-pointers to enforce complete memory safety. Cling [11] enforces temporal memory safety through type-safe memory reuse. Preventing data-oriented attacks requires complete memory safety.

### 8 Conclusion

In this paper, we present a new concept called data-flow stitching and develop a novel solution to systematically construct data-oriented attacks. We discuss innovative stitching methods, including single-edge stitch, multi-edge stitch, stitch with deterministic addresses, and stitch by address reuse. We build a prototype of data-flow stitching, called FLOWSTITCH, which generates 19 data-oriented attacks from eight vulnerable programs. Sixteen of these attacks were previously unknown. All attacks bypass DEP and CFI checks, and 10 bypass ASLR. The results show that automatic generation of data-oriented exploits exhibiting significant damage is practical.

### Acknowledgments

We thank R. Sekar, Shweta Shinde, Yaoqi Jia, Xiaolei Li, Shruti Tople, Pratik Soni, and the anonymous reviewers for their insightful comments. This research is supported in part by the National Research Foundation, Prime Minister’s Office, Singapore, under its National Cybersecurity R&D Program (Award No. NRF2014NCR-NCR001-21) and administered by the National Cybersecurity R&D Directorate, and in part by a research grant from Symantec.

### References

[1] Endspent(3C). https://docs.oracle.com/cd/E36784_01/html/E36874/endspent-3c.html.
[2] How Effective is ASLR on Linux Systems? http://securityetalii.es/2013/02/03/how-effective-is-aslr-on-linux-systems/.
[3] HTTPDX tolog() Function Format String Vulnerability. http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-4769.
[4] Nginx HTTP Server 1.3.9-1.4.0 Chunked Encoding Stack Buffer Overflow. http://mailman.nginx.org/pipermail/nginx-announce/2013/000112.html.
[5] OrzHTTPd. https://code.google.com/p/orzhttpd/.
[6] Subverting without EIP. http://mallocat.com/subverting-without-eip/.
[7] The Heartbleed Bug. http://heartbleed.com/.
[8] Visual Studio 2015 Preview: Work-in-Progress Security Feature. http://blogs.msdn.com/b/vcblog/archive/2014/12/08/visual-studio-2015-preview-work-in-progress-security-feature.aspx.
[9] Sudo Format String Vulnerability. http://www.sudo.ws/sudo/alerts/sudo_debug.html, 2012.
[10] ABADI, M., BUDIU, M., ERLINGSSON, U., AND LIGATTI, J. Control-Flow Integrity. In Proceedings of the 12th ACM Conference on Computer and Communications Security (2005).
[11] AKRITIDIS, P. Cling: A Memory Allocator to Mitigate Dangling Pointers. In Proceedings of the 19th USENIX Security Symposium (2010).
[12] ANDERSEN, S., AND ABELLA, V. Changes to Functionality in Microsoft Windows XP Service Pack 2, Part 3: Memory Protection Technologies, Data Execution Prevention. Microsoft TechNet Library, September 2004.
[13] AVGERINOS, T., CHA, S. K., HAO, B. L. T., AND BRUMLEY, D. AEG: Automatic Exploit Generation. In Proceedings of the 18th Annual Network and Distributed System Security Symposium (2011).
[14] BACKES, M., HOLZ, T., KOLLENDA, B., KOPPE, P., NÜRNBERGER, S., AND PEWNY, J. You Can Run but You Can’t Read: Preventing Disclosure Exploits in Executable Code. In Proceedings of the 21st ACM Conference on Computer and Communications Security (2014).
[15] BHATKAR, S., DUVARNEY, D. C., AND SEKAR, R. Address Obfuscation: An Efficient Approach to Combat a Broad Range of Memory Error Exploits. In Proceedings of the 12th USENIX Security Symposium (2003).
[16] BRUMLEY, D., JAGER, I., AVGERINOS, T., AND SCHWARTZ, E. J. BAP: A Binary Analysis Platform. In Proceedings of the 23rd International Conference on Computer Aided Verification (2011).
[17] BRUMLEY, D., POOSANKAM, P., SONG, D., AND ZHENG, J. Automatic Patch-Based Exploit Generation is Possible: Techniques and Implications. In Proceedings of the 29th IEEE Symposium on Security and Privacy (2008).
[18] CASTRO, M., COSTA, M., AND HARRIS, T. Securing Software by Enforcing Data-Flow Integrity. In Proceedings of the 7th Symposium on Operating Systems Design and Implementation (2006).
[19] CHEN, S., XU, J., SEZER, E. C., GAURIAR, P., AND IYER, R. K. Non-Control-Data Attacks Are Realistic Threats. In Proceedings of the 14th USENIX Security Symposium (2005).
[20] CHOW, J., PFAFF, B., GARFINKEL, T., AND ROSENBLUM, M. Shredding Your Garbage: Reducing Data Lifetime Through Secure Deallocation. In Proceedings of the 14th USENIX Security Symposium (2005).
[21] CRISWELL, J., DAUTENHAHN, N., AND ADVE, V. KCoFI: Complete Control-Flow Integrity for Commodity Operating System Kernels. In Proceedings of the 35th IEEE Symposium on Security and Privacy (2014).
[22] DE MOURA, L., AND BJØRNER, N. Z3: An Efficient SMT Solver. In Proceedings of the Theory and Practice of Software, 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems (2008).
[23] ENCK, W., GILBERT, P., CHUN, B.-G., COX, L. P., JUNG, J., MCDANIEL, P., AND SHETH, A. N. TaintDroid: An Information-Flow Tracking System for Realtime Privacy Monitoring on Smartphones. In Proceedings of the 9th USENIX Conference on Operating Systems Design and Implementation (2010).
[24] FELMETSGER, V., CAVEDON, L., KRUEGEL, C., AND VIGNA, G. Toward Automated Detection of Logic Vulnerabilities in Web Applications. In Proceedings of the 19th USENIX Security Symposium (2010).
[25] GODEFROID, P., LEVIN, M. Y., AND MOLNAR, D. A. Automated Whitebox Fuzz Testing. In Proceedings of the 15th Annual Network and Distributed System Security Symposium (2008), Internet Society.
[26] GODEFROID, P., AND TALY, A. Automated Synthesis of Symbolic Instruction Encodings from I/O Samples. In Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation (2012).
[27] JIM, T., MORRISETT, J. G., GROSSMAN, D., HICKS, M. W., CHENEY, J., AND WANG, Y. Cyclone: A Safe Dialect of C. In Proceedings of the USENIX Annual Technical Conference (2002).
[28] LUK, C.-K., COHN, R., MUTH, R., PATIL, H., KLAUSER, A., LOWNEY, G., WALLACE, S., REDDI, V. J., AND HAZELWOOD, K. Pin: Building Customized Program Analysis Tools with Dynamic Instrumentation. In Proceedings of the 2005 ACM SIGPLAN Conference on Programming Language Design and Implementation (2005).
[29] NAGARAKATTE, S., ZHAO, J., MARTIN, M. M., AND ZDANCEWIC, S. SoftBound: Highly Compatible and Complete Spatial Memory Safety for C. In Proceedings of the 30th ACM SIG-PLAN Conference on Programming Language Design and Implementation (2009).
[30] NAGARAKATTE, S., ZHAO, J., MARTIN, M. M., AND ZDANCEWIC, S. CETS: Compiler Enforced Temporal Safety for C. In Proceedings of the 9th International Symposium on Memory Management (2010).
[31] NECULA, G. C., MCPEAK, S., AND WEIMER, W. CCured: Type-Safe Retrofitting of Legacy Code. In Proceedings of the 29th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (2002).
[32] NIU, B., AND TAN, G. Modular Control-Flow Integrity. In Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation (2014).
[33] PAX TEAM. PaX Address Space Layout Randomization (ASLR). http://pax.grsecurity.net/docs/aslr.txt, 2003.
[34] PAYER, M., AND GROSS, T. R. String Oriented Programming: When ASLR is Not Enough. In Proceedings of the 2nd ACM SIGPLAN Program Protection and Reverse Engineering Workshop (2013).
[35] SERNA, F. J. The Info Leak Era on Software Exploitation. Black Hat USA (2012).
[36] TICE, C., ROEDER, T., COLLINGBOURNE, P., CHECKOWAY, S., ERLINGSSON, U., LOZANO, L., AND PIKE, G. Enforcing Forward-Edge Control-Flow Integrity in GCC & LLVM. In Proceedings of the 23rd USENIX Security Symposium (2014).
[37] UBUNTU. List of Programs Built with PIE, May 2012. https://wiki.ubuntu.com/Security/Features#pie.
[38] WANG, Z., AND JIANG, X. HyperSafe: A Lightweight Approach to Provide Lifetime Hypervisor Control-Flow Integrity. In Proceedings of the 31st IEEE Symposium on Security and Privacy (2010).
[39] XU, W., BHATKAR, S., AND SEKAR, R. Taint-Enhanced Policy Enforcement: A Practical Approach to Defeat a Wide Range of Attacks. In Proceedings of the 15th USENIX Security Symposium (2006).
[40] YIP, A., WANG, X., ZELDOVICH, N., AND KAASHOEK, M. F. Improving Application Security with Data Flow Assertions. In Proceedings of the ACM SIGOPS 22nd Symposium on Operating Systems Principles (2009).
[41] ZENG, B., TAN, G., AND ERLINGSSON, U. Strato: A Retargetable Framework for Low-Level Inlined-Reference Monitors. In Proceedings of the 22nd USENIX Security Symposium (2013).
[42] ZENG, B., TAN, G., AND MORRISETT, G. Combining Control-Flow Integrity and Static Analysis for Efficient and Validated Data Sandboxing. In Proceedings of the 18th ACM Conference on Computer and Communications Security (2011).
[43] ZHANG, C., WEI, T., CHEN, Z., DUAN, L., SZEKERES, L., MCCAMANT, S., SONG, D., AND ZOU, W. Practical Control Flow Integrity and Randomization for Binary Executables. In Proceedings of the 34th IEEE Symposium on Security and Privacy (2013).
[44] ZHANG, M., AND SEKAR, R. Control Flow Integrity for COTS Binaries. In Proceedings of the 22nd USENIX Security Symposium (2013).

---

This optimized version improves the clarity, coherence, and professionalism of the text, making it more suitable for academic and technical audiences.