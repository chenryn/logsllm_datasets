Certainly! Below is the optimized and refined version of your text, ensuring it is more clear, coherent, and professional:

---

**References:**

[1] "I/OMMU Vulnerability," in Proc. Int. Conf. on Malicious and Unwanted Software (MALWARE), 2010, pp. 7–14.

[2] A. Markuze, A. Morrison, and D. Tsafrir, "True IOMMU Protection from DMA Attacks: When Copy is Faster than Zero Copy," in ASPLOS, 2016, pp. 249–262.

[3] G. Klein, K. Elphinstone, G. Heiser, J. Andronick, D. Cock, P. Derrin, D. Elkaduwe, K. Engelhardt, R. Kolanski, M. Norrish, T. Sewell, H. Tuch, and S. Winwood, "seL4: Formal Verification of an OS Kernel," in ACM SOSP, 2009, pp. 207–220.

[4] A. Vasudevan, S. Chaki, L. Jia, J. McCune, J. Newsome, and A. Datta, "Design, Implementation, and Verification of an Extensible and Modular Hypervisor Framework," in IEEE S&P, 2013, pp. 430–444.

[5] A. Vasudevan, S. Chaki, P. Maniatis, L. Jia, and A. Datta, "Überspark: Enforcing Verifiable Object Abstractions for Automated Compositional Security Analysis of a Hypervisor," in USENIX Security, 2016, pp. 87–104.

[6] A. Ferraiuolo, A. Baumann, C. Hawblitzel, and B. Parno, "Komodo: Using Verification to Disentangle Secure-Enclave Hardware from Software," in ACM SOSP, 2017, pp. 287–305.

[7] I. GreenHills Software, "Integrity-178B Separation Kernel Security Target," https://www.commoncriteriaportal.org/files/epfiles/st_vid10362-st.pdf [Accessed on 2 Dec 2020], 2010.

[8] J. M. Rushby, "Separation and Integration in MILS (The MILS Constitution)," Technical Report SRI-CSL-08-XX, February 2008.

[9] P. Colp, M. Nanavati, J. Zhu, W. Aiello, G. Coker, T. Deegan, P. Loscocco, and A. Warfield, "Breaking Up Is Hard to Do: Security and Functionality in a Commodity Hypervisor," in ACM SOSP, 2011, pp. 189–202.

[10] Z. Zhou, V. D. Gligor, J. Newsome, and J. M. McCune, "Building Verifiable Trusted Path on Commodity x86 Computers," in IEEE S&P, 2012.

[11] K. R. M. Leino, "Dafny: An Automatic Program Verifier for Functional Correctness," in LPAR'10, 2010, pp. 348–370. [Online]. Available: http://dl.acm.org/citation.cfm?id=1939141.1939161

[12] Z. Zhou, M. Yu, and V. D. Gligor, "Dancing with Giants: Wimpy Kernels for On-Demand Isolated I/O," in IEEE S&P, 2014, pp. 308–323.

[13] B. Bond, C. Hawblitzel, M. Kapritsos, K. R. M. Leino, J. R. Lorch, B. Parno, A. Rane, S. Setty, and L. Thompson, "Vale: Verifying High-Performance Cryptographic Assembly Code," in USENIX Security, 2017, pp. 917–934.

[14] R. Achermann, N. Hossle, L. Humbel, D. Schwyn, D. Cock, and T. Roscoe, "A Least-Privilege Memory Protection Model for Modern Hardware," 2019.

[15] T. Shanley and D. Anderson, *PCI System Architecture*, 4th ed. Addison-Wesley Professional, 1999.

[16] The System Management Interface Forum (SMIF), Inc., "System Management Bus (SMBus) Specification Version 2.0," 2000.

[17] K. Koscher, A. Czeskis, F. Roesner, S. Patel, T. Kohno, S. Checkoway, D. McCoy, B. Kantor, D. Anderson, H. Shacham, and S. Savage, "Experimental Security Analysis of a Modern Automobile," in IEEE S&P, 2010, pp. 447–462.

[18] ARM, "ARM AMBA 5 AHB Protocol Specification," 2015.

[19] O. Peleg, A. Morrison, B. Serebrin, and D. Tsafrir, "Utilizing the IOMMU Scalably," in USENIX ATC, 2015, pp. 549–562.

[20] J. Zaddach, A. Kurmus, D. Balzarotti, E. Blass, A. Francillon, T. Goodspped, M. Gupta, and I. Koltsidas, "Implementation and Implications of a Stealth Hard-Drive Backdoor," in ACM ACSAC, 2013.

[21] C. L. Rothwell, "Exploitation from Malicious PCI Express Peripherals, PhD Thesis, University of Cambridge, Computer Laboratory, UCAM-CL-TR-934," Feb 2019.

[22] T. Markettos, C. Rothwell, B. Gutstein, A. Pearce, P. Neumann, S. Moore, and R. Watson, "Thunderclap: Exploring Vulnerabilities in Operating System IOMMU Protection via DMA from Untrustworthy Peripherals," in NDSS, 2019.

[23] J. Applebaum, J. Horchert, and C. Stocker, "Catalog Reveals NSA Has Back Doors for Numerous Devices," Spiegel Online, 2013. [Online]. Available: https://www.spiegel.de/international/world/nsa-has-back-doors-for-numerous-devices-a-940994.html

[24] S. Anthony, "Massive, Undetectable Security Flaw in USB: It’s Time to Get Your PS/2 Keyboard Out of the Cupboard," Extreme Tech, July 31, 2014. [Online]. Available: https://www.extremetech.com

[25] L. Mearian, "There’s No Way of Knowing if the NSA’s Spyware Is on Your Hard Drive," Computerworld, vol. 2, 2015.

[26] L. Constantin, "What Is a 'Supply Chain Attack?'," Motherboard, Sept. 2017. [Online]. Available: https://motherboard.vice.com/en_us/article/d3y48v/what-is-a-supply-chain-attack

[27] V. Gligor and M. Woo, "Establishing Software Root of Trust Unconditionally," in NDSS, 2019.

[28] Trusted Computing Group, "Hardware Requirements for Device Identifier Composition Engine," 2018. [Online]. Available: https://trustedcomputinggroup.org/wp-content/uploads/Hardware-Requirements-for-Device-Identifier-Composition-Engine-r78-For-Publication.pdf

[29] M. Yu, V. D. Gligor, and Z. Zhou, "Trusted Display on Untrusted Commodity Platforms," in ACM CCS, 2015, pp. 989–1003.

[30] D. Cerdeira, N. Santos, P. Fonseca, and S. Pinto, "SoK: Understanding the Prevailing Security Vulnerabilities in TrustZone-Assisted TEE Systems," in IEEE S&P, May 2020.

[31] J. M. McCune, Y. Li, N. Qu, Z. Zhou, A. Datta, V. Gligor, and A. Perrig, "TrustVisor: Efficient TCB Reduction and Attestation," in IEEE S&P, 2010.

[32] V. Costan and S. Devadas, "Intel SGX Explained," Cryptology ePrint Archive, Report 2016/086, 2016. [Online]. Available: https://eprint.iacr.org/2016/086

[33] Wikipedia, "CAN bus," 2019. [Online]. Available: https://en.wikipedia.org/wiki/CAN_bus

[34] P. Barham, B. Dragovic, K. Fraser, S. Hand, T. Harris, A. Ho, R. Neugebauer, I. Pratt, and A. Warfield, "Xen and the Art of Virtualization," in ACM SOSP, 2003.

[35] J. M. Rushby, "Design and Verification of Secure Systems," vol. 15, no. 5, pp. 12–21, 1981.

[36] K. Tian, Y. Dong, and D. Cowperthwaite, "A Full GPU Virtualization Solution with Mediated Pass-Through," in USENIX ATC, 2014, pp. 121–132.

[37] M. Peinado, Y. Chen, P. Engl, and J. Manferdelli, "NGSCB: A Trusted Open System," in Proc. Australasian Conference on Information Security and Privacy, 2004.

[38] Y. Cheng and X. Ding, "Guardian: Hypervisor as Security Foothold for Personal Computers," in TRUST, 2013.

[39] Z. Zhou, J. Han, Y.-H. Lin, A. Perrig, and V. Gligor, "KISS: Key It Simple and Secure Corporate Key Management," in TRUST, 2013.

[40] S. Weiser and M. Werner, "SGXIO: Generic Trusted I/O Path for Intel SGX," in CODASPY, 2017, pp. 261–268.

[41] P. Loscocco and S. Smalley, "Integrating Flexible Support for Security Policies into the Linux Operating System," in USENIX ATC, 2001, pp. 29–42.

[42] T. Murray, D. Matichuk, M. Brassil, P. Gammie, T. Bourke, S. Seefried, C. Lewis, X. Gao, and G. Klein, "seL4: From General Purpose to a Proof of Information Flow Enforcement," in IEEE S&P, 2013, pp. 415–429.

[43] H. Mai, E. Pek, H. Xue, S. T. King, and P. Madhusudan, "Verifying Security Invariants in ExpressOS," in ASPLOS, 2013, pp. 293–304.

---

**Appendix A: Operations for I/O Separation Model**

Each operation in the I/O separation model takes the current state \( k \) and the operation arguments and returns the resulting state \( k' \) as well as a boolean (decision) value \( d \), indicating whether the operation is successful. If \( d \) is true, the operation completes successfully; if \( d \) is false, the operation is denied and \( k' = k \). Below are the transitions defined by each operation:

1. **Driver Write:**
   - **Operation:** `DrvWrite(drv_id, td_id_val, fddo_id_val)`
   - **Description:** The driver with ID `drv_id` attempts to update TDs with new values `td_id_val` and FDs and DOs with new values `fddo_id_val`.
   - **Checks:**
     1. The driver must be in the same partition as all the objects specified by `td_id_val` and `fddo_id_val`.
     2. For the transitive closure, `tc`, of the TD state in the updated system state, `knew`, all objects to which transfers could be issued by any active device in `knew` must be in the same partition as the device and must not include a hardcoded TD.

2. **Device Write:**
   - **Operation:** `DevWrite(dev_id, td_id_val, fddo_id_val)`
   - **Description:** A device can also issue write requests. The state is updated without any checks.
   - **Rationale:** Device writes can only occur either as defined by the device’s hardcoded TD, which references device’s object only, or after appropriate driver write operations, which have already been allowed by the I/O kernel.

3. **Driver Read:**
   - **Operation:** `DrvRead(drv_id, read_objs_id, obj_dst_src)`
   - **Description:** The driver with ID `drv_id` attempts to read objects identified by their IDs in `read_objs` and stores a subset of the read values to objects with IDs specified by `obj_dst_src`, which maps destination object IDs to source object IDs.
   - **Checks:**
     1. The driver must be in the same partition as all objects in `read_objs`.
     2. The writes to the destination objects are allowed by the same checks as those specified in the Driver Write operation.

4. **Device Read:**
   - **Operation:** `DevRead(dev_id, read_objs, obj_dst_src)`
   - **Description:** Device read performs similar functions as Driver Read and is always allowed under the same conditions for Device write.

5. **Create Empty Partition:**
   - **Operation:** `EmptyPartitionCreate(new_pid)`
   - **Description:** To create a new I/O partition with ID `new_pid`, the ID `new_pid` must be a fresh ID; i.e., an ID that has not been used before.

6. **Destroy Empty Partition:**
   - **Operation:** `EmptyPartitionDestroy(pid)`
   - **Description:** This operation destroys an empty I/O partition `pid`. The partition ID `pid` must not be NULL and must exist in the set of existing partition IDs in the current state. Furthermore, no subject or object can exist in the partition `pid`.

7. **Driver/Device/External Objects Activation:**
   - **Operations:** `DrvActivate(drv_id, pid)`, `DevActivate(dev_id, pid)`, and `ExternalObjsActivate(obj_ids, pid)`
   - **Description:** These operations activate the given subject and external objects into the partition with ID `pid`.
   - **Checks:**
     1. The given subject and external objects must be inactive.
     2. The partition `pid` exists in the set of non-NULL partition IDs.
   - **Actions:**
     - To fulfill the security property SP2, the kernel clears the subject’s objects and all external objects to prevent object reuse between partitions, but does not modify any given device’s (immutable) hardcoded TD.
     - The given subject’s partition ID, its objects’ partition ID, and given external objects’ partition ID are updated to `pid`.

8. **Driver/Device/External Objects Deactivation:**
   - **Operations:** `DrvDeactivate(drv_id)`, `DevDeactivate(dev_id)`, and `ExternalObjsDeactivate(obj_ids, pid)`
   - **Description:** These operations deactivate the given subject and external objects.
   - **Checks:**
     1. The I/O kernel first checks that they are active.
     2. The I/O kernel computes the transitive closure (tc) of the TD state in the current system state.
     3. The kernel checks `tc` to ensure that no active device can issue transfers to any objects of the given subject, nor to the given external objects.
   - **Actions:**
     - On success, the kernel updates the partition ID of the given subject and its objects to be NULL.

---

**Appendix B: Dafny Specification Example**

**Simplified Specifications of Operations:**

Figure 9 presents a simplified Dafny specification of the Device Write operation. The operation takes the current state \( k \), the ID of the device issuing the write transfer, and IDs of objects to be modified together with the new values to be written. The operation returns the resulting state \( k' \), as well as a boolean value \( d \) to indicate whether the operation is allowed or denied. The specification includes preconditions and postconditions of the operation.

- **Preconditions:**
  - The current state \( k \) fulfills all the state invariants.
  - The device must be active.
  - The write transfers must be defined in TDs.

- **Postconditions:**
  - The result state \( k' \) fulfills all state invariants.
  - The operation fulfills all transition properties.
  - Written objects are in the I/O state.
  - All written objects must be in the same partition with the device.

**State Transition:**

The model calls the `K_CALCNEWSTATE` function to apply a single transition; that is, an operation on the state \( k \). As shown in Figure 10, the function takes a state \( k \) and the operation name `op` corresponding to the transition taking place. After the transition, it returns the result state and the boolean decision value \( d \).

- **Function Requirements:**
  - The state \( k \) is secure; i.e., it fulfills all state invariants.
  - Operations’ preconditions always imply operations’ postconditions.
  - The preconditions hold for the given operation `op`.

- **Function Body:**
  - The body of the `K_CALCNEWSTATE` function returns an arbitrary state fulfilling the post-conditions of operation `op`.
  - This function does not compute the result state \( k' \) by applying the implementations of operations. The operation correctness properties are not used in proving the theorems and the corollary, as long as the result state \( k' \) fulfills the postconditions of operations.

---

This optimized version ensures clarity, coherence, and professionalism, making the text more accessible and understandable.