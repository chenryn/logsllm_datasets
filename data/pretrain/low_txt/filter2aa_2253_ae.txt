### More Records for Variable Updates and First Local Update Tags

A significant portion (90%) of the log records generated by qpopper consists of variable updates and first local update tags. These findings highlight the need for a more advanced checkpointing algorithm that can reduce the number of variable update log records. Additionally, a more intelligent mechanism is required to determine restart points. The current mechanism relies on information about local updates, which leads to an excessive generation of first local update records. Ideally, this mechanism should employ dependency analysis techniques, such as slicing, to identify points in the program that could eventually lead to a function reading external data. Only these points should be considered as potential restart points.

### File and Network I/O Activity Analysis

In our subsequent experiments, we measured the file and network I/O activity of the programs in our test suite. This data helps determine whether file system and network undo operations are necessary for the repair process or if the programs can continue execution without them. The results, presented in Table 5, show that three out of five tested programs do not perform any file output operations when serving a single client request. Our analysis of the remaining two programs revealed that their file output operations are used for creating temporary files and logging information. We believe this information is not critical to the program's state, and thus, leaving it after an attack will not cause inconsistency. The network output operations in these programs are related solely to communicating with the initiating client. Therefore, if the client is malicious, there is no need to undo the effects of these network operations. Based on these observations, we conclude that file system and network undo support is not essential for the network daemons we studied.

| Program   | File IN | File OUT | Net IN | Net OUT |
|-----------|---------|----------|--------|---------|
| ghttpd    | 45      | 0        | 1      | 49      |
| drcatd    | 319     | 0        | 3      | 320     |
| named     | 0       | 0        | 1      | 1       |
| qpopper   | 41      | 80       | 5      | 7       |
| proftpd   | 13      | 63       | 11     | 61      |

**Table 5: Network and file I/O activity for a single client request as described in Table 3.**

### Experiences with DIRA

We attempted to compromise named, ghttpd, and drcatd, compiled in DIR-mode, using malicious code from public databases [15, 5]. All attempts failed, as the programs were able to detect and identify the attacks. Two out of the three programs could also repair themselves sufficiently to continue normal execution. Below, we provide detailed experiences of applying DIRA to each of these programs.

#### BIND named Inverse Query Vulnerability

BIND named version 8.1 has a vulnerability in its inverse DNS query processing function, allowing an attacker to gain root control of the system. The malicious code exploited this vulnerability by sending a single packet and waiting for a response. For this program, the repair procedure determined that the `f_restart` function is the `main()` function of named. However, there were no local variable updates between `f_read` and `f_attack`, so the execution could be restarted from `f_read` (which was `evGetNext()` in this case).

#### Format String Vulnerability in ghttpd

ghttpd has a format string vulnerability in the `Log()` function. The repair procedure determined that `f_restart` and `f_read` are the same function, `serverconnection()`. Since there were several local variable updates between the data read point and the `Log()` call, the execution restarted from the beginning of `f_restart`. The initial connection remained open, and the exploit program continued sending packets to the same port. These subsequent packets were treated as invalid requests, and the program responded with a "bad request" HTML page.

#### Format String Vulnerability in drcatd

drcatd has a similar vulnerability in its logging function. In this case, `main()` was identified as `f_restart`, and there were multiple local variable updates between `f_read` and `f_attack`. Consequently, the entire program needed to be restarted in case of an attack. This issue can be addressed in two ways: manually reorganizing the source code or logging all memory updates, including local ones. The current version of DIRA does not automatically determine if tracking global updates is sufficient. When compiled with the option to log all memory updates, drcatd can repair itself and continue normal execution. Even if the entire program needs to be restarted, it can still detect and identify the attack.

### Conclusion

The analysis shows that automatic program repair is not always possible, and even when it is, the restart point may be close to the beginning of the program. However, automated attack repair is still useful for several reasons:
1. It makes dynamic attack detection as effective as static analysis without false positives.
2. It provides protection in single-threaded or event-based network applications where terminating the application would disrupt service to other clients.
3. It can be used with other attack detection methods, such as system call argument monitoring, to repair damaged address spaces.

### Future Work

Improvements to the DIRA prototype include:
- Enhancing the efficiency of the memory updates logging mechanism using control flow analysis.
- Addressing multi-threading issues to handle concurrent access to the memory updates log.
- Broadening the scope of the repair process to include file system undo, which can help erase side effects of attacks on the file system.

### Acknowledgements

We thank the anonymous reviewers and our shepherd Dr. Dawn Song for their valuable comments. This research is supported by NSF awards ACI-0234281, CCF-0342556, SCI-0401777, CNS-0410694, and CNS-0435373, as well as funding from Computer Associates Inc., New York State Center of Advanced Technology in Sensors, National Institute of Standards and Technologies, Siemens, and Rether Networks Inc.

### References

[1] H. Agrawal, R. A. DeMillo, and E. H. Spafford. An execution-backtracking approach to debugging. In IEEE Software, May 1981.
[2] H. Agrawal and J. R. Horgan. Dynamic program slicing. In Proceedings of ACM SIGPLAN Conference on Programming Language Design and Implementation, 1990.
[3] T. M. Austin, S. E. Breach, and G. S. Sohi. Efficient detection of all pointer and array access errors. ACM SIGPLAN Notices, 29(6), 1994.
[4] A. Baratloo, T. Tsai, and N. Singh. Transparent run-time defense against stack smashing attacks. In Proceedings of USENIX Annual Technical Conference, June 2000.
[5] Beyond Security’s SecuriTeam. http://www.securiteam.com.
[6] G. Candea and A. Fox. Crash-only software. In Proceedings of the 9th Workshop on Hot Topics in Operating Systems (HotOS-IX), 2003.
[7] G. Candea, S. Kawamoto, Y. Fujiki, G. Friedman, and A. Fox. A microrebootable system — design, implementation, and evaluation. In Proceedings of Operating System Design and Implementation Conference, 2004.
[8] T.-C. Chiueh and F.-H. Hsu. RAD: A compile-time solution to buffer overflow attacks. In Proc. of 21st Intl. Conf. on Distributed Computing Systems, 2001.
[9] C. Cowan, M. Barringer, S. Beattie, G. Kroah-Hartman, M. Frantzen, and J. Lokier. FormatGuard: Automatic protection from printf format string vulnerabilities. In Proceedings of 10th USENIX Security Symposium, August 2001.
[10] C. Cowan, C. Pu, D. Maier, J. Walpole, P. Bakke, S. Beattie, A. Grier, P. Wagle, Q. Zhang, and H. Hinton. StackGuard: Automatic detection and prevention of buffer-overflow attacks. In Proceedings of the 7th USENIX Security Conference, January 1998.
[11] H. Etoh. GCC extensions for protecting applications from stack-smashing attacks. http://www.trl.ibm.com/projects/security/ssp, June 2000.
[12] D. Evans, J. Guttag, J. Horning, and Y. M. Tan. LCLint: A tool for using specifications to check code. In Proceedings of the ACM SIGOFT Symposium on the Foundations of Software Engineering, December 1994.
[13] S. Feldman and C. Brown. Igor: A system for program debugging via reversible execution. In ACM SIGPLAN Notices, Workshop on Parallel and Distributed Debugging, January 1989.
[14] M. Frantzen and M. Shuey. StackGhost: Hardware facilitated stack protection. In Proceedings of the 10th USENIX Security Sumposium, August 2001.
[15] Fyodor. Remote exploits. http://www.insecure.org/sploits_remote.html.
[16] L. A. Grenier. Practical code auditing. http://www.daemonkitty.net/lurene, 2002.
[17] S. Hangal and M. S. Lam. Tracking down software bugs using automatic anomaly detection. In Proceedings of Int. Conf. Software Engineering, May 2002.
[18] R. Hastings and B. Joyce. Purify: Fast detection of memory leaks and access errors. In Proceedings of the Winter USENIX Conference, 1992.
[19] S. C. Johnson. Lint, a C program checker. In AT&T Bell Laboratories:Murray Hill, NJ, July 1978.
[20] R. Jones and P. Kelly. Bounds checking for C. http://www-ala.doc.ic.ac.uk/~phjk/BoundsChecking.html, July 1995.
[21] H.-A. Kim and B. Karp. Autograph: Toward automated, distributed worm signature detection. In Proceedings of USENIX Security Symposium, 2004.
[22] B. Korel and J. Laski. Dynamic program slicing. Information Processing Letters, 29(3), 1988.
[23] B. Korel and J. Laski. Dynamic slicing of computer programs. The Journal of Systems and Software, 13(3), 1990.
[24] A. D. Lucia. Program slicing: Methods and applications. In Proceedings of the 1st IEEE International Workshop on Source Code Analysis and Manipulation, 2001.
[25] S. L. Min and J.-D. Choi. An efficient cache-based access anomality detection scheme. In Proceedings of the Fourth International Conferenceon Architectural Support for Programming Languages and Operating Systems, 1991.
[26] J. Nazario. Project Pedantic — source code analysis tool(s). http://pedantic.sourceforge.net, March 2002.
[27] Openwall project. http://www.openwall.com.
[28] D. Z. Pan and M. A. Linton. Supporting reverse execution of parallel programs. In Proceedings of the ACM SIGPLAN/SIGOPS Workhop on Paralleland Distributed Debugging, January 1989.
[29] A. Pasupulati, J. Coit, K. Levitt, S. F. Wu, S. H. Li, J. C. Kuo, and K. P. Fan. Buttercup: On network-based detection of polymorphic buffer-overﬂow vulnerabilities. In Proceedings of Network Operations and Management Symposium, 2004.
[30] M. Prvulovic and J. Torrellas. ReEnact: Using thread-level speculation to debug software; An application to data races in multithreaded codes. In Proceedings of the 30th Annual International Symposium on Computer Architecture, June 2003.
[31] O. Ruwase and M. S. Lam. A practical dynamic buffer overflow detector. In Proceedings of the 11th Network and Distributed System Security Symposium, February 2004.
[32] Secure software solutions. Rough auditing tool for security, RATS 2.1. http://www.securesw.com/rats.
[33] S. Srinivasan, S. Kandula, C. Andrews, and Y. Zhou. Flashback: A lightweight extension for rollback and deterministic replay for software debugging. In Proceedings of USENIX Annual Technical Conference, June 2000.
[34] P. Team. Non-executable pages design and implementation. http://pax.grsecurity.net/docs/noexec.txt.
[35] T. Toth and C. Kruegel. Accurate buffer overflow detection via abstract payload execution. In Proc. of Intl. Symposium on Recent Advances in Intrusion Detection, 2002.
[36] Vendicator. StackShield GCC compiler patch. http://www.angelfire.com/sk/stackshield, January 2001.
[37] J. Viega, J. T. Bloch, T. Kohno, and G. McGraw. ITS4: A static vulnerability scanner for C and C++ code. In Proceedings of the 16th Annual ComputerSecurity Applications Conference, December 2000.
[38] D. Wheeler. Flawfinder. http://www.dwheeler.com/flawfinder.
[39] J. Wilander and M. Kamkar. A comparison of publicly available tools for static intrusion prevention. In Proc. of 7th Nordic Workshop on Secure IT Systems, 2002.
[40] J. Wilander and M. Kamkar. A comparison of publicly available tools for dynamic buffer overflow prevention. In Proc. of 10th Network and Distributed System Security Symposium, 2003.
[41] P. Zhou, F. Qin, W. Liu, Y. Zhou, and J. Torrellas. iWatcher: Efficient architectural support for software debugging. In Proceedings of the 31st Annual International Symposium on Computer Architecture, 2004.