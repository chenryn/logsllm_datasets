# JShield: A Comprehensive Analysis and Performance Evaluation

## 8.4 Performance Evaluation

### 8.4.1 Signature Matching Performance
To evaluate the performance of JShield's signature matching engine, we measured the JavaScript execution latency introduced by JShield against the original execution latency of the top ten Alexa web sites. The latency was measured by injecting code into the WebKit engine before and after JavaScript execution. Since JavaScript is often executed multiple times, we accumulated all latencies for a comprehensive analysis. Both the filtering and detection format opcode matching were included in the measurements.

For the top one hundred Alexa web sites, we found that none could bypass the pre-filtering stage against all vulnerabilities in our library. This indicates that there are no false positives for these web sites given our data set.

**Figure 13: JavaScript Execution Latency Introduced by Matching Filtering and Detection Format of Opcode Signature in JShield**

| Website         | Original (ms) | Matching with Detection Format Directly (ms) | Matching After Filtering (ms) |
|-----------------|---------------|---------------------------------------------|------------------------------|
| Google          | 1500          | 6000                                        | 1530                         |
| YouTube         | 1000          | 5000                                        | 1020                         |
| Facebook        | 500           | 2500                                        | 510                          |
| Wikipedia       | 200           | 1000                                        | 204                          |
| Yahoo           | 1200          | 4800                                        | 1224                         |
| Twitter         | 800           | 4800                                        | 816                          |
| Amazon          | 900           | 3600                                        | 918                          |
| Baidu           | 700           | 2800                                        | 714                          |
| QQ              | 600           | 2400                                        | 612                          |
| Live.com        | 400           | 1600                                        | 408                          |

For matching with detection signatures, the latency is comparable to the latency (2 to 14 times slower) introduced by Nozzle [43] without object sampling. In the worst case, Twitter is about 6 times slower than normal execution. The fastest web site, Wikipedia, experiences a latency within 2% because it hosts very little JavaScript.

Filtering overhead is minimal due to the efficiency of regular expression matching. As shown in the figure, filtering overhead is within 2%.

### 8.4.2 Overall Performance
**Figure 12: Cumulative Distribution Function (CDF) of Overhead Introduced by JShield on Top 500 Alexa Web Sites**

- **Average Overhead:** 9.42%
- **Median Overhead:** 2.39%
- **Standard Deviation:** 3.17%

The experiment was conducted on the top 500 Alexa web sites. Each web site was tested ten times with and without JShield support. The average latency was then calculated to determine the overhead. The results show that the average overhead among the 500 web sites is 9.42%, with a median overhead of 2.39%.

Since the pre-filtering process—regular expression matching—is very fast, most of the overhead is introduced by the event triggering engine.

## 9. Discussion

### Does the Opcode Signature Set Change with Different Browser Kernels?
**Answer:** Yes, each opcode signature set is specific to a particular JShield implementation, similar to how a binary can only be executed on one operating system. However, vulnerabilities in any browser can be represented in one JShield implementation, as we do not require the vulnerability to exist in the browser.

### Do Attackers Need to Know Features Extracted by Anomaly-Based Detection Methods to Pollute Samples?
**Answer:** No, at the detection stage, benign features are extracted from normal web sites rather than those used by anomaly-based detection engines. Therefore, attackers do not need to know the features extracted by these methods to pollute samples.

## 10. Related Work

### 10.1 Pre-Exploit Stage
**Approaches Detecting Heap-Spraying Attacks:**
Researchers have proposed methods to detect the heap spraying stage of drive-by download attacks. For example, Nozzle [43] and Egele et al. [25] detect every object or string created by JavaScript to check if it is executable. DieHarder [40] provides a new memory allocator to secure the heap from execution.

These approaches can be evaded by new technologies like Heap Taichi [24], and heap spraying is not always necessary for a drive-by download attack. According to Zozzle [23], 6 out of 19 malware samples do not use heap spraying. This is due to:
- Address Space Layout Randomization (ASLR) not being enabled in all browsers.
- Alternative techniques such as JIT spraying [10] and spraying by calling other languages like VBScript and ActionScript.

**De-obfuscating JavaScripts:**
Rozzle [30] uses symbolic execution and multi-execution to partially mitigate differences between multiple browsers. Other approaches [18, 23, 33, 46] de-obfuscate JavaScript by executing it. Revolver [29] clusters JavaScript samples based on AST features, but two samples with different ASTs can trigger the same vulnerability.

JShield can incorporate these de-obfuscation techniques, such as Rozzle, to defeat mechanisms that detect monitoring environments. However, since Rozzle is not open-source, this remains future work.

### 10.2 Exploit Stage
**Vulnerability-Based Approaches:**
BrowserShield [44] and Song et al. [50] use vulnerability signatures to detect attacks. These signatures cannot represent stateful intra-module vulnerabilities and do not consider polymorphic attacks.

**Anomaly-Based Approaches:**
Zozzle [23], JSAND [22], CUJO [46], and Wepawet [18] are examples of anomaly-based approaches. These methods have limitations in adversarial environments, as attackers can use polymorphic variants or inject false malicious features to bypass them.

### 10.3 Others
**Static Methods:**
Prophiler [21], Seifert et al. [48, 49], and Ma et al. [36] use static analysis to detect malicious web pages. Obfuscation techniques, such as embedding into `eval` and `document.write`, can evade these approaches.

**Protection Mechanisms:**
Blade [34], BrowserGuard [27], Cisco IronPort [6], SpyProxy [37], and WebShield [31] are effective protection mechanisms. However, deploying them on all client browsers and enterprise networks is challenging.

**Behavior-Based Detection:**
Provos et al. [42] and Google Safe Browsing [9] use anti-virus software and heuristics to detect malicious behavior. Other approaches [38, 47, 55] use high-interaction client honeypots, but their detection scope is limited by the specific detection environment.

## 11. Conclusion
Due to the potential for data pollution in anomaly-based detection and the lack of complete vulnerability representation in vulnerability-based detection, we propose an opcode vulnerability signature. This signature consists of a definitive state automaton and a variable pool to represent both control and data flow of a vulnerability condition. We implemented a prototype system, JShield, which de-obfuscates JavaScript through event triggering and performs opcode signature matching. Our evaluation shows that JShield can detect all JavaScript engine vulnerabilities in web browsers from 2009 to 2014 and PDF vulnerabilities from 2007 to 2014.

## 12. Acknowledgements
This research was supported in part by the Qatar National Research Fund under award ID SP0022512 and the National Natural Science Foundation of China under grant NO. 61472209. The opinions, findings, and conclusions expressed in this material are those of the authors and do not necessarily reflect the views of the funding foundations.

## 13. References
[1] 2013 compare the best antivirus software products. http://anti-virus-software-review.toptenreviews.com/.
[2] Address space layout randomization. http://en.wikipedia.org/wiki/Address_space_layout_randomization#Microsoft_Windows.
[3] Alexa Top Websites. http://www.alexa.com/topsites.
[4] Apple hit by hackers who struck Facebook. http://online.wsj.com/article/SB10001424127887324449104578314321123497696.html.
[5] Cisco IPS signatures. http://tools.cisco.com/security/center/ipshome.x?i=62&shortna=CiscoIPSSignatures#CiscoIPSSignatures.
[6] Cisco IronPort. http://www.cisco.com/web/ironport/index.html.
[7] Doxygen. http://www.stack.nl/~dimitri/doxygen/.
[8] Embedding Perl (using Perl from C). http://docstore.mik.ua/orelly/perl/prog3/ch21_04.htm.
[9] Google Safe Browsing. https://developers.google.com/safe-browsing/.
[10] JIT spraying. http://en.wikipedia.org/wiki/JIT_spraying.
[11] National Vulnerability Database. http://nvd.nist.gov/.
[12] Regular expression library in C++. http://www.cplusplus.com/reference/std/regex/.
[13] Snort rules. http://www.snort.org/snort-rules/.
[14] SpiderMonkey JavaScript engine. https://developer.mozilla.org/en-US/docs/SpiderMonkey.
[15] Standard Template Library. http://www.sgi.com/tech/stl/.
[16] V8 JavaScript engine. https://code.google.com/p/v8/.
[17] WebKit source codes. http://webkit.org/building/checkout.html.
[18] Wepawet. http://wepawet.iseclab.org/.
[19] Barth, A., Jackson, C., and Mitchell, J. Robust defenses for cross-site request forgery. In CCS (2008).
[20] Brumley, D., Newsome, J., Song, D., Wang, H., and Jha, S. Towards automatic generation of vulnerability-based signatures. In SP: the 2006 IEEE Symposium on Security and Privacy (2006).
[21] Canali, D., Cova, M., Vigna, G., and Kruegel, C. Prophiler: a fast filter for the large-scale detection of malicious web pages. In WWW (2011).
[22] Cova, M., Kruegel, C., and Vigna, G. Detection and analysis of drive-by-download attacks and malicious JavaScript code. In WWW (2010).
[23] Curtsinger, C., Livshits, B., Zorn, B., and Seifert, C. Zozzle: fast and precise in-browser JavaScript malware detection. In the 20th USENIX conference on Security (2011).
[24] Ding, Y., Wei, T., Wang, T., Liang, Z., and Zou, W. Heap Taichi: exploiting memory allocation granularity in heap-spraying attacks. In ACSAC (2010).
[25] Egele, M., Wurzinger, P., Kruegel, C., and Kirda, E. Defending browsers against drive-by downloads: Mitigating heap-spraying code injection attacks. In DIMVA (2009).
[26] Grier, C., Tang, S., and King, S. T. Secure web browsing with the OP web browser. In SP: IEEE Symposium on Security and Privacy (2008).
[27] Hsu, F.-H., Tso, C.-K., Yeh, Y.-C., Wang, W.-J., and Chen, L.-H. BrowserGuard: A behavior-based solution to drive-by-download attacks. Selected Areas in Communications, IEEE Journal on (2011).
[28] Jensen, S. H., Møller, A., and Thiemann, P. Type analysis for JavaScript. In SAS: the International Symposium on Static Analysis (2009).
[29] Kapravelos, A., Shoshitaishvili, Y., Cova, M., Kruegel, C., and Vigna, G. Revolver: An automated approach to the detection of evasive web-based malware. In USNIX Security Symposium (2013).
[30] Kolbitsch, C., Livshits, B., Zorn, B., and Seifert, C. Rozzle: De-cloaking internet malware. In SP: IEEE Symposium on Security and Privacy (2012).
[31] Li, Z., Tang, Y., Cao, Y., Rastogi, V., Chen, Y., Liu, B., and Sbisa, C. WebShield: Enabling various web defense techniques without client side modifications. In NDSS (2011).
[32] Li, Z., Xia, G., Gao, H., Yi, T., Chen, Y., Liu, B., Jiang, J., and Lv, Y. NetShield: Massive semantics-based vulnerability signature matching for high-speed networks. In SIGCOMM (2010).
[33] Lu, G., Coogan, K., and Debray, S. K. Automatic simplification of obfuscated JavaScript code (extended abstract). In ICISTM: 6th International Conference of Information Systems, Technology and Management (2012).
[34] Lu, L., Yegneswaran, V., Porras, P. A., and Lee, W. BLADE: An attack-agnostic approach for preventing drive-by malware infections. In CCS (2010).
[35] Lu, X., Zhuge, J., Wang, R., Cao, Y., and Chen, Y. De-obfuscation and detection of malicious PDF files with high accuracy. In HICSS (2013).
[36] Ma, J., Saul, L. K., Savage, S., and Voelker, G. M. Beyond blacklists: learning to detect malicious web sites from suspicious URLs. In SIGKDD (2009).
[37] Moshchuk, A., Bragin, T., Deville, D., Gribble, S., and Levy, H. SpyProxy: Execution-based detection of malicious web content. In 16th USENIX Security Symposium (2007).
[38] Moshchuk, A., Bragin, T., Gribble, S. D., and Levy, H. M. A crawler-based study of spyware on the web. In NDSS (2006).
[39] Mozilla. Narcissus JavaScript engine. http://mxr.mozilla.org/mozilla/source/js/narcissus/.
[40] Novark, G., and Berger, E. D. DieHarder: securing the heap. In CCS (2010).
[41] Perdisci, R., Dagon, D., Lee, W., Fogla, P., and Sharif, M. Misleading worm signature generators using deliberate noise injection. In Proceedings of the 2006 IEEE Symposium on Security and Privacy (2006).
[42] Provos, N., Mavrommatis, P., Rajab, M. A., and Monrose, F. All your iframes point to us. In 17th USENIX Security Symposium (2008).
[43] Ratanaworabhan, P., Livshits, B., and Zorn, B. Nozzle: A defense against heap-spraying code injection attacks. In 18th USENIX Security Symposium (2009).
[44] Reis, C., Dunagan, J., Wang, H. J., Dubrovsky, O., and Esmeir, S. BrowserShield: vulnerability-driven filtering of dynamic HTML. In OSDI (2006).
[45] Reis, C., and Gribble, S. D. Isolating web programs in modern browser architectures. In EuroSys (2009).
[46] Rieck, K., Krueger, T., and Dewald, A. Cujo: efficient detection and prevention of drive-by-download attacks. In ACSAC (2010).
[47] Seifert, C., Steenson, R., Holz, T., Yuan, B., and Davis, M. A. Know your enemy: Malicious web servers. http://www.honeynet.org/papers/mws/.
[48] Seifert, C., Welch, I., and Komisarczuk, P. Identification of malicious web pages with static heuristics. In ATNAC: Telecommunication Networks and Applications Conference (2008).
[49] Seifert, C., Welch, I., Komisarczuk, P., Aval, C. U., and Endicott-Popovsky, B. Identification of malicious web pages through analysis of underlying DNS and web server relationships. In LCN: Local Computer Networks (2008).
[50] Song, C., Zhuge, J., Han, X., and Ye, Z. Preventing drive-by download via inter-module communication monitoring. In ASIACCS (2010).
[51] Tang, S., Mai, H., and King, S. T. Trust and protection in the Illinois Browser Operating System. In OSDI (2010).
[52] Ter Louw, M., and Venkatakrishnan, V. Blueprint: Precise browser-neutral prevention of cross-site scripting attacks. In 30th IEEE Symposium on Security and Privacy (2009).
[53] Wang, H. J., Grier, C., Moshchuk, A., King, S. T., Choudhury, P., and Venter, H. The multi-principal OS construction of the Gazelle web browser. In 18th Usenix Security Symposium (2009).
[54] Wang, H. J., Guo, C., Simon, D. R., and Zugenmaier, A. Shield: vulnerability-driven network filters for preventing known vulnerability exploits. In SIGCOMM (2004).
[55] Wang, Y., Beck, D., Jiang, X., and Roussev, R. Automated web patrol with Strider HoneyMonkeys: Finding web sites that exploit browser vulnerabilities. In NDSS (2006).