### HILTI: Transparent Integration and Optimization for Network Applications

**Second, HILTI’s abstractions enable seamless integration of non-standard hardware capabilities.** Traditionally, integrating custom hardware elements (e.g., FPGA pattern matchers, dedicated lookup modules, fast packet classification) into a networking application requires significant manual effort to adapt the code. HILTI, however, can switch to a different code path as needed, either at compile-time or dynamically during execution, without altering the interface to the host application. For example, preliminary simulations show that HILTI’s hash tables map well to PLUG [13].

**Third, HILTI’s execution model facilitates compiler-level code optimization by providing context for control and data flow analyses [27].** For instance, state management can benefit from grouping memory operations to improve cache locality, based on access patterns suggested by HILTI’s representation (e.g., containers could structure memory operations with element expiration times in mind). Additionally, optimizations can help reduce overhead associated with HILTI’s runtime model, such as skipping unnecessary exception checks, moving bounds-checking from runtime to compile time where statically safe, and optimizing memory management and garbage collection (e.g., BinPAC++-style parsers could often move intermediary heap objects to less expensive stack storage). Another powerful technique is the elimination of unneeded code at link-time, as demonstrated in the Bro example: the HILTI linker can remove any code (as well as state) that it can statically determine as unreachable with the host application’s parameterization.

**Fourth, HILTI has sufficient context to automatically infer suitable parallelization strategies for many networking applications.** By analyzing data flows, potentially augmented with feedback from runtime profiling, it can leverage the typical unit-based structure of network analysis tasks for scalable scheduling across CPUs; see below.

### Global State Management

By design, HILTI does not provide truly global state that concurrent threads can access directly—a choice that enables safety guarantees and optimizations we deem worth the restriction. As an alternative, host applications can generally deploy message passing for communication between threads and potentially designate a single “master” thread for managing state that requires global visibility across the entire system.

In practice, however, we expect the need for global state to remain rare in HILTI’s target domain, as typical analyses tend to structure their logic around inherent units of analysis—such as connections or IP addresses—with little need for correlation across independent instances. For example, consider a scan detector that counts connection attempts per source address. Since each individual counter depends solely on the activity of the associated source, one can parallelize the detector by ensuring, through scheduling, that the same thread carries out all counter operations associated with a particular address. That thread can then keep a local variable to record the current value. We envision such scoped scheduling to become HILTI’s primary concurrency model, and we refer to [14] for more exploration of this topic.

### Porting Legacy Applications

We consider HILTI primarily a platform for implementing novel host applications, significantly reducing the barrier for developing an efficient and robust system. However, legacy applications can also benefit from HILTI, provided the porting effort remains manageable. Generally, existing systems will be most amenable to leveraging HILTI if they already represent their analyses in a structured, customizable way. Indeed, all four of our example applications fall into this category: they express their functionality in terms of expressions, rules, grammars, and scripts, respectively. Traditionally, such applications compile their inputs into custom internal representations before beginning their processing—a step that could now target HILTI instead. We deem HILTI less promising, however, for porting efforts that involve significant hard-coded, low-level logic, such as a manually written TCP stream reassembler. While HILTI can certainly express such functionality—indeed, we envision eventually providing this particular example in the form of a HILTI library—it remains unclear if porting such code would provide significant benefit, as to a large degree it simply reflects translating code from one language into another.

### Related Work

Existing abstract machine implementations focus on specifics of their respective target domains, and to our knowledge, none fits well to the requirements of flexible, high-performance network traffic analysis. This includes machine models underlying typical programming languages (e.g., JVM, Parrot VM, Lua VM, Erlang’s BEAM/HiPE [39]). Despite raising the level of abstraction, these machines do not offer high-level primitives to efficiently express problems of the domain. Consequently, we leverage an existing low-level abstract machine framework, LLVM, in our implementation.

In the networking domain, several efforts share aspects with our approach, but none provides a similarly comprehensive platform for supporting a wide range of applications. Many could, however, benefit from using HILTI internally. For example, the C library libnids [1] implements basic building blocks commonly used by NIDS, paying particular attention to a design robust when facing adversaries and evasion [24]. We envision such libraries eventually using HILTI for their implementation, relieving them from low-level details (e.g., libnids is not thread-safe and has no IPv6 support), and benefiting from a tighter semantic link between host applications and the library. NetShield [31] aims to overcome the fundamentally limited expressiveness of regular expressions by building a custom NIDS engine on top of BinPAC to match more general vulnerability signatures. However, implementing the low-level parts of the engine accounts for a significant share of the effort. Using HILTI primitives would be less time-consuming and also enable other applications to share the developed functionality. The Click modular router [28] allows users to compose a software router from elements that encapsulate predefined primitives, such as IP header extractors, queues, and packet schedulers. Rather than mapping the custom configuration language to the underlying C++ engine, Click configurations could alternatively compile into HILTI. RouteBricks [18] is a multi-Gbps distributed software router that uses techniques akin to HILTI’s concurrency model: per-core packet queues enable a lock-free programming scheme with good cache performance. HILTI can easily express such per-flow analysis (within a single system) by routing related analysis to the same thread, and its threading model allows for other scheduling strategies as well. NetPDL [40] is an XML-based language to describe the structure of packet headers. It decouples protocol parsing code from protocol specifics, supporting fixed and variable-length protocol fields as well as repeated and optional ones. While NetPDL takes a conceptually different approach than BinPAC, it uses similar building blocks and would nicely map to HILTI. Xplico [7] is a network forensic tool written in C that ships with protocol analyzers and manipulators. The HTTP analyzer, for example, reassembles HTTP payload by writing the packet contents into per-flow files on disk, which higher-level analyzers (such as webchat) then re-read for further analysis. HILTI’s incremental and suspendable stream parsing makes it easier to implement such functionality efficiently. Software-defined networking (SDN) separates a network’s device control and data planes, allowing operators to program routers and switches; OpenFlow [33] provides a vendor-agnostic interface to such functionality, and several higher-level languages [21, 29, 19, 34] use it to control compatible hardware devices. By adding an OpenFlow interface to HILTI, it could become a corresponding backend to drive the software component of such systems and dynamically control network policies based on traffic analysis. NetVM [35] compiles Snort rules into a custom intermediary representation, and from there just-in-time into native code. It routes packets through a graph of connected network elements, each of which features a stack-based processor, private registers, and a memory hierarchy. NetVM’s functionality has a lower-level focus than HILTI because it primarily attempts to achieve portability of signature matching. Contrary to the VM isolation model of NetVM, HILTI’s compilation into LLVM code enables late and global optimizations, whereas it appears difficult to optimize across NetVM elements. Similar to our example in §4, Linux has added support for JIT compiling BPF expressions into native assembly [11]. FreeBSD 7 also includes experimental BPF JIT support. Finally, there is a large body of work on accelerating parts of the network traffic analysis pipeline with custom hardware elements, targeting, for example, pattern matching (e.g., [42, 20]), parallelization on GPUs (e.g., [45, 9, 23]), robust TCP stream reassembly [15], and high-speed lookup tables such as PLUG [13]. HILTI’s design allows for transparent offloading of specific computations to such specialized hardware when available.

### Conclusion

We present the design and implementation of HILTI, a platform for deep, stateful network traffic analysis. HILTI represents a middle-layer located between a host application and the hardware platform that executes the analysis. We argue that while networking applications tend to share a large set of common functionality, they typically reimplement it from scratch each time, raising the possibility of falling into pitfalls that others have previously mastered. HILTI bridges that gap by providing a common substrate to applications to support their implementation while facilitating reuse of high-level components built on top of the platform. We developed a prototype compiler that implements all of HILTI’s functionality, including rich domain-specific data types, automatic memory management, flexible control flow, concurrent execution, profiling and debugging support, and an extensive API for host applications. We further built four example applications on top of HILTI that demonstrate its ability to support a range of typical network analyses. We plan to advance HILTI further into a platform suitable for operational deployment in large-scale network environments by exploiting its full performance potential through transparent optimization and integration of non-standard hardware elements. We also envision HILTI to become a platform for networking research by facilitating rapid prototyping of novel network functionality.

### Acknowledgments

This work was supported by the US National Science Foundation under grants CNS-0831535, CNS-0915667, CNS-1228792, and CNS-1228782. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors or originators and do not necessarily reflect the views of the National Science Foundation.

### References

[1] libnids. http://libnids.sourceforge.net.
[2] libtask. http://swtch.com/libtask.
[3] Objective-C Automatic Reference Counting (ARC). http://clang.llvm.org/docs/AutomaticReferenceCounting.html.
[4] re2c. http://re2c.org.
[5] Suricata source code - src/flow-hash.c. https://github.com/inliniac/suricata/blob/master/src/flow-hash.c.
[6] Web site and source code for HILTI and BinPAC++. http://www.icir.org/hilti.
[7] Xplico. http://www.xplico.org.
[8] B. Anderson. Abandoning Segmented Stacks in Rust. https://mail.mozilla.org/pipermail/rust-dev/2013-November/006314.html.
[9] M. B. Anwer, M. Motiwala, M. b. Tariq, and N. Feamster. SwitchBlade: A Platform for Rapid Deployment of Network Protocols on Programmable Hardware. In Proc. ACM SIGCOMM, 2010.
[10] A. W. Appel. Compiling with Continuations. Cambridge University Press, 1992.
[11] J. Corbet. A JIT for packet filters. http://lwn.net/Articles/437981/.
[12] S. Das. Segmented Stacks in LLVM. http://www.google-melange.com/gsoc/project/google/gsoc2011/sanjoyd/13001.
[13] L. De Carli, Y. Pan, A. Kumar, C. Estan, and K. Sankaralingam. PLUG: Flexible Lookup Modules for Rapid Deployment of New Protocols in High-Speed Routers. ACM SIGCOMM Computer Communication Review, 39:207–218, 2009.
[14] L. De Carli, R. Sommer, and S. Jha. Beyond Pattern Matching: A Concurrency Model for Stateful Deep Packet Inspection. In Proc. ACM Computer and Communications Security (CCS), 2014.
[15] S. Dharmapurikar and V. Paxson. Robust TCP Stream Reassembly in the Presence of Adversaries. In USENIX Security, 2005.
[16] H. Dreger, A. Feldmann, V. Paxson, and R. Sommer. Operational Experiences with High-Volume Network Intrusion Detection. In Proc. ACM Computer and Communications Security (CCS), Oct. 2004.
[17] H. Dreger, A. Feldmann, V. Paxson, and R. Sommer. Predicting the Resource Consumption of Network Intrusion Detection Systems. In Proc. Recent Advances in Intrusion Detection (RAID), 2008.
[18] K. Fall, G. Iannaccone, M. Manesh, S. Ratnasamy, K. Argyraki, M. Dobrescu, and N. Egi. RouteBricks: Enabling General Purpose Network Infrastructure. SIGOPS Operating Systems Review, 45:112–125, February 2011.
[19] N. Foster et al. Frenetic: A High-Level Language for OpenFlow Networks. In Proc. PRESTO, 2010.
[20] R. Franklin, D. Carver, and B. Hutchings. Assisting Network Intrusion Detection with Reconfigurable Hardware. In Proc. FCCM, 2002.
[21] N. Gude, T. Koponen, J. Pettit, B. Pfaff, M. Casado, N. McKeown, and S. Shenker. NOX: Towards an Operating System for Networks. ACM SIGCOMM Computer Communication Review, 38:105–110, 2008.
[22] P. Gupta and N. McKeown. Algorithms for Packet Classification. http://yuba.stanford.edu/~nickm/papers/classification_tutorial_01.pdf, 2001.
[23] S. Han, K. Jang, K. Park, and S. Moon. PacketShader: A GPU-accelerated Software Router. In Proc. ACM SIGCOMM, 2010.
[24] M. Handley, C. Kreibich, and V. Paxson. Network Intrusion Detection: Evasion, Traffic Normalization, and End-to-End Protocol Semantics. In Proc. USENIX Security, 2001.
[25] S. Ioannidis, K. Anagnostakis, J. Ioannidis, and A. Keromytis. xPF: Packet Filtering for Lowcost Network Monitoring. In Proc. IEEE HPSR, pages 121–126, 2002.
[26] R. Jones, A. Hosking, and E. Moss. The Garbage Collection Handbook: The Art of Automatic Memory Management. Cambridge University Press, 2011.
[27] K. Kennedy and J. R. Allen. Optimizing Compilers for Modern Architectures. Morgan Kaufmann, 2002.
[28] E. Kohler, R. Morris, B. Chen, J. Jannotti, and M. F. Kaashoek. The Click Modular Router. ACM Transactions on Computer Systems, 18:263–297, August 2000.
[29] T. Koponen et al. Onix: A Distributed Control Platform for Large-Scale Production Networks. In USENIX OSDI, 2010.
[30] C. Lattner and V. Adve. LLVM: A Compilation Framework for Lifelong Program Analysis & Transformation. In Proc. Symposium on Code Generation and Optimization, 2004.
[31] Z. Li et al. NetShield: Massive Semantics-Based Vulnerability Signature Matching for High-Speed Networks. In Proc. ACM SIGCOMM, 2010.
[32] S. McCanne and V. Jacobson. The BSD Packet Filter: A New Architecture for User-level Packet Capture. In Proc. USENIX Winter 1993 Conference.
[33] N. McKeown et al. OpenFlow: Enabling Innovation in Campus Networks. ACM SIGCOMM Computer Communication Review, 38:69–74, 2008.
[34] C. Monsanto, N. Foster, R. Harrison, and D. Walker. A Compiler and Run-time System for Network Programming Languages. In Proc. POPL, 2012.
[35] O. Morandi, G. Moscardi, and F. Risso. An Intrusion Detection Sensor for the NetVM Virtual Processor. In Proc. ICOIN, 2009.
[36] R. Pang, V. Paxson, R. Sommer, and L. Peterson. binpac: A yacc for Writing Application Protocol Parsers. In Proc. ACM Internet Measurement Conference (IMC), 2006.
[37] V. Paxson. Bro: A System for Detecting Network Intruders in Real-Time. Computer Networks, 31(23–24), 1999.
[38] V. Paxson, K. Asanovic, S. Dharmapurikar, J. Lockwood, R. Pang, R. Sommer, and N. Weaver. Rethinking Hardware Support for Network Analysis and Intrusion Prevention. In Proc. USENIX Hot Security Workshop, August 2006.
[39] M. Pettersson, K. Sagonas, and E. Johansson. The HiPE/x86 Erlang Compiler: System Description and Performance Evaluation. In Proc. FLOPS, 2002.
[40] F. Risso and M. Baldi. NetPDL: An Extensible XML-based Language for Packet Header Description. Computer Networks, 50:688–706, April 2006.
[41] N. Schear, D. Albrecht, and N. Borisov. High-Speed Matching of Vulnerability Signatures. In Proc. Recent Advances in Intrusion Detection (RAID), 2008.
[42] R. Sidhu and V. K. Prasanna. Fast Regular Expression Matching using FPGAs. In Proc. IEEE FCCM, Apr. 2001.
[43] R. Sommer, V. Paxson, and N. Weaver. An Architecture for Exploiting Multi-Core Processors to Parallelize Network Intrusion Prevention. Concurrency and Computation: Practice and Experience, 21(10):1255–1279, 2009.
[44] M. Vallentin, R. Sommer, J. Lee, C. Leres, V. Paxson, and B. Tierney. The NIDS Cluster: Scalable, Stateful Network Intrusion Detection on Commodity Hardware. In Proc. Recent Advances in Intrusion Detection (RAID), 2007.
[45] G. Vasiliadis, S. Antonatos, M. Polychronakis, E. P. Markatos, and S. Ioannidis. Gnort: High Performance Network Intrusion Detection Using Graphics Processors. In Proc. Recent Advances in Intrusion Detection (RAID), 2008.
[46] D. Zaparanuks, M. Jovic, and M. Hauswirth. Accuracy of Performance Counter Measurements. In IEEE ISPASS, 2009.