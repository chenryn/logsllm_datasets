### 3.59
**Table 5: Page Load Time (in Seconds) of pSweeper on Five Popular Websites**

### 5.5 Summary
In summary, faster sweeping rates generally result in lower runtime and memory overheads. However, pSweeper with faster sweeping rates will consume more energy and CPU resources. While this is acceptable when there are idle cores, it may significantly impact the performance of CPU-bound multi-threaded applications. Therefore, if an application is not memory-allocation-intensive, pSweeper should typically be configured to run at a lower sweeping rate.

### 6 Discussion & Limitations

#### Comparison to Garbage Collection (GC)
Garbage collection (GC) [6, 18] not only mitigates exploits but also prevents program crashes due to Use-After-Free (UaF) vulnerabilities. However, most GC algorithms consume more memory because they defer freeing until there is insufficient memory or when applications explicitly request it. Additionally, some dangling pointers can remain active for extended periods, preventing conservative GC from reclaiming freed memory. In contrast, pSweeper frees memory after one round of pointer sweeping and proactively eliminates dangling pointers. Moreover, stop-the-world GC can cause unpredictable interference with application performance. pSweeper, on the other hand, does not stall application threads. Finally, although pSweeper can only probabilistically mask program crashes, it guarantees to pinpoint the root causes of UaF vulnerabilities when programs crash.

#### pSweeper Metadata Protection
pSweeper does not specially protect its metadata, such as the MAS and PLM tables. However, this does not compromise our security guarantee. By design, all UaF exploits are disrupted. Thus, attackers can leak and tamper with metadata only through non-UaF vulnerabilities. As discussed in ยง2, orthogonal defenses should be used to protect against these vulnerabilities.

#### Accessing Freed Memory Due to Deferred Free
Since pSweeper defers object freeing until the end of a sweeping round, applications may access memory that should have been freed. This design is similar to garbage collection. Therefore, we believe this is not a critical concern in practice.

#### Energy Consumption
Since pSweeper continuously scans for dangling pointers in a concurrent thread, it consumes more power and energy. Consequently, it may not be suitable for deployment on battery-powered mobile devices. Instead, we envision pSweeper to be primarily deployed on desktops.

#### False Positives
False positives can occur in two cases. First, a pointer may be type-casted to and used as an integer. For example, a program might depend on the difference between two pointers, `p` and `q`. If `p` or `q` is neutralized by pSweeper, the value `(p - q)` will change. Second, applications may intentionally use the values in dangling pointers. Since these false positives are rare in practice, we believe they will not seriously affect the practicality of pSweeper. Notably, all three comparable approaches [36, 54, 58] suffer from the same false positives.

#### False Negatives
pSweeper relies on the types of global/local variables and operands in store instructions to identify live pointers. However, if an integer is type-casted to a pointer at runtime, or if pSweeper conservatively ignores unions containing non-pointer fields, pSweeper will experience false negatives if the missed pointers become dangling.

Another possible cause of false negatives is that pSweeper does not proactively neutralize dangling pointers in registers. Peeking into and tampering with the registers used by application threads would induce undue overhead. While these dangling pointers are theoretically false negatives, they are difficult to exploit in practice. Therefore, we do not currently address them, but we ensure they never propagate to memory (ยง4.5). All existing approaches [36, 54, 58] also do not handle dangling pointers in registers.

### 7 Related Work
We have compared pSweeper with DANGNULL [36], FreeSentry [58], and DangSan [54], which are the works closest to ours (ยง3.1). Here, we discuss the remaining related works.

#### Dangling Pointer Detection
Tools like Valgrind [45] and AddressSanitizer [51] track the (de)allocation status of each memory location. As long as a freed memory block is not reallocated, these tools can detect all dangling pointers. However, they can miss those pointing to a reallocated memory, which is common in UaF exploits. Another set of approaches extends each pointer with a unique identifier and checks the validity on every pointer dereference [15, 43, 56, 57]. Unfortunately, software-only explicit pointer checks can slow applications by an order of magnitude. Recently, Nagarakatte et al. [40, 41] proposed a hardware-assisted approach that provides full memory safety at low overheads. Undangle [19] detects dangling pointers using dynamic taint analysis to track pointer propagations at runtime. It can serve as an in-house testing tool but not a runtime defense system.

#### Safe Memory Allocators
Cling [14] is a safe memory allocator that avoids memory reuse among objects of different types, thwarting many, but not all, UaF exploits. DieHard [16] and DieHarder [47] are based on the idea of "infinite" heaps, which, while idealized, can only provide probabilistic memory safety. Exterminator [48] extends DieHard to automatically fix dangling pointers by delaying object frees. Dhurjati and Adve [26] used a new virtual page for each memory allocation and relied on page protection to detect dangling pointer accesses. Inspired by their work, Oscar [24] develops a page-permission-based protection scheme to ensure pointer safety. In contrast, pSweeper proactively neutralizes all dangling pointers.

#### Safe C Languages
Fail-safe C [49] implements a completely memory-safe compiler that is fully compatible with ANSI C, using garbage collection to protect against dangling pointers. There are also safe C dialects, such as Cyclone [28, 30] and CCured [21, 44]. Although they attempt to maintain compatibility with C/C++ specifications, significant efforts are still needed to retrofit legacy programs.

#### Parallelizing Security Checks
Concurrent security checks, as in pSweeper, have been adopted in several previous works. Speck [46] decouples security checks from applications and executes them in parallel on multiple cores. Unlike Speck, pSweeper does not use speculative execution. Cruiser [59] and Kruiser [52] use concurrent threads to detect buffer overflows in user applications and kernels, respectively. ShadowReplica [29] accelerates dynamic data flow tracking by running analysis on spare cores. However, pSweeper tackles a different problem and faces unique challenges. Finally, RCORE [27] detects program state invariant violations on idle cores. Although RCORE can also detect dangling pointers, it does not consider race conditions (e.g., dangling pointer propagation ยง4.5 and no deferred free in RCORE). RCORE also relies on static type analysis to identify pointers, which is challenging to be complete in real-world software. Therefore, pSweeper is more robust than RCORE.

### 8 Conclusion
This paper presents pSweeper, a system that effectively protects applications from UaF vulnerabilities with low overhead. The key feature of pSweeper is to iteratively sweep live pointers to neutralize dangling ones in concurrent threads. To accomplish this, we devise lock-free algorithms to address the entangled races among pSweeper and application threads, without using any heavyweight synchronization mechanisms that can stall application threads. We also propose encoding object origin information into dangling pointers to achieve object origin tracking, which helps pinpoint the root causes of UaF vulnerabilities. We implement a prototype of pSweeper and validate its effectiveness and efficiency in production environments.

### 9 Acknowledgments
We would like to thank our shepherd Byoungyoung Lee and anonymous reviewers for their insightful feedback, which helped us improve the quality of this paper. This work was supported in part by ONR grant N00014-17-1-248.

### References
[1] Apachebench. https://httpd.apache.org/docs/2.4/programs/ab.html/
[2] App.telemetry page speed monitor. https://addons.mozilla.org/en-US/firefox/addon/apptelemetry/
[3] CVE-2014-3505. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-3505
[4] CVE-2016-6309. https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2016-6309
[5] Detecting memory access errors using hardware support. https://blogs.oracle.com/raj/entry/detecting_memory_access_errors_using
[6] A garbage collector for C and C++. http://hboehm.info/gc/
[7] Intel 64 and IA-32 Architectures Software Developer Manual. https://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-system-programming-manual-325384.html
[8] Jetstream. http://browserbench.org/JetStream/
[9] Lighttpd bug-2440. https://redmine.lighttpd.net/issues/2440
[10] The LLVM Compiler Infrastructure. http://llvm.org/
[11] Motionmark. http://browserbench.org/MotionMark/
[12] Speedometer. http://browserbench.org/Speedometer/
[13] Wireshark bug-12840. https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=12840
[14] Akritidis, P. Cling: A memory allocator to mitigate dangling pointers. Proceedings of the 19th USENIX Conference on Security (Security) (2010).
[15] Austin, T. M., Breach, S. E., and Sohi, G. S. Efficient detection of all pointer and array access errors. In Proceedings of the ACM SIGPLAN 1994 Conference on Programming Language Design and Implementation (PLDI) (1994).
[16] Berger, E. D., and Zorn, B. G. Diehard: Probabilistic memory safety for unsafe languages. In Proceedings of the 27th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI) (2006).
[17] Bienia, C., Kumar, S., Singh, J. P., and Li, K. The PARSEC Benchmark Suite: Characterization and architectural implications. In Proceedings of the 17th International Conference on Parallel Architectures and Compilation Techniques (PACT) (2008).
[18] Boehm, H.-J., and Weiser, M. Garbage collection in an uncooperative environment. Softw. Pract. Exper. 18 (1988).
[19] Caballero, J., Grieco, G., Marron, M., and Nappa, A. Undangle: Early detection of dangling pointers in use-after-free and double-free vulnerabilities. In Proceedings of the 2012 International Symposium on Software Testing and Analysis (ISSTA) (2012).
[20] Chen, X., Slowinska, A., Andriesse, D., Bos, H., and Giuffrida, C. StackArmor: Comprehensive protection from stack-based memory error vulnerabilities for binaries. In Proc. Network and Distributed System Security Symposium (NDSS) (2015).
[21] Condit, J., Harren, M., McPeak, S., Necula, G. C., and Weimer, W. CCured in the real world. In Proceedings of the ACM SIGPLAN 2003 Conference on Programming Language Design and Implementation (PLDI) (2003).
[22] Cowan, C., Pu, C., Maier, D., Hintony, H., Walpole, J., Bakke, P., Beattie, S., Grier, A., Wagle, P., and Zhang, Q. StackGuard: Automatic adaptive detection and prevention of buffer-overflow attacks. In Proceedings of the 7th Conference on USENIX Security Symposium (1998).
[23] Criswell, J., Lenharth, A., Dhurjati, D., and Adve, V. Secure Virtual Architecture: A safe execution environment for commodity operating systems. In Proceedings of Twenty-first ACM SIGOPS Symposium on Operating Systems Principles (SOSP) (2007).
[24] Dang, T. H., Maniatis, P., and Wagner, D. Oscar: A practical page-permissions-based scheme for thwarting dangling pointers. In 26th USENIX Security Symposium (2017).
[25] Devietti, J., Blundell, C., Martin, M. M. K., and Zdancewic, S. Hardbound: Architectural support for spatial safety of the C programming language. In Proceedings of the 13th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS) (2008).
[26] Dhurjati, D., and Adve, V. Efficiently detecting all dangling pointer uses in production servers. In Proceedings of the International Conference on Dependable Systems and Networks (DSN) (2006).
[27] Giuffrida, C., Cavallaro, L., and Tanenbaum, A. S. Practical automated vulnerability monitoring using program state invariants. In 2013 43rd Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN) (2013).
[28] Grossman, D., Morrisett, G., Jim, T., Hicks, M., Wang, Y., and Cheney, J. Region-based memory management in Cyclone. In Proceedings of the ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation (PLDI) (2002).
[29] Jee, K., Kemerlis, V. P., Keromytis, A. D., and Portokalidis, G. ShadowReplica: Efficient parallelization of dynamic data flow tracking. In Proceedings of ACM SIGSAC Conference on Computer and Communications Security (CCS) (2013).
[30] Jim, T., Morrisett, J. G., Grossman, D., Hicks, M. W., Cheney, J., and Wang, Y. Cyclone: A safe dialect of C. In Proceedings of the General Track of the Annual Conference on USENIX Annual Technical Conference (ATC) (2002).
[31] Jones, R., Hosking, A., and Moss, E. The Garbage Collection Handbook: The Art of Automatic Memory Management, 1st ed. Chapman & Hall/CRC, 2011.
[32] Kasikci, B., Schubert, B., Pereira, C., Pokam, G., and Candea, G. Failure sketching: A technique for automated root cause diagnosis of in-production failures. In Proceedings of the 25th Symposium on Operating Systems Principles (SOSP) (2015).
[33] Kharbutli, M., Jiang, X., Solihin, Y., Venkataramani, G., and Prvulovic, M. Comprehensively and efficiently protecting the heap. In Proceedings of the 12th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS) (2006).
[34] Kuznetsov, V., Szekeres, L., Payer, M., Candea, G., Sekar, R., and Song, D. Code-pointer integrity. In Proceedings of the 11th USENIX Conference on Operating Systems Design and Implementation (OSDI) (2014).
[35] Lattner, C., and Adve, V. LLVM: A compilation framework for lifelong program analysis & transformation. In Proceedings of the International Symposium on Code Generation and Optimization: Feedback-directed and Runtime Optimization (CGO) (2004).
[36] Lee, B., Song, C., Jang, Y., Wang, T., Kim, T., Lu, L., and Lee, W. Preventing use-after-free with dangling pointers nullification. In Proc. Network and Distributed System Security Symposium (NDSS) (2015).
[37] Liblit, B., Aiken, A., Zheng, A. X., and Jordan, M. I. Bug isolation via remote program sampling. In Proceedings of the ACM SIGPLAN 2003 Conference on Programming Language Design and Implementation (PLDI) (2003).
[38] Liblit, B., Naik, M., Zheng, A. X., Aiken, A., and Jordan, M. I. Scalable statistical bug isolation. In Proceedings of the 2005 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI) (2005).
[39] Lvin, V. B., Novark, G., Berger, E. D., and Zorn, B. G. Archipelago: Trading address space for reliability and security. In Proceedings of the 13th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS) (2008).
[40] Nagarakatte, S., Martin, M. M. K., and Zdancewic, S. Watchdog: Hardware for safe and secure manual memory management and full memory safety. In Proceedings of the 39th Annual International Symposium on Computer Architecture (ISCA) (2012).
[41] Nagarakatte, S., Martin, M. M. K., and Zdancewic, S. WatchdogLite: Hardware-accelerated compiler-based pointer checking. In Proceedings of Annual IEEE/ACM International Symposium on Code Generation and Optimization (CGO) (2014).
[42] Nagarakatte, S., Zhao, J., Martin, M. M., and Zdancewic, S. SoftBound: Highly compatible and complete spatial memory safety for C. In Proceedings of the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI) (2009).
[43] Nagarakatte, S., Zhao, J., Martin, M. M., and Zdancewic, S. CETs: Compiler enforced temporal safety for C. In Proceedings of the 2010 International Symposium on Memory Management (ISMM) (2010).
[44] Necula, G. C., McPeak, S., and Weimer, W. CCured: Type-safe retrofitting of legacy code. In Proceedings of the 29th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL) (2002).
[45] Nethercote, N., and Seward, J. Valgrind: A framework for heavyweight dynamic binary instrumentation. In Proceedings of the 28th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI) (2007).
[46] Nightingale, E. B., Peek, D., Chen, P. M., and Flinn, J. Parallelizing security checks on commodity hardware. In Proceedings of the 13th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS) (2008).
[47] Novark, G., and Berger, E. D. DieHarder: Securing the heap. In Proceedings of the 17th ACM Conference on Computer and Communications Security (CCS) (2010).
[48] Novark, G., Berger, E. D., and Zorn, B. G. Exterminator: Automatically correcting memory errors with high probability. In Proceedings of the 28th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI) (2007).
[49] Oiwa, Y. Implementation of the memory-safe full ANSI-C compiler. In Proceedings of the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI) (2009).
[50] Prasad, M., and cker Chiueh, T. A binary rewriting defense against stack-based overflow attacks. In In Proceedings of the USENIX Annual Technical Conference (ATC) (2003).
[51] Serebryany, K., Bruening, D., Potapenko, A., and Vyukov, D. AddressSanitizer: A fast address sanity checker. In Proceedings of the 2012 USENIX Conference on Annual Technical Conference (ATC) (2012).
[52] Tian, D., Zeng, Q., Wu, D., Liu, P., and Hu, C. Kruiser: Semi-synchronized non-blocking concurrent kernel heap buffer overflow monitoring. In Proc. Network and Distributed System Security Symposium (NDSS) (2015).
[53] Tucek, J., Lu, S., Huang, C., Xanthos, S., and Zhou, Y. Triage: Diagnosing production run failures at the userโs site. In Proceedings of Twenty-first ACM SIGOPS Symposium on Operating Systems Principles (SOSP) (2007).
[54] van der Kouwe, E., Nigade, V., and Giuffrida, C. DangSan: Scalable use-after-free detection. In Proceedings of the Twelfth European Conference on Computer Systems (EuroSys) (2017).
[55] Venkataramani, G., Roemer, B., Solihin, Y., and Prvulovic, M. MemTracker: Efficient and programmable support for memory access monitoring and debugging. In Proceedings of the 2007 IEEE 13th International Symposium on High Performance Computer Architecture (HPCA) (2007).
[56] Xu, W., DuVarney, D. C., and Sekar, R. An efficient and backwards-compatible transformation to ensure memory safety of C programs. In Proceedings of the 12th ACM SIGSOFT Twelfth International Symposium on Foundations of Software Engineering (FSE) (2004).
[57] Yong, S. H., and Horwitz, S. Protecting C programs from attacks via invalid pointer dereferences. In Proceedings of the 9th European Software Engineering Conference Held Jointly with 11th ACM SIGSOFT International Symposium on Foundations of Software Engineering (ESEC/FSE) (2003).
[58] Younan, Y. FreeSentry: Protecting against use-after-free vulnerabilities due to dangling pointers. In Proc. Network and Distributed System Security Symposium (NDSS) (2015).
[59] Zeng, Q., Wu, D., and Liu, P. Cruiser: Concurrent heap buffer overflow monitoring using lock-free data structures. In Proceedings of the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI) (2011).