以下是优化后的参考文献列表，使其更加清晰、连贯和专业：

---

[26] Tetlow, G. (April 2019). Personal communication via email.

[27] Aftandilian, E., Sauciuc, R., Priya, S., & Krishnan, S. (2012). Building useful program analysis tools using an extensible Java compiler. In *Proceedings of the International Workshop on Cooperative and Human Aspects of Software Engineering* (IWCSCAM).

[28] Akritidis, P., Costa, M., Castro, M., & Hand, S. (2009). Baggy bounds checking: An efficient and backwards-compatible defense against out-of-bounds errors. In *Proceedings of the USENIX Security Symposium* (USENIX Sec).

[29] Anderson, B., Bergstrom, L., Herman, D., Matthews, J., McAllister, K., Goregaokar, M., Moffitt, J., & Sapin, S. (2015). Experience report: Developing the Servo web browser engine using Rust. arXiv:1505.07383.

[30] Arya, A., Chang, O., Moroz, M., Barbella, M., Metzman, J., & ClusterFuzz team. (2019). Open sourcing ClusterFuzz. Retrieved from https://opensource.googleblog.com/2019/02/open-sourcing-clusterfuzz.html

[31] Ashcraft, K., & Engler, D. (2002). Using programmer-written compiler extensions to catch security holes. In *Proceedings of the IEEE Symposium on Security and Privacy* (IEEE S&P).

[32] Avgerinos, T., Cha, S. K., Hao, B. L. T., & Brumley, D. (2011). AEG: Automatic exploit generation. In *Proceedings of the Network and Distributed System Security Symposium* (NDSS).

[33] Avgerinos, T., Rebert, A., Cha, S. K., & Brumley, D. (2014). Enhancing symbolic execution with veritesting. In *Proceedings of the International Conference on Software Engineering* (ICSE).

[34] Babić, D., Martignoni, L., McCamant, S., & Song, D. (2011). Statically-directed dynamic automated test generation. In *Proceedings of the International Symposium on Software Testing and Analysis* (ISSTA).

[35] Bai, J.-J., Lawall, J., Chen, Q.-L., & Hu, S.-M. (2019). Effective static analysis of concurrency use-after-free bugs in Linux device drivers. In *Proceedings of the USENIX Annual Technical Conference* (USENIX ATC).

[36] Baldoni, R., Coppa, E., D'Elia, D. C., Demetrescu, C., & Finocchi, I. (2018). A survey of symbolic execution techniques. *ACM Computing Surveys*, 51(3).

[37] Barrett, C., Stump, A., Tinelli, C., et al. (2010). The SMT-LIB standard: Version 2.0. In *Proceedings of the Satisfiability Modulo Theories Conference* (SMT).

[38] Bergan, T., Grossman, D., & Ceze, L. (2014). Symbolic execution of multithreaded programs from arbitrary program contexts. In *Proceedings of the ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications* (OOPSLA).

[39] Bessey, A., Block, K., Chelf, B., Chou, A., Fulton, B., Hallem, S., Henri-Gros, C., Kamsky, A., McPeak, S., & Engler, D. (2010). A few billion lines of code later: Using static analysis to find bugs in the real world. *Communications of the ACM*, 53(2).

[40] Brown, F., Narayan, S., Wahby, R. S., Engler, D., Jhala, R., & Stefan, D. (2017). Finding and preventing bugs in JavaScript bindings. In *Proceedings of the IEEE Symposium on Security and Privacy* (IEEE S&P).

[41] Brown, F., Nötzli, A., & Engler, D. (2016). How to build static checking systems using orders of magnitude less code. In *Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems* (ASPLOS).

[42] Brumley, D., Hartwig, C., Kang, M. G., Liang, Z., Newsome, J., Poosankam, P., Song, D., & Yin, H. (2007). Bitscope: Automatically dissecting malicious binaries. Technical Report CS-07-133, Carnegie Mellon University.

[43] Brummayer, R., & Biere, A. (2009). Boolector: An efficient SMT solver for bit-vectors and arrays. In *Proceedings of the International Conference on Tools and Algorithms for the Construction and Analysis of Systems* (TACAS).

[44] Bucur, S., Ureche, V., Zamfir, C., & Candea, G. (2011). Parallel symbolic execution for automated real-world software testing. In *Proceedings of the European Conference on Computer Systems* (EuroSys).

[45] Cadar, C., Dunbar, D., & Engler, D. (2008). KLEE: Unassisted and automatic generation of high-coverage tests for complex systems programs. In *Proceedings of the USENIX Symposium on Operating Systems Design and Implementation* (OSDI).

[46] Cadar, C., Ganesh, V., Pawlowski, P. M., Dill, D. L., & Engler, D. R. (2008). EXE: Automatically generating inputs of death. *ACM Transactions on Information and System Security* (TISSEC).

[47] Cadar, C., & Sen, K. (2013). Symbolic execution for software testing: Three decades later. *Communications of the ACM*, 56(2).

[48] Calcagno, C., Distefano, D., Dubreil, J., Gabi, D., Hooimeijer, P., Luca, M., O'Hearn, P., Papakonstantinou, I., Purbrick, J., & Rodriguez, D. (2015). Moving fast with software verification. In *Proceedings of the NASA Formal Methods Symposium*.

[49] Cha, S. K., Avgerinos, T., Rebert, A., & Brumley, D. (2012). Unleashing mayhem on binary code. In *Proceedings of the IEEE Symposium on Security and Privacy* (IEEE S&P).

[50] Chipounov, V., Kuznetsov, V., & Candea, G. (2011). S2E: A platform for in-vivo multi-path analysis of software systems. In *Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems* (ASPLOS).

[51] Google. (n.d.). Chrome vulnerability reward program rules. Retrieved from https://www.google.com/about/appsecurity/chrome-rewards/

[52] The Clang Static Analyzer. (n.d.). Retrieved from https://chromium.googlesource.com/chromium/src/+/HEAD/docs/clang_static_analyzer.md

[53] Chromium Project. (n.d.). Severity guidelines for security issues. Retrieved from https://chromium.googlesource.com/chromium/src/+master/docs/security/severity-guidelines.md

[54] Chromium Code Coverage. (n.d.). Retrieved from https://chromium-coverage.appspot.com/

[55] LLVM Project. (n.d.). AddressSanitizer. Retrieved from https://clang.llvm.org/docs/AddressSanitizer.html

[56] LLVM Project. (n.d.). MemorySanitizer. Retrieved from https://clang.llvm.org/docs/MemorySanitizer.html

[57] LLVM Project. (n.d.). UndefinedBehaviorSanitizer. Retrieved from https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html

[58] Corrigan-Gibbs, H. (February 2019). Personal communication.

[59] Cui, H., Hu, G., Wu, J., & Yang, J. (2013). Verifying systems rules using rule-directed symbolic execution. In *Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems* (ASPLOS).

[60] Distefano, D., Fähndrich, M., Logozzo, F., & O'Hearn, P. W. (2019). Scaling static analyses at Facebook. *Communications of the ACM*.

[61] Elkarablieh, B., Godefroid, P., & Levin, M. Y. (2009). Precise pointer reasoning for dynamic test generation. In *Proceedings of the International Symposium on Software Testing and Analysis* (ISSTA).

[62] Engler, D., Chelf, B., Chou, A., & Hallem, S. (2000). Checking system rules using system-specific, programmer-written compiler extensions. In *Proceedings of the USENIX Symposium on Operating Systems Design and Implementation* (OSDI).

[63] Engler, D., & Dunbar, D. (2007). Under-constrained execution: Making automatic code destruction easy and scalable. In *Proceedings of the International Symposium on Software Testing and Analysis* (ISSTA).

[64] Erlingsson, Ú., Younan, Y., & Piessens, F. (2010). Low-level software security by example. In *Handbook of Information and Communication Security*.

[65] Evans, D., & Larochelle, D. (2002). Improving security using extensible lightweight static analysis. *IEEE Software*, 19(1).

[66] Feist, J., Mounier, L., Bardin, S., David, R., & Potet, M.-L. (2016). Finding the needle in the heap: Combining static analysis and dynamic symbolic execution to trigger use-after-free. In *Proceedings of the International Workshop on Software and Performance* (SSPREW).

[67] Mozilla. (n.d.). ASan nightly project. Retrieved from https://developer.mozilla.org/en-US/docs/Mozilla/Testing/ASan_Nightly_Project

[68] Mozilla. (n.d.). NSPR. Retrieved from https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSPR

[69] Mozilla. (n.d.). NSS. Retrieved from https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS

[70] Flanagan, C., Leino, K. R. M., Lillibridge, M., Nelson, G., Saxe, J. B., & Stata, R. (2002). Extended static checking for Java. In *Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation* (PLDI).

[71] Gadelha, M. R., Stefﬁnlongo, E., Cordeiro, L. C., Fischer, B., & Nicole, D. A. (2018). SMT-based refutation of spurious bug reports in the Clang static analyzer. arXiv:1810.12041.

[72] Garmany, B., Stoffel, M., Gawlik, R., & Holz, T. (2019). Static detection of uninitialized stack variables in binary code. In *Proceedings of the European Symposium on Research in Computer Security* (ESORICS).

[73] Gerasimov, A. Y. (2018). Directed dynamic symbolic execution for static analysis warnings confirmation. *Programming and Computer Software*, 44(5).

[74] Godefroid, P., Klarlund, N., & Sen, K. (2005). DART: Directed automated random testing. In *Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation* (PLDI).

[75] Godefroid, P., Lahiri, S. K., & Rubio-González, C. (2011). Statically validating must summaries for incremental compositional dynamic test generation. In *Proceedings of the International Static Analysis Symposium* (SAS).

[76] Godefroid, P., Levin, M. Y., & Molnar, D. A. (2008). Automated whitebox fuzz testing. In *Proceedings of the Network and Distributed System Security Symposium* (NDSS).

[77] Goregaokar, M. (November 2017). Fearless concurrency in Firefox Quantum. Retrieved from https://blog.rust-lang.org/2017/11/14/Fearless-Concurrency-In-Firefox-Quantum.html

[78] Guo, S., Kusano, M., & Wang, C. (2016). Conc-iSE: Incremental symbolic execution of concurrent software. In *Proceedings of the International Conference on Automated Software Engineering* (ASE).

[79] Guo, S., Kusano, M., Wang, C., Yang, Z., & Gupta, A. (2015). Assertion guided symbolic execution of multithreaded programs. In *Proceedings of the ACM SIGSOFT Symposium on the Foundations of Software Engineering* (FSE).

[80] Hallem, S., Chelf, B., Xie, Y., & Engler, D. (2002). A system and language for building system-specific, static analyses. In *Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation* (PLDI).

[81] Haller, I., Slowinska, A., Neugschwandtner, M., & Bos, H. (2013). Dowser: A guided fuzzer to find buffer overflow vulnerabilities. In *Proceedings of the USENIX Security Symposium* (USENIX Sec).

[82] Hastings, R., & Joyce, B. (1991). Purify: Fast detection of memory leaks and access errors. In *Proceedings of the Winter USENIX Conference*.

[83] Helmer, R., Miyaguchi, A., & Rescorla, E. (October 2018). Testing privacy-preserving telemetry with Prio. Retrieved from https://hacks.mozilla.org/2018/10/testing-privacy-preserving-telemetry-with-prio/

[84] Hovemeyer, D., & Pugh, W. (2004). Finding bugs is easy. In *Proceedings of the ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications* (OOPSLA).

[85] Joern. (n.d.). Retrieved from https://joern.io/docs/

[86] Kim, S. Y., Lee, S., Yun, I., Xu, W., Lee, B., Yun, Y., & Kim, T. (2017). CAB-Fuzz: Practical concolic testing techniques for COTS operating systems. In *Proceedings of the USENIX Annual Technical Conference* (USENIX ATC).

[87] Kremenek, T. (2008). Finding software bugs with the Clang Static Analyzer. Retrieved from https://llvm.org/devmtg/2008-08/Kremenek_StaticAnalyzer.pdf

[88] Kwong, G. (2017). JavaScript fuzzing in Mozilla. Retrieved from https://nth10sd.github.io/js-fuzzing-in-mozilla/

[89] Larochelle, D., & Evans, D. (2001). Statically detecting likely buffer overflow vulnerabilities. In *Proceedings of the USENIX Security Symposium* (USENIX Sec).

[90] Lawall, J., & Muller, G. (2018). Coccinelle: 10 years of automated evolution in the Linux kernel. In *Proceedings of the USENIX Annual Technical Conference* (USENIX ATC).

[91] Lee, B., Song, C., Jang, Y., Wang, T., Kim, T., Lu, L., & Lee, W. (2015). Preventing use-after-free with dangling pointers nullification. In *Proceedings of the Network and Distributed System Security Symposium* (NDSS).

[92] Lee, J., Kim, Y., Song, Y., Hur, C.-K., Das, S., Majnemer, D., Regehr, J., & Lopes, N. P. (2017). Taming undefined behavior in LLVM. In *Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation* (PLDI).

[93] Li, K. (2016). Combining static and dynamic analysis for bug detection and program understanding. PhD thesis, University of Massachusetts Amherst.

[94] LLVM Project. (n.d.). The often misunderstood GEP instruction. Retrieved from https://llvm.org/docs/GetElementPtr.html

[95] LLVM Project. (n.d.). PHI Instruction. Retrieved from https://llvm.org/docs/LangRef.html#phi-instruction

[96] LLVM Project. (n.d.). Undefined Values. Retrieved from https://llvm.org/docs/LangRef.html#undefined-values

[97] Lu, K., Walter, M.-T., Pfaff, D., Nümberger, S., Lee, W., & Backes, M. (2017). Unleashing use-before-initialization vulnerabilities in the Linux kernel using targeted stack spraying. In *Proceedings of the Network and Distributed System Security Symposium* (NDSS).

[98] Luk, C.-K., Cohn, R., Muth, R., Patil, H., Klauser, A., Lowney, G., Wallace, S., Reddi, V. J., & Hazelwood, K. (2005). Pin: Building customized program analysis tools with dynamic instrumentation. In *Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation* (PLDI).

[99] Ma, K.-K., Phang, K. Y., Foster, J. S., & Hicks, M. (2011). Directed symbolic execution. In *Proceedings of the International Static Analysis Symposium* (SAS).

[100] Majumdar, R., & Sen, K. (2007). Hybrid concolic testing. In *Proceedings of the International Conference on Software Engineering* (ICSE).

[101] Milburn, A., Bos, H., & Giuffrida, C. (2017). SafeInit: Comprehensive and practical mitigation of uninitialized read vulnerabilities. In *Proceedings of the Network and Distributed System Security Symposium* (NDSS).

[102] Moroz, M., & Serebryany, K. (2016). Guided in-process fuzzing of Chrome components. Retrieved from Google Security Blog.

[103] Mozilla. (n.d.). Bug bounty program. Retrieved from https://www.mozilla.org/en-US/security/bug-bounty/

[104] Mozilla. (n.d.). Clang static analysis. Retrieved from https://developer.mozilla.org/en-US/docs/Mozilla/Testing/Clang_static_analysis

[105] Mozilla. (n.d.). Security severity ratings. Retrieved from https://wiki.mozilla.org/Security_Severity_Ratings

[106] Nethercote, N., & Seward, J. (2007). Valgrind: A framework for heavyweight dynamic binary instrumentation. In *Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation* (PLDI).

[107] Niemetz, A., Preiner, M., & Biere, A. (2015). Boolector 2.0. *Journal on Satisfiability, Boolean Modeling and Computation* (JSAT), 9(1).

[108] Pak, B. S. (2012). Hybrid fuzz testing: Discovering software bugs via fuzzing and symbolic execution. PhD thesis, Carnegie Mellon University.

[109] Parvez, R., Ward, P. A., & Ganesh, V. (2016). Combining static analysis and targeted symbolic execution for scalable bug-finding in application binaries. In *Proceedings of the IBM Centre for Advanced Studies Conference* (CASCON).

[110] Păsăreanu, C. S., & Visser, W. (2004). Verification of Java programs using symbolic execution and invariant generation. In *Proceedings of the SPIN Model Checking and Software Verification Workshop* (SPIN).

[111] Peng, H., Shoshitaishvili, Y., & Payer, M. (2018). T-fuzz: Fuzzing by program transformation. In *Proceedings of the IEEE Symposium on Security and Privacy* (IEEE S&P).

[112] Person, S., Yang, G., Rungta, N., & Khurshid, S. (2011). Directed incremental symbolic execution. In *Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation* (PLDI).

[113] Ramos, D. A. (2015). Under-constrained symbolic execution: Correctness checking for real code. PhD thesis, Stanford University.

[114] Ramos, D. A. (August 2019). Personal communication.

[115] Ramos, D. A., & Engler, D. (2015). Under-constrained symbolic execution: Correctness checking for real code. In *Proceedings of the USENIX Security Symposium* (USENIX Sec).

[116] Regehr, J. (n.d.). SQLite with a fine-toothed comb. Retrieved from https://blog.regehr.org/archives/1292

[117] Regehr, J., Reid, A., & Webb, K. (2005). Eliminating stack overflow by abstract interpretation. *ACM Transactions on Embedded Computing Systems* (TECS).

[118] Renzelmann, M. J., Kadav, A., & Swift, M. M. (2012). SymDrive: Testing drivers without devices. In *Proceedings of the USENIX Symposium on Operating Systems Design and Implementation* (OSDI).

[119] Ritter, T. (November 2019). Adding CodeQL and Clang to our bug bounty program. Retrieved from https://blog.mozilla.org/security/2019/11/14/adding-codeql-and-clang-to-our-bug-bounty-program/

[120] Rungta, N., Person, S., & Branchaud, J. (2012). A change impact analysis to characterize evolving program behaviors. In *Proceedings of the International Conference on Software Maintenance and Evolution* (ICSM).

[121] Sadowski, C., Aftandilian, E., Eagle, A., Miller-Cushon, L., & Jaspan, C. (2018). Lessons from building static analysis tools at Google. *Communications of the ACM*.

[122] Sadowski, C., Van Gogh, J., Jaspan, C., Söderberg, E., & Winter, C. (2015). Tricorder: Building a program analysis ecosystem. In *Proceedings of the International Conference on Software Engineering* (ICSE).

[123] Savage, S., Burrows, M., Nelson, G., Sobalvarro, P., & Anderson, T. (1997). Eraser: A dynamic data race detector for multithreaded programs. *ACM Transactions on Computer Systems* (TOCS), 15(4).

[124] Schwartz, E. J., Avgerinos, T., & Brumley, D. (2010). All you ever wanted to know about dynamic taint analysis and forward symbolic execution (but might have been afraid to ask). In *Proceedings of the IEEE Symposium on Security and Privacy* (IEEE S&P).

[125] Security at Mozilla. (n.d.). Retrieved from https://wiki.mozilla.org/security

[126] Semmle. (n.d.). Retrieved from https://semmle.com/

[127] Sen, K., Marinov, D., & Agha, G. (2005). CUTE: A concolic unit testing engine for C. In *Proceedings of the International Conference on Empirical Software Engineering and Measurement* (ESE-FSE).

[128] Serebryany, K., Bruening, D., Potapenko, A., & Vyukov, D. (2012). AddressSanitizer: A fast address sanity checker. In *Proceedings of the USENIX Annual Technical Conference* (USENIX ATC).

[129] Seward, J., & Nethercote, N. (2005). Using Valgrind to detect undefined value errors with bit-precision. In *Proceedings of the USENIX Annual Technical Conference* (USENIX ATC).

[130] Shoshitaishvili, Y., Wang, R., Hauser, C., Kruegel, C., & Vigna, G. (2015). Firmalice: Automatic detection of authentication bypass vulnerabilities in binary firmware. In *Proceedings of the Network and Distributed System Security Symposium* (NDSS).

[131] Shoshitaishvili, Y., Wang, R., Salls, C., Stephens, N., Polino, M., Dutcher, A., Grosen, J., Feng, S., Hauser, C., Kruegel, C., & Vigna, G. (2016). SoK: (State of) The Art of War: Offensive Techniques in Binary Analysis. In *Proceedings of the IEEE Symposium on Security and Privacy* (IEEE S&P).

[132] Song, D., Brumley, D., Yin, H., Caballero, J., Jager, I., Kang, M. G., Liang, Z., Newsome, J., Poosankam, P., & Saxena, P. (2008). BitBlaze: A new approach to computer security via binary analysis. In *Proceedings of the International Conference on Information Systems Security* (ICISS).

[133] Song, D., Lettner, J., Rajasekaran, P., Na, Y., Volckaert, S., Larsen, P., & Franz, M. (2019). SoK: Sanitizing for security. In *Proceedings of the IEEE Symposium on Security and Privacy* (IEEE S&P).

[134] SQLite Documentation. (n.d.). The virtual table mechanism of SQLite. Retrieved from https://sqlite.org/vtab.html

[135] Srivastava, A., & Eustace, A. (1994). ATOM: A system for building customized program analysis tools. In *Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation* (PLDI).

[136] Stepanov, E., & Serebryany, K. (2015). MemorySanitizer: Fast detector of uninitialized memory use in C++. In *Proceedings of the International Symposium on Code Generation and Optimization* (CGO).

[137] Stephens, N., Grosen, J., Salls, C., Dutcher, A., Wang, R., Corbetta, J., Shoshitaishvili, Y., Krügel, C., & Vigna, G. (2016). Driller: Augmenting fuzzing through selective symbolic execution. In *Proceedings of the Network and Distributed System Security Symposium* (NDSS).

[138] Stuart, H. (2008). Hunting bugs with Coccinelle. Master’s thesis, University of Copenhagen.

[139] Szekeres, L., Payer, M., Wei, T., & Song, D. (2013). SoK: Eternal war in memory. In *Proceedings of the IEEE Symposium on Security and Privacy* (IEEE S&P).

[140] Trabish, D., Mattavelli, A., Rinetzky, N., & Cadar, C. (2018). Chopped symbolic execution. In *Proceedings of the International Conference on Software Engineering* (ICSE).

[141] Van Der Kouwe, E., Nigade, V., & Giuffrida, C. (2017). Dangsan: Scalable use-after-free detection. In *Proceedings of the European Conference on Computer Systems* (EuroSys).

[142] Wang, X., Chen, H., Jia, Z., Zeldovich, N., & Kaashoek, M. F. (2012). Improving integer security for systems with KINT. In *Proceedings of the USENIX Symposium on Operating Systems Design and Implementation* (OSDI).

[143] Xie, Y., & Aiken, A. (2005). Saturn: A SAT-based tool for bug detection. In *Proceedings of the International Conference on Computer-Aided Verification* (CAV).

[144] Xie, Y., & Aiken, A. (2005). Scalable error detection using boolean satisfiability. In *Proceedings of the ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages* (POPL).

[145] Xu, M., Qian, C., Lu, K., Backes, M., & Kim, T. (2018). Precise and scalable detection of double-fetch bugs in OS kernels. In *Proceedings of the IEEE Symposium on Security and Privacy* (IEEE S&P).

[146] Yan, H., Sui, Y., Chen, S., & Xue, J. (2018). Spatio-temporal context reduction: A pointer-analysis-based static approach for detecting use-after-free vulnerabilities. In *Proceedings of the International Conference on Software Engineering* (ICSE).

[147] Yang, G., Khurshid, S., Person, S., & Rungta, N. (2014). Property differencing for incremental checking. In *Proceedings of the International Conference on Software Engineering* (ICSE).

[148] Ye, D., Sui, Y., & Xue, J. (2014). Accelerating dynamic detection of uses of undefined values with static value-flow analysis. In *Proceedings of the International Symposium on Code Generation and Optimization* (CGO).

[149] Younan, Y. (2015). FreeSentry: Protecting against use-after-free vulnerabilities due to dangling pointers. In *Proceedings of the Network and Distributed System Security Symposium* (NDSS).

[150] Yun, I., Lee, S., Xu, M., Jang, Y., & Kim, T. (2018). QSYM: A practical concolic execution engine tailored for hybrid fuzzing. In *Proceedings of the USENIX Security Symposium* (USENIX Sec).

[151] Zaks, A., & Rose, J. (2012). How to write a checker in 24 hours. Retrieved from https://llvm.org/devmtg/2012-11/Zaks-Rose-Checker24Hours.pdf

[152] Zalewski, M. (n.d.). American fuzzy lop. Retrieved from http://lcamtuf.coredump.cx/afl

[153] Zhang, Y., Chen, Z., Wang, J., Dong, W., & Liu, Z. (2015). Regular property guided dynamic symbolic execution. In *Proceedings of the International Conference on Software Engineering* (ICSE).

[154] Zinzindohoué, J.-K., Bhargavan, K., Protzenko, J., & Beurdouche, B. (2017). HACL*: A verified modern cryptographic library. In *Proceedings of the ACM Conference on Computer and Communications Security* (ACM CCS).

---

希望这些优化能帮助你更好地组织和呈现你的参考文献。如果有任何进一步的需求，请告诉我！