# 【技术分享】Windows内核Pool溢出漏洞：组合对象的Spray利用

##### 译文声明
本文是翻译文章，原文来源：srcincite.io
原文地址：[请提供具体链接]
译文仅供参考，具体内容表达以及含义以原文为准。
译者：[myswsun](http://bobao.360.cn/member/contribute?uid=2775084127)
预估稿费：200RMB
投稿方式：发送邮件至linwei#360.cn，或登录网页版在线投稿

## 0x00 前言
本文将介绍一种基础的Windows内核pool溢出漏洞，并演示如何通过混合内核对象喷射（spray）内核pool后，覆盖**TypeIndex**实现漏洞利用。

## 0x01 介绍
在参加了BlackHat的[AWE课程](https://www.offensive-security.com/information-security-training/advanced-windows-exploitation/)之后，我希望能够发现并利用一些内核漏洞。尽管HackSys Extreme Vulnerable Driver (HEVD) 是一个很好的学习工具，但我更倾向于在实际应用程序中发现并利用漏洞。

自参加该课程以来，我开发了一个私有的Windows内核设备驱动fuzzer。使用这个fuzzer，我发现了本文将要介绍的漏洞。虽然这种漏洞利用的技术并不新颖，但稍作修改后可以使攻击者几乎可以利用任意大小的pool。本文主要作为我个人的学习参考，希望也能帮助其他人尝试pool漏洞利用。

## 0x02 漏洞介绍
在测试了一些SCADA产品后，我发现了一个名为**WinDriver**的第三方组件。经过简单调查，我发现这是[Jungo的DriverWizard WinDriver](http://www.jungo.com/st/products/windriver/)。这个产品捆绑在多个SCADA产品中，且通常是较老的版本。

安装后，它会在标准的Windows驱动目录中安装一个名为`wndrvr1240.sys`的设备驱动。通过简单的逆向分析，我发现了几个IOCTL码，并将这些值插入到我的fuzzer配置文件中。随后，我使用命令行`verifier /volatile /flags 0x1 /adddriver wndrvr1240.sys`启用了special pool，并运行了我的fuzzer。最终，我发现了几个可利用的漏洞，特别是以下这个：

用户可控的数据存储在**[esi+ecx]**中，这会导致越界写入内核pool。进一步检查后，我发现这是一个pool溢出，由`loc_4199D8`中的内联复制操作触发。每次循环拷贝8个字节（一个QWORD），并且溢出了一个大小为0x460（0x458+0x8字节的头）的缓冲区。拷贝的大小直接由攻击者的输入缓冲区控制，无需整数溢出，数据也没有存储在隐蔽的地方。我们在`0x004199E8`处可以看到，大小是由攻击者控制的，来自于提供的缓冲区的+0x18偏移。非常简单！

## 0x03 漏洞利用
现在，让我们进入有趣的部分。通用的技术是对象**TypeIndex**覆盖，这种技术已经被广泛介绍过，至少已有六年历史，因此我不打算深入太多细节。基本上，就是使用任何内核对象来覆盖存储在_OBJECT_HEADER中的**TypeIndex**。

过去常用的对象是**Event**对象（大小为0x40）和**IoCompletionReserve**对象（大小为0x60）。典型的漏洞利用步骤如下：
1. 使用大小为X的对象**喷射**pool，填充内存页。
2. 通过释放附近的对象在内存页中“**打洞**”，触发合并（coalescing）以满足目标块的大小（我们的例子中是0x460）。
3. 分配并**溢出**缓冲区，希望命中一个“洞”，破坏下一个对象的_OBJECT_HEADER，最终破坏**TypeIndex**。

例如，如果你溢出的缓冲区大小为0x200，你应该分配一堆Event对象，并释放其中的0x8个对象（0x40*0x8==0x200）。这样你就有了“洞”，可以在其中分配并溢出。因此，我们需要的内核对象的大小应是我们pool大小的模数（取模余数为0）。

问题在于某些大小无法满足。假设我们的pool大小为0x460，那么：
- 我们总是有余数。这意味着我们不能构造一个适合我们块的“洞”。我们能实现吗？

有一些方法可以解决这个问题。一种方法是寻找一个内核对象，使其大小是我们目标缓冲区大小的模数。我花了一些时间完成了这个工作，并找到了两个其他的内核对象：
- 这些大小无用，因为它们不是0x460的模数。

经过一段时间的测试和调整，我确定了如下的模数可以满足：
- 太好了！0xa0可以均分0x460，但我们怎么才能得到大小为0xa0的内核对象呢？如果我们将Event和IoCompletionReserve对象组合起来（0x40+0x60=0xa0）就能实现。

### 喷射
上述函数喷射了50000个对象，包括25000个Event对象和25000个IoCompletionReserve对象。在windbg中看起来非常完美：

### “打洞”
‘IoCo’标记表示一个IoCompletionReserve对象，而“Even”标记表示一个Event对象。注意我们首个块偏移是0x60，这是我们将要释放的起始偏移。因此，我们释放几组对象，计算如下：
- 最终，我们会得到正确的大小。让我们快速浏览一下只释放7个IoCompletionReserve的情况。

我们可以看到有分隔开的被释放的内存块，但我们希望将它们合并成一个0x460的被释放的内存块。为了实现这一点，我们需要设置我们块的偏移为0x60（指向0xXXXXY060）。

现在，当我们运行释放函数时，我们在pool中打洞，并最终得到一个满足我们目标大小的被释放的内存块。我们可以看到，被释放的内存块已经合并，现在我们有了一个完美大小的“洞”。接下来需要做的就是分配并覆盖内存。

### 溢出并“存活”
你可能注意到，在利用中的缓冲区偏移0x90处有一个NULL dword。这是为了让溢出能够“存活”下来，并避免任何进一步的处理。下面的代码在拷贝循环后直接执行。

关键点在于代码将调用`sub_4196CA`。还要注意到`@eax`为我们的缓冲区+0x90（0x004199FA）。我们看一下这个函数调用。

代码从我们的SystemBuffer+0x90中获取一个dword值，写入被溢出的缓冲区，然后检查它是否为null。我们可以通过这个函数避免进一步处理并返回。如果我们不做这个，当试图访问不存在的指针时将会导致BSOD。

现在，我们可以干净地返回并无错地触发eop。关于shellcode清理，我们的溢出缓冲区存储在`@esi`中，因此我们可以计算到**TypeIndex**的偏移并修补它。最后，使用NULL破坏ObjectCreateInfo，因为系统将避免使用那个指针。

### 构造我们的缓冲区
因为在每次循环中会拷贝0x8个字节，且起始索引是0x1c：
- 我们可以进行一些溢出计算。假设我们想要通过44字节（0x2c）溢出缓冲区。我们将缓冲区的大小减去头，再减去起始索引偏移，加上我们想要溢出的字节数，并将它们按0x8字节分割（因为每次循环是一个qword拷贝）。

    \[
    (0x460 - 0x8 - 0x1c + 0x2c) / 0x8 = 0x8d
    \]

因此，通过0x2c字节溢出缓冲区的大小是0x8d。这将破坏pool头、quota和对象头。

我们可以看到设置了**TypeIndex**为0x00080000。这意味着函数表将指向0x0，我们可以方便地映射NULL页。

注意第二个索引是0xbad0b0b0。我觉得很开心，我能在x64上使用相同的技术。

### 在内核中触发代码执行
在触发溢出后，我们能成功执行，但为了获得eop，我们需要设置一个指针指向0x00000074来利用OkayToCloseProcedure函数指针。

因此，0x28+0x4c = 0x74，这是我们指针需要的位置。但是怎么调用OkayToCloseProcedure？它是一个注册的aexit处理函数。因此，为了触发代码执行，只需释放“损坏”的IoCompletionReserve。我们不知道哪个句柄关联着溢出块，因此我们将它们全部释放。

运行截图如下：

## 0x04 时间线
- 2017-08-22 – 验证并通过邮件{sales,first,security,info}@jungo.com发送给Jungo。
- 2017-08-25 – Jungo没有回应。
- 2017-08-26 – 试图通过网站联系供应商。
- 2017-08-26 – 通过网站联系无回应。
- 2017-09-03 – 收到Jungo的邮件，表明他们正在调查。
- 2017-09-03 – 请求补丁开发时间并发布可能的0day警告。
- 2017-09-06 – 没有回应。
- 2017-09-06 – 发布0day安全公告。

## 0x05 总结
使用这种方法可以利用的块大小参考以下资源：
- [FuzzySecurity教程](http://www.fuzzysecurity.com/tutorials/expDev/20.html)
- [BlackHat DC 2011 Mandt演讲](https://media.blackhat.com/bh-dc-11/Mandt/BlackHat_DC_2011_Mandt_kernelpool-Slides.pdf)
- [MSDN文档](https://msdn.microsoft.com/en-us/library/windows/desktop/ms724485(v=vs.85).aspx)
- [Exploit-DB上的相关exploit](https://www.exploit-db.com/exploits/34272)