### 2. Embedding Untrusted Remote Content

Office 2010 provides a rich add-in interface, which we utilized to make all necessary modifications without needing access to the source code of Word and Excel. Our add-in ensures that every opened document is routed to an appropriate Word instance using `CreatePI()`. Additionally, it extends Word’s hyperlink class to enable an iframe-like embedding model, allowing users to embed a frame pointing to a remote web page or object.

Upon opening a document, our add-in scans for these special hyperlinks, extracts information such as the frame's URL, position, and dimensions, and calls `Embed()` accordingly. ServiceOS then fetches the corresponding remote content, dispatches it to a properly isolated principal instance, and integrates the rendered content into the UI container within the Word document. For example, we have used our add-in to securely embed video clips from YouTube, making them playable directly from the containing Word document—a functionality previously unavailable in Word.

Our Word add-in consists of only 223 lines of C# code and took approximately one man-day to develop after familiarizing ourselves with Word’s add-in APIs. We also ported this plugin to Excel 2010, which required only two man-hours and resulted in a 227-line Excel add-in.

Each Word or Excel principal instance has its own UI, with most menu items performing functions on the underlying document and continuing to work on ServiceOS. Some features, such as document comparison or merge, will not function if the involved documents are owned by different principals. However, such features can be enabled via explicit ServiceOS-mediated IPC between different instances of Word.

### 7.1.2 Wordpad

Wordpad is a sophisticated text editor, chosen as a case study for porting via source code modification. Unlike Word, Wordpad is not modularized and does not provide plugin interfaces. It consists of over 50,000 lines of C++ code, representing a reasonably complex application.

We extended Wordpad with the same ServiceOS support as for Word and Excel. For instance, we modified the document parser to recognize special objects representing remote content and to call `Embed()`, and we adjusted the UI code to accommodate embedded content frames during document rendering. This effort, carried out by one author with no prior knowledge of Wordpad, took about 50 hours, with most of the time spent understanding the source code. In total, we added only 435 lines of C++ code, and we expect that Wordpad developers could implement these changes more quickly. Overall, our experience demonstrated that adapting to ServiceOS is feasible even when source code modification is required.

### 7.1.3 Internet Explorer

As our primary browser renderer, we ported Microsoft Internet Explorer’s Trident rendering engine to use our new system APIs. This effort closely mirrors the implementation of the Gazelle browser, so we omit further details here. In summary, we modified Trident to use ServiceOS system calls (see Table 1) through public IE COM interfaces, thereby enforcing ServiceOS’s isolation policies instead of IE’s. This could impact web compatibility, but recent work suggests that an architecture like ours should have little or no compatibility issues [44].

### 7.1.4 Microsoft Outlook 2010

Microsoft Outlook 2010 is a popular email and personal information management application. Outlook needs to isolate untrusted content in email messages, which are not addressable via URLs. For such content, applications can still use our `Embed()` call to offload content isolation while rendering it in-place with the rest of the application’s UI. We extended Outlook to use `Embed()` to render email messages in a separate protection domain, using our IE renderer (Section 7.1.3). Because ServiceOS cannot determine the owner information of such content, we let Outlook download message bodies and provide them directly to `Embed()` via "data:" URLs; ServiceOS uses uniquely-labeled containers in such cases.

Outlook’s own protection mechanisms for restricting email rendering, such as filters for `<script>`, `<iframe>`, and other dangerous tags, have been error-prone. Recent patches fixed 15 vulnerabilities that, in severe cases, allowed attackers to take control of a system when a victim simply viewed a specially-crafted email [34]. With ServiceOS, Outlook gains stronger isolation from email rendering bugs, while email content can benefit from additional functionality provided by IE, such as scripts and embeddable iframes.

We also extended Outlook to safely preview attachments using any ServiceOS content processor. ServiceOS selects the renderer based on the content type of the attachment, replacing the system-wide Windows registry lookup, which is unavailable in sandboxed applications. This isolation is not only stronger but also more user-friendly, as it eliminates the need for Outlook to prompt the user to consent to a preview of untrusted attachments.

Like Word, we modified Outlook using its add-in framework. This effort required 20 hours, including the time to understand Outlook’s add-in model, and resulted in a small 342-line add-in.

### 7.2 Vulnerability Analysis

We analyzed vulnerabilities published for three large Windows applications during 2008-2011 [2, 34]. We evaluated whether ServiceOS’s design mitigated these vulnerabilities by checking if each vulnerability was related to parsing or other content processing errors. The results are shown in Table 2. Content processing errors are widespread: 88% of Office vulnerabilities and 85% of IE vulnerabilities are related to content parsing. Adobe Reader’s numbers included 125 vulnerabilities with unknown attack vectors; of the rest, 83% involved content processing. Exploits of all these flaws would be naturally contained if users were using these applications on ServiceOS; Section 7.3 demonstrates this with two concrete exploits. The remaining vulnerabilities that ServiceOS cannot contain include insecure library loading vulnerabilities exploitable by planting malicious DLLs, HTML sanitization vulnerabilities leading to XSS, and denial-of-service vulnerabilities.

The ServiceOS monitor has only 9.4K lines of code, significantly smaller than many applications. For example, OpenOffice has about 9M lines of code [6], and even the relatively simple Wordpad has over 50K lines of code. Fundamentally, ServiceOS does not rely on large applications to enforce remote content security, thus reducing the TCB for isolation logic significantly.

### 7.3 Exploit Mitigation

To verify that our system can stop exploits of content processing flaws, we examined two real-world Word 2010 exploits. First, we used a proof-of-concept parsing exploit that uses an RTF Header stack overflow vulnerability [35] to construct a malicious document that looks for other, potentially sensitive Word documents the user has concurrently opened in the same Word instance and sends them to an attacker via HTTP. The attack worked successfully on Word 2010 version 14.0.4760, bypassing both DEP and ASLR [35].

We also crafted a second malicious document that uses macros to perform the same attack. Word treats documents opened from the web as untrusted and does not run macros by default, but offers users a choice to trust the document via a single click on a yellow security button above it. The attack document tricks the victim into clicking this button by pretending to be a greeting card that needs permission to be customized. Such an attack is easier to implement as it does not require bypassing existing security mechanisms and demonstrates the pitfalls of relying on user prompts for isolation decisions. This attack works on the latest version of Word 2010, provided the victim clicks on the yellow security button.

Application-based isolation (such as that on iOS or Android) would also not stop these two exploits, as they both work within the permission boundaries of their Word instance. When we tried opening both attack documents in Word running on ServiceOS, we observed that ServiceOS stopped both exploits. Moreover, ServiceOS’s Word version did not use any user prompts to enable macros, as it no longer needs to restrict remote documents since they are already isolated according to their owner. This provides a better user experience for documents that legitimately use dangerous features such as macros or ActiveX.

### 7.4 Performance

In measuring ServiceOS performance, we focused on (1) startup latencies imposed on opening documents, (2) overheads on memory usage, and (3) performance of our content fetch APIs. Our measurements were performed on a 64-bit Windows 7 desktop with dual 3.16GHz Intel Xeon E8500 Duo-Core CPUs, 4GB of RAM, and a Broadcom NetXtreme Gigabit Ethernet NIC. We present results for three applications: Excel 2010, Internet Explorer (IE), and Wordpad. Excel and Wordpad experiments used 10KB, 10MB, and 100MB documents; IE was used to open a simple test page on an Intranet web server. We separated the overhead of Drawbridge from the rest of our system where possible, as our system can work with other sandboxing mechanisms. To run a ServiceOS application without Drawbridge, we executed it as a regular Windows process.

**Startup Latencies:** The ServiceOS monitor and shell take 118ms to start. After a user navigates to a URL, our system starts the appropriate renderer. Figure 6 compares this startup time to the native versions of the applications on Windows. Most overhead (up to 1.5 sec) comes from starting the Drawbridge environment. Excluding Drawbridge, in all tests, ServiceOS adds less than 200ms to connect to the monitor and initialize. An obvious optimization is to maintain a small number of pre-created renderers for popular content types. Even without this optimization, we feel the startup overhead is acceptable. For example, if a user is viewing a web page with an embedded 10KB Excel spreadsheet, starting our modified Excel on ServiceOS would add only 112ms to Excel’s normal startup time.

**Memory Usage:** We measured the committed memory size for each application with one document open. Excel running on ServiceOS uses about 47MB more memory than when running on Windows, regardless of document size. This is due to Excel’s loading of interoperability DLLs required to run any Excel add-in; our plugin itself has negligible additional memory cost. Both Wordpad and ported IE carry a very small memory overhead (less than 3MB), which is required to load and initialize our 74KB LibServiceOS DLL. Drawbridge isolation introduces an additional overhead of up to 37MB for Excel.

Figures 7 and 8 show the aggregate memory usage for running multiple instances of Excel and Wordpad simultaneously. Both native and ServiceOS-enabled Excel can open multiple documents in the same process or separate processes. ServiceOS-enabled Excel renders documents in the same process only if their owners are the same.

### 8. Related Work

**Browsers:** Much recent work in browsers has explored stronger isolation of websites. OP [18] applies a microkernel architecture design with a browser kernel that enforces SOP. Tahoma [10] isolates (its own definition of) web applications using virtual machines. Major commercial browsers like Chrome and IE have adopted a process-per-tab multi-process model and reduce privileges of tab processes. Gazelle [49] has a design that treats websites as OS principals and makes its browser kernel the exclusive place for cross-principal protection. Our work builds on Gazelle and generalizes Gazelle’s design to support all applications beyond web applications. We introduce the notion of a content processing stack to give a uniform treatment for both web content and content processed by native applications, generalize browsers’ same-origin policy to allow arbitrary isolation granularity for URI-addressable content, and introduce the dispatch bit mechanism to enforce principal definitions.

**Modern Client Platforms:** iOS, Android, Windows Phone, Windows 8, and the research OS Singularity [20, 51] all treat application code packages as different principals and put their execution instances into separate processes with different UIDs. While this marks a milestone of finally moving away from the decades-old model of treating user accounts as principals, we take another significant step by advocating a content-based principal model.

IBOS [45] aims to reduce the trusted computing base for browsers by applying a microkernel design for all traditional OS components, exposing browser abstractions at the lowest software layer, and removing many components not needed by browsers. IBOS solves an orthogonal problem from ours. Our problem is to let the OS provide content-based isolation for browsers and non-browser applications alike.

Embassies [19] describes web browsers as pico-datacenters where each “machine” corresponds to a website and is isolated from other sites or “machines.” This view is consistent with the semantics of existing browsers where the same-origin policy is applied to isolate websites. Nevertheless, existing browsers do not realize isolation reliably. Embassies advocates refactoring browsers into the CEI and the DPI. This mirrors the refactoring done in Gazelle [49]: CEI corresponds to the Browser Kernel API in Gazelle, which is runtime-independent; DPI corresponds to the runtime API in Gazelle’s principal instances, allowing any programming languages or enrichment of the runtime as needed. Embassies defines website principals using public keys, similar to one of our principal ID proposals (Section 4.2.1). Our work additionally considers content processing stacks (Section 4.1) and cross-principal content fetch of two forms: data communication and spawning new principals (Section 5), which are commonplace in practice. Finally, ServiceOS aims to support both web applications and native applications on the same OS platform without compromising security semantics of the web while allowing easy adaptation of native applications.