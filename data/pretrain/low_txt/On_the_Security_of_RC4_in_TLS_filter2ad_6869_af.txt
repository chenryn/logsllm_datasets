### Recall of Single-Byte Bias Attack
Our single-byte bias attack targets the first 256 bytes of plaintext across multiple TLS sessions or connections with random keys. To efficiently generate the large number of ciphertexts required for testing this attack, we utilized the `s_client` and `s_server` tools, modifying the `s_client` source code to force session resumption for each TLS packet sent.

Using this approach, we were able to generate approximately \(2^{21}\) encryptions of a fixed plaintext per hour. With \(2^{25}\) recorded ciphertexts, we obtained results comparable to the simulation of our single-byte bias attack reported in Section 5.1. An alternative method to ensure frequent rekeying is to actively interfere with the TLS session after each ciphertext is sent, causing it to fail and be restarted by injecting a bad TLS packet or resetting the corresponding TCP connection.

We acknowledge that we do not currently have an automated mechanism for forcing session resumption, such as from JavaScript. However, JavaScript running in the browser can trigger the establishment of a fresh TLS session (with a fresh, random key) after each HTTP connection is torn down by the attacker. We estimate that this second approach would be significantly slower than using session resumption due to the additional overhead of the full TLS Handshake. Thus, even though our double-byte bias attack has higher complexity in terms of its ciphertext requirements compared to the single-byte bias attack, it could be more efficient in practice in terms of total running time because it can be executed in a single session (or a small number of sessions).

Furthermore, while the single-byte bias attack successfully recovered fixed plaintext bytes in the initial 256 bytes of the TLS ciphertexts, our subsequent experimentation with modern web browsers revealed that these bytes consisted mostly of less interesting HTTP headers rather than cookies. For this reason, after basic validation, we shifted our experimental focus to the double-byte bias attack.

### Validating the Double-Byte Bias Attack
The double-byte bias attack does not rely on session resumption or renegotiation, making it easier to implement in practice. Our experimental setup for this attack involved a network comprising three non-virtualized nodes: a legitimate web server (`www.abc.com`) that serves 16-byte secure cookies over HTTPS, a malicious web server (`www.evil.com`) serving a malicious JavaScript, and a client running a web browser representing a user. The legitimate and malicious web servers ran Apache and PHP. For the client, we tested various browsers, including Firefox, Opera, and Chrome. The nodes were connected through a 100 Mbps Ethernet link, equipped with Intel Core i7 processors with 2.3 GHz cores and 16 GB of RAM. None of our experiments used all available CPU resources or saturated the network bandwidth.

In this setup, we let the client visit `https://www.abc.com`. This resulted in the legitimate web server sending the client a secure cookie, which was stored by the client’s browser. The cookie became the target of the attack. We then let the client visit `http://www.evil.com` and run the malicious JavaScript served by the malicious web server. Note that the same-origin policy (SOP) implemented by the client’s browser prevented the JavaScript from directly accessing the secure cookie. However, the JavaScript directed repeated HTTP requests to the legitimate server over TLS (i.e., using HTTPS). The client’s browser automatically attached the cookie to each request, thereby repeatedly encrypting the target cookie as required for the attack.

The JavaScript used `XMLHttpRequest` objects to send the requests. We tested GET, POST, and HEAD requests, but found that POST requests provided the best performance (using Firefox). Additionally, we found that the requests needed to be sent in blocks to ensure the browser remained responsive and did not become overloaded.

For all the browsers we tested (Firefox, Chrome, and Opera), the requests generated by the JavaScript resulted in TLS messages containing more than 256 bytes of ciphertext. To keep the target cookie in a fixed position in the TLS message (modulo 256) as needed for the double-byte bias attack, we added padding by manipulating the HTTP headers in the request to bring the encrypted POST requests up to exactly 512 bytes. This padding introduced some overhead to the attack. The exact amount and location of padding needed are browser-dependent, as different browsers behave differently in terms of the content and order of HTTP headers included in POST requests. In practice, the attacker's JavaScript would need to perform some browser fingerprinting before carrying out the attack.

As an alternative method for generating requests to the legitimate web server, we tried replacing the JavaScript code with basic HTML code, using HTML tags such as `img`, pointing to `https://www.abc.com`. The target cookie was still sent in every request, but this approach was less effective (i.e., slower) than using JavaScript.

For Firefox with 512-byte ciphertexts encrypting padded `XMLHttpRequest` POST requests, we were able to generate 6 million ciphertexts per hour on our network, with each request containing the target cookie in the same position (modulo 256) in the corresponding plaintext. Given that our attack needs on the order of \(13 \times 2^{30}\) encryptions to recover a 16-byte plaintext with high success probability, we estimate that the running time for the whole attack would be on the order of 2000 hours using our experimental setup. The attack generates large volumes of network traffic over long periods, and thus should not be considered a practical threat. Nevertheless, it demonstrates that our double-byte bias attack works in principle.

### Discussion and Conclusions
We have shown that plaintext recovery for RC4 in TLS is possible for the first about 200 bytes of the plaintext stream (after the Finished message), provided sufficiently many independent encryptions of the same plaintext are available. The number of encryptions required (around \(2^{28}\) to \(2^{32}\) for reliable recovery) is large but not completely infeasible. We have also shown that plaintext recovery for RC4 is possible from arbitrary positions in the plaintext, given enough encryptions of the same plaintext bytes. Here, the number of encryptions required is higher (around \(13 \times 2^{30}\)), but the attack is more flexible and more efficient in practice because it avoids rerunning the TLS Handshake. Certainly, the security level provided by RC4 in TLS is far below the strength implied by the 128-bit key in TLS.

However, it would be incorrect to describe the attacks as a practical threat to TLS today. Our attacks are open to further enhancement, using, for example, the ability of our algorithms to output likelihoods for candidate plaintext bytes coupled with more sophisticated plaintext models. It may also be possible to enhance the rate of ciphertext generation in browsers using methods beyond our knowledge. It would seem dangerous to assume that the attacks will not be improved by other researchers in the future.

There are countermeasures to the attacks. We discussed these extensively with vendors during the disclosure process. They include: discarding the initial keystream bytes output by RC4, fragmenting the initial HTTP requests at the browser so that the initial keystream bytes are mostly (or entirely) used to encrypt MAC fields, adding random padding to HTTP requests, and limiting the lifetime of cookies or the number of times they can be sent from the browser. The first countermeasure cannot easily be implemented in TLS because it would require mass coordination between the many different client and server implementations. The first two countermeasures are not effective against our double-byte bias attack. The third countermeasure can be relatively easily implemented in browsers but increases the complexity of our attacks rather than defeating them completely. The fourth countermeasure is currently effective but not immune to further improvements of our attacks. Some vendors (e.g., Opera) have implemented a combination of these (and other) countermeasures; others (e.g., Google in Chrome) are focusing on implementing TLS 1.2 and AES-GCM.

We recognize that, with around 50% of TLS traffic currently using RC4, recommending that it be avoided completely in TLS is not a suggestion to be made lightly. Nevertheless, given the rather small security margin provided by RC4 against our attacks, our recommendation is that RC4 should henceforth be avoided in TLS and deprecated as soon as possible.

### Acknowledgements
We thank David McGrew for raising the question of the security of RC4 in TLS.

### References
[1] Wireless LAN medium access control (MAC) and physical layer (PHY) specification, 1997.
[2] Wireless LAN medium access control (MAC) and physical layer (PHY) specification: Amendment 6: Medium access control (MAC) security enhancements, 2004.
[3] ALFARDAN, N., AND PATERSON, K. G. Lucky 13: Breaking the TLS and DTLS record protocols. In IEEE Symposium on Security and Privacy (2013).
[4] ALFARDAN, N. J., BERNSTEIN, D. J., PATERSON, K. G., POETTERING, B., AND SCHULDT, J. C. N. On the security of RC4 in TLS and WPA. Information Security Group at Royal Holloway, University of London, 2013. http://www.isg.rhul.ac.uk/tls/RC4biases.pdf.
[5] AMMAN, B. Personal communication, February 2013.
[6] CANVEL, B., HILTGEN, A., VAUDENAY, S., AND VUAGNOUX, M. Password interception in a SSL/TLS channel. Advances in Cryptology-CRYPTO 2003 (2003), 583–599.
[7] DIERKS, T., AND ALLEN, C. The TLS Protocol Version 1.0. RFC 2246, Internet Engineering Task Force, Jan. 1999.
[8] DIERKS, T., AND RESCORLA, E. The Transport Layer Security (TLS) Protocol Version 1.1. RFC 4346, Internet Engineering Task Force, Apr. 2006.
[9] DIERKS, T., AND RESCORLA, E. The Transport Layer Security (TLS) Protocol Version 1.2. RFC 5246, Internet Engineering Task Force, Aug. 2008.
[10] DUONG, T., AND RIZZO, J. Here come the ⊕ Ninjas. Unpublished manuscript, 2011.
[11] FLUHRER, S. R., MANTIN, I., AND SHAMIR, A. Weaknesses in the key scheduling algorithm of RC4. In Selected Areas in Cryptography (2001), S. Vaudenay and A. M. Youssef, Eds., vol. 2259 of Lecture Notes in Computer Science, Springer, pp. 1–24.
[12] FLUHRER, S. R., AND MCGREW, D. Statistical analysis of the alleged RC4 keystream generator. In FSE (2000), B. Schneier, Ed., vol. 1978 of Lecture Notes in Computer Science, Springer, pp. 19–30.
[13] ISOBE, T., OHIGASHI, T., WATANABE, Y., AND MORII, M. Full plaintext recovery attack on broadcast RC4. In Preproceedings of FSE (2013).
[14] JAGANATHAN, K., ZHU, L., AND BREZAK, J. The RC4-HMAC Kerberos Encryption Types Used by Microsoft Windows. RFC 4757 (Informational), Dec. 2006.
[15] MAITRA, S., PAUL, G., AND SENGUPTA, S. Attack on broadcast RC4 revisited. In FSE (2011), A. Joux, Ed., vol. 6733 of Lecture Notes in Computer Science, Springer, pp. 199–217.
[16] MANTIN, I. Predicting and distinguishing attacks on RC4 keystream generator. In EUROCRYPT (2005), R. Cramer, Ed., vol. 3494 of Lecture Notes in Computer Science, Springer, pp. 491–506.
[17] MANTIN, I., AND SHAMIR, A. A practical attack on broadcast RC4. In FSE (2001), M. Matsui, Ed., vol. 2355 of Lecture Notes in Computer Science, Springer, pp. 152–164.
[18] MCGREW, D., AND BAILEY, D. AES-CCM Cipher Suites for Transport Layer Security (TLS). RFC 6655 (Proposed Standard), 2012.
[19] MIRONOV, I. (Not so) random shuffles of RC4. In CRYPTO (2002), M. Yung, Ed., vol. 2442 of Lecture Notes in Computer Science, Springer, pp. 304–319.
[20] PHP DOCUMENTATION GROUP. PHP manual, Feb 2013. http://www.php.net/manual/en/session.configuration.php#ini.session.hash-bits-per-character.
[21] SALOWEY, J., CHOUDHURY, A., AND MCGREW, D. AES Galois Counter Mode (GCM) Cipher Suites for TLS. RFC 5288 (Proposed Standard), Aug. 2008.
[22] SEN GUPTA, S., MAITRA, S., PAUL, G., AND SARKAR, S. Proof of empirical RC4 biases and new key correlations. In Selected Areas in Cryptography (2011), pp. 151–168.
[23] SEN GUPTA, S., MAITRA, S., PAUL, G., AND SARKAR, S. (Non-) random sequences from (non-) random permutations – analysis of RC4 stream cipher. Journal of Cryptology to appear (2013).
[24] SEPEHRDAD, P., VAUDENAY, S., AND VUAGNOUX, M. Discovery and exploitation of new biases in RC4. In Selected Areas in Cryptography (2010), A. Biryukov, G. Gong, and D. R. Stinson, Eds., vol. 6544 of Lecture Notes in Computer Science, Springer, pp. 74–91.
[25] SEPEHRDAD, P., VAUDENAY, S., AND VUAGNOUX, M. Statistical attack on RC4 – distinguishing WPA. In EUROCRYPT (2011), K. G. Paterson, Ed., vol. 6632 of Lecture Notes in Computer Science, Springer, pp. 343–363.
[26] VAUDENAY, S., AND VUAGNOUX, M. Passive-only key recovery attacks on RC4. In Selected Areas in Cryptography (2007), C. M. Adams, A. Miri, and M. J. Wiener, Eds., vol. 4876 of Lecture Notes in Computer Science, Springer, pp. 344–359.