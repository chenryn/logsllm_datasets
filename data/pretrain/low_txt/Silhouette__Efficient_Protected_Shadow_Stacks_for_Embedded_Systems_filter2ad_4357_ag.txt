以下是优化后的文本，使其更加清晰、连贯和专业：

---

**参考文献**

[26] John Criswell, Nathan Dautenhahn, 和 Vikram Adve. KCoFI: 完整的控制流完整性用于商用操作系统内核. 在 2014 年 IEEE 安全与隐私研讨会论文集, SP '14, 第 292-307 页, 加利福尼亚州圣何塞, 2014. IEEE 计算机学会.

[27] John Criswell, Andrew Lenharth, Dinakar Dhurjati, 和 Vikram Adve. 安全虚拟架构：商品操作系统的安全执行环境. 在第 21 届 ACM SIGOPS 操作系统原理研讨会论文集, SOSP '07, 第 351-366 页, 华盛顿州斯特文森, 2007. ACM.

[28] Thurston H.Y. Dang, Petros Maniatis, 和 David Wagner. 影子栈和栈金丝雀的性能开销. 在第 10 届 ACM 信息安全、计算机和通信安全研讨会论文集, ASIACCS '15, 第 555-566 页, 新加坡, 2015. ACM.

[29] Lucas Davi, Ahmad-Reza Sadeghi, Daniel Lehmann, 和 Fabian Monrose. 缝合小工具：粗粒度控制流完整性保护的无效性. 在第 23 届 USENIX 安全研讨会论文集, Security '14, 第 401-416 页, 加利福尼亚州圣地亚哥, 2014. USENIX 协会.

[30] Dinakar Dhurjati 和 Vikram Adve. C 语言中具有非常低开销的向后兼容数组边界检查. 在第 28 届国际软件工程会议论文集, ICSE '06, 第 162-171 页, 中国上海, 2006. ACM.

[31] Dinakar Dhurjati, Sumant Kowshik, 和 Vikram Adve. SAFE-Code: 强制弱类型语言的别名分析. 在第 27 届 ACM SIGPLAN 编程语言设计与实现会议论文集, PLDI '06, 第 144-157 页, 加拿大渥太华, 2006. ACM.

[32] Baozeng Ding, Yeping He, Yanjun Wu, Alex Miller, 和 John Criswell. 具有准确检查的宽松边界. 在第 23 届 IEEE 软件可靠性工程国际研讨会论文集, ISSREW '12, 第 195-200 页, 德克萨斯州达拉斯, 2012. IEEE 计算机学会.

[33] CoreMark: EEMBC 基准测试.
<https://www.eembc.org/coremark>

[34] CoreMark-Pro: EEMBC 基准测试.
<https://www.eembc.org/coremark-pro>

[35] Isaac Evans, Fan Long, Ulziibayar Otgonbaatar, Howard Shrobe, Martin Rinard, Hamed Okhravi, 和 Stelios Sidiroglou-Douskos. 控制柔术：细粒度控制流完整性的弱点. 在第 22 届 ACM 计算机和通信安全会议论文集, CCS '15, 第 901-913 页, 科罗拉多州丹佛, 2015. ACM.

[36] GNU 项目. 标签作为值.
<https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html>

[37] Enes Göktas, Elias Athanasopoulos, Herbert Bos, 和 Georgios Portokalidis. 失控：克服控制流完整性. 在 2014 年 IEEE 安全与隐私研讨会论文集, SP '14, 第 575-589 页, 加利福尼亚州圣何塞, 2014. IEEE 计算机学会.

[38] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler, 和 Kristofer Pister. 网络传感器的系统架构方向. 在第 9 届支持编程语言和操作系统的体系结构国际会议论文集, ASPLOS '00, 第 93-104 页, 马萨诸塞州剑桥, 2000. ACM.

[39] Hong Hu, Shweta Shinde, Sendroiu Adrian, Zheng Leong Chua, Prateek Saxena, 和 Zhenkai Liang. 数据导向编程：非控制数据攻击的表达能力. 在 2016 年 IEEE 安全与隐私研讨会论文集, SP '16, 第 969-986 页, 加利福尼亚州圣何塞, 2016. IEEE 计算机学会.

[40] Yier Jin, Grant Hernandez, 和 Daniel Buentello. 智能 Nest 恒温器：家中的智能间谍. 在 Black Hat USA, 2014.

[41] Richard W. M. Jones 和 Paul H. J. Kelly. C 程序中的向后兼容数组和指针边界检查. 在第 3 届自动调试国际研讨会论文集, AADEBUG '97, 第 13-26 页, 瑞典林雪平, 1997. 林雪平大学电子出版社.

[42] Chung Hwan Kim, Taegyu Kim, Hongjun Choi, Zhongshu Gu, Byoungyoung Lee, Xiangyu Zhang, 和 Dongyan Xu. 通过定制内存视图切换保护实时微控制器系统. 在 2018 年网络和分布式系统安全研讨会论文集, NDSS '18, 加利福尼亚州圣地亚哥, 2018. 互联网协会.

[43] Volodymyr Kuznetsov, László Szekeres, Mathias Payer, George Candea, R. Sekar, 和 Dawn Song. 代码指针完整性. 在第 11 届 USENIX 操作系统设计与实现研讨会论文集, OSDI '14, 第 147-163 页, 科罗拉多州布鲁姆菲尔德, 2014. USENIX 协会.

[44] Donghyun Kwon, Jangseop Shin, Giyeol Kim, Byoungyoung Lee, Yeongpil Cho, 和 Yunheung Paek. uXOM: ARM Cortex-M 上高效的只执行内存. 在第 28 届 USENIX 安全研讨会论文集, Security '19, 第 231-247 页, 加利福尼亚州圣克拉拉, 2019. USENIX 协会.

[45] Chris Lattner 和 Vikram Adve. LLVM: 终身程序分析与转换的编译框架. 在第 2 届代码生成与优化国际研讨会论文集, CGO '04, 加利福尼亚州帕洛阿尔托, 2004. IEEE 计算机学会.

[46] Chris Lattner, Andrew Lenharth, 和 Vikram Adve. 使基于堆克隆的上下文敏感指向分析在现实世界中实用. 在第 28 届 ACM SIGPLAN 编程语言设计与实现会议论文集, PLDI '07, 第 278-289 页, 加利福尼亚州圣地亚哥, 2007. ACM.

[47] Zhengyang Liu 和 John Criswell. 灵活且高效的内存对象元数据. 在 2017 年 ACM SIGPLAN 内存管理国际研讨会论文集, ISMM '17, 第 36-46 页, 西班牙巴塞罗那, 2017. ACM.

[48] ARMConstantIslandPass 文件引用.
<https://llvm.org/doxygen/ARMConstantIslandPass_8cpp.html>

[49] IndirectBrExpandPass.cpp 文件引用.
<https://llvm.org/doxygen/IndirectBrExpandPass_8cpp.html>

[50] LLVM 语言参考手册.
<https://llvm.org/docs/LangRef.html>

[51] llvm::LivePhysRegs 类引用.
<https://llvm.org/doxygen/classllvm_1_1LivePhysRegs.html>

[52] Azure Sphere.
<https://azure.microsoft.com/en-us/services/azure-sphere>

[53] Daniele Midi, Mathias Payer, 和 Elisa Bertino. 使用 nesCheck 的嵌入式设备内存安全. 在 2017 年 ACM 亚洲计算机和通信安全会议论文集, ASIACCS '17, 第 127-139 页, 阿联酋阿布扎比, 2017. ACM.

[54] Charlie Miller 和 Chris Valasek. 远程汽车攻击面调查. 在 Black Hat USA, 2014.

[55] George C. Necula, Scott McPeak, 和 Westley Weimer. CCured: 旧代码的类型安全改造. 在第 29 届 ACM SIGPLAN-SIGACT 编程语言原理研讨会论文集, POPL '02, 第 128-139 页, 俄勒冈州波特兰, 2002. ACM.

[56] Newlib.
<https://sourceware.org/newlib>

[57] Thomas Nyman, Jan-Erik Ekberg, Lucas Davi, 和 N. Asokan. CFI CaRE: 商用微控制器的硬件支持调用和返回强制. 在第 20 届研究攻击、入侵和防御国际研讨会论文集, RAID '17, 第 259-284 页, 佐治亚州亚特兰大, 2017. 施普林格出版社.

[58] James Pallister, Simon Hollis, 和 Jeremy Bennett. BEEBS: 开放的嵌入式平台能耗测量基准. arXiv 预印本 arXiv:1308.5174, 2013 年 8 月.

[59] Ryan Roemer, Erik Buchanan, Hovav Shacham, 和 Stefan Savage. 返回导向编程: 系统、语言和应用. ACM 信息系统与安全事务, 15(1):2:1–2:34, 2012 年 3 月.

[60] Olatunji Ruwase 和 Monica S. Lam. 实用的动态缓冲区溢出检测器. 在第 11 届网络和分布式系统安全研讨会论文集, NDSS '04, 加利福尼亚州圣地亚哥, 2004. 互联网协会.

[61] Ahmad-Reza Sadeghi, Christian Wachsmann, 和 Michael Waidner. 工业物联网的安全和隐私挑战. 在第 52 届年度设计自动化会议论文集, DAC '15, 第 54:1–54:6 页, 加利福尼亚州旧金山, 2015. ACM.

[62] Konstantin Serebryany, Derek Bruening, Alexander Potapenko, 和 Dmitriy Vyukov. AddressSanitizer: 快速地址健全性检查器. 在 2012 年 USENIX 年度技术会议论文集, ATC '12, 第 309-318 页, 马萨诸塞州波士顿, 2012. USENIX 协会.

[63] STMicroelectronics. UM1725 用户手册: STM32F4 HAL 和 LL 驱动程序描述, 2017 年 2 月. 文档 ID 025834 修订版 5.

[64] STMicroelectronics. RM0386 参考手册: STM32F469xx 和 STM32F479xx 高级 Arm®-Based 32 位 MCU, 2018 年 6 月. RM0386 修订版 5.

[65] STMicroelectronics. PM0214 编程手册: STM32 Cortex®-M4 MCU 和 MPU 编程手册, 2020 年 3 月. PM0214 修订版 10.

[66] STMicroelectronics. UM1932 用户手册: 带 STM32F469NI MCU 的 Discovery Kit, 2020 年 4 月. UM1932 修订版 3.

[67] László Szekeres, Mathias Payer, Tao Wei, 和 Dawn Song. SoK: 内存中的永恒战争. 在 2013 年 IEEE 安全与隐私研讨会论文集, SP '13, 第 48-62 页, 加利福尼亚州旧金山, 2013. IEEE 计算机学会.

[68] Texas Instruments. Hercules MCU 的硬件抽象层代码生成器, 2019.
<https://www.ti.com/tool/HALCOGEN>

[69] Robert Wahbe, Steven Lucco, Thomas E. Anderson, 和 Susan L. Graham. 高效的软件故障隔离. 在第 14 届 ACM 操作系统原则研讨会论文集, SOSP '93, 第 203-216 页, 北卡罗来纳州阿什维尔, 1993. ACM.

[70] Robert J. Walls, Nicholas F. Brown, Thomas Le Baron, Craig A. Shue, Hamed Okhravi, 和 Bryan C. Ward. 实时嵌入式系统的控制流完整性. 在第 31 届 Euromicro 实时系统会议论文集, ECRTS '19, 第 2:1–2:24 页, 德国斯图加特, 2019. Schloss Dagstuhl–Leibniz-Zentrum für Informatik.

[71] Mario Werner, Thomas Unterluggauer, David Schaffenrath, 和 Stefan Mangard. 适用于 IoT 设备的海绵式控制流保护. 在 2018 年 IEEE 欧洲安全与隐私研讨会论文集, EuroSP '18, 第 214-226 页, 英国伦敦, 2018. IEEE 计算机学会.

[72] Yajin Zhou, Xiaoguang Wang, Yue Chen, 和 Zhi Wang. ARM-Lock: ARM 的硬件基础故障隔离. 在 2014 年 ACM SIGSAC 计算机和通信安全会议论文集, CCS '14, 第 558-569 页, 亚利桑那州斯科茨代尔, 2014. ACM.

### 支持 setjmp/longjmp 的设计

对 setjmp 和 longjmp 的调用可能会破坏 Silhouette 的返回地址完整性保证，因为 longjmp 从其 jmp_buf 参数中使用一个返回地址，该地址可能位于可篡改的全局、堆或栈内存中。应用程序也可能误用 setjmp 和 longjmp，例如在调用 setjmp 的函数返回后调用 longjmp，导致可被攻击者利用的未定义行为。Silhouette 修改了 setjmp 和 longjmp 的实现，以支持它们同时保持其返回地址完整性保证。

具体来说，Silhouette 在受保护的影子堆栈区域预留了一部分空间，用于存储程序正在使用的活动 jmp_buf 记录映射。图 3 显示了映射条目的格式；传递给 setjmp/longjmp 的 jmp_buf 地址作为键，所有被保存的寄存器加上 sp 和 lr 作为值。算法 1 和 2 分别展示了我们自定义的 setjmp 和 longjmp 的设计。当应用程序调用 setjmp 时，Silhouette 的 setjmp 不是将执行上下文保存到应用程序指定的 jmp_buf 中，而是将其保存到映射中，通过插入新条目或覆盖现有条目来实现，基于 jmp_buf 的地址。如果我们在插入新条目并且活动 jmp_buf 记录的数量达到映射的容量时，Silhouette 的 setjmp 会报告错误并终止程序；这实际上不是一个实际问题，因为我们预计程序只有少数几个 jmp_buf。我们还可以提供一个选项，让应用程序开发人员指定所需的映射大小。我们的存储硬化通道将识别这个安全版本的 setjmp，并为其生成常规存储（而不是无特权存储）以访问映射。将执行上下文保存在受保护区域确保了保存的堆栈指针值和返回地址的完整性。

Silhouette 的 longjmp 检查提供的 jmp_buf 地址是否与映射中的条目匹配。如果没有找到匹配的条目，则提供的 jmp_buf 无效或已过期（由于函数返回或在外层定义的 jmp_buf 上调用 longjmp）。在这两种情况下，都会终止执行。如果找到匹配的条目，Silhouette 的 longjmp 首先使映射中所有 sp 值小于匹配条目 sp 值的条目失效；这些 jmp_buf 在控制流回退到外层 setjmp 调用点时过期。然后恢复匹配条目中存储的执行上下文。

另一种情况是，当调用 setjmp 的函数返回时，该函数及其被调用者中使用的 jmp_buf 变得过时。Silhouette 通过在这些函数的结尾插入代码来处理这种情况，以使所有 sp 值小于或等于当前 sp 值的映射条目失效。这确保了未来的 longjmp 调用不会使用过时的 sp 和 lr 值。

---

希望这能帮助你更好地理解和使用这些文献。