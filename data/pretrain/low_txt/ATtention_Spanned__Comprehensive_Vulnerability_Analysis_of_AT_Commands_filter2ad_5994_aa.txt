### Title: ATtention Spanned: Comprehensive Vulnerability Analysis of AT Commands Within the Android Ecosystem

**Authors:**
- Dave (Jing) Tian, University of Florida
- Grant Hernandez, University of Florida
- Joseph I. Choi, University of Florida
- Vanessa Frost, University of Florida
- Christie Ruales, University of Florida
- Patrick Traynor, University of Florida
- Hayawardh Vijayakumar, Samsung Research America
- Lee Harrison, Samsung Research America
- Amir Rahmati, Samsung Research America and Stony Brook University
- Michael Grace, Samsung Research America
- Kevin R. B. Butler, University of Florida

**Abstract:**
AT commands, originally designed in the early 1980s for controlling modems, are still widely used in modern smartphones to support telephony functions. The role of AT commands has expanded through vendor-specific customizations, but their functionality is often poorly documented. In this paper, we systematically retrieve and extract 3,500 AT commands from over 2,000 Android smartphone firmware images across 11 vendors. We methodically test these commands on eight Android devices from four different vendors through their USB interface and characterize the powerful functionality they expose, including the ability to rewrite device firmware, bypass Android security mechanisms, exfiltrate sensitive information, perform screen unlocks, and inject touch events. Our analysis reveals that the AT command interface represents a significant attack surface on Android devices.

**Introduction:**
Since their introduction, smartphones have evolved to offer substantial functionality beyond basic telephony, including access to a wide variety of sensors and user data. However, the ability to make calls over the cellular network remains a fundamental feature. This heritage in telephony is reflected in the continued use of AT commands, which were designed to control modem functions and date back to the 1980s. While some AT commands have been standardized by regulatory and industry bodies, manufacturers and operating system designers have also used them to access and control device functionality in proprietary ways. For example, AT commands on Sony Ericsson smartphones can be used to access GPS accessories and the camera flash.

Previous research has shown that these commands can expose actions that may cause security vulnerabilities, but these analyses have been ad-hoc and narrowly focused on specific vendors. To date, there has been no systematic study of the types of AT commands available on modern smartphone platforms or the functionality they enable. In effect, AT commands represent a source of largely undocumented and unconstrained functionality.

In this paper, we comprehensively examine the AT command ecosystem. We assemble a corpus of 2,018 smartphone firmware images from 11 Android smartphone manufacturers, extract 3,500 unique AT commands, and combine them with 222 commands found through standards to create an annotated, cross-referenced database of 3,722 commands. To our knowledge, this is the largest known repository of AT commands. We characterize the commands based on the evolution of the Android operating system and smartphone models and determine where AT commands are delivered and consumed within different smartphone environments. We test the full corpus of 3,500 AT commands by issuing them through the USB charging interface common to all smartphones and execute these commands across eight smartphones from four different manufacturers.

Our analysis exposes powerful and broad capabilities, including the ability to bypass Android security mechanisms such as SEAndroid to retrieve and modify sensitive information. Moreover, we find that firmware images from newer smartphones reinstate AT command functionality previously removed due to security concerns, causing those vulnerabilities to re-emerge. In short, we find that AT commands accessed through the USB interface allow almost arbitrarily powerful functionality without any authentication required, presenting a large attack surface for modern smartphones.

**Contributions:**
- **Systematic Collection and Characterization of AT Commands:** We develop regular expressions and heuristics to determine the presence of AT commands in binary smartphone firmware images, extracting them into an annotated database that tracks metadata and provenance for each command. Our database and code are publicly available at http://atcommands.org.
- **Comprehensive Runtime Vulnerability Analysis:** We systematically test 13 Android smartphones and one tablet for exposure to the USB modem interface and find that five devices expose the modem by default while three other devices will do so if rooted. Using this interface, we comprehensively test all 3,722 AT commands to determine the effect of both standard and vendor-specific commands on individual devices. We characterize notable classes of commands that can cause vulnerabilities such as firmware flashing, bypassing Android security mechanisms, and leaking sensitive device information. We find that new smartphone platforms reintroduce AT command-based vulnerabilities that were purportedly previously patched.
- **Development of Attack Scenarios and Mitigations:** We demonstrate that previously-disclosed attacks targeting the lock screen, which required malicious application access, can be performed through a USB cable without requiring any code on the target phone. We demonstrate that arbitrary touchscreen events can be injected over USB. We discover multiple buffer overflow vulnerabilities and commands to expose the contents of /proc and /sys filesystems, as well as path traversal vulnerabilities. We even discover a method to "brick" and "unbrick" certain phones. We also discuss how mechanisms such as "charger" mode and SELinux policies only partially mitigate the threat that broadly accessible AT commands can pose to smartphone platforms.

**Background:**

**2.1 AT Commands:**
First developed by Dennis Hayes in 1981, the AT (Attention) command set comprises commands that predominantly start with the string "AT." The AT command set rapidly became an industry standard for controlling modems, allowing for actions such as selecting communication protocols, setting line speeds, and dialing numbers. The International Telephone Union (ITU-T) codified the AT command set over the telephone network in Recommendation V.250. In the late 1990s, ETSI standardized the AT command set for GSM and SMS/CBS, and later for UMTS and LTE. Based on the Hayes and GSM AT command sets, additional AT commands were introduced for CDMA and EVDO.

Manufacturers of cellular baseband processors have added proprietary and vendor-specific AT commands to their chipsets. As a result, smartphones also support their own AT command sets and expose modem and/or serial interfaces once connected via USB to receive these commands. In some cases, these vendor-specific AT commands are designed to be issued by software to invoke specific functionality, such as backing up contact information on a PC. These commands often do not invoke any functionality related to telephony but rather access other resources on the device. Android phone makers further extended the AT command set by adding Android-specific commands (e.g., to enable debugging over USB) to be consumed by the Android OS running on the application processor. These AT commands are usually sent over a USB connection, although a subset can also be sent over Bluetooth with limited functionality.

**2.2 USB on Android:**
USB is the most important and widely adopted peripheral interface in the Android ecosystem, responsible for tasks such as battery charging, data transmission, and network sharing with other devices. Android devices support three different USB modes: host, device, and accessory mode. USB device mode, the most common mode, is used when the phone connects to a PC and emulates device functionality such as exposing an MTP (Media Transfer Protocol) endpoint.

As shown in Figure 1, the Android USB implementation in device mode relies on both the Linux kernel and the Android framework. In the kernel space, the Android composite driver exposes a sysfs entry to user space and interfaces with the kernel's USB gadget driver. Different USB functionalities (such as USB Mass Storage or MTP) require different gadget drivers to be loaded. The gadget driver sits above the USB controller driver, which communicates with the USB device controller (UDC) hardware. Within the user space, the Android UsbService provides Java interfaces to applications, instantiating UsbDeviceManager and UsbSettingsManager to enable users to switch between different USB functionalities. The Android init daemon typically takes care of setting user-requested USB functionality by loading an init.usb.rc script during startup. This init script contains detailed procedures for setting functionality on the phone, essentially writing data to the sysfs.

**2.3 Android USB Modem Interface:**
USB Modem functionality in Android can be accessed if the smartphone vendor exposes a USB CDC (Communication Device Class) ACM (Abstract Control Model) interface from within their phones. Once enabled and connected, this creates a tty device such as /dev/ttyACM0, enabling the phone to receive AT commands over the USB interface. As shown in Figure 1, the tty device relays AT commands to the Android user space. Vendor-specific native daemons read from the device file and take further actions based on the nature of the AT command. These daemons can handle vendor/carrier-added AT commands, such as "AT+USBDEBUG" (enabling USB debugging), locally without notifying the upper layer. Otherwise, pre-installed applications will be triggered to process the commands. These AT commands are often designed to provide shortcuts for managing, testing, and debugging within Android. For Hayes and GSM AT commands, such as "ATD" (which enables voice dialing), the RIL (Radio Interface Layer) will be triggered to deliver the command to the baseband processor.

**2.4 Threat Model:**
Throughout the paper, we assume a malicious USB host, such as a PC or a USB charging station controlled by an adversary, tries to attack the connected Android phone via USB. We assume the attacker can access or switch to the possibly inactive AT interface, if available. With access to this interface, the attacker can send arbitrary AT commands supported by the target device to launch attacks. We assume that all of these attacks can be fully scripted and only require a physical USB connection. Additionally, we assume that Developer Options and USB Debugging are disabled by default. During the extraction of AT commands from firmware images, we assume that the existence of AT commands in binaries and applications is not purposefully obfuscated, encrypted, or compressed.

**3 Design & Implementation:**
We design and implement methods to extract, filter, and test AT commands found within the Android ecosystem. Our procedure for acquiring these commands is shown in Figure 2. We begin by identifying and retrieving 2,018 Android binary smartphone firmware images, covering 11 major Android cellphone vendors. The details of this corpus are shown in Table 1. Next, for each firmware, we unpack the image using a variety of tools and extract AT command strings using a regular expression. After additional filtering, we recover 3,500 unique AT commands, many of which have differing parameter strings. Finally, using this database, we evaluate the security impact of these commands on real Android devices by setting up an automated testing framework to send the commands to physical Android devices and monitor any side-effects.

**3.1 AT Command Extraction:**
We first gather Android firmware images from manufacturer websites and third-party hosts. For more details on the downloading process, see Section A.3. With a corpus of firmware images, we begin extraction and filtering for commands. We traverse each Android firmware image as deeply as possible, recovering unique AT commands and parameter combinations. Additionally, we capture build information for each image from the standard Android build properties file, build.prop. This file provides key metadata about the image itself. We also collect any USB init/pre-configuration files (e.g., init.usb.rc) found in Android boot images to gain insight into the USB modes supported by each firmware.

To find AT commands present in firmware images, we look in every file for any string containing the regular expression AT[+*!@#$%^&]. AT commands with a symbol immediately following the ATtention string are known as extended AT commands. Original Equipment Manufacturers (OEMs) are free to add any amount of extended commands to their products. We focus on solely collecting AT extended command references within these firmware images for later categorization and testing.

Many pieces of firmware were archived using standard formats. Vendor-specific formats included: HTC's .exe format, unpackable using the HTC RUU Decrypt Tool; Huawei's update.app format, unpackable using splitupdate; LG's .kdz/.dz format, unpackable using LGE KDZ Utilities; and Sony's .ftf format, unpackable using 7-Zip. Any nested archives directly under the top-level archive (e.g., Samsung images' several nested tars) are similarly unpacked.

Once all files are extracted from the archives, we process each file according to its characteristics. For native binaries, such as ELF, we use strings to extract all possible strings, over which we grep for any of our target AT prefixes. For text-based files, grep is applied directly to catch potential AT commands. For ZIP-like files, we unzip and traverse the directory to examine each extracted file. ZIP-like files include yaffs (unpacked using unyaffs), Lenovo's SZB (unpacked using szbtool), and Lenovo's QSB (unpacked using a qsb splitter).

If the file is a VFAT or EXT4 filesystem image (e.g., system.img), we mount the filesystem and traverse it once mounted to check each contained file. Filesystem images are not always readily mountable. They may be single or split-apart sparse Android images, which we first convert into EXT4 using the Android simg2img tool.