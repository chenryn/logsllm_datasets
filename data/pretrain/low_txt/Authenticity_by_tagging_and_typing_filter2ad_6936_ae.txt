# Lowe’s Fixed Version of SPLICE/AS and Needham-Schroeder Public Key Protocol

## Introduction
This document discusses the fixed version of the Needham-Schroeder Public Key Protocol by Lowe, as well as other related protocols and their security foundations.

## Protocols and References
- **Lowe’s Fixed Version of Needham-Schroeder Public Key Protocol**
  - [17] G. Lowe. "Breaking and Fixing the Needham-Schroeder Public-Key Protocol Using FDR." In *Tools and Algorithms for the Construction and Analysis of Systems (TACAS)*, volume 1055 of Lecture Notes in Computer Science, pages 147–166. Springer-Verlag, 1996.
- **ISO’s Symmetric Key Three Pass Mutual Authentication Protocol**
- **Private Authentication Protocols**
  - [1] Reference to be provided.

## Security Foundations
- [18] G. Lowe. "A Hierarchy of Authentication Specification." In *Proceedings of the 10th Computer Security Foundation Workshop (CSFW’97)*, pages 31–44. IEEE Computer Society Press, 1997.
- [19] G. Lowe. "Towards a Completeness Result for Model Checking of Security Protocols." In *Proceedings Eleventh IEEE Computer Security Foundation Workshop (CSFW’98)*. IEEE Computer Society Press, June 1998.
- [20] M. Maffei. "Tags for Multi-Protocol Authentication." In *Proceedings of the 2nd International Workshop on Security Issues in Coordination Models, Languages, and Systems (SECCO ’04)*. To appear. ENTCS, August 2004.
- [21] R. Focardi and M. Maffei. "ρ-spi Calculus at Work: Authentication Case Studies." In *Proceedings of Meﬁsto Project*. To appear. ENTCS, March 2004.
- [22] J. Thayer, J. Herzog, and J. Guttman. "Strand Spaces: Proving Security Protocols Correct." *Journal of Computer Security*, 1999. 7(2/3).
- [23] Thomas Y. C. Woo and Simon S. Lam. "A Lesson on Authentication Protocol Design." *Operating Systems Review*, 28(3):24–37, 1994.
- [24] T.Y.C. Woo and S.S. Lam. "A Semantic Model for Authentication Protocols." In *Proceedings of 1993 IEEE Symposium on Security and Privacy*, pages 178–194, 1993.

## Appendix: Semantics of ρ-spi

### Transition System for ρ-spi
The dynamics of ρ-spi are formalized by a transition relation between configurations, i.e., pairs \((s, P)\), where \(s \in \text{Act}\) is a trace, and \(P\) is a (closed) process. Each transition \((s, P) \rightarrow (s :: \alpha, P')\) simulates one computation step in \(P\) and records the corresponding action in the trace.

#### Transitions
- **Sequential Process**: \((s, I; \pi.S) \rightarrow (s :: \alpha, I; S)\), where \(\alpha\) is the action corresponding to the primitive \(\pi\).
- **Actions**:
  - `out(M1, ..., Mn)`: Generated by output.
  - `run(I, J, M)`: Generated by `run`.
  - `commit(I, J, M)`: Generated by `commit`.
  - `in(M1, ..., Mn)`: Generated by input.
  - `decrypt{M1, ..., Mn}K` and `decrypt{|M1, ..., Mn|}Key(K)`: Generated by symmetric and asymmetric decryption.
  - `encrypt{M1, ..., Mn}K` and `encrypt{|M1, ..., Mn|}Key(K)`: Generated by symmetric and asymmetric encryption.
  - `f resh(n)`: Generated by restriction.
  - `sym-key(k, I1, I2)` and `asym-key(k, I)`: Generated by symmetric and asymmetric key assignment.

### Most General Unifier (m.g.u.)
- **Definition**: The most general unifier (m.g.u.) is defined in Table 9.
- **Example**:
  - \(m.g.u.(C(M1), C(M2)) = m.g.u.(M1, M2)\)
  - \(m.g.u.(n, n) = []\)
  - \(m.g.u.(n, x) = [n/x]\)
  - \(m.g.u.(Key(M), Key(M)) = []\)
  - \(m.g.u.(Key(M), x) = [Key(M)/x]\)
  - \(m.g.u.({M1, ..., Mn}, K, x) = [{M1, ..., Mn}/x]\)
  - \(m.g.u.({|M1, ..., Mn|}, Key(K), x) = [{|M1, ..., Mn|}/Key(K)/x]\)

### Message Manipulation Rules
- **Rules**: The message manipulation rules, in Table 11, formalize the environment actions.
  - **OUT**: Every message sent on the network is known by the environment.
  - **ENV**: The environment can generate a new bound name not occurring in the trace.
  - **TAG** and **UNTAG**: The environment can tag and untag messages.
  - **KEY PAIR**: Given a term \(M\), the environment can build the private and public components of \(M\).
  - **SYMMETRIC ENCRYPTION** and **ASYMMETRIC DECRYPTION**: If the environment knows \(M0, M1, ..., Mn\), it can encrypt \(M1, ..., Mn\) with \(M0\).
  - **SYMMETRIC DECRYPTION** and **ASYMMETRIC DECRYPTION**: The environment can decrypt ciphertexts if the decryption key is known.
  - **PUBLIC KEYS**: All public keys are known by the environment.
  - **ENEMY KEYS**: The environment may be provided with own key pairs and long-term keys shared among participants, allowing the enemy to start authentication sessions.

### Notation Conventions
- **Restriction Operator**: `new(n).S` is a binder for name \(n\).
- **Key Declarations**: `let k = sym-key(I1, I2)` and `let k = asym-key(I)` are binders for \(k\).
- **Input and Decryption Primitives**: Binders for the variables that occur in components \(Mi\).
- **Encryption**: Binder for variable \(x\).

In all cases, the scope of the binders is the continuation process. The notions of free/bound names and variables arise as expected. Processes are identified up to renaming of bound variables and names, i.e., up to α-equivalence. We assume two infinite sets of bound and free names so that bound names are distinct from free names and not touched by substitutions.

### Tables
- **Table 9**: Most General Uniﬁer
- **Table 10**: Transition System for ρ-spi
- **Table 11**: Message Manipulation Rules

For detailed definitions and examples, refer to the respective tables and sections in the document.