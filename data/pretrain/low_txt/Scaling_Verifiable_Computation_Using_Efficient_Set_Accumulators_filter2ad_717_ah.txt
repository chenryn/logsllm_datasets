### References

1. G. Jaeschke. On strong pseudoprimes to several bases. *Mathematics of Computation*, 61(204):915–926, 1993.
2. M. Joye and P. Paillier. Fast generation of prime numbers on portable devices: An update. In *CHES*, October 2006.
3. M. Joye, P. Paillier, and S. Vaudenay. Efficient generation of prime numbers. In *CHES*, August 2000.
4. B. Kaliski. RSA factoring challenge. In H. C. A. van Tilborg (Ed.), *Encyclopedia of Cryptography*. Springer, 2005.
5. A. Kate, G. M. Zaverucha, and I. Goldberg. Constant-size commitments to polynomials and their applications. In *ASIACRYPT*, December 2010.
6. A. E. Kosba, D. Papadopoulos, C. Papamanthou, M. F. Sayed, E. Shi, and N. Triandopoulos. TRUESET: Faster verifiable set computations. In *USENIX Security*, August 2014.
7. A. E. Kosba, C. Papamanthou, and E. Shi. xJsnark: A framework for efficient verifiable computation. In *IEEE S&P*, May 2018.
8. J. Lee, K. Nikitin, and S. Setty. Replicated state machines without replicated execution. In *IEEE S&P*, May 2020.
9. J. Li, N. Li, and R. Xue. Universal accumulators with efficient nonmembership proofs. In *ACNS*, June 2007.
10. B. Libert, S. C. Ramanna, and M. Yung. Functional commitment schemes: From polynomial commitments to pairing-based accumulators from simple assumptions. In *ICALP*, July 2016.
11. B. Libert and M. Yung. Concise mercurial vector commitments and independent zero-knowledge sets with short proofs. In *TCC*, February 2010.
12. H. Lipmaa. Secure accumulators from Euclidean rings without trusted setup. In *ACNS*, June 2012.
13. M. Maller, S. Bowe, M. Kohlweiss, and S. Meiklejohn. Sonic: Zero-knowledge SNARKs from linear-size universal and updatable structured reference strings. In *ACM CCS*, November 2019.
14. Matter Network. <https://demo.matter-labs.io/explorer/>.
15. U. M. Maurer. Fast generation of secure RSA-moduli with almost maximal diversity. In *EUROCRYPT*, April 1990.
16. U. M. Maurer. Fast generation of prime numbers and secure public-key cryptographic parameters. *Journal of Cryptology*, 8(3):123–155, September 1995.
17. I. Meckler and E. Shapiro. Coda: Decentralized cryptocurrency at scale. <https://cdn.codaprotocol.com/v2/static/coda-whitepaper-05-10-2018-0.pdf>, May 2018.
18. R. C. Merkle. A digital signature based on a conventional encryption function. In *CRYPTO*, August 1988.
19. B. Möller. Algorithms for multi-exponentiation. In *SAC*, August 2001.
20. N. Nethercote and J. Seward. How to shadow every byte of memory used by a program. In *VEE*, June 2007.
21. L. Nguyen. Accumulators from bilinear pairings and applications. In *CT-RSA 2005*, February 2005.
22. On-chain scaling to potentially ~500 tx/sec through mass tx validation. <https://ethresear.ch/t/on-chain-scaling-to-potentially-500-tx-sec-through-mass-tx-validation/3477>.
23. C. Papamanthou, E. Shi, and R. Tamassia. Signatures of correct computation. In *TCC*, March 2013.
24. B. Parno, J. Howell, C. Gentry, and M. Raykova. Pinocchio: Nearly practical verifiable computation. In *IEEE S&P*, May 2013.
25. T. P. Pedersen. Non-interactive and information-theoretic secure verifiable secret sharing. In *CRYPTO*, August 1992.
26. M. O. Rabin. Probabilistic algorithm for testing primality. *J. Number Theory*, 12(1):128–138, February 1980.
27. L. Reyzin, D. Meshkov, A. Chepurnoy, and S. Ivanov. Improving authenticated dynamic dictionaries, with applications to cryptocurrencies. In *FC*, April 2017.
28. L. Reyzin and S. Yakoubov. Efficient asynchronous accumulators for distributed PKI. In *SCN*, August/September 2016.
29. R. L. Rivest, A. Shamir, and D. A. Wagner. Time-lock puzzles and timed-release crypto. Technical report, MIT LCS, March 1996.
30. The RSA challenge numbers. <https://web.archive.org/web/20130921041734/http://www.emc.com/emc-plus/rsa-labs/historical/the-rsa-challenge-numbers.htm>.
31. Rust programming language. <https://www.rust-lang.org/>.
32. Sapling cryptography library, community edition. <https://github.com/matter-labs/sapling-crypto>.
33. S. Setty, S. Angel, T. Gupta, and J. Lee. Proving the correct execution of concurrent services in zero-knowledge. In *OSDI*, October 2018.
34. S. Setty, B. Braun, V. Vu, A. J. Blumberg, B. Parno, and M. Walfish. Resolving the conflict between generality and plausibility in verified computation. In *EuroSys*, April 2013.
35. S. T. V. Setty, R. McPherson, A. J. Blumberg, and M. Walfish. Making argument systems for outsourced computation practical (sometimes). In *NDSS*, February 2012.
36. S. T. V. Setty, V. Vu, N. Panpalia, B. Braun, A. J. Blumberg, and M. Walfish. Taking proof-based verified computation a few steps closer to practicality. In *USENIX Security*, August 2012.
37. J. Shawe-Taylor. Generating strong primes. *Electronics Letters*, 22(16):875–877, 1986.
38. E. G. Straus. Addition chains of vectors (problem 5125). *Amer. Math. Monthly*, 70:806–808, 1964.
39. J. Thaler. Time-optimal interactive proofs for circuit evaluation. In *CRYPTO*, August 2013.
40. J. Thaler, M. Roberts, M. Mitzenmacher, and H. Pfister. Verifiable computation with massively parallel interactive proofs. In *HotCloud*, June 2012.
41. V. Vu, S. T. V. Setty, A. J. Blumberg, and M. Walfish. A hybrid architecture for interactive verifiable computation. In *IEEE S&P*, May 2013.
42. R. S. Wahby, M. Howald, S. J. Garg, a. shelat, and M. Walfish. Verifiable ASICs. In *IEEE S&P*, May 2016.
43. R. S. Wahby, Y. Ji, A. J. Blumberg, a. shelat, J. Thaler, M. Walfish, and T. Wies. Full accounting for verifiable outsourcing. In *ACM CCS*, October/November 2017.
44. R. S. Wahby, S. T. V. Setty, Z. Ren, A. J. Blumberg, and M. Walfish. Efficient RAM and control flow in verifiable outsourced computation. In *NDSS*, February 2015.
45. R. S. Wahby, I. Tzialla, a. shelat, J. Thaler, and M. Walfish. Doubly-efficient zkSNARKs without trusted setup. In *IEEE S&P*, May 2018.
46. A. Waksman. A permutation network. *Journal of the ACM*, 15(1):159–163, January 1968.
47. M. Walfish and A. J. Blumberg. Verifying computations without reexecuting them: from theoretical possibility to near practicality. *Communications of the Association for Computing Machinery*, February 2015.
48. B. Wesolowski. Efficient verifiable delay functions. In *EUROCRYPT*, May 2019.
49. H. Wu, W. Zheng, A. Chiesa, R. A. Popa, and I. Stoica. DIZK: A distributed zero-knowledge proof system. In *USENIX Security*, August 2018.
50. T. Xie, J. Zhang, Y. Zhang, C. Papamanthou, and D. Song. Libra: Succinct zero-knowledge proofs with optimal prover computation. In *CRYPTO*, August 2019.
51. Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou. vSQL: Verifying arbitrary SQL queries over dynamic outsourced databases. In *IEEE S&P*, May 2017.
52. Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou. vRAM: Faster verifiable RAM with program-independent preprocessing. In *IEEE S&P*, May 2018.

### Proof of MultiSwap Consistency

Let \(\sigma\) denote a multiset of swaps. Let \(in\sigma\) denote \(\{y : (x, y) \in \sigma\}\) and let \(rm\sigma\) denote \(\{x : (x, y) \in \sigma\}\).

**Claim 1.** Let \(\sigma\) be a multiset of swaps and \(\sigma_c\) be a cycle. \(MultiSwap(S, \sigma \cup \sigma_c, S')\) holds if and only if \(MultiSwap(S, \sigma, S')\) does.

**Proof:**
We prove both directions simultaneously by illustrating a bidirectional chain of mutually implicating equalities. We start with the definition of \(MultiSwap(S, \sigma \cup \sigma_c, S')\):

\[ S' = S \cup (in\sigma \cup in\sigma_c) \setminus (rm\sigma \cup rm\sigma_c) \]

Using the properties of union and set difference, we can rewrite this as:

\[ S' = S \cup in\sigma_c \cup in\sigma \setminus rm\sigma_c \setminus rm\sigma \]

Since \(\sigma_c\) is a cycle, we have that \(in\sigma_c = rm\sigma_c\), so \(rm\sigma_c \subseteq S \cup in\sigma_c\), and the removal of \(rm\sigma_c\) can be moved earlier:

\[ S' = S \cup in\sigma_c \setminus rm\sigma_c \cup in\sigma \setminus rm\sigma \]

This simplifies to:

\[ S' = S \cup in\sigma \setminus rm\sigma \]

which is exactly the statement that \(MultiSwap(S, \sigma, S')\) holds.

**Claim 2.** If \(\sigma\) contains no cycles and \(MultiSwap(S, \sigma, S')\) holds, then \(\sigma\) is sequentially consistent with respect to \(S\), producing \(S'\).

**Proof:**
Let \(n\) be the number of swaps in \(\sigma\). For a set \(S\) and multiset of swaps \(\tau\), define the directed multigraph \(G_{S, \tau}\) as a multigraph where the vertices are the universe of multiset elements, the edges point from each removal to its corresponding insertion, and each vertex is labeled with a multiplicity equal to the multiplicity of that vertex’s element in \(S\), minus the out-degree, plus the in-degree. Observe that in \(G = G_{S, \sigma}\), the multiplicity of each vertex is equal to the multiplicity of that element in \(S'\). Furthermore, by the predicate \(MultiSwap(S, \sigma, S')\) and the soundness of the proofs of insertions and removals, all multiplicities in \(G\) are non-negative.

We now construct the sequentially valid ordering of \(\sigma\). Since \(\sigma\) has no swap cycles, \(G\) has no edge cycles. Thus, the edges of \(G\) can be topologically sorted such that all edges to a vertex occur before any edge from that vertex. We lift this edge order to a swap order, observing that in this swap order, all swaps inserting an element occur before all swaps removing it.

It suffices to show that when \(\sigma\) is applied to \(S\) in this order, each swap is valid. Let \(\sigma_i\) denote the first \(i\) elements of \(\sigma\) in the aforementioned order. Thus, \(G_{S, \sigma_n}\) is equal to \(G\). Furthermore, the order ensures that for all \(i > j\) and for all vertices \(v\), the multiplicity of \(v\) in \(G_{S, \(\sigma_i\)}\) is at most the multiplicity of \(v\) in \(G_{S, \(\sigma_j\)}\). Suppose that the \(i\)-th element of this order, \((x_i, y_i)\), were invalid, where \(i \leq n\). This implies that the multiplicity of \(x_i\) in \(G_{S, \(\sigma_i\)}\) is negative. This would imply that the multiplicity of \(x_i\) in \(G_{S, \(\sigma_n\)} = G\) were negative, a contradiction. Thus, no swap \((x_i, y_i)\) is invalid in this order.

**Proof of Lemma 1.** The reverse direction follows immediately from the definition of \(MultiSwap\).

We prove the forward direction by (strong) induction on the size of \(\sigma\). Suppose \(\sigma\) has no cycles. Then the lemma follows from Claim 2. Otherwise, let \(\tau\) be a multiset of swaps and let \(\sigma_c\) be a cycle such that \(\sigma = \tau \cup \sigma_c\). By Claim 1, \(MultiSwap(S, \tau, S')\) holds. Then, by the inductive hypothesis, \(\tau\) can be decomposed into a cycle-free \(\tau'\) and cycles \(\tau_c^i\) such that \(\tau = \tau' \cup \bigcup_i \tau_c^i\) and \(\tau'\) is sequentially consistent with respect to \(S\), producing \(S'\). By observing that \(\tau' \cup (\bigcup_i \tau_c^i) \cup \sigma_c\) is a decomposition of \(\sigma\) into a cycle-free swap multiset and cycles, we conclude this direction of the proof.

### Parameter Values

Our RSA accumulators work in \(G = \mathbb{Z}_N^* / \{\pm 1\}\), where \(N\) is the RSA-2048 challenge number [102], and \(N = 0xc7970ceedcc3b0754490201a7aa613cd73911081c790f5f1a8726f463550bb5b7ff0db8e1ea1189ec72f93d1650011bd721aeeacc2acde32a04107f0648c2813a31f5b0b7765ff8b44b4b6ffc93384b646eb09c7cf5e8592d40ea33c80039f35b4f14a04b51f7bfd781be4d1673164ba8eb991c2c479af89d64d373f442709439de66ceb955f3ea37d5159f6135809f85334b5cb1813addc80cd05609f10ac6a95ad65872c909525bdad32bc729592642920f24c61dc5b3c3b7923e56b16a4d9d373d8721f24a3fc0f1b3131f55615172866bccc30f95054c824e733a5eb6817f7bc16399d48c6361cc7e5\).

We randomly selected a 2048-bit offset \(\Delta\) for our division-intractable hash \(H_\Delta\) (§4.2); we use the value \(\Delta = 0xf3709c40772816d668926cae548ffea31f49034ab1b30fb84b595ca6c126a6646a4341abea2f8b07bf8d366801ac293e5a286abb43accdec39ac8f0bc599519cf1e532f9c70b5406c4b652ca7da4e1cb102b69953841ae20d4bcab055c5338487ba00fe95e821abd381b191dfb77bae3e022ccd818d4064882d28481ffa2db45093a4deab05f6ebfbadcf11afe7369caeaaf1f02572348a17f0510b333b8a2d56e67d892f1e1182b26301d9347ae0a900cff2a0979caddb1a86e04a6cbc9704d6549e5b3aef0d5c3dc4aba648ed421b0ba37c3f8e8edc12ef42b86d8e5fbc0dbd903238ca2e9ed6873ccb68e8103b5d01b4249bfbe8e70cb4f4983f41df8c8f\).

Our evaluation (§7) builds on the BLS12-381 elliptic curve [27], which is the Barreto-Lynn-Scott curve [6] with parameter \(z = -0xd201000000010000\) whose subgroup order is \(p = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\). This is the characteristic of the field \(\mathbb{F}_p\) for which we synthesize constraints.