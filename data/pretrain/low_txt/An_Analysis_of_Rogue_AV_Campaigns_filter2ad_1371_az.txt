### 5.4 Address Space Construction and Switching

We create an isolated address space for untrusted drivers using the Xen hypervisor and a Windows XP 32-bit guest operating system, although our design is general and can be applied to other operating systems and hypervisors. Memory for Untrusted Page Tables (UPT) is allocated transparently to the guest OS within the hypervisor. We then map the untrusted driver code pages into the UPT and the trusted kernel and driver code into the Trusted Page Tables (TPT). All untrusted driver code pages in the TPT are marked as non-executable and non-writable, while all trusted code pages in the UPT are marked as non-executable, non-writable, and non-readable.

Pyrenée switches between the two address spaces based on the execution context by manipulating the CR3 register, a hardware register that points to the current page tables used by memory management hardware and is inaccessible to any guest OS. When an untrusted driver invokes a kernel API, execution faults into the hypervisor due to the non-executable kernel code in the UPT. Inside the hypervisor, Pyrenée verifies the legitimacy of the control flow by checking if the entry point into the TPT is valid. If the entry point is valid, it switches the address space by storing the value of the TPT CR3 (the trusted page table base) into the CR3 register. If the entry point is not valid, Pyrenée records this behavior as an attack and raises an alarm. Similarly, control flow transfers from TPT to UPT fault because untrusted driver code pages are marked non-executable inside the TPT. On this fault, Pyrenée switches the address space by storing the untrusted page table base (UPT CR3) in the CR3 register.

Pyrenée identifies legitimate entry points into the TPT by finding the kernel and trusted drivers' exported functions. The names and addresses of these exported functions are generated from the PDB files available from Microsoft's symbol server. Pyrenée keeps this information in the hypervisor for use by the host-attribution sensor.

### 5.5 Interception of Driver Loading

Pyrenée requires knowledge of drivers' load addresses to map their code pages into either the UPT or TPT. Since Windows dynamically allocates memory for all drivers, these addresses change. Additionally, Windows uses multiple mechanisms to load drivers. Pyrenée intercepts all driver loading mechanisms by rewriting the kernel's binary code on driver loading paths automatically at runtime. It modifies the direct call instruction to the `ObInsertObject` kernel function by changing its target to a location in the guest that is not assigned to the guest VM; it stores the original target. With this design, during the driver loading process, execution faults into the hypervisor. On the fault, Pyrenée securely extracts the driver’s load address from the driver object and resumes execution at the original target location. This design provides complete interpositioning of driver loading.

### 6 Evaluation

We tested our prototype implementation of Pyrenée to evaluate its ability to identify malicious software on infected systems, its performance, and its avoidance of false positives. To generate alerts notifying the correlation engine of suspicious network activity in our test environment, we ran a network simulator that acted as a network-based Intrusion Detection System (IDS).

#### 6.1 User-Level Malware Identification

We tested Pyrenée’s ability to detect process-to-process parasitic behaviors using the recent Conficker worm [38]. Conficker employs DLL injection to infect benign processes running on the victim system. We executed Conficker inside a test VM monitored by Pyrenée and connected to a network overseen by our NIDS simulator. When executed, the worm ran as a process called `rundll32.exe`. The host attribution sensor recorded DLL injection behavior from `rundll32.exe` targeting specific `svchost` processes.

When our NIDS simulator sent the IP addresses and port numbers for outbound malicious traffic to Pyrenée’s correlation engine, the engine determined what malicious code on the host was responsible. It searched the network attribution sensor’s data to extract the name of the process bound to the connection’s source port, here `svchost.exe`. It then searched the host attribution sensor’s data and found that `svchost.exe` was the victim of a parasitic DLL injection from `rundll32.exe`. The correlation engine also found the names of other executables infected by the malware and generated a complete listing that could be sent to a security administrator.

We repeated these tests with the Adclicker.BA trojan and successfully detected its parasitic behavior.

#### 6.2 Kernel-Level Malware Identification

We evaluated Pyrenée’s ability to detect kernel-level parasitism by testing it with the recent Storm worm [23]. Storm is a kernel-level malware that exhibits parasitic behaviors by injecting malicious DLLs into the benign `services.exe` process, causing `services.exe` to launch DDoS attacks. We loaded Storm’s malicious driver in the test VM. Since the driver is untrusted, Pyrenée loaded it into a separate isolated address space. On the execution of the driver’s code, all kernel APIs invoked by the driver were verified and logged by Pyrenée’s host attribution sensor. The sensor found that the driver was performing injection via APCs and recorded both the parasitic behavior and the victim process.

When our network simulator flagged the traffic made by `services.exe`, the correlation engine gathered the data collected by the host and network attribution sensors. The network attribution sensor determined `services.exe` to be the endpoint of the connection, and the host attribution sensor identified the parasitism of the malicious driver.

#### 6.3 Performance

We designed Pyrenée to operate at runtime, so its performance cost on an end user’s system must remain low. We tested our prototype on an Intel Core 2 Quad 2.66 GHz system. We assigned 1 GB of memory to the untrusted Windows XP SP2 VM and 3 GB combined to the Xen hypervisor and the high-privilege Fedora Core 9 VM. We carried out CPU and memory experiments using a Windows benchmark tool called PassMark Performance Test [24]. We measured networking overheads using IBM Page Detailer [13] and `wget`. Our experiments measured Pyrenée’s overhead during benign operations, during active parasitic attacks, and during the isolation of a heavily-used driver in the UPT. We executed all measurements five times and present here the median values.

First, we measured Pyrenée’s overhead on CPU-bound and memory-intensive operations. Tables 3 and 4 list a collection of benchmark measurements for execution in a VM with and without Pyrenée’s monitoring. For executions including Pyrenée, we measured performance both during the execution of a DLL injection attack against an unrelated process and during benign system operation. Our system’s performance in the absence of parasitic behavior is excellent and largely reflects the cost of system-call tracing. Experiments including the execution of an injection attack show diminished performance ranging from inconsequential to a more substantial performance loss of 27%. The additional overhead measured during the attack occurred when Pyrenée’s host sensor identified injection behavior and harvested state information for its log. This overhead is infrequent and occurs only when parasitic behaviors actually occur.

Next, we measured Pyrenée’s performance during network operations. Using the IBM Page Detailer, we measured the time to load a complex webpage spread across multiple servers (http://www.cnn.com). The page load caused the browser to make numerous network connections—an important test because Pyrenée’s network attribution sensor intercepts each packet and performs introspection on SYN packets. The result, shown in Table 5, demonstrates that the overhead of the network attribution sensor is low. We next executed a network file transfer by hosting a 174 MB file on a local networked server running `thttpd` and then downloading the file over HTTP using `wget` from the untrusted VM. Table 5 shows that Pyrenée incurred less than 3% overhead on the network transfer; we expect that this strong performance is possible because its packet interception design does not require it to queue and delay packets.

Finally, we measured the cost of our driver isolation strategy by isolating a heavily-used driver in the UPT, forcing a high volume of page faults handled by our hypervisor-level code. We isolated the networking driver `tcpip.sys` and repeated our previous CPU, memory, and network performance measurements in the new setting without active parasitic behaviors. We anticipated that CPU and memory overheads would remain similar, but that network operations would experience decreased performance. Tables 6, 7, and 8 provide evidence that our intuition was correct. Given that the moderate performance cost of isolating a driver in the UPT is borne only by operations invoking that driver’s functionality, we believe that it represents a feasible deployment strategy for unknown and untrusted drivers. The clear performance gain to be had by relocating known-benign drivers in the TPT provides an incentive for driver authors to produce verifiably-safe drivers acceptable to a driver-signing authority.

#### 6.4 False Positive Analysis

Pyrenée finds malicious code present on an infected system whenever it receives an alert from a NIDS; it does not detect attacks directly on its own. Hence, false positives will be exhibited by Pyrenée only when it identifies a benign process’s binary or a driver as malicious. We see two possible reasons for such behavior.

First, a NIDS may have false positives when distinguishing between benign and malicious traffic, and it may mis-characterize benign traffic as malicious. In this case, when the NIDS sends an alert along with the network-related information, the network attribution sensor will identify the process that is bound to the connection, and the correlation engine will mark that process as malicious. Certainly, this is a false positive. Fortunately, this problem will diminish over time as NIDS’ false positive rates decrease [11]. Even in the case of such false positives, Pyrenée helps an administrator meaningfully look into the actual problem by locating the endpoint of the network traffic. We feel that this design is stronger than an alternative that stores a whitelist of benign parasitic applications and considers malicious parasitic behaviors to be those initiated by non-whitelisted applications. The alternative design requires a whitelist that may not be feasible to generate.

Second, Pyrenée could identify a benign process as malicious when a NIDS correctly generates an alert. Absent implementation bugs, this could only be possible if the network attribution sensor or the host attribution sensor collect incorrect information. Benign parasitic behaviors, such as injections caused by debugging, will not appear to be malicious unless the debugged process is using the network in a way that appears to the NIDS as an attack.

### 7 Conclusions

We demonstrated the usefulness of identifying malicious code present on an infected system during attacks. We presented techniques and a prototype system, Pyrenée, for the automatic discovery of unknown malicious code. Pyrenée correlates network-level events to host-level activities with the help of multiple sensors and the correlation engine. When alerted by a NIDS, our system discovered malicious code, even in the presence of parasitic malware, by correlating information gathered from the host and network attribution sensors. Real malware samples showed that Pyrenée correctly identified malicious code. Our performance analysis demonstrated that our solution was suitable for real-world deployment.

### Acknowledgment of Support and Disclaimer

We thank our shepherd, Davide Balzarotti, and our anonymous reviewers for their extremely helpful comments. This material is based upon work supported by National Science Foundation contract number CNS-0845309. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not reflect the views of the NSF or the U.S. Government.