### 第31天：写在开发完成之后

#### 敬语体系说明
日语中有一套严格的敬语体系。当对方是长辈、上级或合作伙伴时，必须使用敬语。——译者注

---

**读者寄语**

想象一下，在屏幕后面不是你的分身，而是你自己不断升级。这种说法听起来有点像推销（笑）。但请允许我再强调一次相反的情况：如果购买了一本昂贵的书后感到后悔，那将是一件非常令人沮丧的事情。因此，请大家参考已经读过这本书的人的意见，或者先试读一部分内容，仔细考虑后再决定是否购买。也可以与其他同等价位的商品（例如几根巧克力棒）进行比较，思考这本书对你来说是否有价值。不过，这些话放在最后似乎意义不大了，如果你看到这里，可能已经买了这本书吧……

作为作者，我在内容的充实方面做了很多努力。虽然定价调整有限，但如果能将内容质量提高到原来的两倍，就相当于价格降到了一半。尽管这本书还远未达到两倍的标准，但我确实已经尽了最大的努力。

---

**内容安排与节奏**

本书的讲解长度和整体节奏都经过精心调整。如果加快节奏，以我的能力恐怕难以讲清楚。如果把两天的内容压缩成一天，用15章就可以完成，但这可能会导致一些读者无法消化。单看书名“30天自制操作系统”，对于毫无相关知识的人来说，可能会觉得30天太长了。我知道30天确实有些长，但以目前的节奏，如果在第20天结束，会感觉非常遗憾（不信可以看看第20天的内容……我们才刚刚开始编写API）。仅仅多出10天的内容，我们的系统就能变得更加有趣。如果在第10天或第15天收尾，则更加无法接受，完全体现不出编写操作系统的乐趣。

反过来，如果我们延长开发周期到40天或50天，一定能做出更有意思的系统。但我的体力实在支撑不了，而且书名变成《50天自制操作系统》的话，估计读者们会望而却步。

关于操作系统，我有很多个人观点，其中之一是操作系统应自带文件压缩功能。但这个观点并未成为业界常识，因此我在书中没有过多讨论，仅在29.2节中以缩小字库文件大小为目的加入了压缩功能，而未提及压缩对操作系统的重要性。

如果操作系统自带压缩功能是常识，我会在29.2节中从构思基本算法开始，详细介绍tek压缩。可惜篇幅有限，无法展开这一话题。

我的许多观点都在OSASK中有所体现，但在撰写本书时，我尽量避免流露个人观点，也没有将OSASK搬出来炫耀其功能。我不想给大家强加先入为主的观念，扼杀大家的好点子。

因此，我只向大家介绍编写操作系统的技术，并希望各位读者能自由发挥想象力，开发出各种各样的操作系统。如果大家开发出来的操作系统都像OSASK的克隆一样，那自制操作系统的世界也就没有进步，变得相当无聊了。

---

**感谢与致谢**

临近收尾时，预定的截稿日一拖再拖，给编辑添了不少麻烦，对此我深感抱歉。同时，也要感谢出版社听取了我的建议。

特别感谢以下几位：
- 参与校对的初中生代表DAsoran同学和高中生代表uchan同学。
- 提供了许多客观诚恳指摘的成人读者代表若生启先生。
- 为本书绘制插图及制作示意图的hideyosi先生。
- OSASK社区的各位成员。在过去的一年多时间里，为了撰写这本书，我中断了OSASK的开发。尽管有些抱怨，但大家还是坚持了下来。归根结底，正是有了社区各位的支持，OSASK才能一举成名，我也才有机会出版这本书。

当然，最要感谢的是现在正在读这本书的你，谢谢！

---

**联系方式**

如果各位想给我发邮件，请发送至以下邮箱：
Hidemi KAWAI 

不过，我不能保证对收到的每封来信都一一回复。如果是提问或感想，请尽量到支持网页的论坛中发帖，这样其他人也能看到并回帖，可能会更快得到有用的回答。如果想给我发私人邮件，且不介意回复慢或收不到回复，那么请发到上面的邮箱吧。

---

**专栏：这也能叫自制操作系统？**

说到编写操作系统，难道不该先从应该编写一个怎样的操作系统开始讨论吗？要编写多任务操作系统，如何解决访问冲突难道不是最重要的吗？连文件系统都没有设计怎么能算是自制操作系统啊！根本没有考虑设备驱动程序的问题嘛！内存不足时的处理实在是不够完善啊！窗口系统也太粗糙了吧？中断处理的少许优化、窗口移动的加速、加入压缩功能之类的，都不算是操作系统中本质的部分，难道不该减少这部分内容的篇幅，将重点更多地放在操作系统的本质上吗？如果操作系统都照这样来做，那世上的操作系统得有多不靠谱啊！

当然，这本书也有其他方面的不足。作为汇编语言的入门，指令讲解太少；作为C语言的入门，语法讲解不充分；作为算法的入门，需要介绍的东西太多。无论哪个方面都是半吊子，没有什么用处。这种对操作系统大小的过度追求，对编程初学者来说难道不是有害的吗？

的确，这些质疑的声音肯定会有的。没错，你说得对，这本书确实有这些不足之处。不过，我在写这本书的时候，并不是对这些不足一无所知（关于操作系统大小的那一点，我认为是有益而不是有害的）。

---

**“从失败中学习”的理念**

“从失败中学习”是贯穿本书的一个理念。当然，一开始在什么都不知道的情况下，谈不上失败，所以我先单方面进行了一些讲解。随着内容的进行，我们一般是先随便做一个版本，然后发现这个版本的缺陷再进行改良。因此，你可能会看到“纸娃娃系统”在访问冲突方面考虑不周，其实我是故意这样做的。如果有更多篇幅，我可以让“纸娃娃系统”崩溃一次，然后再引出改良的话题。

或者说，我正是因为清楚这些不足才希望各位指教。如果你能指出其中的不足，并提出对策，我可以直接将这些对策告诉各位读者。也就是说，你可以为这本书撰写续篇。所以别客气，请多多指教吧。

当然，这个“从失败中学习”的理念也可能遭到质疑。如果不经过这些失败的例子，从一开始就条理清楚地讲解各个功能的必要性，整个篇幅可以缩短，最终的操作系统完成度也会提高，大概15天左右就可以达到现在的完成度。但那样的讲解效果如何呢？是不是通俗易懂呢？就像算术，我们不要一上来就介绍乘法运算，而是先用反复的加法运算凑合一段时间，等实在觉得太麻烦受不了的时候，再介绍乘法运算，这样一下子就可以感受到乘法运算的便利，也就更有动力去背九九乘法表了。

对这本书标题感兴趣的读者，一定都曾经萌发过编写操作系统的念头吧。因此凡是可能会影响读者兴趣的东西，我都尽量避免。在使用汇编语言时，尽量减少所使用的指令种类；对C语言的语法并非完全讲解，而是仅限于其中容易理解的部分（或者说不用的话反而会变得更难懂的部分）。

对我来说，这的确是一个挑战。“纸娃娃系统”到底能用多简单的语法实现丰富功能，这是一个挑战；到底能用多简单的知识就能完成一个操作系统，也是一个挑战。大家可能也不止一次会想，在某些地方使用更高级的命令会更好。我也想过在某些地方使用一些高级的算法，也想过为了本书的读者将来能读懂其他程序而对C语言的一些其他语法进行讲解，但这些都没有做，因为一旦开始这样的话题，可能就没完没了了。

---

**本书的主旨**

本书的主旨就是要让本来很难的东西看上去变得很容易。只要看上去很容易，读者就会在基本理解的基础上有动力继续读下去。即使有些东西无法实际感受到，只要基本上理解了就没有问题。如果本来就很难的东西，还要用很难的方式去讲解，那读者马上就会厌倦。因此，我尽量避免这种情况。

当然，把本来简单的东西搞得很复杂，那就更不应该了。

在内容的先后上我也花了心思。本书是从简单的、好看的、效果容易理解的、有成就感的、而且是对操作系统有必要的部分开始，逐步进行开发的。因此，可能会出现一些不太寻常的东西。例如，为了介绍操作系统的核心，从一开始就引入了bim2hrb.exe，其实这个工具是应用程序用的连接器。也就是说，本来应该在编写应用程序的时候才引入bim2hrb.exe，但我们却在一开始几乎不加说明地引入了它。另外，在本书中根本没有操作系统用的连接器，这也是在内容上花了心思的结果。

在编写“纸娃娃系统”的过程中，有很多涉及速度优化的内容。现在想想，其中有一些内容感觉不是非常有必要。不过，在撰写那些章节的时候，考虑到这个算法在以后还可以派上别的用场，因此附带提了一下。另一方面，优化速度在某些情况下还是相当重要的。如果因为没有优化而造成速度很慢，读者可能会误以为“果然初学者做出的系统，速度没办法达到像Windows和Linux那样实用的程度”，从而影响了开发的斗志。

---

**总结**

嗯，就说这么多吧。如果无法接受这些观点也没关系，但希望大家在批判前能理解我的想法。

---

**毕业典礼**

/* 《友谊天长地久》苏格兰民谣①*/
$E"SJIS"; T100L4O4
$K"ほたるのひかり まどのゆき"; CF.F8FAG.F8GAFFA>CD2&D8R8
$K"书(ふみ)よむつき日 かさねつつ"; DC.
$K"いつしか年も すぎのとを"; DC.DC.CD2&D8R8
$K"あけてぞ けさは わかれゆく"; DC.<A8AFG.F8GAF.D8DCF2&F8R8
$K""; R

---

**附录**

这本书如果按顺序读下来应该是一本不错的书，但在读过一遍之后，忽然想知道某个知识点是在哪里讲解的，找起来可就麻烦了。此外，如果对于某个函数的写法不太理解，想找到这个写法是在哪个章节提到的，就更加麻烦了。

因此，我们在这里提供了一个简单的函数索引。它是在bootpack.h和apilib.h的代码中加上注释所构成的，通过这个索引，就可以追溯到某个函数是在哪个章节进行过修改了。

**bootpack.h**

```c
/* asmhead.nas */
struct BOOTINFO { /* 0x0ff0.0x0fff */ /* 5.2, 6.3, 18.7 */
    char cyls; /* 引导扇区读取到磁盘的哪个位置 */
    char leds; /* 引导时键盘的LED状态 */
    char vmode; /* 显卡的颜色位数 */
    char reserve;
    short scrnx, scrny; /* 画面分辨率 */
    char *vram;
};

#define ADR_BOOTINFO 0x00000ff0
#define ADR_DISKIMG 0x00100000

/* naskfunc.nas */
void io_hlt(void); /* 3.9, 4.6 */
void io_cli(void); /* 4.6 */
void io_sti(void); /* 4.6 */
void io_stihlt(void); /* 4.6 */
int io_in8(int port); /* 4.6 */
void io_out8(int port, int data); /* 4.6 */
int io_load_eflags(void); /* 4.6 */
void io_store_eflags(int eflags); /* 4.6 */
void load_gdtr(int limit, int addr); /* 6.4 */
void load_idtr(int limit, int addr);
int load_cr0(void); /* 9.2 */
void store_cr0(int cr0); /* 9.2 */
void load_tr(int tr); /* 15.1 */
void asm_inthandler0c(void); /* 22.2 */
void asm_inthandler0d(void); /* 21.5, 21.6 */
void asm_inthandler20(void); /* 12.1, 21.4, 21.6 */
void asm_inthandler21(void); /* 6.6 */
void asm_inthandler2c(void);
unsigned int memtest_sub(unsigned int start, unsigned int end); /* 9.2, 9.3 */
void farjmp(int eip, int cs); /* 15.3 */
void farcall(int eip, int cs); /* 20.4 */
void asm_hrb_api(void); /* 20.8, 21.4, 21.6 */
void start_app(int eip, int cs, int esp, int ds, int *tss_esp0); /* 21.4, 21.6 */
void asm_end_app(void); /* 22.3 */

/* fifo.c */
struct FIFO32 { /* 13.4, 16.2 */
    int *buf;
    int p, q, size, free, flags;
    struct TASK *task;
};

void fifo32_init(struct FIFO32 *fifo, int size, int *buf, struct TASK *task); /* 13.4, 16.2 */
int fifo32_put(struct FIFO32 *fifo, int data); /* 13.4, 16.2, 16.4, 16.5 */
int fifo32_get(struct FIFO32 *fifo); /* 13.4 */
int fifo32_status(struct FIFO32 *fifo); /* 13.4 */

/* graphic.c */
void init_palette(void); /* 4.6, 25.2 */
void set_palette(int start, int end, unsigned char *rgb); /* 4.6 */
void boxfill8(unsigned char *vram, int xsize, unsigned char c, int x0, int y0, int x1, int y1); /* 4.7 */
void init_screen8(char *vram, int x, int y);
void putfont8(char *vram, int xsize, int x, int y, char c, char *font); /* 5.4 */
void putfonts8_asc(char *vram, int xsize, int x, int y, char c, unsigned char *s); /* 5.6, 28.5, 28.6, 28.7 */
void init_mouse_cursor8(char *mouse, char bc); /* 5.8 */
void putblock8_8(char *vram, int vxsize, int pxsize, int pysize, int px0, int py0, char *buf, int bxsize);

#define COL8_000000 0
#define COL8_FF0000 1
#define COL8_00FF00 2
#define COL8_FFFF00 3
#define COL8_0000FF 4
#define COL8_FF00FF 5
#define COL8_00FFFF 6
#define COL8_FFFFFF 7
#define COL8_C6C6C6 8
#define COL8_840000 9
#define COL8_008400 10
#define COL8_848400 11
#define COL8_000084 12
```

---

希望这些改进能使文本更加清晰、连贯和专业。