### Framework Overview
Our framework automatically logs potential restore points without requiring user intervention. However, users have the option to enable specific alerts for certain types of system events. For example, a user can set an alert for system driver installations, which will notify them if they are about to install a privileged component. It is important to note that users can still proceed with the installation, regardless of whether the driver is benign or malicious, as the framework ensures that the system can be restored to a previous state.

### 6. Discussion

#### 6.1. Framework Security

**Security of Views:**
The implementation of views leverages the fact that, under normal system operations, executables are not modified, and data files are typically modified within a single session. This allows for a simple and effective method of maintaining copy-on-write (COW) copies of modified files.

An adversary might attempt to overwhelm the system by repeatedly opening and closing files, leading to the creation of many COWed copies. This attack can be detected by monitoring the frequency and number of such accesses and triggering an alert for suspicious activity. Our tests indicate that normal applications should not trigger these alerts. An adversary could also perform moderate open and close operations on large files, but such applications are often database-oriented and include internal rollback features. Therefore, for large files, the framework maintains only a single COWed copy. Future work could enhance this by supporting incremental changes instead of full COWed copies.

Another form of attack involves locating and tampering with the framework's view files. To do this, malware would need to go through the file system driver. Our framework intercepts access to these files and returns values that mimic their non-existence.

**Security of Mappings:**
Our framework maps system operations to executing code streams using call-contexts. If the malware is in the form of an executable, DLL, kernel mode driver, or allocated pool, the framework ties these into the parent information of the request to a particular file or configuration object. Malware could exploit vulnerabilities to execute code on the stack, potentially overwriting code in other modules to access a file or configuration object.

In user mode, such modifications are detected using COW. In kernel mode, detection is more challenging. Additionally, in user mode, malware could jump to a module from the stack to create a file, resulting in an orphaned mapping. If there are modified modules, they will be linked to the parent. In kernel mode, file creations by standard modules are rare, so any such creation would be flagged as an orphan unless it can be linked to a loaded module. Depending on where the file is created, the framework can issue an alert, especially if the file is in a system path, indicating persistence.

**Security of Interceptors:**
Intercepts within our framework are directly within the file system driver. While malware could intercept within the FSD, it would still need to invoke the framework since we intercept at the lowest level, capturing detailed information about manipulated files. Inserting below our interceptors is non-trivial and would compromise system stability, as these routines and structures vary with the file system driver. A malware cannot dynamically load another FSD for the same volume, and installing a filter would still require invoking our framework. Overwriting the file system driver image for activation on the next bootup would be detected and trigger an alert.

**Security of Recovery:**
Since we track all modifications to the system state and ensure this information cannot be tampered with, recovery will always succeed. The recovery process aborts all processes related to the current view, preventing interruptions and reinfection.

#### 6.2. Limitations

While our framework captures all filesystem and configuration changes, there are some limitations:

- **Internal Memory Structures:** The framework maintains memory structures related to views and mappings, periodically flushing them to disk. Kernel-mode malware could tamper with these structures, leading to system instability. Although the system can be restored to a clean state on the next boot, this could result in the loss of more clean data than usual.
- **Recovery Console Tampering:** Malware could tamper with the recovery console (a user-mode interface) to prevent restoration. However, the system can still be restored after a reboot.
- **Performance Impact:** The COW mechanism applied to entire files can significantly impact performance, especially with large files or high volumes of small file creations and modifications. A solution would be to apply COW at a finer granularity (e.g., 512 or 1024 bytes), reducing the disk space required.
- **Kernel-Mode Access:** Malware running in kernel mode could bypass the file system driver to access the disk directly. This is non-trivial and could lead to filesystem inconsistencies due to cached directory entry information.
- **Mapping Granularity:** The framework's mappings help minimize the loss of clean data but are coarse-grained. Precise pinpointing of the operation originator requires complete control over executing code streams, which is particularly challenging in kernel mode.

### 7. Conclusions

We have described MalTRAK, a framework for tracking and eliminating known and unknown malware. The framework allows users to run any program without pre-defined policies, ensuring the system can be restored to a clean state in case of infection. It achieves this with minimal runtime overhead and by minimizing the loss of clean data. The framework establishes different logical views of the system during runtime and maintains relationships between these views based on system operations. Upon infection, it switches to a clean system state by reverting to the appropriate view before the infection. Monitoring at the lowest possible level makes it extremely difficult to bypass. We implemented MalTRAK on Windows and tested it against 8 real-world malware samples, comparing it with two popular commercial antivirus tools. With minimal overhead, we were able to completely remove the effects of the malware, while the commercial tools, on average, restored only 36% of the effects. For one malware sample, the commercial tools could detect but not repair the damage, and for two samples, they failed to detect or restore any effects.

### References

[1] A. B. Brown and D. A. Patterson. Undo for operators: Building an undoable e-mail store. In Proceedings of the Usenix Annual Technical Conference, 2003.
[2] M. Christodorescu, S. Jha, S. Shesia, D. Song, and R. Bryant. Semantic aware malware detection. In Proceedings of the IEEE Symposium on Security and Privacy, 2005.
[3] M. Christodorescu and J. S. Static analysis of executables to detect malicious patterns. In Proceedings of the USENIX Security Symposium, 2003.
[4] F. Cohen. Operating system protection through program evolution. Available at (http://all.net/books/ip/evolve.html), 1998.
[5] G. W. Dunlap, S. T. King, S. Cinar, M. Basrai, and P. M. Chen. Revirt: Enabling intrusion analysis through virtual machine logging and replay. In Proceedings of the Usenix Symposium on Operating Systems Design and Implementation (OSDI), 2002.
[6] J. Giffin, S. Jha, and B. Miller. Detecting manipulated remote call streams. In Proceedings of the USENIX Security Symposium, 2002.
[7] A. Goel, K. Po, K. Farhadi, Z. Li, and E. de Lara. The taser intrusion recovery system. In Proceedings of the ACM Symposium on Operating System Principles (SOSP), pages 163–176, 2005.
[8] A. Gostev. Malware evolution: January - July 2007. Kaspersky Lab Report, October 2007.
[9] F. Hsu, H. Chen, T. Ristenpart, J. Li, and Z. Su. Back to the future: A framework for automatic malware removal and system repair. In Proceedings of the Annual Computer Security and Applications Conference (ACSAC), 2006.
[10] G. Hunt and D. Brubacher. Detours: Binary interception of win32 functions. In Proceedings of USENIX Windows NT Symposium, 1999.
[11] K. Kasslin. Kernel malware: The attack from within. Association of Anti-virus Asia Researchers (AVAR), 2006.
[12] S. King and P. Chen. Backtracking intrusions. In Proceedings of the ACM Symposium on Operating Systems Principles (SOSP), 2003.
[13] S. King, G. W. Dunlap, and P. M. Chen. Debugging operating systems with time-traveling virtual machines. In Proceedings of the Usenix Annual Technical Conference, 2005.
[14] S. T. King, G. W. Dunlap, and P. M. Chen. Operating system support for virtual machines. In Proceedings of the Usenix Annual Technical Conference, 2003.
[15] E. Kirda, C. Kruegel, G. Banks, G. Vigna, and R. A. Kemmerer. Behavior-based spyware detection. In Proceedings of IEEE Symposium on Security and Privacy, 2007.
[16] B. Krebs. Mpack exploit tool slips through security holes. The Washington Post, June 2007.
[17] C. Kruegel, W. Robertson, and C. Vigna. Detecting kernel-level rootkits through binary analysis. In Proceedings of the Annual Computer Security and Applications Conference, 2004.
[18] R. Kuster. Three ways to inject your code into another process. Code Project (http://www.codeproject.com/KB/threads/winspy.aspx), August 2003.
[19] Z. Liang, V. Venkatakrishnan, and R. Sekar. Isolated program execution: An application-transparent approach for executing untrusted programs. In Proceedings of Annual Computer Security and Applications Conference (ACSAC), 2003.
[20] C. Linn and S. Debray. Obfuscation of executable code to improve resistance to static disassembly. In Proceedings of ACM Conference on Computer and Communication Security, 2003.
[21] McAfee Inc. Top 10 computer virus threats in 2007. VirusScan Plus: Anti-virus and anti-spyware. (http://www.mcafee.com), 2007.
[22] mi2g. Five solutions to the rising identity theft and malware problem. mi2g alerts (http://www.mi2g.com/cgi/mi2g/press/240304.php), March 2004.
[23] Microsoft Corp. Windows asynchronous procedure calls. MSDN (http://msdn2.microsoft.com/en-us/library/ms681951.aspx), 2007.
[24] D. A. Patterson, A. Brown, P. Broadwell, G. Candea, M. Chen, J. Cutler, P. Enriquez, A. Fox, E. Kiciman, M. Merzbacher, D. Oppenheimer, N. Sastry, W. Tetzlaff, J. Traupman, and N. Treuhaft. Recovery-oriented computing (ROC): Motivation, definition, techniques, and case-studies. In Technical Report UCB/CSD021175, 2002.
[25] M. Rosenblum and J. K. Ousterhout. The design and implementation of a log-structured file system. In ACM Transactions of Computer Systems (TOCS), volume 10(1), pages 26–52, 1992.
[26] E. Skoudis. 10 emerging malware trends for 2007. Search Security, January 2007.
[27] N. Zhu and T. C. Chiueh. Design, implementation, and evaluation of repairable file service. In International Conference on Dependable Systems and Networks (DSN), 2003.
[28] W. Sun, Z. Liang, V. Venkatakrishnan, and R. Sekar. One-way isolation: An effective approach for realizing safe execution environments. In Proceedings of Network and Distributed Systems Symposium (NDSS), 2005.
[29] Symantec Corp. Norton Anti-Virus. (http://www.symantec.com).
[30] P. Szor. The art of antivirus research. Wiley Publishers, 2005.
[31] A. Vasudevan and R. Yerraballi. Sakthi: A retargetable dynamic framework for binary instrumentation. In Proceedings of the Hawaii International Conference in Computer Science (HICCS), 2004.
[32] M. Wise. Windows XP System Restore. Microsoft Technet Library, 2007.