### Turing [6, 22] and the Use of GNU Coreutils for Benchmarks

Turing [6, 22] implements a comprehensive set of utilities, generating a wide range of real-world control flow graphs (CFGs) that are not typically seen in toy examples. For our benchmarks, we compiled GNU Coreutils 9.29 using GCC 4.9.3, targeting the x86-64 architecture, without debug symbols and dynamic linking. We evaluated the performance of four optimization levels: O0, O1, O2, and O3.

All generated binaries were decompiled using multiple decompilers to produce C code. Notably, based on our evaluation data, revng-c is the only decompiler that generates valid C code as output. The decompiled code from Hex-Rays Decompiler and Ghidra could not be parsed by a standard-conforming C parser. To collect our evaluation metrics, we had to make ad-hoc changes to the decompiled sources, such as declaring missing variables and types, correcting function call parameters, and other adjustments.

To ensure a fair comparison, we used IDAPython for the Hex-Rays Decompiler and Java scripts for Ghidra to extract information about the decompiled functions, including their entry points and sizes. We then compared only those functions for which all three tools provided identical information. Table 1 reports the percentage of functions that matched in size and were used in our evaluation.

### Considerations with Using Coreutils as Benchmarks

All programs in Coreutils share a core library called gnulib, which is statically linked with all binaries. This results in the duplication of functions in gnulib across multiple binaries. This issue has been previously noted by the authors of DREAM [22], who also proposed a strategy to address it. The solution involves deduplicating all decompiled functions across Coreutils before the final comparison to avoid overrepresenting duplicated functions. We adopted this strategy for our comparison.

### Evaluation of the Results

The quality of the generated code was measured using two metrics:

1. **Gotos**: The number of goto statements emitted. Goto statements can significantly reduce code readability by arbitrarily diverting the control flow, making it difficult to track execution [10].
2. **Cyclomatic Complexity**: The increase in cyclomatic complexity [18] of the decompiled code, using the original code as the baseline. This metric measures the mental effort required to understand the decompiled code.

We evaluated the code generated by the three decompilers from binaries with different optimization levels according to these metrics. The evaluation was limited to functions that all decompilers correctly identified. The results are reported in Table 1.

By design, revng-c eliminates goto statements, generating zero gotos across the entire GNU Coreutils suite. Additionally, revng-c produces decompiled code with reduced cyclomatic complexity compared to the Hex-Rays Decompiler and Ghidra. The cyclomatic complexity of the decompiled code is expressed relative to the baseline. We assume that the inherent complexity of the code is intrinsic, and the goal of decompilation is to introduce as little additional complexity as possible.

For the -O2 optimization level, typically used in release builds, revng-c reduces the additional cyclomatic complexity by 40% compared to IDA and almost 50% compared to Ghidra.

### Metrics for Hex-Rays Decompiler and Ghidra

Ghidra performs slightly better in terms of goto statements, emitting fewer gotos than the Hex-Rays Decompiler. Overall, these metrics suggest that both decompilers adopt a similar approach to decompilation.

Table 2 provides an overview of the increase in code size due to duplication introduced by our approach. Figure 12 shows the estimated probability distribution function (using the KDE method) of the size increase for all optimization levels. This metric was not computed for the other tools because they do not introduce duplication.

Regular optimizations, such as dead code elimination, could mitigate the effects of duplication. However, due to time constraints, we have not assessed the impact of such optimizations.

Figure 13 presents heat maps visualizing the relationship between duplication and the reduction in cyclomatic complexity for the -O2 optimization level, comparing revng-c with both Hex-Rays and Ghidra. The heat maps show that even when significant duplication occurs, there is a reduction in cyclomatic complexity compared to IDA and Ghidra.

### Conclusion

In this work, we presented a novel approach to control flow restructuring and decompilation by introducing new techniques to transform any given CFG into a directed acyclic graph (DAG) form, which we call Preprocessing. We then apply our Combing algorithm to build a C abstract syntax tree (AST) from the input code, which is transformed by the Matching phase to emit idiomatic C. We implemented our solution on top of the rev.ng framework, building a decompiler tool called revng-c. Our evaluation compared our results against both academic and commercial state-of-the-art decompilers.

Experimental results show that our solution avoids the emission of goto statements, an improvement over the Hex-Rays Decompiler and Ghidra, without resorting to predicated execution, which affects DREAM. In future work, we aim to improve the quality of the decompiled code by focusing on the recovery of more idiomatic C constructs, leveraging the modular nature of the Matching phase of our algorithm.

We also plan to support the emission of some goto statements in a very limited and controlled setting, where they may be considered idiomatic and legitimate, such as in the goto cleanup pattern. This would allow us to trade the introduction of a goto for further reducing the duplication introduced by our combing algorithm. Additionally, we aim to verify the semantic preservation of the control flow restructuring transformations by enforcing modifications at the LLVM IR level and using recompilation features to prove behavioral equivalence.

### References

[1] Hex-rays decompiler. https://www.hex-rays.com/products/decompiler/.
[2] National Security Agency. Ghidra. https://ghidra-sre.org/.
[3] Fabrice Bellard. QEMU, a fast and portable dynamic translator. In Proceedings of the FREENIX Track: 2005 USENIX Annual Technical Conference, April 10-15, 2005, Anaheim, CA, USA, 2005.
[4] David Brumley, Ivan Jager, Thanassis Avgerinos, and Edward J Schwartz. Bap: A binary analysis platform. In International Conference on Computer Aided Verification. Springer, 2011.
[5] David Brumley, JongHyup Lee, Edward J Schwartz, and Maverick Woo. Native x86 decompilation using semantics-preserving structural analysis and iterative control-flow structuring. In Presented as part of the 22nd USENIX Security Symposium (USENIX Security 13), 2013.
[6] David Brumley, JongHyup Lee, Edward J. Schwartz, and Maverick Woo. Native x86 decompilation using semantics-preserving structural analysis and iterative control-flow structuring. In Proceedings of the 22th USENIX Security Symposium, Washington, DC, USA, August 14-16, 2013, 2013.
[7] Cristina Cifuentes. Reverse compilation techniques. Queensland University of Technology, Brisbane, 1994.
[8] Alessandro Di Federico and Giovanni Agosta. A jump-target identification method for multi-architecture static binary translation. In Compilers, Architectures, and Synthesis of Embedded Systems (CASES), 2016 International Conference on, 2016.
[9] Alessandro Di Federico, Mathias Payer, and Giovanni Agosta. Rev. ng: a unified binary analysis framework to recover CFGs and function boundaries. In Proceedings of the 26th International Conference on Compiler Construction, 2017.
[10] Edsger W Dijkstra. Go to statement considered harmful. Communications of the ACM, 11(3), 1968.
[11] Alessandro Di Federico, Pietro Fezzardi, and Giovanni Agosta. Rev.ng: A multi-architecture framework for reverse engineering and vulnerability discovery. In International Carnahan Conference on Security Technology, ICCST 2018, Montr√©al, Canada, October 22-25, 2018. IEEE, 2018.
[12] Ilfak Guilfanov. Decompilers and beyond. Black Hat USA, 2008.
[13] Hex-Rays. Ida pro. https://www.hex-rays.com/products/ida/.
[14] Donald E. Knuth. The Art of Computer Programming, Volume 1 (3rd Ed.): Fundamental Algorithms. Addison Wesley Longman Publishing Co., Inc., Redwood City, CA, USA, 1997.
[15] Christopher Kruegel, William Robertson, Fredrik Valeur, and Giovanni Vigna. Static disassembly of obfuscated binaries. In USENIX security Symposium, volume 13, 2004.
[16] Chris Lattner and Vikram Adve. LLVM: A Compilation Framework for Lifelong Program Analysis & Transformation. In CGO 2004.
[17] Thomas Lengauer and Robert Endre Tarjan. A fast algorithm for finding dominators in a flowgraph. ACM Transactions on Programming Languages and Systems (TOPLAS), 1979.
[18] T. J. McCabe. A complexity measure. IEEE Transactions on Software Engineering, SE-2(4), Dec 1976.
[19] Dawn Song, David Brumley, Heng Yin, Juan Caballero, Ivan Jager, Min Gyung Kang, Zhenkai Liang, James Newsome, Pongsin Poosankam, and Prateek Saxena. Bitblaze: A new approach to computer security via binary analysis. In International Conference on Information Systems Security. Springer, 2008.
[20] Khaled Yakdan. Dream code snippets. https://net.cs.uni-bonn.de/fileadmin/ag/martini/Staff/yakdan/code_snippets_ndss_2015.pdf.
[21] Khaled Yakdan, Sergej Dechand, Elmar Gerhards-Padilla, and Matthew Smith. Helping johnny to analyze malware: A usability-optimized decompiler and malware analysis user study. In 2016 IEEE Symposium on Security and Privacy (SP). IEEE, 2016.
[22] Khaled Yakdan, Sebastian Eschweiler, Elmar Gerhards-Padilla, and Matthew Smith. No more gotos: Decompilation using pattern-independent control-flow structuring and semantic-preserving transformations. In NDSS, 2015.