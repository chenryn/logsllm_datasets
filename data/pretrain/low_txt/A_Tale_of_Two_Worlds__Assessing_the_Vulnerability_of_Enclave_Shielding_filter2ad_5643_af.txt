### Attack Vector #10: Uninitialized Padding

Uninitialized padding in structures can lead to unintentional leakage of secret memory, even when the visible state (i.e., individual members of the structure) is sanitized. Prior research on operating system kernels [7] and SGX enclaves [23] has shown that padding bytes added by the compiler may still leak uninitialized secret memory.

#### Relevance for Production SDKs
This attack vector is particularly relevant for production SDKs that expose enclave interfaces to programmers. Traditional TEE designs are vulnerable to this subtle attack vector, which cannot be easily mitigated by sanitizing the program-visible API state. Possible mitigations include:

- **Secure Initialization**: Use `memset()` to securely initialize the entire output structure.
- **Member-wise Deep Copy**: Perform a deep copy of the structure's members.
- **Packed Structures**: Declare the output structure as "packed" to prevent the compiler from adding padding.

However, these solutions require application-specific knowledge about the exact types of structures being passed. A key insight is that this attack vector can only be transparently shielded if the enclave interface is predefined and fixed. For example, the fixed ocall interface in libOS-based runtimes can be manually scrutinized for such vulnerabilities. In contrast, SDK-based runtimes with generic enclave interfaces defined by the programmer outsource the responsibility of scrubbing uninitialized struct padding to the application developer.

#### SDK-Based Runtimes
Lee et al. [23] first demonstrated how uninitialized struct padding can pose a subtle information leakage source in the edger8r-generated code of the Intel SGX-SDK. Building on their findings, we generalized this attack vector to show its applicability to oeedger8r-generated code in Microsoft’s Open Enclave SDK and the Sancus TEE. We also confirmed that padding leakage can occur in Keystone, for example, through the padding of `calc_message_t` in the demo enclave.

#### LibOS-Based Runtimes
We reviewed the ocall interfaces in libOS-based runtimes, including Graphene-SGX, LKL, and Rust-EDP. Rust-EDP appears to be free of such issues, and Graphene-SGX explicitly enforces struct packing through a compiler `#pragma`. However, SGX-LKL contains at least two instances where an ocall uses a structure with potentially vulnerable padding bytes (`sigaction` and `siginfo_t`). In Google Asylo, most structures passed through an ocall are explicitly declared as packed, but we found one instance of a padded structure (`BridgeSignalHandler`) used in the syscall interface.

### Discussion and General Mitigations

The most intuitive solution to defend against these attacks is to incorporate additional checks in the enclave code to properly sanitize ABI state and API arguments/return values. When implemented correctly, such checks can block all the attacks described in this work. However, relying on enclave developers, who may be unaware of this class of vulnerabilities, to implement these checks can be problematic. Our analysis revealed several recurring pitfalls, including subtle logical bugs, side-channels, double fetches, and integer overflows. This highlights the need for more principled approaches to rule out this class of vulnerabilities, as well as defense-in-depth code hardening measures to raise the bar for successful exploitation.

#### Code Hardening
Interface sanitization vulnerabilities are closely related to a wider class of memory safety issues [3, 22], and their exploitation can be partially hindered by established techniques such as heap obfuscation (cf. Section 4.1). SGX-Shield [40] aims to obstruct memory corruption attacks by randomizing the memory layout of enclaved binaries. However, prior research [3] has shown that SGX-Shield does not randomize the trusted runtime, meaning that the code studied would still feature a deterministic and static memory layout, potentially offering numerous gadgets for mounting code reuse attacks. Additionally, any memory safety or side-channel vulnerabilities in the trusted runtime itself could disrupt the preliminary randomization stage. While randomizing the memory layout of the trusted runtime is desirable, it is a non-trivial task given its low-level nature, including hand-written assembly code and static memory addresses expected by SGX’s eenter and eresume instructions. Some of the attacks we presented are immune to software randomization schemes, such as the SGX-SDK `strlen()` oracle in Fig. 4, which depends solely on the fixed address of the victim’s SSA frame.

As an alternative code hardening approach, we recommend implementing more aggressive responses when detecting pointer violations in the trusted runtime. Most runtimes we studied merely reject the ecall attempt when detecting pointer poisoning. In the SGX-SDK `strlen()` oracle attack, we abused this by repeatedly calling a victim enclave, each time passing an illegal pointer and making side-channel observations before the ecall is rejected. To prevent such repeated attacks, we recommend immediately destroying secrets and/or initiating an infinite loop upon detecting the first pointer poisoning attempt in the trusted runtime.

#### Hardware-Assisted Solutions
A more principled approach to rule out confused deputy attacks is to leverage finer-grained memory protection features in the processor. Tagged memory [51] or capability architectures [52] appear to be promising for inherently separating the memory domains of untrusted and trusted code. On a capability machine [52], pointers are represented at runtime as unforgeable objects carrying associated permissions and length fields, ensuring that untrusted code cannot create a valid capability pointing inside enclave-private memory.

An example of an alternative tagged memory design is the recently proposed Timber-V [51] architecture, which provides lightweight and strong enclaved execution on embedded RISC-V platforms. Timber-V processors offer enhanced MPU isolation by keeping track of a 2-bit tag for every memory word, allowing individual memory locations to be associated with one of four possible security domains. The CPU restricts tag updates and offers checked memory load/store operations, which trap whenever the actual memory location being dereferenced does not match the expected tag. This ensures that any pointer poisoning attempts by untrusted code outside the enclave are immediately caught by the hardware.

The untrusted pointer dereference issues we identified bear similarities to how privileged OS kernel code needs to sanitize user space pointers in system call arguments. As a defense-in-depth mechanism, recent x86 processors support Supervisor Mode Access Protection (SMAP) features to disallow unintended user space pointer dereferences in kernel mode [17]. Further research is encouraged to investigate porting such CPU features to enclave mode.

#### Safe Programming Languages
Combining TEEs with safe programming languages like Rust has been proposed as a promising direction to safeguard enclave program semantics, but still requires additional interface sanitizations [48]. Fortanix’s Rust-EDP [11] demonstrates how the compiler’s type system can be leveraged to limit the burden of pointer sanitization concerns. However, safe languages alone are not a silver bullet. The trusted runtime code must still bootstrap memory safety guarantees by establishing expected ABI calling conventions in the low-level entry assembly code and providing a correct implementation of sanitization in the untrusted pointer type. The subtle integer overflow vulnerability in Fortanix’s EDP, presented in Section 5.3, illustrates that developing both the trusted runtime libraries and the enclave in safe Rust may still not fully eradicate pointer sanitization vulnerabilities.

As an alternative to Intel’s edger8r tool, the use of separation logic has been proposed to automatically generate secure wrappers for SGX enclaves [49]. This approach aims to provide the advantages of safe languages and even formal verification guarantees but still relies on explicit developer annotations.

### Conclusions and Future Work

Our work highlights that the shielding responsibilities in today’s TEE runtimes are not sufficiently understood, and various security issues exist in the respective trusted computing bases. We have identified 35 interface sanitization vulnerabilities in 8 open-source TEE runtimes, including production-quality SDKs written by security-savvy developer teams. Our analysis reveals that the entry points into this attack surface are more pervasive than just argument pointers, and we contributed a classification of 10 recurring vulnerability classes spanning the ABI and API tiers.

In the defensive landscape, our work emphasizes the need for more principled interface sanitization strategies to safeguard the unique TEE shielding responsibilities. We particularly encourage the development of static analysis tools and fuzzing-based vulnerability discovery and exploitation techniques to further explore this attack surface.

### Acknowledgments

We thank Jethro Beekman (Fortanix), Job Noorman (KU Leuven), and Johannes Götzfried for insightful discussions, and the anonymous reviewers for constructive feedback that helped improve the paper. We also thank the maintainers of the open-source projects we studied for their contributions to the community and for promptly responding and working on mitigations.

This research is partially funded by the Research Fund KU Leuven, the Agency for Innovation and Entrepreneurship (Flanders), the Research Foundation – Flanders (FWO), the Engineering and Physical Sciences Research Council (EPSRC) under grants EP/R012598/1, EP/R008000/1, and the European Union’s Horizon 2020 research and innovation programme under grant agreement No. 779391 (FutureTPM). Abdulla Aldoseri is supported by a stipend from the University of Bahrain.

### References

[1] Sergei Arnautov, Bohdan Trach, Franz Gregor, Thomas Knauth, Andre Martin, Christian Priebe, Joshua Lind, Divya Muthukumaran, Dan O’Keeffe, Mark L Stillwell, et al. 2016. SCONE: Secure Linux Containers with Intel SGX. In Proceedings of the 12th USENIX Symposium on Operating Systems Design and Implementation. USENIX Association, 689–703.

[2] Andrew Baumann, Marcus Peinado, and Galen Hunt. 2014. Shielding applications from an untrusted cloud with Haven. In Proceedings of the 11th USENIX conference on Operating Systems Design and Implementation. USENIX Association, 267–283.

[3] Andrea Biondo, Mauro Conti, Lucas Davi, Tommaso Frassetto, and Ahmad-Reza Sadeghi. 2018. The Guard’s Dilemma: Efficient Code-Reuse Attacks Against Intel SGX. In Proceedings of the 27th USENIX Security Symposium. 1213–1227.

[4] S. Checkoway and H. Shacham. 2013. Iago Attacks: Why the System Call API is a Bad Untrusted RPC Interface. In International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS). 253–264.

[5] Guoxing Chen, Sanchuan Chen, Yuan Xiao, Yinqian Zhang, Zhiqiang Lin, and Ten H Lai. 2019. SgxPectre: Stealing Intel Secrets from SGX Enclaves Via Speculative Execution. In 2019 IEEE European Symposium on Security and Privacy (EuroS&P). IEEE, 142–157.

[6] Haogang Chen, Yandong Mao, Xi Wang, Dong Zhou, Nickolai Zeldovich, and M Frans Kaashoek. 2011. Linux kernel vulnerabilities: State-of-the-art defenses and open problems. In Proceedings of the Second Asia-Pacific Workshop on Systems. ACM, 5:1–5:5.

[7] J. Corbet. 2010. Structure holes and information leaks. online, accessed 2019-08-06: https://lwn.net/Articles/417989/. (December 2010).

[8] V. Costan and S. Devadas. 2016. Intel SGX Explained. IACR Cryptology ePrint Archive 2016, 086 (2016), 1–118.

[30] A. Moghimi, J. Wichelmann, T. Eisenbarth, and B. Sunar. 2019. Memjam: A false dependency attack against constant-time crypto implementations. International Journal of Parallel Programming 47, 4 (2019), 538–570.

[31] J. Noorman, J. Tobias Mühlberg, and F. Piessens. 2017. Authentic execution of distributed event-driven applications with a small TCB. In STM. 55–71.

[32] J. Noorman, J. Van Bulck, J. Tobias Mühlberg, F. Piessens, P. Maene, B. Preneel, I. Verbauwhede, J. Götzfried, T. Müller, and F. Freiling. 2017. Sancus 2.0: A low-cost security architecture for IoT devices. ACM Transactions on Privacy and Security (TOPS) 20, 3 (2017), 7:1–7:33.

[33] OP-TEE. 2019. Security Advisories. online, accessed 2019-08-29: https://www.op-tee.org/security-advisories. (2019).

[9] J. Edge. 2008. CVE-2008-1367 Kernel doesn’t clear DF for signal handlers. https://bugzilla.redhat.com/show_bug.cgi?id=437312. (March 2008).

[10] A. Fog. 2018. Calling conventions for different C++ compilers and operating systems. http://www.agner.org/optimize/calling_conventions.pdf. (April 2018).

[11] Fortanix. 2019. Fortanix Enclave Development Platform – Rust EDP. online, accessed 2019-08-30: https://edp.fortanix.com/. (2019).

[12] J. D. Golić and C. Tymen. 2003. Multiplicative Masking and Power Analysis of AES. In Cryptographic Hardware and Embedded Systems (CHES). 198–212.

[13] Google. 2019. Asylo: An open and flexible framework for enclave applications. online, accessed 2019-08-06: https://asylo.dev/. (2019).

[14] J. Götzfried, T. Müller, R. De Clercq, P. Maene, F. Freiling, and I. Verbauwhede. 2015. Soteria: Offline software protection within low-cost embedded devices. In Annual Computer Security Applications Conference (ACSAC). 241–250.

[15] Jago Gyselinck, Jo Van Bulck, Frank Piessens, and Raoul Strackx. 2018. Off-limits: Abusing legacy x86 memory segmentation to spy on enclaved execution. In International Symposium on Engineering Secure Software and Systems (ESSoS ’18). Springer, 44–60.

[16] N. Hardy. 1988. The Confused Deputy (or why capabilities might have been invented). ACM SIGOPS Operating Systems Review 22, 4 (1988), 36–38.

[17] Intel. 2016. Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3 (3A, 3B & 3C): System Programming Guide. 325384 (2016).

[18] Intel. 2018. Intel Software Guard Extensions (SGX) SW Development Guidance for Potential Edger8r Generated Code Side Channel Exploits. Revision 1.0.

[19] Intel. 2019. Intel Software Guard Extensions – Get Started with the SDK. online, accessed 2019-05-10: https://software.intel.com/en-us/sgx/sdk. (2019).

[20] E. Mohammadian Koruyeh, K. N Khasawneh, C. Song, and N. Abu-Ghazaleh. 2018. Spectre returns! speculation attacks using the return stack buffer. In USENIX Workshop on Offensive Technologies (WOOT).

[21] D. Lee, D. Kohlbrenner, S. Shinde, D. Song, and K. Asanović. 2019. Keystone: A Framework for Architecting TEEs. arXiv preprint arXiv:1907.10119 (2019).

[22] J. Lee, J. Jang, Y. Jang, N. Kwak, Y. Choi, C. Choi, T. Kim, M. Peinado, and B. Byunghoon Kang. 2017. Hacking in Darkness: Return-oriented Programming against Secure Enclaves. In Proceedings of the 26th USENIX Security Symposium. 523–539.

[23] S. Lee and T. Kim. 2017. Leaking Uninitialized Secure Enclave Memory via Structure Padding. arXiv preprint arXiv:1710.09061 (2017).

[24] Sangho Lee, Ming-Wei Shih, Prasun Gera, Taesoo Kim, Hyesoon Kim, and Marcus Peinado. 2017. Inferring Fine-grained Control Flow Inside SGX Enclaves with Branch Shadowing. In Proceedings of the 26th USENIX Security Symposium. 557–574.

[25] G. Lehel and N. Matsakis. 2017. rust-lang RFC: Integer overflows in Rust. online, accessed 2019-05-10: https://github.com/rust-lang/rfcs/blob/9ef0c35/text/0560-integer-overflow.md. (2017).

[26] M. Lipp, D. Gruss, R. Spreitzer, C. Maurice, and S. Mangard. 2016. Armageddon: Cache attacks on mobile devices. In Proceedings of the 25th USENIX Security Symposium. 549–564.

[27] A. Machiry, E. Gustafson, C. Spensky, C. Salls, N. Stephens, R. Wang, A. Bianchi, Y. Ryn Choe, C. Kruegel, and G. Vigna. 2017. BOOMERANG: Exploiting the Semantic Gap in Trusted Execution Environments. In NDSS 2017.

[28] Pieter Maene, Johannes Götzfried, Ruan De Clercq, Tilo Müller, Felix Freiling, and Ingrid Verbauwhede. 2017. Hardware-Based Trusted Computing Architectures for Isolation and Attestation. IEEE Trans. Comput. PP, 99 (2017).

[29] Microsoft. 2019. Open Enclave SDK. online, accessed 2019-05-10: https://openenclave.io/sdk/. (2019).

[34] S. Pinto and N. Santos. 2019. Demystifying Arm TrustZone: A Comprehensive Survey. ACM Computing Surveys (CSUR) 51, 6 (2019), 130.

[35] Christian Priebe, Divya Muthukumaran, Joshua Lind, Huanzhou Zhu, Shujie Cui, Vasily A Sartakov, and Peter Pietzuch. 2019. SGX-LKL: Securing the Host OS Interface for Trusted Execution. arXiv preprint arXiv:1908.11143 (2019).

[36] Graphene Project. 2019. Graphene: a Library OS for Unmodified Applications. online, accessed 2019-08-30: https://grapheneproject.io/. (2019).

[37] M. Schwarz, D. Gruss, M. Lipp, C. Maurice, T. Schuster, A. Fogh, and S. Mangard. 2018. Automated detection, exploitation, and elimination of double-fetch bugs using modern CPU features. In Asia CCS 2018. 587–600.

[38] M. Schwarz, Samuel Weiser, and Daniel Gruss. 2019. Practical enclave malware with Intel SGX. In DIMVA. 177–196.

[39] M. Schwarz, S. Weiser, D. Gruss, C. Maurice, and S. Mangard. 2017. Malware guard extension: using SGX to conceal cache attacks. In DIMVA. 3–24.

[40] J. Seo, B. Lee, S. Min Kim, M.W Shih, I. Shin, D. Han, and T. Kim. 2017. SGX-Shield: Enabling Address Space Layout Randomization for SGX Programs.. In NDSS 2017.

[41] H. Shacham et al. 2007. The geometry of innocent flesh on the bone: return-into-libc without function calls (on the x86).. In ACM CCS 2007. 552–561.

[42] S. Shinde, D. Le Tien, S. Tople, and P. Saxena. 2017. Panoply: Low-TCB Linux Applications With SGX Enclaves. In NDSS 2017.

[43] C.C Tsai, D. E Porter, and M. Vij. 2017. Graphene-SGX: A practical library OS for unmodified applications on SGX. In USENIX ATC.

[44] J. Van Bulck, M. Minkin, O. Weisse, D. Genkin, B. Kasikci, F. Piessens, M. Silberstein, T. F. Wenisch, Y. Yarom, and R. Strackx. 2018. Foreshadow: Extracting the keys to the Intel SGX kingdom with transient out-of-order execution. In Proceedings of the 27th USENIX Security Symposium.

[45] J. Van Bulck, F. Piessens, and R. Strackx. 2017. SGX-Step: A practical attack framework for precise enclave execution control. In SysTEX. 4:1–4:6.

[46] J. Van Bulck, F. Piessens, and R. Strackx. 2018. Nemesis: Studying microarchitectural timing Leaks in rudimentary CPU interrupt logic. In ACM CCS 2018.

[47] J. Van Bulck, N. Weichbrodt, R. Kapitza, F. Piessens, and R. Strackx. 2017. Telling your secrets without page faults: Stealthy page table-based attacks on enclaved execution. In Proceedings of the 26th USENIX Security Symposium. 1041–1056.

[48] N. van Ginkel, R. Strackx, T. Mühlberg, and F. Piessens. 2016. Towards safe enclaves. In Hot Issues in Security Principles and Trust (HotSpot). 1–16.

[49] N. van Ginkel, R. Strackx, and F. Piessens. 2017. Automatically generating secure wrappers for SGX enclaves from separation logic specifications. In Asian Symposium on Programming Languages and Systems. 105–123.

[50] N. Weichbrodt, A. Kurmus, P. Pietzuch, and R. Kapitza. 2016. AsyncShock: