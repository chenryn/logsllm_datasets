### References

1. **Oss-fuzz: Continuous Fuzzing for Open Source Software**
   - URL: <https://github.com/google/oss-fuzz>

2. **QSYM: A Practical Concolic Execution Engine Tailored for Hybrid Fuzzing**
   - URL: <https://github.com/sslab-gatech/qsym>

3. **Tcpdump Test Cases**
   - URL: <https://github.com/the-tcpdump-group/tcpdump/tree/master/tests>

4. **Cristian Cadar, Daniel Dunbar, and Dawson Engler. KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs**
   - In *Proceedings of the 8th USENIX Conference on Operating Systems Design and Implementation*, pages 209–224. USENIX Association, 2008.

5. **Peng Chen and Hao Chen. Angora: Efficient Fuzzing by Principled Search**
   - In *2018 IEEE Symposium on Security and Privacy (SP)*, pages 711–725. IEEE, 2018.

6. **Y. Chen, P. Li, J. Xu, S. Guo, R. Zhou, Y. Zhang, T. Wei, and L. Lu. SAVIOR: Towards Bug-Driven Hybrid Testing**
   - In *2020 IEEE Symposium on Security and Privacy (SP)*, pages 2–2, Los Alamitos, CA, USA, May 2020. IEEE Computer Society.

7. **Y. Dang, R. Wu, H. Zhang, D. Zhang, and P. Nobel. Rebucket: A Method for Clustering Duplicate Crash Reports Based on Call Stack Similarity**
   - In *2012 34th International Conference on Software Engineering (ICSE)*, pages 1084–1093, June 2012.

8. **Brendan Dolan-Gavitt, Patrick Hulin, Engin Kirda, Tim Leek, Andrea Mambretti, Wil Robertson, Frederick Ulrich, and Ryan Whelan. LAVA: Large-Scale Automated Vulnerability Addition**
   - In *Proceedings of the 2016 IEEE Symposium on Security and Privacy (SP)*, pages 110–121. IEEE, 2016.

9. **Manuel Fernández-Delgado, Eva Cernadas, Senén Barro, and Dinani Amorim. Do We Need Hundreds of Classifiers to Solve Real World Classification Problems?**
   - *J. Mach. Learn. Res.*, 15(1):3133–3181, January 2014.

10. **Patrice Godefroid, Michael Y Levin, David A Molnar, et al. Automated Whitebox Fuzz Testing**
    - In *NDSS*, volume 8, pages 151–166, 2008.

11. **Patrice Godefroid, Hila Peleg, and Rishabh Singh. Learn&Fuzz: Machine Learning for Input Fuzzing**
    - In *Proceedings of the 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE 2017)*, pages 50–59, Piscataway, NJ, USA, 2017. IEEE Press.

12. **Alon Halevy, Peter Norvig, and Fernando Pereira. The Unreasonable Effectiveness of Data**
    - *IEEE Intelligent Systems*, 24(2):8–12, March 2009.

13. **George Klees, Andrew Ruef, Benji Cooper, Shiyi Wei, and Michael Hicks. Evaluating Fuzz Testing**
    - In *Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security*, pages 2123–2138. ACM, 2018.

14. **lcamtuf. American Fuzzy Lop**
    - URL: <http://lcamtuf.coredump.cx/afl/>, 2015.

15. **Caroline Lemieux and Koushik Sen. FairFuzz: Targeting Rare Branches to Rapidly Increase Greybox Fuzz Testing Coverage**
    - *CoRR*, abs/1709.07101, 2017.

16. **Zhen Li, Deqing Zou, Shouhuai Xu, Xinyu Ou, Hai Jin, Sujuan Wang, Zhijun Deng, and Yuyi Zhong. VulDeePecker: A Deep Learning-Based System for Vulnerability Detection**
    - In *Network and Distributed System Security Symposium (NDSS)*, 2018.

17. **Mehryar Mohri, Afshin Rostamizadeh, and Ameet Talwalkar. Foundations of Machine Learning**
    - The MIT Press, 2012.

18. **M. Nayrolles and A. Hamou-Lhadj. CLEVER: Combining Code Metrics with Clone Detection for Just-in-Time Fault Prevention and Resolution in Large Industrial Projects**
    - In *2018 IEEE/ACM 15th International Conference on Mining Software Repositories (MSR)*, pages 153–164, May 2018.

19. **S. J. Pan and Q. Yang. A Survey on Transfer Learning**
    - *IEEE Transactions on Knowledge and Data Engineering*, 22(10):1345–1359, October 2010.

20. **Hui Peng, Yan Shoshitaishvili, and Mathias Payer. T-Fuzz: Fuzzing by Program Transformation**
    - In *2018 IEEE Symposium on Security and Privacy (SP)*, pages 697–710. IEEE, 2018.

21. **Mohit Rajpal, William Blum, and Rishabh Singh. Not All Bytes Are Equal: Neural Byte Sieve for Fuzzing**
    - *CoRR*, abs/1711.04596, 2017.

22. **Sanjay Rawat, Vivek Jain, Ashish Kumar, Lucian Cojocar, Cristiano Giuffrida, and Herbert Bos. VUZZER: Application-Aware Evolutionary Fuzzing**
    - In *Proceedings of the Network and Distributed System Security Symposium (NDSS)*, 2017.

23. **Gary J. Saavedra, Kathryn N. Rodhouse, Daniel M. Dunlavy, and Philip W. Kegelmeyer. A Review of Machine Learning Applications in Fuzzing**
    - *arXiv preprint arXiv:1906.11133*, 2019.

24. **Adam Santoro, David Raposo, David G. T. Barrett, Mateusz Malinowski, Razvan Pascanu, Peter W. Battaglia, and Timothy P. Lillicrap. A Simple Neural Network Module for Relational Reasoning**
    - *CoRR*, abs/1706.01427, 2017.

25. **Edward J. Schwartz, Thanassis Avgerinos, and David Brumley. All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution (But Might Have Been Afraid to Ask)**
    - In *2010 IEEE Symposium on Security and Privacy*, pages 317–331. IEEE, 2010.

26. **Konstantin Serebryany, Derek Bruening, Alexander Potapenko, and Dmitry Vyukov. AddressSanitizer: A Fast Address Sanity Checker**
    - In *Proceedings of the 2012 USENIX Conference on Annual Technical Conference*, pages 28–28. USENIX Association, 2012.

27. **Shai Shalev-Shwartz and Shai Ben-David. Understanding Machine Learning: From Theory to Algorithms**
    - Cambridge University Press, 2014.

28. **Dongdong She, Kexin Pei, Dave Epstein, Junfeng Yang, Baishakhi Ray, and Suman Jana. NEUZZ: Efficient Fuzzing with Neural Program Smoothing**
    - In *NEUZZ: Efficient Fuzzing with Neural Program Smoothing*. IEEE, 2018.

29. **Evgeniy Stepanov and Konstantin Serebryany. MemorySanitizer: Fast Detector of Uninitialized Memory Use in C++**
    - In *Proceedings of the 13th Annual IEEE/ACM International Symposium on Code Generation and Optimization*, pages 46–55. IEEE, 2015.

30. **Nick Stephens, John Grosen, Christopher Salls, Andrew Dutcher, Ruoyu Wang, Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vigna. Driller: Augmenting Fuzzing Through Selective Symbolic Execution**
    - In *Proceedings of the Network and Distributed System Security Symposium (NDSS)*, 2016. USENIX Association.

31. **Yulei Sui and Jingling Xue. SVF: Interprocedural Static Value-Flow Analysis in LLVM**
    - In *Proceedings of the 25th International Conference on Compiler Construction*, pages 265–266. ACM, 2016.

32. **Maverick Woo, Sang Kil Cha, Samantha Gottlieb, and David Brumley. Scheduling Black-Box Mutational Fuzzing**
    - In *Proceedings of the 2013 ACM SIGSAC Conference on Computer & Communications Security*, pages 511–522. ACM, 2013.

33. **G. Yan, J. Lu, Z. Shu, and Y. Kucuk. ExploitMeter: Combining Fuzzing with Machine Learning for Automated Evaluation of Software Exploitability**
    - In *2017 IEEE Symposium on Privacy-Aware Computing (PAC)*, pages 164–175, August 2017.

34. **Wei You, Xueqiang Wang, Shiqing Ma, Jianjun Huang, Xiangyu Zhang, XiaoFeng Wang, and Bin Liang. ProFuzzer: On-the-Fly Input Type Probing for Better Zero-Day Vulnerability Discovery**
    - In *ProFuzzer: On-the-Fly Input Type Probing for Better Zero-Day Vulnerability Discovery*. IEEE.

35. **Insu Yun, Sangho Lee, Meng Xu, Yeongjin Jang, and Taesoo Kim. QSYM: A Practical Concolic Execution Engine Tailored for Hybrid Fuzzing**
    - In *Proceedings of the 27th USENIX Conference on Security Symposium*, pages 745–761. USENIX Association, 2018.

36. **Lei Zhao, Yue Duan, Heng Yin, and Jifeng Xuan. Send Hardest Problems My Way: Probabilistic Path Prioritization for Hybrid Fuzzing**
    - In *Proceedings of the Network and Distributed System Security Symposium (NDSS)*, 2019.

### Appendix A: Why Use UBSAN

Note that although the design of MEUZZ is generically compatible with mainstream sanitizers [15, 45, 48], our implementation uses UBSan for the following reasons:
1. **Pure Static Checks**: UBSan instruments programs with pure static checks that can be easily converted to solvable SMT constraints. In contrast, other sanitizers, such as ASAN and MSAN, employ red-zones and status bitmaps, which are less amenable to constraint solving.
2. **Concolic Execution**: Our concolic engine is based on SAVIOR’s KLEE, which uses UBSan as the primary sanitizer. Using UBSan makes concolic execution more effective, as shown in [25].

### Appendix B: Bugs Found by MEUZZ

We provide a more detailed triage information of the bugs found by MEUZZ. In total, MEUZZ found 30 undefined behaviors, among which 21 have been confirmed/fixed so far by the developers, and the rest are pending. For the reported bugs, we found the potential UBs with UBSAN [15] and manual analysis; we found the memory errors and DoS with ASAN [45] and memory leaks with LeakSAN [7].

| Program | Potential UB | ME | DoS | ML | Confirmed |
|---------|--------------|----|-----|----|-----------|
| tcpdump | 14           | 1  | 2   | 4  | 7         |
| objdump | 4            | 4  | 1   | 2  | 6         |
| readelf | 2            | 5  | 1   | 2  | 5         |
| tiff2pdf| 1            | 4  | 1   | 2  | 4         |
| tiff2ps | 9            | 7  | 1   | 2  | 6         |
| jasper  | 3            | 6  | 1   | 2  | 6         |
| djpeg   | 30           | 21 | 7   | 6  | 21        |

**Table 4:** The table shows the discovered bugs by MEUZZ. UB, ME, DoS, and ML refer to Undefined Behavior, Memory Error, Denial of Service, and Memory Leak, respectively.

**Figure 9: Off-by-One Heap Read Overflow in tiff2ps**

One of the heap overflow vulnerabilities in tiff2ps is discovered only by MEUZZ. Figure 9 shows the vulnerable code snippet. This bug has been confirmed and fixed by the developers. It is an out-of-bound read vulnerability that can lead to information disclosure. The vulnerability takes place at `PSDataColorContig` function where the `cp` buffer with the size of 4 bytes is allocated in the heap, and the 5th element of the buffer is accessed by `cp[4]`, leading to an out-of-bound read. To trigger this bug, the loop needs to be executed without early breaks. Moreover, to control the buffer size, the input needs to satisfy many constraints in the `TIFFScanlineSize` function so that it will return a value of 4. Based on the feature importance of tiff2ps (Appendix D), Size, Cmp, and External Call play more important roles in its model, which is why MEUZZ is able to guide the fuzzer to explore and trigger this bug. On the contrary, by replaying the fuzzing corpora, we found that other fuzzers miss this bug because they either exit the loop early or fail the checks in `TIFFScanlineSize`.

### Appendix C: Discussion on Extra Experiments

We attempted to compare MEUZZ with many state-of-the-art fuzzing systems but could not conduct an apple-to-apple comparison with some of them due to various reasons:
- **Driller**: Uses [3] as its concolic engine, which has limited support for system calls, causing the engine's failure to generate new test cases. Similar issues were also reported by Insu et al. [54].
- **Vuzzer and T-Fuzz**: Do not have support for concurrent fuzzing. After discussing with the developers, we assigned only one core to them and ran them for 72 hours (3×24) instead of 24 hours. We report the branch coverage results of Vuzzer and T-Fuzz in Table 5.

**Table 5: Number of Branches Covered by Vuzzer and T-Fuzz**

| Program  | Vuzzer  | T-Fuzz  |
|----------|---------|---------|
| tcpdump  | 1103    | 1317    |
| objdump  | 711     | 11566   |
| readelf  | 1025    | 4216    |
| libxml2  | 715     | 842     |
| tiff2pdf | ✗       | ✗       |
| tiff2ps  | ✗       | 4892    |
| jasper   | ✗       | 3534    |
| djpeg    | 6084    | 763     |

**✗** means the fuzzer crashed on the program.

### Appendix D: Detailed Feature Importance Study

**Figure 10: Feature Importance Extracted from Models Learned in the Effectiveness Test (§ 6.2)**

The initial importances are randomly generated. Sz: Size, RdL: Reached Label, EC: External Call, IC: Indirect Call, NC: New Coverage, PL: Path Length, UN: Undiscovered Neighbors, RbL: Reachable Labels, Cmp: Comparisons.

- **(a) Feature Importance in tcpdump**
- **(b) Feature Importance in objdump**
- **(c) Feature Importance in libxml**
- **(d) Feature Importance in tiff2pdf**
- **(e) Feature Importance in tiff2ps**
- **(f) Feature Importance in jasper**
- **(g) Feature Importance in readelf**
- **(h) Feature Importance in djpeg**

**Figure 10** demonstrates how the randomly initialized model evolved with more and more training data available during fuzzing. MEUZZ automatically identified which features are more important for each specific program, showing it is more scalable than manually-written heuristics.