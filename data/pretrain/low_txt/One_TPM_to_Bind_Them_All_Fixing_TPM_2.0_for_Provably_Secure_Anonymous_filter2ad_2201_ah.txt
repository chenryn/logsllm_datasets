### References

[1] Springer Berlin Heidelberg, 2010, pp. 181–195.

[2] Trusted Computing Group, “Trusted Platform Module Library Specification, Family ‘2.0’,” 2014.

[3] L. Chen and J. Li, “Flexible and Scalable Digital Signatures in TPM 2.0,” in ACM CCS. ACM, 2013, pp. 37–48.

[4] C. Schnorr, “Efficient Signature Generation by Smart Cards,” Journal of Cryptology, vol. 4, no. 3, pp. 161–174, 1991.

[5] C. Paquin and G. Zaverucha, “U-Prove Cryptographic Specification (Revision 3),” December 2013. Available: https://www.microsoft.com/en-us/research/publication/u-prove-cryptographic-specification-v1-1-revision-3/

[6] L. Xi, K. Yang, Z. Zhang, and D. Feng, “DAA-Related APIs in TPM 2.0 Revisited,” in Trust and Trustworthy Computing: TRUST 2014, Springer International Publishing, 2014, pp. 1–18.

[7] J. Camenisch, M. Drijvers, and A. Lehmann, “Universally Composable Direct Anonymous Attestation,” in Public-Key Cryptography - PKC 2016, Springer Berlin Heidelberg, 2016, pp. 234–264.

[8] J. Camenisch, M. Drijvers, and A. Lehmann, “Anonymous Attestation Using the Strong Diffie-Hellman Assumption Revisited,” in Trust and Trustworthy Computing: TRUST 2016, Springer International Publishing, 2016, pp. 1–20.

[9] J. Camenisch, S. Hohenberger, and A. Lysyanskaya, “Compact E-Cash,” in Advances in Cryptology – EUROCRYPT 2005, Springer Berlin Heidelberg, 2005, pp. 302–321.

[10] S. D. Galbraith, K. G. Paterson, and N. P. Smart, “Pairings for Cryptographers,” Discrete Applied Mathematics, vol. 156, no. 16, pp. 3113–3121, 2008, applications of Algebra to Cryptography.

[11] P. S. L. M. Barreto and M. Naehrig, “Pairing-Friendly Elliptic Curves of Prime Order,” in SAC 2005, Springer Berlin Heidelberg, 2006, pp. 319–331.

[12] D. Boneh and X. Boyen, “Short Signatures Without Random Oracles and the SDH Assumption in Bilinear Groups,” Journal of Cryptology, vol. 21, no. 2, pp. 149–177, 2007.

[13] A. Lysyanskaya, R. Rivest, A. Sahai, and S. Wolf, “Pseudonym Systems,” in SAC 2000, Lecture Notes in Computer Science, Springer Berlin Heidelberg, 2000, vol. 1758, pp. 184–199.

[14] V. Shoup, “Lower Bounds for Discrete Logarithms and Related Problems,” in Advances in Cryptology – EUROCRYPT ’97, Springer Berlin Heidelberg, 1997, pp. 256–266.

[15] J. Camenisch and A. Lysyanskaya, “Signature Schemes and Anonymous Credentials from Bilinear Maps,” in Advances in Cryptology - CRYPTO 2004, Springer Berlin Heidelberg, 2004, vol. 3152, pp. 56–72.

[16] M. H. Au, W. Susilo, and Y. Mu, “Constant-Size Dynamic k-TAA,” in Security and Cryptography for Networks: 5th International Conference, SCN 2006, Springer Berlin Heidelberg, 2006, pp. 111–125.

[17] J. Camenisch and M. Stadler, “Efficient Group Signature Schemes for Large Groups,” in Advances in Cryptology - CRYPTO ’97, Springer Berlin Heidelberg, 1997, vol. 1294, pp. 410–424.

[18] J. Camenisch, A. Kiayias, and M. Yung, “On the Portability of Generalized Schnorr Proofs,” in Advances in Cryptology - EUROCRYPT 2009, Springer Berlin Heidelberg, 2009, vol. 5479, pp. 425–442.

[19] A. Fiat and A. Shamir, “How to Prove Yourself: Practical Solutions to Identification and Signature Problems,” in Advances in Cryptology - CRYPTO ’86, Springer Berlin Heidelberg, 1987, vol. 263, pp. 186–194.

[20] M. Bellare and P. Rogaway, “Random Oracles are Practical: A Paradigm for Designing Efficient Protocols,” in ACM CCS, ACM, 1993, pp. 62–73.

[21] L. Chen, D. Page, and N. Smart, “On the Design and Implementation of an Efficient DAA Scheme,” in Smart Card Research and Advanced Application, Springer Berlin Heidelberg, 2010, vol. 6035, pp. 223–237.

[22] J. Camenisch, M. Drijvers, and A. Lehmann, “Anonymous Attestation with Subverted TPMs,” Cryptology ePrint Archive, Report 2017/200, 2017. Available: http://eprint.iacr.org/2017/200

[23] T. Acar, L. Nguyen, and G. Zaverucha, “A TPM Diffie-Hellman Oracle,” Cryptology ePrint Archive, Report 2013/667, 2013. Available: http://eprint.iacr.org/2013/667

[24] D. R. L. Brown and R. P. Gallant, “The Static Diffie-Hellman Problem,” Cryptology ePrint Archive, Report 2004/306, 2004. Available: http://eprint.iacr.org/2004/306

[25] J. H. Cheon, “Security Analysis of the Strong Diffie-Hellman Problem,” in Advances in Cryptology - EUROCRYPT 2006, 2006, pp. 1–11.

[26] E. Brickell and J. Li, “Enhanced Privacy ID from Bilinear Pairing for Hardware Authentication and Attestation,” International Journal of Information Privacy, Security and Integrity, vol. 1, no. 1, pp. 3–33, 2011.

[27] E. Brickell and J. Li, “Enhanced Privacy ID: A Direct Anonymous Attestation Scheme with Enhanced Revocation Capabilities,” in Proceedings of the 2007 ACM Workshop on Privacy in Electronic Society, New York, NY, USA: ACM, 2007, pp. 21–30.

[28] R. Canetti, “Universally Composable Security: A New Paradigm for Cryptographic Protocols,” Cryptology ePrint Archive, Report 2000/067, 2000. Available: http://eprint.iacr.org/2000/067

[29] International Organization for Standardization, “ISO/IEC 20008-2: Information Technology - Security Techniques - Anonymous Digital Signatures - Part 2: Mechanisms Using a Group Public Key,” 2013.

[30] L. Chen and R. Urian, “DAA-A: Direct Anonymous Attestation with Attributes,” in Trust and Trustworthy Computing: TRUST 2015, Springer International Publishing, 2015, pp. 228–245.

[31] D. Bernhard, G. Fuchsbauer, E. Ghadafi, N. Smart, and B. Warinschi, “Anonymous Attestation with User-Controlled Linkability,” International Journal of Information Security, vol. 12, no. 3, pp. 219–249, 2013.

[32] J. Camenisch, M. Drijvers, A. Edgington, A. Lehmann, R. Lindemann, and R. Urian, “FIDO ECDAA Algorithm, Implementation Draft,” February 2017. Available: https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-ecdaa-algorithm-v1.1-id-20170202.html

---

### Appendix A: Formal Security Model

This section introduces our formal security model for Direct Anonymous Attestation (DAA), based on the definitions by Camenisch et al. [7], [8], [22]. We also compare the captured privacy guarantees in the presence of subverted TPMs with existing privacy notions and optimal privacy [22].

#### A1 Universal Composability

Our security definition is formulated as an ideal functionality \( F_{\text{pdaa+}} \) within the Universal Composability (UC) framework [28]. In UC, an environment \( E \) provides inputs to the protocol parties and receives their outputs. In the real world, honest parties execute the protocol over a network controlled by an adversary \( A \), who can also communicate freely with the environment \( E \). In the ideal world, honest parties forward their inputs to the ideal functionality \( F \). The ideal functionality internally performs the defined task and generates outputs for the honest parties. Since \( F \) performs the task ideally, it is secure by construction.

Informally, a protocol \( \Pi \) is said to securely realize an ideal functionality \( F \) if the real world is as secure as the ideal world. To prove this, one must show that for every adversary \( A \) attacking the real world, there exists an ideal world attacker or simulator \( S \) that performs an equivalent attack on the ideal world. More precisely, \( \Pi \) securely realizes \( F \) if for every adversary \( A \), there exists a simulator \( S \) such that no environment \( E \) can distinguish the real world (with \( \Pi \) and \( A \)) from the ideal world (with \( F \) and \( S \)).

#### A2 Session Identifiers and Input/Output

In the UC model, different instances of the protocol are distinguished using session identifiers. Here, we use session identifiers of the form \( \text{sid} = (I, \text{sid}^\ast) \) for some issuer \( I \) and a unique string \( \text{sid}^\ast \). To allow multiple sub-sessions for the join and sign related interfaces, we use unique sub-session identifiers \( \text{jsid} \) and \( \text{ssid} \).

Each party can provide different inputs to the protocol, distinguished by adding different labels to these inputs. For example, the host can provide an input labeled with JOIN to request to join, and an input labeled with SIGN to start signing a message. Outputs are labeled similarly.

#### A3 Ideal Functionality \( F_{\text{pdaa+}} \)

This section formally introduces our ideal DAA functionality \( F_{\text{pdaa+}} \), which defines DAA with attributes, signature-based revocation, and strong privacy. It is based on \( F_{\text{pdaa}} \) and \( F_{\text{l-daa+}} \) by Camenisch et al. [8], [22]. We now give an informal overview of the interfaces of \( F_{\text{pdaa+}} \), and present the full definition in Figure 5.

**Setup.** The SETUP interface on input \( \text{sid} = (I, \text{sid}^\ast) \) initiates a new session for the issuer \( I \) and expects the adversary to provide algorithms \( (\text{ukgen}, \text{sig}, \text{ver}, \text{link}, \text{identify}) \) that will be used inside the functionality. ukgen creates a new key \( \text{gsk} \) and a tracing trapdoor \( \tau \) that allows \( F_{\text{pdaa+}} \) to trace signatures generated with \( \text{gsk} \). sig, ver, and link are used by \( F_{\text{pdaa+}} \) to create, verify, and link signatures, respectively. Finally, identify allows verifying whether a signature belongs to a certain tracing trapdoor. This enables \( F_{\text{pdaa+}} \) to perform multiple consistency checks and enforce the desired non-frameability and unforgeability properties.

Note that the ver and link algorithms assist the functionality only for signatures not generated by \( F_{\text{pdaa+}} \) itself. For signatures generated by the functionality, \( F_{\text{pdaa+}} \) enforces correct verification and linkage using its internal records. While ukgen and sig are probabilistic algorithms, the others are required to be deterministic. The link algorithm must also be symmetric, i.e., for all inputs, it must hold that \( \text{link}(\sigma, m, \sigma^\ast) = \text{link}(\sigma^\ast, m, \sigma) \).

**Join.** A host \( H_j \) can request to join with a TPM \( M_i \) using the JOIN interface. The issuer is asked to approve the join request and choose the platform’s attributes. \( F_{\text{pdaa+}} \) is parameterized by \( L \) and \( \{A_i\}_{0 < i \leq L} \), offering support for attributes. \( L \) is the number of attributes each credential contains, and \( A_i \) is the set from which the \( i \)-th attribute is taken. When the issuer approves with attributes \( \text{attrs} \in A_1 \times \ldots \times A_L \), the functionality stores an internal membership record for \( M_i, H_j, \text{attrs} \) in Members, indicating that the platform is now allowed to create attestations.

If the host is corrupt, the adversary must provide \( F_{\text{pdaa+}} \) with a tracing trapdoor \( \tau \). This value is stored in the membership record and allows the functionality to check via the identify function whether signatures were created by this platform. \( F_{\text{pdaa+}} \) uses these checks to ensure non-frameability and unforgeability whenever it creates or verifies signatures. To ensure that the adversary cannot provide bad trapdoors that would break the completeness or non-frameability properties, \( F_{\text{pdaa+}} \) checks the legitimacy of \( \tau \) via the "macro" function CheckTtdCorrupt. This function checks that for all previously generated or verified signatures for which \( F_{\text{pdaa+}} \) has already seen another matching tracing trapdoor \( \tau^\ast \neq \tau \), the new trapdoor \( \tau \) is not identified as a matching key as well. CheckTtdCorrupt is defined as follows:

\[ \text{CheckTtdCorrupt}(\tau) = \neg \exists (\sigma, m, \text{bsn}) : \text{identify}(\sigma, m, \text{bsn}, \tau) = \text{identify}(\sigma, m, \text{bsn}, \tau^\ast) = 1 \]

**Sign.** After joining, a host \( H_j \) can use the SIGN interface to request a signature on a message \( m \) with respect to basename \( \text{bsn} \) while proving a certain predicate \( p \) holds for his attributes and proving that he is not revoked by the signature revocation list (SRL). The signature will only be created when the TPM \( M_i \) explicitly agrees to signing \( m \), a join record for \( M_i, H_j, \text{attrs} \) in Members exists such that \( \text{attrs} \) satisfy \( p \) (if the issuer is honest), and the platform is not revoked by SRL.

When a platform wants to sign a message \( m \) w.r.t. a fresh basename \( \text{bsn} \), \( F_{\text{pdaa+}} \) generates a new key \( \text{gsk} \) (and tracing trapdoor \( \tau \)) via ukgen and then signs \( m \) with that key. The functionality also stores the fresh key \( (\text{gsk}, \tau) \) together with \( \text{bsn} \) in DomainKeys, and reuses the same key when the platform wishes to sign repeatedly under the same basename. Using fresh keys for every signature naturally enforces the desired privacy guarantees: the signature algorithm does not receive any identifying information as input, and thus the created signatures are guaranteed to be anonymous (or pseudonymous in case \( \text{bsn} \) is reused).

To further guarantee non-frameability and completeness, \( F_{\text{pdaa+}} \) ensures that every freshly generated key, tracing trapdoor, and signature does not falsely match with any existing signature or key. More precisely, \( F_{\text{pdaa+}} \) first uses the CheckTtdHonest macro to verify whether the new key does not match any existing signature. CheckTtdHonest is defined as follows:

\[ \text{CheckTtdHonest}(\tau) = \forall (\sigma, m, \text{bsn}, M, H) \in \text{Signed} : \text{identify}(\sigma, m, \text{bsn}, \tau) = 0 \land \forall (\sigma, m, \text{bsn}, \ast, 1) \in \text{VerResults} : \text{identify}(\sigma, m, \text{bsn}, \tau) = 0 \]

Likewise, before outputting \( \sigma \), the functionality checks that no one else already has a key that would match this newly generated signature.

Finally, for ensuring unforgeability, the signed message, basename, attribute predicate, signature revocation list, and platform identity are stored in Signed, which will be used when verifying signatures.

**Verify.** Signatures can be verified by any party using the VERIFY interface. \( F_{\text{pdaa+}} \) uses its internal Signed, Members, and DomainKeys records to enforce unforgeability and non-frameability. It uses the tracing trapdoors \( \tau \) stored in Members and DomainKeys to find out which platform created the signature. If no match is found and the issuer is honest, the signature is a forgery and rejected by \( F_{\text{pdaa+}} \). If the signature to be verified matches the tracing trapdoor of some platform with an honest host, but the signing records do not show that they signed this message w.r.t. the basename, attribute predicate, and signature revocation list, \( F_{\text{pdaa+}} \) again considers this to be a forgery and rejects. If the platform has an honest TPM, only checks on the message and basename are made. If the records do not reveal any issues with the signature, \( F_{\text{pdaa+}} \) uses the ver algorithm to obtain the final result.

The verify interface also supports verifier-local revocation. The verifier can input a revocation list RL containing tracing trapdoors, and signatures matching any of those trapdoors are no longer accepted.

**Link.** Using the LINK interface, any party can check whether two signatures \( (\sigma, \sigma^\ast) \) on messages \( (m, m^\ast) \) generated with the same basename \( \text{bsn} \) originate from the same platform or not. \( F_{\text{pdaa+}} \) again uses the tracing trapdoors \( \tau \) stored in Members and DomainKeys to check which platforms created the two signatures. If they are the same, \( F_{\text{pdaa+}} \) outputs that they are linked. If it finds a platform that signed one, but not the other, it outputs that they are unlinked, which prevents framing of platforms with an honest host.

**Conventions.** The full definition of \( F_{\text{pdaa+}} \) is presented in Figure 5. We use several conventions to simplify the definition of \( F_{\text{pdaa+}} \). First, we require that \( \text{identify}(\sigma, m, \text{bsn}, \tau) = 0 \) if \( \sigma \) or \( \tau \) is \( \bot \). Second, whenever we need approval from the adversary to proceed, \( F_{\text{pdaa+}} \) sends an output to the adversary and waits for a response. This means that in that join or sign session, no other inputs are accepted except the expected response from the adversary. Third, if any check that \( F_{\text{pdaa+}} \) makes fails, the sub-session is invalidated, and \( \bot \) is output to the caller.

#### A4 Comparison of \( F_{\text{pdaa+}} \) with Previous Definitions

Our functionality \( F_{\text{pdaa+}} \) is based on previous UC-based DAA functionalities \( F_{\text{l-daa+}} \) [8], which extends \( F_{\text{l-daa}} \) with attributes and signature-based revocation, and \( F_{\text{pdaa}} \) [22], which strengthens the privacy guarantees of \( F_{\text{l-daa}} \). We now show how our functionality compares to these other DAA functionalities.

**Attributes and Signature-Based Revocation.** Our functionality \( F_{\text{pdaa+}} \) supports adding attributes to the membership credentials and includes signature-based revocation, extending the capabilities of \( F_{\text{l-daa+}} \) and \( F_{\text{pdaa}} \).

**Privacy Guarantees.** \( F_{\text{pdaa+}} \) provides stronger privacy guarantees compared to \( F_{\text{l-daa+}} \) and \( F_{\text{pdaa}} \) by ensuring that even in the presence of subverted TPMs, the privacy of honest users is maintained. This is achieved through the use of fresh keys for each signature and additional checks to prevent framing and forgery.