### References

1. Ben Gras, Kaveh Razavi, Herbert Bos, and Cristiano Giuffrida. 2018. Translation Leak-aside Buffer: Defeating Cache Side-channel Protections with TLB Attacks. In *USENIX Security*.
2. [ASLR on the Line: Practical Cache Attacks on the MMU]. In *NDSS*.
3. Spyridoula Gravani, Mohammad Hedayati, John Criswell, and Michael L. Scott. 2019. IskiOS: Lightweight Defense Against Kernel-level Code-reuse Attacks. *arXiv* preprint arXiv:1903.04654 (2019).
4. Daniel Gruss, Clémentine Maurice, Anders Fogh, Moritz Lipp, and Stefan Mangard. 2016. Prefetch Side-channel Attacks: Bypassing SMAP and Kernel ASLR. In *CCS*.
5. [Rowhammer.js: A Remote Software-induced Fault Attack in JavaScript]. In *DIMVA*.
6. Jann Horn. 2018. [Spectre Attacks: Exploiting Speculative Execution]. https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html
7. Ben Gras, Kaveh Razavi, Erik Bosman, Herbert Bos, and Cristiano Giuffrida. 2017. [Translation Leak-aside Buffer: Defeating Cache Side-channel Protections with TLB Attacks]. In *USENIX Security*.
8. Daniel Gruss, Clémentine Maurice, and Stefan Mangard. 2016. Rowhammer.js: A Remote Software-induced Fault Attack in JavaScript. In *DIMVA*.
9. Hong Hu, Shweta Shinde, Sendroiu Adrian, Zheng Leong Chua, Prateek Saxena, and Zhenkai Liang. 2016. Data-oriented Programming: On the Expressiveness of Non-control Data Attacks. In *IEEE S&P*.
10. Saad Islam, Ahmad Moghimi, Ida Bruhns, Moritz Krebbel, Berk Gulmezoglu, Thomas Eisenbarth, and Berk Sunar. 2019. {SPOILER}: Speculative Load Hazards Boost Rowhammer and Cache Attacks. In *USENIX Security*.
11. Yeongjin Jang, Sangho Lee, and Taesoo Kim. 2016. Breaking Kernel Address Space Layout Randomization with Intel TSX. In *CCS*.
12. Vasileios P. Kemerlis, Michalis Polychronakis, and Angelos D. Keromytis. 2014. [ret2dir: Rethinking Kernel Isolation]. In *USENIX Security*.
13. Vasileios P. Kemerlis, Georgios Portokalidis, and Angelos D. Keromytis. 2012. kGuard: Lightweight Kernel Protection Against Return-to-user Attacks. In *USENIX Security*.
14. Khaled N. Khasawneh, Esmaeil Mohammadian Koruyeh, Chengyu Song, Dmitry Evtyushkin, Dmitry Ponomarev, and Nael Abu-Ghazaleh. [n.d.]. SafeSpec: Banishing the Spectre of a Meltdown with Leakage-Free Speculation (DAC’19).
15. Paul Kocher, Jann Horn, Anders Fogh, Daniel Genkin, Daniel Gruss, Werner Haas, Mike Hamburg, Moritz Lipp, Stefan Mangard, Thomas Prescher, Michael Schwarz, and Yuval Yarom. 2019. Spectre Attacks: Exploiting Speculative Execution. In *IEEE S&P*.
16. Benjamin Kollenda, Enes Goktas, Tim Blazytko, Philipp Koppe, Robert Gawlik, Radhesh Krishnan Konoth, Cristiano Giuffrida, Herbert Bos, and Thorsten Holz. 2017. Towards Automated Discovery of Crash-Resistant Primitives in Binaries. In *DSN*.
17. Koen Koning, Xi Chen, Herbert Bos, Cristiano Giuffrida, and Elias Athanasopoulos. 2017. No Need to Hide: Protecting Safe Regions on Commodity Hardware. In *EuroSys*.
18. Vladimir Kiriansky and Carl Waldspurger. 2018. [Speculative Buffer Overflows: Attacks and Defenses]. *arXiv* preprint arXiv:1807.03757 (2018).
19. Andrey Konovalov. 2017. [Exploiting the Linux Kernel via Packet Sockets]. https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-via-packet.html
20. Hyungjoon Koo, Yaohui Chen, Long Lu, Vasileios P. Kemerlis, and Michalis Polychronakis. 2018. Compiler-assisted Code Randomization. In *IEEE S&P*.
21. Andrei Tatar, Radhesh Krishnan Konoth, Elias Athanasopoulos, Cristiano Giuffrida, Herbert Bos, and Kaveh Razavi. 2018. Throwhammer: Rowhammer Attacks over the Network and Defenses. In *USENIX ATC*.
22. Minh Tran, Mark Etheridge, Tyler Bletsch, Xuxian Jiang, Vincent Freeh, and Peng Ning. 2011. On the Expressiveness of Return-into-libc Attacks. In *Proceedings of the 14th International Conference on Recent Advances in Intrusion Detection (RAID)*.
23. Paul Turner. 2018. [Retpoline: A Software Construct for Preventing Branch-target-injection]. https://support.google.com/faqs/answer/7625886
24. Jo Van Bulck, Marina Minkin, Ofir Weisse, Daniel Genkin, Baris Kasikci, Frank Piessens, Mark Silberstein, Thomas F. Wenisch, Yuval Yarom, and Raoul Strackx. [n.d.]. Foreshadow: Extracting the Keys to the Intel SGX Kingdom with Transient Out-of-order Execution. In *SEC'18*.
25. Jo Van Bulck, Daniel Moghimi, Michael Schwarz, Moritz Lipp, Marina Minkin, Daniel Genkin, Yarom Yuval, Berk Sunar, Daniel Gruss, and Frank Piessens. 2020. LVI: Hijacking Transient Execution through Microarchitectural Load Value Injection. In *S&P'20*.
26. Victor van der Veen, Dennis Andriesse, Manolis Stamatogiannakis, Xi Chen, Herbert Bos, and Cristiano Giuffrida. 2017. The Dynamics of Innocent Flesh on the Bone: Code Reuse Ten Years Later. In *CCS*.
27. Victor van der Veen, Yanick Fratantonio, Martina Lindorfer, Daniel Gruss, Clémentine Maurice, Giovanni Vigna, Herbert Bos, Kaveh Razavi, and Cristiano Giuffrida. 2016. Drammer: Deterministic Rowhammer Attacks on Mobile Platforms. In *CCS*.
28. Stephan van Schaik, Cristiano Giuffrida, Herbert Bos, and Kaveh Razavi. 2018. Malicious Management Unit: Why Stopping Cache Attacks in Software is Harder Than You Think. In *USENIX Security*.
29. Stephan van Schaik, Alyssa Milburn, Sebastian Osterlund, Pietro Frigo, Giorgi Maisuradze, Kaveh Razavi, Herbert Bos, and Cristiano Giuffrida. 2019. RIDL: Rogue In-flight Data Load. In *S&P*.
30. Jan Werner, George Baltas, Rob Dallara, Nathan Otterness, Kevin Z. Snow, Fabian Monrose, and Michalis Polychronakis. 2016. No-execute-after-read: Preventing Code Disclosure in Commodity Software. In *ASIACCS*.
31. David Williams-King, Graham Gobieski, Kent Williams-King, James P. Blake, Xinhao Yuan, Patrick Colp, Michelle Zheng, Vasileios P. Kemerlis, Junfeng Yang, and William Aiello. 2016. Shuffler: Fast and Deployable Continuous Code Re-randomization. In *OSDI*.
32. Yuval Yarom and Katrina Falkner. 2014. FLUSH+RELOAD: A High Resolution, Low Noise, L3 Cache Side-Channel Attack. In *USENIX Security*.
33. Pepe Vila, Boris Köpf, and José Francisco Morales. 2019. Theory and Practice of Finding Eviction Sets. In *IEEE S&P*.
34. Jakob Koschel, Cristiano Giuffrida, Herbert Bos, and Kaveh Razavi. 2020. Tag-Bleed: Breaking KASLR on the Isolated Kernel Address Space Using Tagged TLB. In *EuroS&P*.
35. Donghyun Kwon, Jangseop Shin, Giyeol Kim, Byoungyoung Lee, Yeongpil Cho, and Yunheung Paek. 2019. uXOM: Efficient eXecute-Only Memory on ARM Cortex-M. In *USENIX Security*.
36. Moritz Lipp, Vedad Hadžić, Michael Schwarz, Arthur Perais, Clémentine Maurice, and Daniel Gruss. 2019. Take A Way: Exploring the Security Implications of AMD’s Cache Way Predictors. (2019).
37. Moritz Lipp, Michael Schwarz, Daniel Gruss, Thomas Prescher, Werner Haas, Anders Fogh, Jann Horn, Stefan Mangard, Paul Kocher, Daniel Genkin, Yuval Yarom, and Mike Hamburg. 2018. Meltdown: Reading Kernel Memory from User Space. In *USENIX Security*.
38. Hongjiu Lu, Michael Matz, Milind Girkar, Jan Hubiaka, Andreas Jaeger, and Mark Mitchell. 2018. System V Application Binary Interface AMD64 Architecture Processor Supplement (With LP64 and ILP32 Programming Models) Version 1.0. https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf
39. Kangjie Lu, Wenke Lee, Stefan Nürnberger, and Michael Backes. 2016. How to Make ASLR Win the Clone Wars: Runtime Re-Randomization. In *NDSS*.
40. Giorgi Maisuradze, Michael Backes, and Christian Rossow. 2016. What Cannot Be Read, Cannot Be Leveraged? Revisiting Assumptions of JIT-ROP Defenses. In *USENIX Security*.
41. Giorgi Maisuradze and Christian Rossow. 2018. Ret2Spec: Speculative Execution Using Return Stack Buffers. In *Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security*.
42. Giorgi Maisuradze and Christian Rossow. 2018. Speculose: Analyzing the Security Implications of Speculative Execution in CPUs. *arXiv* preprint arXiv:1801.04084 (2018).
43. Ahmad Moghimi, Thomas Eisenbarth, and Berk Sunar. 2018. MemJam: A False Dependency Attack Against Constant-Time Crypto Implementations in SGX. In *CT-RSA*.
44. Angelos Oikonomopoulos, Elias Athanasopoulos, Herbert Bos, and Cristiano Giuffrida. 2016. Poking Holes in Information Hiding. In *USENIX Security*.
45. Dag Arne Osvik, Adi Shamir, and Eran Tromer. 2006. Cache Attacks and Countermeasures: The Case of AES. In *CT-RSA*.
46. Soyeon Park, Sangho Lee, Wen Xu, Hyungon Moon, and Taesoo Kim. 2019. libmpk: Software Abstraction for Intel Memory Protection Keys (Intel MPK). In *USENIX ATC*.
47. Marios Pomonis, Theofilos Petsios, Angelos D. Keromytis, Michalis Polychronakis, and Vasileios P. Kemerlis. 2017. kR^X: Comprehensive Kernel Protection Against Just-in-time Code Reuse. In *EuroSys*.
48. Kaveh Razavi, Ben Gras, Erik Bosman, Bart Preneel, Cristiano Giuffrida, and Herbert Bos. 2016. Flip Feng Shui: Hammering a Needle in the Software Stack. In *USENIX Security*.
49. Robert Rudd, Richard Skowyra, David Bigelow, Veer Dedhia, Thomas Hobson, Stephen Crane, Christopher Liebchen, Per Larsen, Lucas Davi, Michael Franz, et al. 2017. Address Oblivious Code Reuse: On the Effectiveness of Leakage Resilient Diversity. In *NDSS*.
50. Felix Schuster, Thomas Tendyck, Christopher Liebchen, Lucas Davi, Ahmad-Reza Sadeghi, and Thorsten Holz. 2015. Counterfeit Object-oriented Programming: On the Difficulty of Preventing Code Reuse Attacks in C++ Applications. In *IEEE S&P*.
51. Michael Schwarz, Moritz Lipp, Daniel Moghimi, Jo Van Bulck, Julian Stecklina, Thomas Prescher, and Daniel Gruss. 2019. ZombieLoad: Cross-privilege-boundary Data Sampling. In *CCS*.
52. Mark Seaborn and Thomas Dullien. 2015. [Exploiting the DRAM Rowhammer Bug to Gain Kernel Privileges]. Black Hat (2015).
53. Fermin J. Serna. 2012. The Info Leak Era on Software Exploitation. Black Hat USA (2012).
54. Hovav Shacham. 2007. The Geometry of Innocent Flesh on the Bone: Return-into-libc Without Function Calls (on the x86). In *CCS*.
55. Hovav Shacham, Matthew Page, Ben Pfaff, Eu-Jin Goh, Nagendra Modadugu, and Dan Boneh. 2004. On the Effectiveness of Address-space Randomization. In *CCS*.
56. Kevin Z. Snow, Fabian Monrose, Lucas Davi, Alexandra Dmitrienko, Christopher Liebchen, and Ahmad-Reza Sadeghi. 2013. Just-in-time Code Reuse: On the Effectiveness of Fine-grained Address Space Layout Randomization. In *IEEE S&P*.
57. Kevin Z. Snow, Roman Rogowski, Jan Werner, Hyungjoon Koo, Fabian Monrose, and Michalis Polychronakis. 2016. Return to the Zombie Gadgets: Undermining Destructive Code Reads via Code Inference Attacks. In *IEEE S&P*.
58. Wei Song and Peng Liu. 2019. Dynamically Finding Minimal Eviction Sets Can Be Quicker Than You Think for Side-Channel Attacks against the LLC. In *RAID*.
59. Dean Sullivan, Orlando Arias, Travis Meade, and Yier Jin. 2018. Microarchitectural Minefields: 4K-Aliasing Covert Channel and Multi-Tenant Detection in IaaS Clouds. In *CCS*.
60. Andrei Tatar, Cristiano Giuffrida, Herbert Bos, and Kaveh Razavi. 2018. Defeating Software Mitigations Against Rowhammer: A Surgical Precision Hammer. In *USENIX Security*.
61. Adrian Tang, Simha Sethumadhavan, and Salvatore Stolfo. 2015. Heisenbyte: Thwarting Memory Disclosure Attacks Using Destructive Code Reads. In *CCS*.

### Appendix A - Impact of Repetitions

This appendix details the impact of repetitions on the success rate of individual probes used in our exploits. In our experiments, we arranged memory such that the probes were expected to give a signal. We report experimental results (Figures 3-7) on the setup detailed earlier, measured over 20 runs.

For the noise-sensitive prime+probe (p+p) method, a certain number of hits on the target page are required to assert with high certainty that a signal is present. This threshold is expressed as a percentage, indicating the minimum number of hits out of the total number of measurement repetitions. We calculated this threshold for each primitive using p+p by taking the minimum number of hits in 100 measurements over 20 runs and reducing this number by 10% to account for potential outliers. The calculated threshold was then used to determine whether a signal was obtained over the given number of measurement repetitions. For example, a success rate of 90% means that for the given number of repetitions per run, the number of hits exceeded the calculated threshold in 90% of the 20 runs.

For p+p-based probing, we selected the lowest number of repetitions with a 100% success rate (highlighted with a dot in Figures 3-6).

For the more noise-resistant flush+reload (f+r) method, a single hit at the expected cache line was sufficient to assert a signal (e.g., for gadget probing and Spectre probing in testing mode). This is because the verification step is sufficient to weed out false hits caused by the prefetcher—our Spectre gadget loads consecutive cache lines for consecutive f+r buffer offsets. For calibration, we picked the maximum of repetitions (8) required to produce the first hit across 20 runs (𝑁 = 1 in Figure 7).

When the specific cache line producing the signal is unknown (e.g., for Spectre probing in leaking mode), it is preferable to aim for more hits. We found that 2 hits were sufficient to avoid interference from the prefetcher in practice for our gadget. For calibration, we initially picked the maximum of repetitions (9) required to produce the first 2 hits across 20 runs (𝑁 = 2 in Figure 7). As an optimization, we lowered this value to 7 repetitions without reducing the (100%) success rate, as the redundancy offered by our gadget in leaking mode allowed us to efficiently detect and recover from occasionally erroneous leaked byte values.

**Figure 3:** Success rate vs. number of repetitions to sample the target cache signal with p+p for our code region probing primitive (calculated threshold: 78.3%).

**Figure 4:** Success rate vs. number of repetitions to sample the target cache signal with p+p and f+r for our data region probing primitive (calculated thresholds: 52.2%).

**Figure 5:** Success rate vs. number of repetitions to sample the target cache signal with p+p and f+r for our object probing primitive (calculated thresholds: ≈49%).

**Figure 6:** Success rate vs. number of repetitions to sample the target cache signal with p+p and f+r for our gadget probing and Spectre probing (testing mode) primitives (calculated thresholds: 45.0% and 27.9%, respectively).

**Figure 7:** Frequency of the number of repetitions at which the first or second hit was seen in the user page using the Spectre gadget with f+r. When using Spectre probing in testing (leaking) mode, we consult the histogram with N=1 (N=2).

```plaintext
 0 10 20 30 40 50 60 70 80 90 100 0 10 20 30 40 50 60 70 80 90 100
Success rate (%) Number of repetitions Prime+Probe
 0 10 20 30 40 50 60 70 80 90 100 0 10 20 30 40 50 60 70 80 90 100
Success rate (%) Number of repetitions Prime+Probe Flush+Reload
 0 10 20 30 40 50 60 70 80 90 100 0 10 20 30 40 50 60 70 80 90 100
Success rate (%) Number of repetitions Prime+Probe Flush+Reload
 0 10 20 30 40 50 60 70 80 90 100 0 10 20 30 40 50 60 70 80 90 100
Success rate (%) Number of repetitions Prime+Probe Flush+Reload
 0 1 2 3 4 5 6 7 8
1 2 3 4 5 6 7 8 9 10
Frequency Number of repetitions for first N hits
N=1
N=2
```

This structured format should make the references and the appendix more organized and easier to read.