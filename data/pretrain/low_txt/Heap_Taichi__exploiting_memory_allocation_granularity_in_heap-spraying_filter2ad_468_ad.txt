### 6. Related Work

#### 6.1 Heap Spraying with ASLR and DEP
Address Space Layout Randomization (ASLR) [22, 33, 40, 44] is a widely used security feature in recent versions of Windows, such as Windows Vista and Windows 7. Analyses [40, 44] have shown that the randomization of the heap area is relatively weak. For each heap memory block, the system generates a five-bit random number (ranging from 0 to 31), multiplies it by 64K, and adds the result to the initial allocation base. This technique introduces unpredictable gaps between memory blocks, making heap-spraying attacks more challenging. However, attackers can mitigate this by allocating large memory blocks and carefully structuring them to reduce the risk of landing in these gaps.

The new attack discussed in this paper is not effectively mitigated by ASLR. Due to the Windows memory allocation granularity, heap blocks remain aligned to 64K boundaries even after randomization. This means that the relative positions within each heap object remain unchanged. As long as attackers can spray enough memory using the heap region, the attack can still achieve a high success rate.

Data Execution Prevention (DEP) [1] complements ASLR by preventing code execution from non-executable memory regions. When both DEP and ASLR are enabled, most code injection attacks are thwarted. However, techniques to bypass DEP and ASLR continue to be developed. For example, Nenad Stojanovski et al. [41] demonstrated that the initial implementation of DEP in Windows XP was insecure, and many attacks, such as return-to-libc, could bypass DEP. Alexander Sotirov and Mark Dowd [39] implemented several exploitation techniques to bypass protections and execute remote code on Windows Vista. Dion Blazakis [15] introduced two novel techniques, pointer inference and JIT spraying, for Windows Vista with IE8. During the PWN2OWN hacking contest in 2010 [10], both IE 8 and Firefox 3 running on Windows 7 (with both DEP and ASLR enabled) were successfully compromised. These examples illustrate that attacks against DEP and ASLR cannot be completely avoided due to vulnerabilities in operating systems or critical applications.

#### 6.2 Heap-Spraying Attack and Detection
Our approach is closely related to existing work on heap behavior manipulation, heap-spraying detection, and x86 executable code detection.

**Heap Behavior Manipulation:**
A successful heap-spraying attack requires attackers to predict the heap organization and, more importantly, the locations of allocated heap objects. Sotirov [38] introduced a technique using JavaScript to manipulate browser heap layout, implementing this into a JavaScript library to set up the heap state before triggering a vulnerability. Daniel et al. [19] developed a method to reliably position a function pointer after a vulnerable heap buffer. In this paper, we exploit a weakness in Windows heap allocation due to the large memory allocation granularity, making heap allocation more predictable for attackers.

**Executable Code Detection:**
Recent research [28, 37] has shown that detecting arbitrary shellcode by static code features is difficult and often infeasible. While several solutions [11, 30, 42] can detect executable code in network packets, they generate high false positives in the context of heap objects [32], making them unsuitable for heap-spraying detection. We discuss several detection methods in detail in Section 2.2.

#### 6.3 Memory Exploit Detection and Prevention
Heap spraying alone cannot directly cause malicious payload execution; another vulnerability must trigger a control flow change to the sprayed heap. Detecting and preventing such vulnerabilities can stop heap spraying.

**Buffer Overflow:**
Buffer overflow is a common vulnerability exploited to redirect the control flow of a victim process. Traditional buffer overflow attacks target pointer variables on the stack or heap. Many solutions [45] have been proposed to address this, including ASLR [2, 13, 14], which randomizes the location of memory objects, making heap-spraying attacks less effective. Address space layout randomization makes the location of memory objects, including heap objects, unpredictable, forcing attackers to inject a large number of heap objects containing code to increase the chance of success. This forms the basis for existing heap-spraying detection solutions.

**Integer Overflow:**
Another common vulnerability in browsers is integer overflow. Many such vulnerabilities have been disclosed in recent years, and some detection and prevention methods have been proposed [16, 43]. Integer overflow often leads to heap overflow, and heap spraying can facilitate exploiting these vulnerabilities.

In practice, eliminating all such vulnerabilities is very challenging, and the runtime overhead of many approaches prevents their widespread deployment. Therefore, the solution presented in this paper complements existing memory exploit prevention methods.

### 7. Conclusion
Heap-spraying code injection attacks are commonly used in websites with exploits and drive-by downloads. This technique provides attackers with an easy-to-use method for code injection, implementable in many type-safe languages. Traditional heap-spraying attacks require a large number of NOP sleds to increase the likelihood of success, and existing detection solutions primarily check for a large amount of executable instructions on the heap.

By analyzing the memory allocation mechanisms of operating systems, we found that a large number of NOP sleds is not necessary if the memory alignment size is sufficiently large. We introduced a new technique for launching heap-spraying attacks that injects only a small amount of executable instructions, making it undetectable by existing approaches. We discussed four basic types of attack modes and provided insights into the relationship between memory alignment size and heap-spraying attack surface areas. We verified our technique with a proof-of-concept implementation, showing that even with a 32-byte alignment size, our attack can evade existing detection techniques. As a solution, we propose enforcing finer memory allocation granularity at all levels of memory managers, trading a limited amount of performance for better security.

### Acknowledgments
The authors would like to thank the anonymous reviewers for their valuable comments. This work was supported in part by the National Natural Science Foundation of China under grant No. 61003216, the National Development and Reform Commission under the project "A monitoring platform for web safe browsing," and the Singapore Ministry of Education under the NUS grant R-252-000-367-133.

### 8. References
[1] Microsoft Corporation. Data execution prevention. http://technet.microsoft.com/enus/library/cc738483.aspx.
[2] The PaX team. http://pax.grsecurity.net.
[3] Why is address space allocation granularity 64k? http://blogs.msdn.com/oldnewthing/archive/2003/10/08/55239.aspx.
[4] Microsoft Internet Explorer .ANI file “anjh” header BoF exploit, 2004. http://skypher.com/wiki/index.php?title=www.edup.tudelft.nl/~bjwever/details_msie_ani.html.php.
[5] Microsoft Internet Explorer DHTML object handling vulnerabilities (MS05-20), 2004. http://skypher.com/wiki/index.php?title=www.edup.tudelft.nl/~bjwever/advisory_msie_R6025.html.php.
[6] Microsoft Internet Explorer IFRAME src&name parameter BoF remote compromise, 2004. http://skypher.com/wiki/index.php?title=www.edup.tudelft.nl/~bjwever/advisory_iframe.html.php.
[7] Microsoft Internet Explorer javaprxy.dll COM object vulnerability, 2005. http://www.frsirt.com/english/advisories/2005/0935.
[8] Microsoft Internet Explorer “msdds.dll” remote code execution, 2005. http://www.frsirt.com/english/advisories/2005/1450.
[9] libemu - shellcode detection, 2007. http://libemu.carnivore.it.
[10] Pwn2own 2010, 2010. http://dvlabs.tippingpoint.com/blog/2010/02/15/pwn2own-2010.
[11] P. Akritidis, E. P. Markatos, M. Polychronakis, and K. Anagnostakis. STRIDE: Polymorphic sled detection through instruction sequence analysis. In Security and Privacy in the Age of Ubiquitous Computing, 2005.
[12] C. Anley, J. Heasman, F. Lindner, and G. Richarte. The Shellcoder’s Handbook: Discovering and Exploiting Security Holes. Wiley, 2004.
[13] S. Bhatkar, D. C. DuVarney, and R. Sekar. Address obfuscation: An efficient approach to combat a broad range of memory error exploits. In Proceedings of the 12th USENIX Security Symposium, 2003.
[14] S. Bhatkar, R. Sekar, and D. C. DuVarney. Efficient techniques for comprehensive protection from memory error exploits. In Proceedings of the 14th USENIX Security Symposium, 2005.
[15] D. Blazakis. Interpreter exploitation: Pointer inference and JIT spraying. In Blackhat, USA, 2010.
[16] D. Brumley, T. Chiueh, R. Johnson, H. Lin, and D. Song. RICH: Automatically protecting against integer-based vulnerabilities. In Proceedings of the 14th Annual Network and Distributed System Security Symposium (NDSS), 2007.
[17] C. Collberg, C. Thomborson, and D. Low. Manufacturing cheap, resilient, and stealthy opaque constructs. In POPL '98: Proceedings of the 25th ACM SIGPLAN-SIGACT symposium on Principles of programming languages, 1998.
[18] CVE, 2007. http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-0038.
[19] M. Daniel, J. Honoroff, and C. Miller. Engineering heap overflow exploits with JavaScript. In Proceedings of the 2nd USENIX Workshop on Offensive Technologies, 2008.
[20] T. Detristan, T. Ulenspiegel, and Yann_malcom. Polymorphic shellcode engine using spectrum analysis. Phrack 11,57-15 (2001).
[21] M. Egele, P. Wurzinger, C. Kruegel, and E. Kirda. Defending browser against drive-by downloads: Mitigating heap-spraying code injection attacks. In Proceedings of the 6th Conference on Detection of Intrusions and Malware & Vulnerability Assessment (DIMVA), 2009.
[22] M. E.Russinovich and D. A.solomon. Microsoft Windows Internals, Fourth Edition: Microsoft Windows Server 2003, Windows XP, and Windows 2000. Microsoft Press, 2008.
[23] J. Evans. A scalable concurrent malloc(3) implementation for FreeBSD. In BSDCan conference, 2006.
[24] P. Fogla and W. Lee. Evading network anomaly detection systems: formal reasoning and practical techniques. In CCS '06: Proceedings of the 13th ACM conference on Computer and communications security, 2006.
[25] D. R. Hanson. Fast allocation and deallocation of memory based on object lifetimes. Softw. Pract. Exper., 20(1):5–12, 1990.
[26] C. Kil, J. Jun, C. Bookholt, J. Xu, and P. Ning. Address space layout permutation (ASLP): Towards fine-grained randomization of commodity software. In ACSAC'06: Proceedings of the 22nd Annual Computer Security Applications Conference, 2006.
[27] C. Linn and S. Debray. Obfuscation of executable code to improve resistance to static disassembly. In CCS '03: Proceedings of the 10th ACM conference on Computer and communications security, 2003.
[28] J. Mason, S. Small, F. Monrose, and G. MacManus. English shellcode. In CCS '09: Proceedings of the 16th ACM conference on Computer and communications security, 2009.
[29] M. Polychronakis, K. Anagnostakis, and E. Markatos. Emulation-based detection of non-self-contained polymorphic shellcode. In Proceedings of the 10th International Symposium on Recent Advances in Intrusion Detection (RAID), 2007.
[30] M. Polychronakis, K. G. Anagnostakis, and E. P. Markatos. Network-level polymorphic shellcode detection using emulation. In Proceedings of the 3rd Conference on Detection of Intrusions and Malware & Vulnerability Assessment (DIMVA), 2006.
[31] I. V. Popov, S. K. Debray, and G. R. Andrews. Binary obfuscation using signals. In SS'07: Proceedings of the 16th USENIX Security Symposium on USENIX Security Symposium, Berkeley, CA, USA, 2007.
[32] P. Ratanaworabhan, B. Livshits, and B. Zorn. NOZZLE: A defense against heap-spraying code injection attacks. In Proceedings of the 18th USENIX Security Symposium, 2009.
[33] J. Richter and C. Nasarre. Windows via C/C++ 5th edition. Microsoft Press, 2008.
[34] RIX. Writing ia32 alphanumeric shellcodes. Phrack 11,57-15 (2001).
[35] P. M. Sanjay Ghemawat, 2005. http://goog-perftools.sourceforge.net/doc/tcmalloc.html.
[36] SecurityFocus. Mozilla Firefox 3.5 ‘TraceMonkey’ component remote code execution vulnerability, 2009. http://www.securityfocus.com/bid/35660.
[37] Y. Song, M. E. Locasto, A. Stavrou, A. D. Keromytis, and S. J. Stolfo. On the infeasibility of modeling polymorphic shellcode. In CCS '07: Proceedings of the 14th ACM conference on Computer and communications security. ACM, 2007.
[38] A. Sotirov. Heap feng shui in JavaScript. In Blackhat, USA, 2007.
[39] A. Sotirov. Bypassing browser memory protections in Windows Vista. In Blackhat, USA, 2008.
[40] A. Sotirov and M. Dowd. Bypassing browser memory protections. In BlackHat, USA, 2008.
[41] N. Stojanovski, M. Gusev, D. Gligoroski, and Svein.J.Knapskog. Bypassing data execution prevention on Microsoft Windows XP SP2. In The Second International Conference on Availability, Reliability and Security (ARES), 2007.
[42] T. Toth and C. Kruegel. Accurate buffer overflow detection via abstract payload execution. In Proceedings of the 5th International Symposium on Recent Advances in Intrusion Detection (RAID), 2002.
[43] T. Wang, T. Wei, Z. Lin, and W. Zou. IntScope: Automatically detecting integer overflow vulnerability in x86 binary using symbolic execution. In Proceedings of the 16th Annual Network and Distributed System Security Symposium (NDSS), 2009.
[44] O. Whitehouse. An analysis of address space layout randomization on Windows Vista™. In Symantec Advanced Threat Research, 2007.
[45] Y. Younan, W. Joosen, and F. Piessens. Code injection in C and C++: A survey of vulnerabilities and countermeasures. Technical Report CW386, Department of Computer Science, Katholieke Universiteit Leuven, 2004.
[46] A. Young and M. Yung. Cryptovirology: Extortion-based security threats and countermeasures. In SP '96: Proceedings of the 1996 IEEE Symposium on Security and Privacy, page 129, Washington, DC, USA, 1996. IEEE Computer Society.
[47] J. Zhuge, T. Holz, C. Song, J. Guo, X. Han, and W. Zou. Studying malicious websites and the underground economy on the Chinese web. In Proceedings of the 7th Workshop on the Economics of Information Security (WEIS'08), 2008.