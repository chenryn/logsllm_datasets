**Title: Resolving the Predicament of Android Custom Permissions**

**Authors:**
GÃ¼liz Seray Tuncay, Soteris Demetriou, Karan Ganju, Carl A. Gunter  
University of Illinois at Urbana-Champaign  
{tuncay2, sdemetr2, kganju2, cgunter}@illinois.edu

**Abstract:**
Android employs a set of system permissions to safeguard platform resources. Additionally, it allows untrusted third-party applications to declare their own custom permissions to control access to app components. However, Android treats custom permissions identically to system permissions, despite the different trust levels of their declarers. In this work, we identify two new classes of vulnerabilities arising from the 'predicament' created by the intermingling of system and custom permissions in Android. These vulnerabilities have been recognized as serious security flaws by Google, and we demonstrate how they can be exploited to gain unauthorized access to platform resources and compromise popular Android apps. To address these issues, we propose Cusper, a new modular design for the Android permission model. Cusper separates the management of system and custom permissions and introduces a backward-compatible naming convention for custom permissions to prevent spoofing. We validate Cusper's correctness by introducing the first formal model of Android runtime permissions, extending it to describe Cusper, and formally proving that key security properties violated in the current model are always satisfied in Cusper. To demonstrate Cusper's practicality, we implemented it in the Android platform, showing that it is both effective and efficient.

**I. Introduction**
The Android permission model serves as the security foundation for critical operations performed by apps on the platform. It regulates access to platform and app resources using a set of security labels called permissions. System permissions, predefined by the platform, protect platform resources (e.g., microphone, internet). The model also provides finer-grained security for Inter-Process Communication (IPC) between different app or system components. For this purpose, Android introduces custom permissions, which are application-defined and allow developers to control access to their app components. Our study of the top free apps on the Google Play Store reveals that 65% of the apps define custom permissions, and 70% request them for their operation.

Unfortunately, design flaws and vulnerabilities in custom permissions can severely compromise IPC security, leading to exploits on third-party apps and the platform. Previous research has consistently highlighted problems with custom permissions [30], [28]. Despite Google's efforts to address these issues with bug fixes, similar vulnerabilities persist. In this work, we present two classes of attacks that exploit custom permission vulnerabilities to gain unauthorized access to platform and app resources. One attack bypasses user interaction requirements for dangerous system permissions, allowing stealthy access to high-risk resources (e.g., camera, microphone). The other attack escalates privileges to gain elevated access to protected components of other apps. We demonstrate how these vulnerabilities can be used to target high-profile apps like CareZone and Skype, accessing sensitive user data and functionalities. We reported these attacks to Google, which acknowledged them as severe flaws requiring attention in future Android versions.

Our investigation of the Android permission model and its source code revealed that there is no separation of trust between system and custom permissions, leading to the 'predicament' of custom permissions. First, the insufficient isolation of system and custom permissions creates opportunities for malicious apps to exploit custom permissions for unauthorized access. Second, the lack of an enforced naming convention for custom permissions leads to a confused deputy problem, where unauthorized apps can use similarly named custom permissions to access protected resources. To address these issues, we propose Cusper, a design and implementation that decouples the handling of custom permissions from system permissions and implements a backward-compatible naming convention to prevent spoofing.

To prove Cusper's correctness, we built the first formal model of the Android runtime permission model using the Alloy specification language. This model demonstrates that the original permission model violates two fundamental security properties: 1) no unauthorized component access, and 2) no access to high-risk resources without user consent. We show that Cusper satisfies these properties. Finally, we implemented Cusper in Android, demonstrating its effectiveness and efficiency in resolving the identified vulnerabilities.

**II. Background**
This section covers the background on Android permissions, IPC on Android, and formal verification using Alloy.

**A. Android Permissions**
In Android, each app runs as a separate Linux user within a sandboxed environment to ensure system and app integrity. Apps must request permissions to access resources outside their sandbox. Android permissions are associated with protection levels: normal, signature, and dangerous. Normal permissions protect low-risk resources, while dangerous permissions protect high-risk resources. Signature permissions protect private resources, granting access only to apps signed with the same certificate as the permission definer. Before Android 6.0, all permissions were granted at installation time. Starting with Android 6.0, the runtime permission model was introduced, where dangerous permissions are granted at runtime by the user and can be revoked at any time.

Custom permissions, defined by third-party apps, protect app resources from others. Apps define custom permissions by providing a name and optionally a permission group and description. To request a custom permission, an app must declare it in its manifest. Custom permissions can also be created dynamically using the `addPermission()` API method, provided the app declares permission trees in its manifest. While reverse domain name notation is suggested for custom permission names, there is no enforced naming convention, leading to potential conflicts.

**B. Inter-Component Communication (IPC)**
Android relies on IPC (also known as ICC) for reusability. Apps consist of four components: activities, services, broadcast receivers, and content providers. Activities provide a graphical interface for tasks, services perform background operations, broadcast receivers handle broadcast messages, and content providers share data via a relational database interface. Communication between components is achieved through intents, asynchronous messages used for component activation.

IPC security is ensured by the permission model. Both the caller and callee can require certain permissions for successful communication. Custom permissions are used to restrict access to components, and their correct operation is crucial for the security of both third-party apps and the system.

**C. Formal Verification via Alloy**
Alloy is a declarative specification language used to model complex systems. It provides the Alloy Analyzer, a tool based on first-order logic for analyzing formal models. Alloy statements can be interpreted from object-oriented and set theory perspectives. Signatures define schemas, similar to classes in object-oriented programming and sets in set theory. Facts are global constraints, predicates are parametrized constraints, functions return results based on parameters, and assertions are assumptions that can be validated. Alloy supports quantifiers (all, some, lone, one, no) and multiplicity keywords for field and signature declarations.

The Alloy Analyzer performs finite scope checks, ensuring soundness and completeness up to a specified scope. It generates examples and counterexamples to validate claims and assertions in the model.

**III. Use of Custom Permissions**
Custom permissions are essential for securing IPC in Android apps. They are used by developers to restrict access to components based on the sensitivity of the protected resource. In this section, we investigate the prevalence of custom permissions among the top free apps on Google Play and showcase two high-profile apps targeted by our attacks exploiting custom permission vulnerabilities.

**A. Prevalence**
We collected 50 top free apps from each category on the Google Play Store and analyzed their use of custom permissions.