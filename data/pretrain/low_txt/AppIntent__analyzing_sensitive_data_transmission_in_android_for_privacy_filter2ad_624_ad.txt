# Triggering Sensitive SMS Data Transmission

Figure 6(a) illustrates one of the feasible inputs, while a simplified version is shown in Figure 5. For the purpose of this discussion, we will focus on the first input.

## Dynamic Analysis Platform

Our dynamic analysis platform accepts this input and creates an execution, as demonstrated in the video [4]. The controlled execution first selects a conversation record from the list of all stored messages on the phone. By choosing a message and clicking a button labeled "转发" (forward in Chinese, as seen in Figure 7(a)), the user can forward the message to another recipient. The message can then be sent by entering the receiver's name and clicking the "发送" (send) button, as shown in Figures 7(b) and 7(c). This process is commonly used for forwarding a stored message to a friend, and thus should not be classified as malicious or unintended behavior.

## Tapsnake: A Malicious App

Tapsnake is a malicious app that stealthily transmits user location data to a predefined third-party receiver. As depicted in Figure 6(b), the app input generated by AppIntent shows that two components are activated when the location information is transmitted: the main activity of the app and an embedded Service that registers an event listener for location change events. Based on this input, the corresponding execution, as demonstrated in the video [5], waits until the current time exceeds 0xdbba0 (representing 15 minutes from the start of the wall time). After a location change event is detected, the location information is sent (as shown in Figure 7(d)). Since the original application is a simple "snake" game and does not require location information, this behavior is considered unintended.

## Usability of AppIntent

To evaluate the usability of AppIntent, we randomly selected 100 reported cases and used them to assess the user experience. We invited three Android experts to participate in our study. After a brief introduction to AppIntent (less than 15 minutes), the participants were familiarized with the given cases. We then ran the driven executions generated by AppIntent on a Samsung Nexus S mobile phone and presented them to the participants. Each case was classified as either "user-intended" or "unintended." The participants were able to make their decisions within one minute after the execution finished, demonstrating that AppIntent significantly speeds up the process of validating Android apps.

The results from the three users were unambiguously consistent with our judgment in 98 cases. However, there were differing opinions in two cases involving the transmission of IMEI data. Two out of the three experts classified these transmissions as user-intended, reasoning that the apps needed the IMEI number for their functionality. In contrast, we classified them as unintended because there was no direct relationship between the data transmission and the user experience. This evaluation indicates that AppIntent is a highly usable tool in practice, though it still has room for improvement.

## Related Work

AppIntent appears to be the first method to systematically distinguish user-intended Android data transmission from unintended ones. Existing approaches for detecting sensitive data transmission, such as Static Taint Analysis [21, 40] and Dynamic Taint Tracking [22, 41], often generate false positives and cannot differentiate between user-intended and unintended operations due to a lack of context and user intention. Vision [26] and BLADE [32] propose using end-user license agreements (EULAs) and explicit notifications to represent user consent, but many mobile apps do not provide EULAs even for user-intended data transmission (e.g., SMS forwarding). Pegasus [18] focuses on detecting malicious behaviors inconsistent with GUI events, but it cannot model privacy leakages as app usage of permissions or APIs. VetDroid [44] enhances Dynamic Taint Tracking by generating specifications for sensitive operations, but it does not consider the trigger conditions of each operation.

AppIntent requires the extraction of app inputs to distinguish between user-intended and unintended data transmission. SmartDroid [45] proposes a hybrid static and dynamic analysis method to reveal UI-based event trigger conditions based on sensitive Android APIs. However, AppIntent provides a more complete and systematic approach by generating both event and data inputs. AppIntent uses symbolic execution to extract inputs, addressing the well-known issue of search space explosion. Earlier guided symbolic executions [11, 33, 36, 37] and profiled program behavior [14, 19, 43] have focused on reducing the data input space but not the runtime event space. Ganov et al. [25] set an upper bound on the number of event sequences, Kudzu [38] uses random event ordering, and Ganov et al. [24] propose symbolically executing each event handler separately. These methods reduce the exploration space but sacrifice code coverage. Contest [9] prunes redundant event sequences, reducing the running time of symbolic execution, but the event space remains large.

In this paper, we use the result of static analysis to guide event-space constraint symbolic execution, effectively bounding the search space without sacrificing accuracy.

## Conclusion and Future Work

This paper addresses the challenge of detecting privacy leakage in Android apps. Unlike previous approaches that consider any private data transmission as a privacy leakage, we argue that the key indicator should be whether the transmission is user-intended. We present AppIntent, a new framework to help human analysts determine if data transmission is intended by the user. Using event-space constraint guided symbolic execution, AppIntent efficiently extracts app inputs representing user interactions.

Our current techniques have limitations, which are also areas for future work. First, AppIntent does not support native code, so privacy leakages in native code cannot be captured. Second, the Android InstrumentationTestRunner [1] does not support network input instrumentation, which could be addressed by instrumenting code in the Android network interface. Finally, AppIntent fails to analyze some apps due to decompilation issues with DED [23]. We plan to use Dexpler [12] to directly parse DEX files in Soot, eliminating the need for decompilation.

## Acknowledgments

We thank the anonymous reviewers for their insightful comments and ChenHao Qu for his assistance in the experiments. This work is funded by the China National Natural Science Foundation, the Science and Technology Commission of Shanghai Municipality, a joint program between the China Ministry of Education and Intel, Fundamental Research Funds for the Central Universities in China, and the Shanghai Leading Academic Discipline Project. It is also partially supported by the National Science Foundation under Grant no. CNS-0954096.

## References

[1] Android InstrumentationTestRunner. http://developer.android.com/reference/android/test/InstrumentationTestRunner.html.
[2] Android Intent. http://developer.android.com/reference/android/content/Intent.html.
[3] Anzhuoduanxin. http://dx.91.com/.
[4] AppIntent Demo: Anzhuoduanxin. http://www.youtube.com/watch?v=RRqWQk4ztmI.
[5] AppIntent Demo: Tapsnake. http://www.youtube.com/watch?v=L4IvXzpYqzw.
[6] Choco Data Constraint Solver. http://www.emn.fr/z-info/choco-solver/.
[7] Google Maps. http://www.google.com/mobile/maps/.
[8] Soot Analysis Framework. http://www.sable.mcgill.ca/soot/.
[9] S. Anand, M. Naik, H. Yang, and M. J. Harrold. Automated Concolic Testing of Smartphone Apps. In Proc. FSE, 2012.
[10] S. Anand, C. S. Pasareanu, and W. Visser. JPF-SE: A Symbolic Execution Extension to Java Pathfinder. In TACAS 2007, pages 134-138, 2007.
[11] D. Babic, L. Martignoni, S. McCamant, and D. Song. Statically-Directed Dynamic Automated Test Generation. In Proc. ISSTA, pages 12-22, 2011.
[12] A. Bartel, J. Klein, Y. Le Traon, and M. Monperrus. Dexpler: Converting Android Dalvik Bytecode to Jimple for Static Analysis with Soot. In Proc. SOAP, 2012.
[13] P. Bisht, T. Hinrichs, N. Skrupsky, and V. N. Venkatakrishnan. WAPTEC: Whitebox Analysis of Web Applications for Parameter Tampering Exploit Construction. In CCS, pages 575-586, 2011.
[14] P. Boonstoppel, C. Cadar, and D. R. Engler. RWSET: Attacking Path Explosion in Constraint-Based Test Generation. In TACAS, 2008.
[15] D. Brumley, J. Newsome, D. Song, H. Wang, and S. Jha. Towards Automatic Generation of Vulnerability Signatures. In IEEE Symposium on Security and Privacy, 2006.
[16] C. Cadar, D. Dunbar, and D. R. Engler. KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs. In OSDI, pages 209-224, 2008.
[17] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and D. R. Engler. EXE: Automatically Generating Inputs of Death. In CCS, pages 322-335, 2006.
[18] K. Z. Chen, N. Johnson, V. D’Silva, S. Dai, K. MacNamara, T. Magrino, E. X. Wu, M. Rinard, and D. Song. Contextual Policy Enforcement in Android Applications with Permission Event Graphs. In Proc. NDSS, 2013.
[19] C. Y. Cho, D. Babic, P. Poosankam, K. Z. Chen, S. McCamant, and D. Song. MACE: Model-Inference-Assisted Concolic Exploration for Protocol and Vulnerability Discovery. In USENIX Security, 2011.
[20] M. Costa, M. Castro, L. Zhou, L. Zhang, and M. Peinado. Bouncer: Securing Software by Blocking Bad Input. In SOSP, pages 117-130, 2007.
[21] M. Egele, C. Kruegel, E. Kirda, and G. Vigna. PIOS: Detecting Privacy Leaks in iOS Applications. In NDSS, 2011.
[22] W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung, P. McDaniel, and A. N. Sheth. TaintDroid: An Information-Flow Tracking System for Realtime Privacy Monitoring on Smartphones. In OSDI, pages 1-6, 2010.
[23] W. Enck, D. Octeau, P. McDaniel, and S. Chaudhuri. A Study of Android Application Security. In USENIX Security, 2011.
[24] S. R. Ganov, C. Killmar, S. Khurshid, and D. E. Perry. Test Generation for Graphical User Interfaces Based on Symbolic Execution. In AST, pages 33-40, 2008.
[25] S. R. Ganov, C. Killmar, S. Khurshid, and D. E. Perry. Event Listener Analysis and Symbolic Execution for Testing GUI Applications. In ICFEM, 2009.
[26] P. Gilbert, B.-G. Chun, L. P. Cox, and J. Jung. VISION: Automated Security Validation of Mobile Apps at App Markets. In Proc. MCS, 2011.
[27] P. Godefroid. Compositional Dynamic Test Generation. In POPL, pages 47-54, 2007.
[28] P. Godefroid, N. Klarlund, and K. Sen. DART: Directed Automated Random Testing. In PLDI, pages 213-223, 2005.
[29] M. C. Grace, W. Zhou, X. Jiang, and A.-R. Sadeghi. Unsafe Exposure Analysis of Mobile In-App Advertisements. In WiSec, 2012.
[30] P. Hornyack, S. Han, J. Jung, S. Schechter, and D. Wetherall. These Aren’t the Droids You’re Looking For: Retrofitting Android to Protect Data from Imperious Applications. In CCS, pages 639-652, 2011.
[31] A. Kieyzun, P. J. Guo, K. Jayaraman, and M. D. Ernst. Automatic Creation of SQL Injection and Cross-Site Scripting Attacks. In ICSE, pages 199-209, 2009.
[32] L. Lu, V. Yegneswaran, P. Porras, and W. Lee. BLADE: An Attack-Agnostic Approach for Preventing Drive-By Malware Infections. In Proc. CCS, pages 440-450, 2010.
[33] K.-K. Ma, K. Y. Phang, J. S. Foster, and M. Hicks. Directed Symbolic Execution. In Proc. SAS, 2011.
[34] D. Molnar, X. C. Li, and D. A. Wagner. Dynamic Test Generation to Find Integer Bugs in x86 Binary Linux Programs. In USENIX Security, pages 67-82, 2009.
[35] G. Patrice, Y. L. Michael, and A. M. David. Automated Whitebox Fuzz Testing. In NDSS, 2008.
[36] N. Rungta, E. G. Mercer, and W. Visser. Efficient Testing of Concurrent Programs with Abstraction-Guided Symbolic Execution. In Proc. SPIN, 2009.
[37] R. Santelices and M. J. Harrold. Exploiting Program Dependencies for Scalable Multiple-Path Symbolic Execution. In Proc. ISSTA, 2010.
[38] P. Saxena, D. Akhawe, S. Hanna, F. Mao, and S. McCamant. KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs. In OSDI, pages 209-224, 2008.
[39] K. Sen, D. Marinov, and G. Agha. CUTE: A Concolic Unit Testing Engine for C. In ESEC/SIGSOFT FSE, pages 263-272, 2005.
[40] O. Tripp, M. Pistoia, S. J. Fink, M. Sridharan, and O. Weisman. TAJ: Effective Taint Analysis of Web Applications. In PLDI, pages 87-97, 2009.
[41] N. Vachharajani, M. J. Bridges, J. Chang, R. Rangan, G. Ottoni, J. A. Blome, G. A. Reis, M. Vachharajani, and D. I. August. RIFE: An Architectural Framework for User-Centric Information-Flow Security. In MICRO, pages 243-254, 2004.
[42] T. Wang, T. Wei, Z. Lin, and W. Zou. IntScope: Automatically Detecting Integer Overflow Vulnerability in x86 Binary Using Symbolic Execution. In NDSS, 2009.
[43] T. Xie, N. Tillmann, P. de Halleux, and W. Schulte. Fitness-Guided Path Exploration in Dynamic Symbolic Execution. In Proc. DSN, 2009.
[44] Y. Zhang, M. Yang, B. Xu, Z. Yang, G. Gu, P. Ning, X. Wang, and B. Zang. Vetting Undesirable Behaviors in Android Apps with Permission Use Analysis. In CCS, 2013.
[45] C. Zheng, S. Zhu, S. Dai, G. Gu, X. Gong, and W. Zou. SmartDroid: An Automatic System for Revealing UI-Based Trigger Conditions in Android Applications. In Proc. SPSM, October 2012.
[46] Y. Zhou and X. Jiang. Dissecting Android Malware: Characterization and Evolution. In IEEE Symposium on Security and Privacy, 2012.