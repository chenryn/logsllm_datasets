### Acknowledgments

This work was conducted by Honeywell International Inc. for the U.S. Department of Energy’s National Nuclear Security Administration under contract DE-NA0003525. The research is also supported by the National Science Foundation (Award No. CNS-1704253) and the Office of Naval Research (Award No. N00014-17-1-2011). Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the authors and do not necessarily reflect the views of the National Science Foundation or the Office of Naval Research. Additionally, this work was partially funded by a research contract with Siemens AG.

### References

1. A. Beckus, "Qemu with an STM32 microcontroller implementation," 2012. Available: <http://beckus.github.io/qemu_stm32/>
2. F. Bellard, "Qemu, a fast and portable dynamic translator," in *USENIX Annual Technical Conference, FREENIX Track*, vol. 41, 2005, p. 46.
3. L. Ionescu, "GNU MCU Eclipse: A family of Eclipse CDT extensions and tools for GNU ARM & RISC-V development," 2015. Available: <https://gnu-mcu-eclipse.github.io/>
4. D. D. Chen, M. Egele, M. Woo, and D. Brumley, "Towards automated dynamic analysis for Linux-based embedded firmware," in *ISOC Network and Distributed System Security Symposium (NDSS)*, 2016.
5. V. Chipounov, V. Kuznetsov, and G. Candea, "S2E: A platform for in-vivo multi-path analysis of software systems," *ACM SIGPLAN Notices*, vol. 46, no. 3, pp. 265–278, 2011.
6. Comsecuris, "Luaqemu," 2012. Available: <https://github.com/comsecuris/luaqemu>
7. J. Corina, A. Machiry, C. Salls, Y. Shoshitaishvili, S. Hao, C. Kruegel, and G. Vigna, "Difuze: Interface-aware fuzzing for kernel drivers," in *Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security (CCS '17)*, New York, NY, USA: ACM, 2017, pp. 2123–2138. [Online]. Available: <http://doi.acm.org/10.1145/3133956.3134069>
8. N. Corteggiani, G. Camurati, and A. Francillon, "Inception: System-wide security testing of real-world embedded systems software," in *27th USENIX Security Symposium (USENIX Security 18)*, Baltimore, MD: USENIX Association, 2018. [Online]. Available: <https://www.usenix.org/conference/usenixsecurity18/presentation/corteggiani>
9. A. Costin, A. Zarras, and A. Francillon, "Automated dynamic firmware analysis at scale: A case study on embedded web interfaces," in *Proceedings of the 11th ACM on Asia Conference on Computer and Communications Security*, ACM, 2016, pp. 437–448.
10. D. Davidson, B. Moench, T. Ristenpart, and S. Jha, "Fie on firmware: Finding vulnerabilities in embedded systems using symbolic execution," in *USENIX Security*, 2013, pp. 463–478.
11. B. Dolan-Gavitt, J. Hodosh, P. Hulin, T. Leek, and R. Whelan, "Repeatable reverse engineering with PANDA," in *Proceedings of the 5th Program Protection and Reverse Engineering Workshop*, ACM, 2015, p. 4.
12. M. Ester, H.-P. Kriegel, J. Sander, X. Xu et al., "A density-based algorithm for discovering clusters in large spatial databases with noise," in *Conference on Knowledge Discovery and Data Mining*, 1996.
13. G. Hernandez, F. Fowze, D. J. Tian, T. Yavuz, and K. R. Butler, "FirmUSB: Vetting USB device firmware using domain-informed symbolic execution," in *Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security*, ACM, 2017, pp. 2245–2262.
14. M. Kammerstetter, D. Burian, and W. Kastner, "Embedded security testing with peripheral device caching and runtime program state approximation," in *10th International Conference on Emerging Security Information, Systems and Technologies (SECUREWARE)*, 2016.
15. M. Kammerstetter, C. Platzer, and W. Kastner, "PROSPECT: Peripheral proxying supported embedded code testing," in *Proceedings of the 9th ACM Symposium on Information, Computer and Communications Security*, ACM, 2014, pp. 329–340.
16. K. Koscher, T. Kohno, and D. Molnar, "Surrogates: Enabling near-real-time dynamic analyses of embedded systems," in *WOOT*, 2015.
17. P. S. Magnusson, M. Christensson, J. Eskilson, D. Forsgren, G. Hallberg, J. Hogberg, F. Larsson, A. Moestedt, and B. Werner, "Simics: A full system simulation platform," *Computer*, vol. 35, no. 2, pp. 50–58, 2002.
18. Maxim Integrated, "MAX32600MBED ARM mbed Enabled Development Platform for MAX32600," 2018. Available: <https://www.maximintegrated.com/en/products/microcontrollers/MAX32600MBED.html>
19. M. Muench, D. Nisi, A. Francillon, and D. Balzarotti, "Avatar2: A Multi-target Orchestration Platform," in *Workshop on Binary Analysis Research (colocated with NDSS Symposium)*, BAR 18, February 2018.
20. M. Muench, J. Stijohann, F. Kargl, A. Francillon, and D. Balzarotti, "What You Corrupt Is Not What You Crash: Challenges in Fuzzing Embedded Devices," in *Network and Distributed System Security (NDSS) Symposium*, NDSS 18, February 2018.
21. P. Osbourne, "CMSIS-SVD repository and parsers," 2012. Available: <https://github.com/posborne/cmsis-svd>
22. Y. Shoshitaishvili, R. Wang, C. Hauser, C. Kruegel, and G. Vigna, "FIRMALICE: Automatic detection of authentication bypass vulnerabilities in binary firmware," in *NDSS*, 2015.
23. Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino, A. Dutcher, J. Grosen, S. Feng, C. Hauser, C. Kruegel, and G. Vigna, "SoK: (State of) The Art of War: Offensive Techniques in Binary Analysis," in *IEEE Symposium on Security and Privacy*, 2016.
24. STMicroelectronics, "STM32F072RB," 2018. Available: <https://www.st.com/en/microcontrollers/stm32f072rb.html>
25. R. Toulson and T. Wilmshurst, *Fast and Effective Embedded Systems Design: Applying the ARM mbed*. Newnes, 2016.
26. J. Zaddach, L. Bruno, A. Francillon, and D. Balzarotti, "AVATAR: A framework to support dynamic security analysis of embedded systems' firmwares," in *NDSS*, 2014.
27. M. Zalewski, "American Fuzzy Lop (AFL)," 2017. Available: <http://lcamtuf.coredump.cx/afl/technical_details.txt>

### Appendices

#### A. Recording Rationale

While we describe our means of recording in Section 3.1, our approach may seem overly complicated. In the following, we provide the rationale behind the design decisions for the recording subcomponent of PRETENDER.

**Recording MMIO:**
The natural first step in building models of hardware is to record a trace of the I/O activity that occurs during execution. As outlined in Section 2, the firmware depends on both internal "on-chip" peripherals and external "off-chip" peripherals, both of which are necessary for the firmware to operate as expected. However, the firmware communicates with off-chip peripherals through its interactions with on-chip peripherals. Therefore, to have a complete recording, we must capture all memory accesses that constitute MMIO.

Peripherals are considered "memory-mapped" because they are attached to and addressed via one of the CPU's internal memory buses. Unlike external buses, which can be physically probed and monitored, these interactions occur within the CPU's die and cannot be directly monitored. While some debugging facilities used in the development of new chips offer a data trace of the memory bus, such as ARM's ETM/HTM Data Trace, these features are seldom available on production chips and are entirely absent in low-cost, low-pin-count chips of commercial embedded devices. Typical CPUs found in the wild include, at best, a debugger capable of simple execution control and memory/register access.

MMIO behaves differently from a normal region of memory; instead of just storing data, these locations control or represent aspects of on-chip peripherals. Their value or function may change based on external factors without any interaction with the firmware.

One possible alternative approach to MMIO recording would be to instrument the firmware to record I/O interactions. This requires us to understand, from the binary firmware itself, where this I/O takes place. This could be done on architectures where explicit `in` and `out` instructions are used for peripherals. On ARM, however, this is not straightforward, as peripherals are accessed via normal memory handling instructions (LDR/STR), and it is often difficult to tell statically whether an instruction is addressing a peripheral or normal memory. Inserting this instrumentation code non-destructively and collecting the cumbersome volumes of data it generates are both hard problems and may even be impossible if the code is present on Read-Only Memory (ROM). As a result of these complications, our approach involves virtually extending the internal memory bus of the device by emulating the firmware and forwarding and recording only the hardware-related accesses to the original physical device (as detailed in Section 3).

**Recording Interrupts:**
Interrupts play an important role in most peripherals and are particularly difficult to record and model correctly. Interrupts are triggered by some event, whether it is an explicit MMIO operation or an event in the physical world, and cause the execution of Interrupt Service Routines (ISRs) as a result. These ISRs typically contain MMIO operations associated with the peripheral that triggered the interrupt (e.g., reading data that arrives at a serial port or counting the number of times a counter overflows). Without the peripherals' ISRs executing at the correct times, the peripherals may not function, or the system may crash. This behavior is a property of the hardware itself; the internal logic of the peripheral decides when and how often to trigger its associated interrupts. Many peripherals allow this behavior to be adjusted at runtime through their configuration registers. For example, many peripherals have a single bit in their configuration register controlling whether interrupt events are generated at all.

Hardware features exist on many chips for providing a log of the interrupts, such as ARM's Instrumentation Trace Macrocell (ITM), but these features are not universal and are difficult to coordinate with simultaneous peripheral recording or even basic hardware-in-the-loop emulation. Hence, previous solutions, such as the first version of the Avatar framework [26] or SURROGATES [16], tried to tackle interrupt forwarding with custom stubs injected onto the device under analysis. However, both of these solutions forward interrupts in a "fire-and-forget" manner, resulting in inconsistencies between hardware and emulated firmware, as incoming interrupts on the hardware could easily be missed when the emulator serves a previous interrupt. Although these inconsistencies are a negligible problem for manual analysis, they dramatically complicate automated modeling and must be avoided.

A more recent approach, presented by Corteggiani et al. [7], uses a custom-tailored protocol to keep hardware and emulator synchronized during interrupt forwarding. Unfortunately, this method requires custom debugging hardware, which would greatly reduce the generality of PRETENDER. Hence, we heavily extended avatar2 to support the notion of forwarding and recording interrupts while carefully keeping the two systems synchronized without the need for specialized debugging hardware. The current published version of avatar2 retains the hardware in a "debug-halt" state while forwarding memory accesses, in order to avoid side-effects from the resident code. Unfortunately, this debug-halt state inhibits all interrupts and thus cannot be used as-is. However, we cannot simply keep the CPU running and forward all of the generated interrupts into the emulator; if too many unhandled interrupts arrive, or spurious, unwanted interrupts occur, the hardware or emulator can experience an unrecoverable fault. The current version of avatar2 also does not support writing to memory while the CPU is running. To make matters worse, halting the CPU during interrupt routines is problematic, as we noticed that some peripherals, particularly those that control future interrupts, will not work properly in this halted state because they are bound to the CPU's instruction pipeline. As a final complication, we must ensure that we return from these interrupts properly, both in the emulator and on the hardware, to ensure that the hardware continues to function, even though it is not executing any code.

#### B. State Approximation Details

Our state approximation model is used when an MMIO location does not fit any other model. According to our observations, these tend to be the locations in a peripheral directly affected by external events, such as the data register of a serial port, a bus controller, or a status and event flag register. These locations are the most challenging to model and emulate.

For example, in the case of an I2C bus controller, there are many sources of state, and numerous causes for the state to change, many of which are not observable. From the software's perspective, the I2C bus controller presents an MMIO interface, which specifies how the bus protocol is spoken (baud rate, master/slave), whether queuing is enabled, or interrupts are fired, and so on. At another layer, the hardware between the MMIO and the pins has a state, containing the data queue, bus-related timers, and other condition flags not visible directly through MMIO. Both of these portions also occur in the device on the other side of the bus. Finally, the two devices share a protocol spoken on the I2C bus itself, which specifies an ordering of events (start symbol, address, data with acknowledgment, etc.). The result is a series of composed, inter-related state machines, which also rely somewhat on the physical world's events and can only be observed through the rather limited window of MMIO memory accesses.

Unfortunately, this means that we fail the requirements of state machine recovery techniques, which are typically used to infer states and transitions from an activity trace. We do not know the number of possible states, we cannot tell when two states are equivalent, and it is challenging to know concretely if we have even changed the state of the peripheral. We also cannot easily distinguish data registers, which may contain data respecting some protocol, from others containing status flags, error codes, and configuration data. However, it is also not sufficient to simply replay values verbatim from the recorded trace. This is because our models need to be able to function even when we observe deviation from the recording caused by new input, timing-related deviations caused by differences between the hardware and emulator, as well as to tolerate the asynchronous and non-deterministic occurrence of interrupts. In avoiding these limitations, we created the State Approximation algorithm described in Section 3.

**State Approximation Example:**
As an example, consider a hypothetical device that uses a serial port to act as a client for the thermostat we model in Section 4. This device's firmware will query the thermostat with 't' and 'h', and expect a properly formatted temperature or humidity in return. Furthermore, the firmware reacts to this data, for instance, by sending the information across a network or raising an alarm. The device firmware must receive a response from the thermostat when expected, and the response must make sense for the given command, for the firmware to behave correctly.

An illustration of what this model might look like can be seen in Figure B.1. Note that, in a real-world scenario, there will be many peripherals needed to operate the firmware, but here we focus on just one to better explain its behavior.

The client device's serial controller contains many registers, including a configuration register, a status register, a data register, as well as assorted registers governing physical hardware details, like baud rate. Each of these is addressed by its own MMIO location, in a contiguous memory region we identified during clustering. We notice, from our traces and previous Memory Model Training, that the configuration register is a simple storage location, and the baud rate control register is only ever written to. The contents of the status register follow a pattern, alternating between the values 0x1 and 0x3, which we will interpret as whether data is ready to receive or not. The data register, on the other hand, will change without respecting any pattern or direct stimulation from the firmware. Therefore, this location is handled by State Approximation.

When emulation begins, we start in the peripheral's initial state. During boot-up, the firmware configures the serial port, writing to the configuration register to enable the serial port and set the baud rate to 9600, advancing the peripheral's state pointer to the point at which these actions occurred. The firmware then begins its main loop and requests a temperature by writing a 't' into the data register. Naturally, the next thing that happens chronologically is for the status register to indicate that bytes are ready to read, and the firmware will read a temperature value out of the data register one byte at a time (e.g., "24.24C"). Similar actions occur if an 'h' is written to the data register by the firmware; the status register indicates new data, and the firmware reads it back (e.g., "50.35%").

However, when emulating with new input, interrupts, or after the duration of the original peripheral's chronologically observed states, we must make a decision about what state the peripheral is in. In these cases, following the simple rules in Section 3, we will enter the state where a 't' or an 'h' was written to the data register, and subsequent reads will return a temperature or a humidity. In this simple example, the serial port will, after some time, return only the last valid temperature and humidity values, but it will continue to return only temperatures or humidities when asked for and respect whatever formatting or encoding for these responses the thermostat uses, which may be checked by the firmware.

**Figure B.1: Illustration of State Approximation in action, on a simplified serial port peripheral**

| Address | Type          | Description                           |
|---------|---------------|---------------------------------------|
| 0x0     | Storage       | Configuration Register                |
| 0x4     | Write-only    | Baud Rate Control Register            |
| 0x8     | Pattern Model | Status Register                       |
| 0xC     | State Approx  | Data Register                         |

**Recorded MMIO Trace:**
- **READ 0x0** 0x4040
- **WRITE 0x0** 0x4040
- **WRITE 0x4** 0x9600
- **READ 0x8** 0x1
- **READ 0x8** 0x3
- **WRITE 0xC** 0x74 ('t')
- **READ 0x8** 0x1
- **READ 0x8** 0x3
- **READ 0xC** 0x32 ('2')
- ...
- **READ 0x8** 0x3
- **READ 0xC** 0x43 ('C')
- **READ 0x8** 0x1
- **WRITE 0xC** 0x68 ('h')
- **READ 0x8** 0x3
- **READ 0xC** 0x35 ('5')
- ...
- **READ 0x8** 0x3
- **READ 0xC** 0x35 ('%')

**Responses:**
- "2.24C"
- "50.35%"

**Example State Transitions:**
- **Command: 't'**
  - WRITE 0x0 0x4040
  - READ 0x8
  - READ 0xC
  - WRITE 0xC 0x74
  - READ 0xC
- **Command: 'h'**
  - WRITE 0x0 0x4040
  - READ 0x8
  - READ 0xC
  - WRITE 0xC 0x68
  - READ 0xC

This example illustrates how the State Approximation model allows the serial port to continue functioning correctly, even with new input and timing variations, by maintaining a consistent and predictable state.