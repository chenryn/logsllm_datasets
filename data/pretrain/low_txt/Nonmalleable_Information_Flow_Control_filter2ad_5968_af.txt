# References

1. Martín Abadi. 2006. Access Control in a Core Calculus of Dependency. In *11th ACM SIGPLAN International Conference on Functional Programming*. ACM, New York, NY, USA, 263–273.

2. Martín Abadi. 2008. Variations in Access Control Logic. In *Deontic Logic in Computer Science*, edited by Ron van der Meyden and Leendert van der Torre. Lecture Notes in Computer Science, Vol. 5076. Springer Berlin Heidelberg, 96–109.

3. Martín Abadi, Anindya Banerjee, Nevin Heintze, and Jon Riecke. 1999. A Core Calculus of Dependency. In *26th ACM Symposium on Principles of Programming Languages (POPL)*, 147–160.

4. Owen Arden, Jed Liu, and Andrew C. Myers. 2015. Flow-Limited Authorization. In *28th IEEE Symposium on Computer Security Foundations (CSF)*, 569–583.

5. Owen Arden and Andrew C. Myers. 2016. A Calculus for Flow-Limited Authorization. In *29th IEEE Symposium on Computer Security Foundations (CSF)*, 135–147.

6. Aslan Askarov and Andrew C. Myers. 2011. Attacker Control and Impact for Confidentiality and Integrity. *Logical Methods in Computer Science* 7, 3 (September 2011).

7. K. J. Biba. 1977. Integrity Considerations for Secure Computer Systems. Technical Report ESD-TR-76-372. USAF Electronic Systems Division, Bedford, MA. (Also available through National Technical Information Service, Springfield, VA, NTIS AD-A039324.)

8. Niklas Broberg and David Sands. 2010. Paralocks—Role-Based Information Flow Control and Beyond. In *37th ACM Symposium on Principles of Programming Languages (POPL)*.

9. Pablo Buiras, Dimitrios Vytiniotis, and Alejandro Russo. 2015. HLIO: Mixing Static and Dynamic Typing for Information-Flow Control in Haskell. In *20th ACM SIGPLAN International Conference on Functional Programming*. ACM, 289–301.

10. Ethan Cecchetti, Andrew C. Myers, and Owen Arden. 2017. Nonmalleable Information Flow Control: Technical Report. Technical Report. Cornell University Computing and Information Science. https://arxiv.org/abs/1708.08596.

11. Stephen Chong and Andrew C. Myers. 2006. Decentralized Robustness. In *19th IEEE Computer Security Foundations Workshop (CSFW)*, 242–253.

12. Stephen Chong and Andrew C. Myers. 2008. End-to-End Enforcement of Erasure and Declassification. In *IEEE Symposium on Computer Security Foundations (CSF)*, 98–111.

13. Michael R. Clarkson and Fred B. Schneider. 2008. Hyperproperties. In *IEEE Symposium on Computer Security Foundations (CSF)*, 51–65.

14. Dorothy E. Denning. 1976. A Lattice Model of Secure Information Flow. *Communications of the ACM* 19, 5 (May 1976), 236–243.

15. Danny Dolev, Cynthia Dwork, and Moni Naor. 2003. Nonmalleable Cryptography. *SIAM Review* 45, 4 (2003), 727–784.

16. Petros Efstathopoulos, Maxwell Krohn, Steve VanDeBogart, Cliff Frey, David Ziegler, Eddie Kohler, David Mazières, Frans Kaashoek, and Robert Morris. 2005. Labels and Event Processes in the Asbestos Operating System. In *20th ACM Symposium on Operating System Principles (SOSP)*.

17. Michael D. Ernst, René Just, Suzanne Millstein, Werner Dietl, Stuart Pernsteiner, Franziska Roesner, Karl Koscher, Paulo Barros, Ravi Bhoraskar, Seungyeop Han, Paul Vines, and Edward X. Wu. 2014. Collaborative Verification of Information Flow for a High-Assurance App Store. In *21st ACM Conference on Computer and Communications Security (CCS)*, 1092–1104.

18. David Ferraiolo and Richard Kuhn. 1992. Role-Based Access Controls. In *15th National Computer Security Conference*.

19. Joseph A. Goguen and Jose Meseguer. 1982. Security Policies and Security Models. In *IEEE Symposium on Security and Privacy*, 11–20.

20. Limin Jia, Jeffrey A. Vaughan, Karl Mazurak, Jianzhou Zhao, Luke Zarko, Joseph Schorr, and Steve Zdancewic. 2008. Aura: A Programming Language for Authorization and Audit. In *13th ACM SIGPLAN International Conference on Functional Programming*.

21. krdlab. 2014. Haskell Servant Example. https://github.com/krdlab/examples. (December 2014).

22. Maxwell Krohn, Alexander Yip, Micah Brodsky, Natan Cliffer, M. Frans Kaashoek, Eddie Kohler, and Robert Morris. 2007. Information Flow Control for Standard OS Abstractions. In *21st ACM Symposium on Operating System Principles (SOSP)*.

23. Peng Li and Steve Zdancewic. 2006. Encoding Information Flow in Haskell. In *19th IEEE Computer Security Foundations Workshop (CSFW)*.

24. Benoît Montagu, Benjamin C. Pierce, and Randy Pollack. 2013. A Theory of Information-Flow Labels. In *26th IEEE Symposium on Computer Security Foundations (CSF)*, 3–17.

25. Andrew C. Myers. 1999. JFlow: Practical Mostly-Static Information Flow Control. In *26th ACM Symposium on Principles of Programming Languages (POPL)*, 228–241.

26. Andrew C. Myers and Barbara Liskov. 2000. Protecting Privacy Using the Decentralized Label Model. *ACM Transactions on Software Engineering and Methodology* 9, 4 (October 2000), 410–442.

27. Andrew C. Myers, Andrei Sabelfeld, and Steve Zdancewic. 2006. Enforcing Robust Declassification and Qualified Robustness. *Journal of Computer Security* 14, 2 (2006), 157–196.

28. Aleksandar Nanevski, Anindya Banerjee, and Deepak Garg. 2011. Verification of Information Flow and Access Control Policies with Dependent Types. In *IEEE Symposium on Security and Privacy*, 165–179.

29. Sylvan Pinsky. 1995. Absorbing Covers and Intransitive Non-Interference. In *IEEE Symposium on Security and Privacy*, 102–113.

30. François Pottier and Sylvain Conchon. 2000. Information Flow Inference for Free. In *5th ACM SIGPLAN International Conference on Functional Programming (ICFP '00)*, 46–57.

31. François Pottier and Vincent Simonet. 2003. Information Flow Inference for ML. *ACM Transactions on Programming Languages and Systems* 25, 1 (January 2003).

32. A. W. Roscoe and M. H. Goldsmith. 1999. What is Intransitive Noninterference? In *12th IEEE Computer Security Foundations Workshop (CSFW)*, 228–238.

33. Indrajit Roy, Donald E. Porter, Michael D. Bond, Kathryn S. McKinley, and Emmett Witchel. 2009. Laminar: Practical Fine-Grained Decentralized Information Flow Control. In *ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)*.

34. John Rushby. 1992. Noninterference, Transitivity, and Channel-Control Security Policies. Technical Report CSL-92-02. SRI.

35. Andrei Sabelfeld and Andrew C. Myers. 2003. Language-Based Information-Flow Security. *IEEE Journal on Selected Areas in Communications* 21, 1 (January 2003), 5–19.

36. Andrei Sabelfeld and David Sands. 2005. Dimensions and Principles of Declassification. In *18th IEEE Computer Security Foundations Workshop (CSFW)*, 255–269.

37. Servant Contributors. 2016. Servant – A Type-Level Web DSL. https://haskell-servant.readthedocs.io/. (2016).

38. Marcelo Sousa and Isil Dillig. 2016. Cartesian Hoare Logic for Verifying k-Safety Properties. In *SIGPLAN Notices, Volume 51*. ACM, 57–69.

39. Deian Stefan, Amit Levy, Alejandro Russo, and David Mazières. 2014. Building Secure Systems with LIO. In *Haskell Symposium*. ACM SIGPLAN.

40. Nikhil Swamy, Michael Hicks, Stephen Tse, and Steve Zdancewic. 2006. Managing Policy Updates in Security-Typed Languages. In *19th IEEE Computer Security Foundations Workshop (CSFW)*, 202–216.

41. The Glasgow Haskell Compiler. 2016. The Glasgow Haskell Compiler. https://www.haskell.org/ghc/.

42. Ron van der Meyden. 2007. What, Indeed, Is Intransitive Noninterference? In *12th European Symposium on Research in Computer Security (ESORICS)*, 235–250.

43. Lucas Waye, Pablo Buiras, Dan King, Stephen Chong, and Alejandro Russo. 2015. It’s My Privilege: Controlling Downgrading in DC-Labels. In *Proceedings of the 11th International Workshop on Security and Trust Management*.

44. J. Todd Wittbold and Dale M. Johnson. 1990. Information Flow in Nondeterministic Systems. In *IEEE Symposium on Security and Privacy*, 144–161.

45. Andrew K. Wright and Matthias Felleisen. 1994. A Syntactic Approach to Type Soundness. *Information and Computation* 115, 1 (February 1994), 38–94.

46. Steve Zdancewic and Andrew C. Myers. 2001. Robust Declassification. In *14th IEEE Computer Security Foundations Workshop (CSFW)*, 15–23.

47. Steve Zdancewic, Lantian Zheng, Nathaniel Nystrom, and Andrew C. Myers. 2002. Secure Program Partitioning. *ACM Transactions on Computer Systems* 20, 3 (August 2002), 283–328.

48. Nickolai Zeldovich, Silas Boyd-Wickizer, Eddie Kohler, and David Mazières. 2006. Making Information Flow Explicit in HiStar. In *7th USENIX Symposium on Operating Systems Design and Implementation (OSDI)*, 263–278.

49. Lantian Zheng and Andrew C. Myers. 2007. Dynamic Security Labels and Static Information Flow Control. *International Journal of Information Security* 6, 2–3 (March 2007).

## Full NMIFC

We present the full syntax, semantics, and typing rules for NMIFC in Figures 17, 18, and 20, respectively. This is a straightforward extension of the core language presented in Section 5. We note that polymorphic terms specify a pc just as λ terms. This is because they contain arbitrary expressions which could produce arbitrary effects, so we must constrain the context that can execute those effects.

Figure 21 presents the full set of derivation rules for the acts-for (delegation) relation \( p \succeq q \).

### A.1 Label Tracking with Brackets

To simplify proofs of hyperproperties requiring 2 and 4 traces, we introduce a new bracket syntax to track secret and untrusted data. These brackets are inspired by those used by Pottier and Simonet [31] to prove their FlowCaml type system enforced noninterference. Their brackets served two purposes simultaneously. First, they allow a single execution of a bracketed program to faithfully model two executions of a non-bracketed program. Second, the brackets track secret/untrusted information through the execution of the program, making it easy to verify that it did not interfere with public/trusted information simply by proving that brackets could not be syntactically present in such values.

Since noninterference only requires examining pairs of traces, these purposes complement each other well; if the two executions vary only on high inputs, then low outputs cannot contain brackets. While this technique is very effective for proving noninterference, nonmalleable information flow provides security guarantees even in the presence of both declassification and endorsement. As a result, we need to track secret/untrusted information even through endorsements.

### Syntax and Semantics

#### Figure 17: Full NMIFC Syntax

- **Atomic Principals**: \( n \)
- **Variable Names**: \( x \)
- **Principal Operations**:
  - \( p \sqcup p \)
  - \( p \sqcap p \)
- **Types**:
  - \( \tau \)
  - \( \text{unit} \)
  - \( \forall X [pc]. \tau \)
  - \( \ell \text{ says } \tau \)
  - \( \tau_1 \times \tau_2 \)
  - \( \tau_1 + \tau_2 \)
  - \( X \)
- **Values**:
  - \( v \)
  - \( \langle v, v \rangle \)
  - \( \eta \ell v \)
  - \( \text{inji } v \)
- **Expressions**:
  - \( e \)
  - \( \lambda (x : \tau) [pc]. e \)
  - \( e_1 \, e_2 \)
  - \( \Lambda X [pc]. e \)
  - \( e \, \tau \)
  - \( \langle e, e \rangle \)
  - \( \eta \ell e \)
  - \( \text{inji } e \)
  - \( \text{bind } x = e \text{ in } e \)
  - \( \text{endorse } e \text{ to } \ell \)
  - \( \text{proji } e \)
  - \( \text{case } e \text{ of } \text{inj1}(x).e | \text{inj2}(x).e \)
  - \( \text{decl } e \text{ to } \ell \)

#### Figure 18: Full NMIFC Operational Semantics

- **Evaluation Contexts**:
  - \( E ::= [ \cdot ] \)
  - \( E ::= E[e] \)
  - \( E ::= E \, \tau \)
  - \( E ::= \langle E, e \rangle \)
  - \( E ::= \langle v, E \rangle \)
  - \( E ::= (\eta \ell E) \)
  - \( E ::= \text{inji } E \)
  - \( E ::= \text{bind } x = E \text{ in } e \)
  - \( E ::= \text{endorse } E \text{ to } \ell \)
  - \( E ::= \text{proji } E \)
  - \( E ::= \text{case } E \text{ of } \text{inj1}(x).e | \text{inj2}(x).e \)
  - \( E ::= \text{decl } E \text{ to } \ell \)

- **Operational Rules**:
  - \( (\lambda (x : \tau) [pc]. e) \, v \rightarrow e[x \mapsto v] \)
  - \( (\Lambda X [pc]. e) \, \tau \rightarrow e[X \mapsto \tau] \)
  - \( \text{proji } \langle v_1, v_2 \rangle \rightarrow v_i \)
  - \( \text{case } (\text{inji } v) \text{ of } \text{inj1}(x).e_1 | \text{inj2}(x).e_2 \rightarrow e_i[x \mapsto v] \)
  - \( \text{bind } x = (\eta \ell v) \text{ in } e \rightarrow e[x \mapsto v] \)
  - \( \langle e, t \rangle \rightarrow \langle e', t' \rangle \)
  - \( \langle E[e], t \rangle \rightarrow \langle E[e'], t' \rangle \)
  - \( \langle v, E \rangle \rightarrow \langle v, E' \rangle \)
  - \( \langle \eta \ell v, t \rangle \rightarrow \langle \eta \ell v, t; \eta \ell v \rangle \)
  - \( \langle \eta \ell v, t \rangle \rightarrow \langle \eta \ell v, t; \downarrow \rightarrow \ell', \eta \ell v \rangle \)
  - \( \langle \eta \ell v, t \rangle \rightarrow \langle \eta \ell v, t; \downarrow \leftarrow \ell', \eta \ell v \rangle \)

#### Figure 19: Type Protection Levels

- **Type Protection Level Rules**:
  - \( \vdash \ell \sqsubseteq \text{unit} \)
  - \( \vdash \ell' \sqsubseteq \ell \Rightarrow \vdash \ell' \sqsubseteq \ell \text{ says } \tau \)
  - \( \vdash \ell \sqsubseteq \tau_1 \) and \( \vdash \ell \sqsubseteq \tau_2 \) imply \( \vdash \ell \sqsubseteq (\tau_1 \times \tau_2) \)
  - \( H \in H \Rightarrow \vdash H \sqsubseteq \tau \)
  - \( \vdash \tau \sqsubseteq H \)
  - \( H \) is upward closed
  - \( \vdash \ell \sqsubseteq \tau \)

#### Figure 20: Typing Rules

- **Typing Rules**:
  - **Var**: \( \Gamma, x : \tau, \Gamma' ; pc \vdash x : \tau \)
  - **Unit**: \( \Gamma ; pc \vdash () : \text{unit} \)
  - **Lam**: \( \Gamma, x : \tau_1 ; pc' \vdash e : \tau_2 \Rightarrow \Gamma ; pc \vdash \lambda (x : \tau_1) [pc']. e : \tau_1 \rightarrow_{pc'} \tau_2 \)
  - **App**: \( \Gamma ; pc \vdash e_1 : \tau' \rightarrow_{pc'} \tau \) and \( \Gamma ; pc \vdash e_2 : \tau' \Rightarrow \Gamma ; pc \vdash e_1 \, e_2 : \tau \)
  - **TApp**: \( \Gamma ; pc \vdash e : \forall X [pc']. \tau \) and \( pc \sqsubseteq pc' \Rightarrow \Gamma ; pc \vdash e \, \tau' : \tau [X \mapsto \tau'] \) where \( \tau' \) is well-formed in \( \Gamma \)
  - **Pair**: \( \Gamma ; pc \vdash e_1 : \tau_1 \) and \( \Gamma ; pc \vdash e_2 : \tau_2 \Rightarrow \Gamma ; pc \vdash \langle e_1, e_2 \rangle : (\tau_1 \times \tau_2) \)
  - **UnPair**: \( \Gamma ; pc \vdash e : (\tau_1 \times \tau_2) \Rightarrow \Gamma ; pc \vdash \text{proji } e : \tau_i \)

#### Figure 21: Acts-For (Delegation) Relation

- **Acts-For (Delegation) Relation**:
  - \( p \succeq q \)

This structured and detailed presentation should make the content more accessible and professional.