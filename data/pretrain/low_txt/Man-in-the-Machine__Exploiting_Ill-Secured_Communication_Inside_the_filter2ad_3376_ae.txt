### Attacks Presented in This Paper

#### IPC Security
Windows named pipes have been a frequent target for security analysts. Despite the operating system providing Discretionary Access Control Lists (DACLs) to secure named pipes, the default security descriptor of a Windows named pipe allows anyone to read its content [38]. In some cases, developers may inadvertently grant write access to everyone, making the pipe vulnerable.

In such scenarios, even a remote attacker could potentially impersonate the pipe client to execute code or perform a denial-of-service attack [19, 20]. However, the server-impersonation and name-hijacking attacks described in our paper are not feasible for remote attackers.

Named pipes are also known to be susceptible to an impersonation attack [53], distinct from the client or server impersonation discussed in this paper. In this type of attack, the pipe server assumes the security context of its client, enabling it to act on behalf of the client. This attack requires the server and client processes to run as the same user or for the server to run with superuser privileges, which is a more stringent assumption than our threat model.

#### Vulnerabilities in Other IPC Mechanisms
Similar vulnerabilities have been identified in other Inter-Process Communication (IPC) mechanisms. Xing et al. [55] demonstrated that a malicious application on macOS and iOS can access another application's resources despite app isolation. The attack intercepts IPC in a manner similar to ours, but the malicious binary executes with the victim's privileges. Related issues have also been found in Android app isolation [22, 46].

The DNS rebinding vulnerability [26, 27, 31] mentioned in Sections 6.1 and 6.2 has simple solutions based on whitelisting. However, whitelisting approaches, such as Cross-Origin Resource Sharing (CORS) for HTTP, often lead to unsafe wildcard policies. Overly relaxed whitelists on locally running services can enable XMLHttpRequest from untrusted web applications, even without DNS rebinding. These attacks are similar to our client impersonation, but they originate from sandboxed code running in the web browser rather than from another user's session.

Automated detection and firewall-like defenses can help prevent attacks between users and applications on the same computer. Vijayakumar et al. [51] automate the detection of name-resolution vulnerabilities using dynamic analysis. A process firewall can prevent unauthorized cross-user resource access via system calls [52] and file and IPC squatting attacks [50]. The attacks presented in this paper could be mitigated by firewalls, although accurately whitelisting desirable interactions may become cumbersome.

#### Password Manager Security
Secure and usable integration of a password manager and a browser is a well-studied problem. Since the password manager is expected to autofill passwords into web forms, credentials are exposed to network attackers running malicious scripts on websites. Silver et al. [48] showed that autofill policies in some browsers allow a network attacker to steal credentials. Li et al. [37] found that password managers are vulnerable to traditional web vulnerabilities (e.g., XSS, CSRF), poor user-interface design, and poorly understood threat models. Unlike these remote attackers, our MitMa attacker exploits IPC communication within a single computer.

Several attempts have been made to create more secure password-manager architectures, specifically addressing autofill attacks [36] and offline cracking attacks [17]. While these efforts highlight the variety of threats that must be considered when designing a password manager, to our knowledge, there is little prior work addressing security issues arising within the computer.

#### USB Hardware Token Security
Hardware tokens can serve as a second authentication factor to protect against credential leaking, phishing, and man-in-the-middle attacks [35]. The security of these tokens has been studied under various threat models [14, 29, 33, 42]. Unlike the attacks described in these papers, our MitMa attacks do not require the attacker to physically access the hardware token or find a side channel.

### Conclusion
We analyzed the security of inter-process communication in the presence of a non-privileged malicious process on the same computer. The malicious process may belong to another user with login access or to a guest user. We discovered several vulnerabilities in security-critical applications, including password managers, two-factor authentication, and applications split into separate frontend and backend processes. While it is possible to use IPC securely, many applications either neglect the security of local communication or implement ad-hoc measures that are insufficient. As operating systems strive to isolate not only users but also applications, the importance of IPC security is expected to increase.

Following responsible disclosure, we reported the vulnerabilities discovered in this research project to the respective vendors, and we believe they have taken steps to prevent the attacks.

### Acknowledgments
This work originated from a collaborative research project with F-Secure. We are grateful to Alexey Kirichenko and others at F-Secure for their support and feedback. The research was partially funded by the CyberTrust program of DIMECC and Tekes (Business Finland) and by the Academy of Finland (project 296693).

### References
[1] 1Password. https://agilebits.com/onepassword.
[2] Blizzard. https://www.blizzard.com/.
[3] Dashlane. https://www.dashlane.com/.
[4] F-Secure Key. https://www.f-secure.com/en/web/home-global/key.
[5] Keybase. https://keybase.io/.
[6] Password Boss. https://www.passwordboss.com/.
[7] RoboForm. https://www.roboform.com/.
[8] Sticky Password. https://www.stickypassword.com/.
[9] Transmission. https://transmissionbt.com/.

... (additional references continue)

[55] Xing, L., Bai, X., Li, T., Wang, X., Chen, K., Liao, X., Hu, S.-M., & Han, X. (2015). Cracking app isolation on Apple: Unauthorized cross-app resource access on macOS. In Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security, CCS 2015 (pp. 31â€“43). ACM.

[56] Ylonen, T., & Lonvick, C. (2006). The Secure Shell (SSH) Protocol Architecture. RFC 4251, IETF.

[57] Yubico Developer Program. (2017). U2F Technical Overview. https://developers.yubico.com/U2F/Protocol_details/Overview.html.