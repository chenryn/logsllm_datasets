### Analysis of Emulated Malware and Control-Flow Graphs

Our analyzer successfully detected the emulator in all tested cases. The table below presents information about the extracted bytecode trace, from which we constructed the control-flow graph (CFG) using the extracted control-flow semantics of the bytecode language.

We do not provide a detailed breakdown of the syntax and semantic information of the bytecode instruction set here, as we found that the instruction sets consistently contain 31 instructions. However, the syntax of these instructions varied, indicating that the instruction sets were highly randomized. Manual analysis of the instruction set revealed that the semantics closely resembled those of Code Virtualizer, which is not surprising given that both tools are from the same vendor [22].

In all samples, the x86 CFG was significantly larger compared to the corresponding bytecode CFG, even though their program sizes and MD5 checksums varied. After analyzing these malware samples with Rotalumé, we observed that, unlike samples tested with Themida and VMProtect, these samples had large portions of their code converted into bytecode. The bytecode CFGs of these programs varied significantly, suggesting that they may be different programs despite sharing the same name.

### Discussion

In this section, we discuss three open problems and challenges: alternative emulator designs, incomplete bytecode reconstruction, and code analysis limitations.

#### Alternative Emulator Designs
Our current work assumes a decode-dispatch emulation model. Malware authors might implement variations or alternative approaches to evade our system [5], [16], [19], [30]. For example, our loop identification strategies (Section 3.3) are not directly applicable to malware emulators using a threaded approach. However, the methods for identifying candidate bytecode regions and virtual program counters (VPCs) remain applicable. As discussed in Section 2.2, our approach is also not suitable for dynamic translation-based emulation. In dynamic translation, the emulator dynamically generates new code, and we expect that heuristics used by unpackers to detect unpacked code will identify the translated instructions. From the translated code, a system could trace backward to find the translation routines and then use our methods to identify bytecode regions and VPCs. More generally, we believe that our fundamental ideas and techniques can be applied to other emulation models by analyzing an emulator’s execution trace to identify the bytecode region and discover the syntax and semantics of the bytecode instructions. The main challenge in future research is to identify observable and discernible run-time behavior exhibited by sophisticated emulation approaches.

Malware using decode-dispatch emulation may attempt to evade accurate analysis by targeting specific properties of our analysis. For example, since our approach expects each unique address in memory to hold only one abstract variable, an adversary may use the same location for different variables at different times to introduce imprecision in our analysis. Our system will group memory reads performed using these variables into the same cluster due to the conservativeness of our analysis. If the additional data included in the cluster containing the bytecode program is used in decode or dispatch-like behavior, they may be incorrectly identified as bytecode instructions.

#### Incomplete Bytecode Reconstruction
The second open problem is how to reconstruct complete information about the bytecode instruction syntax and semantics so that a system can extract the entire emulated malware bytecode program. Using dynamic analysis, we extracted execution paths in the bytecode program and the syntax and semantics of the bytecode instructions used in those paths. However, the paths may not have utilized all possible bytecode instructions supported by the emulator, even though they may be used in other execution paths of the program. A plausible approach would be to apply static analysis on the dispatch routine once our system has correctly identified the emulation phases. Specifically, once the dispatching method is identified, static analysis and symbolic execution may identify other execution routines and the opcodes of the bytecode instructions that invoke their dispatch, providing syntactic and semantic information of the bytecode instructions even if they are not part of the executed bytecode.

A subsequent open problem is utilizing the discovered syntax and semantics to completely convert bytecode to native instructions. This is only possible when all execution paths of the bytecode program can be explored. A potential solution is to use previous techniques for multi-path exploration [21] with the help of control-flow semantics identified in the bytecode. However, emulators may be written so that specific control-flow semantics need not be supported in the bytecode language. Such is the case for VMProtect, where we have only identified unconditional branches. In such bytecode languages, the effects of conditional branches are performed in the program by dynamically computing the target address based on the condition and then using an unconditional branch to the specific target (an example was provided in Figure 2). More research is required before multi-path exploration can be applied to programs written in such languages.

Another related problem is the use of recursive emulation, which converts the emulator itself to another bytecode language and introduces an additional emulator to emulate it. The recursive step can be performed multiple times by a malware author, with size and performance increases as the limiting factors. The solution is to first apply our reverse engineering method to the malware instance, use the discovered syntax and semantics to completely convert the bytecode program into native binary code, and then apply our method (recursively) on the converted program to identify any additional emulation-like behavior.

#### Code Analysis Limitations
As with all program analysis tasks, reverse engineering of emulators faces challenges such as heap analysis imprecision and limitations of loop detection. The techniques to address these problems are orthogonal to our techniques in reverse engineering.

### Related Work

Malware authors have developed obfuscation schemes designed to impede static analysis [8], [18], [25], [26]. Dynamic analysis approaches that treat malware as a black box can overcome these obfuscation schemes but can observe only a small number of execution paths. Several approaches have been proposed to address this limitation. Moser et al. proposed a scheme [21] that explored multiple paths during malware execution. Another approach [36] forces program execution along different paths but disregards consistent memory updates. In Rotalumé, these solutions are unable to properly analyze emulated malware because they will explore execution paths of the emulator rather than the bytecode program.

Malware authors have broadly applied packing to impede and evade malware detection and analysis. Several approaches based on the general unpacking idea have been proposed [14], [20], [27]. For example, Polyunpack performs universal unpacking based on a combination of static and dynamic binary analysis. Given a packed executable, Polyunpack first constructs a static view of the code. If the executable tries to execute any code that is not present in the static view, Polyunpack detects this as unpacked code.

Recently, we observed a new trend in using virtualizers or emulators such as Themida [24], Code Virtualizer [23], and VMProtect [35] to obfuscate malware. These emulators all use a basic interpretation model [31] and transform x86 program instructions into their own bytecode to hide the syntax and semantic of the original code and thwart program analysis. Moreover, by using a randomized instruction set for the bytecode language together with a polymorphic emulator, the reverse engineering effort will have to be applied to every new malware instance, making it very difficult to reuse the reverse-engineered information of one emulator for another. We argue that this trend will continue and that a large portion of malware in the near future will be emulation-based. There is no existing technique that can reliably counter an emulation-based obfuscation technique.

Researchers have proposed using a randomized instruction set with emulation as a software defense against code injection attacks. Kc et al. [15] and Barrantes et al. [4] developed approaches that converted a binary program’s native instructions into a per-process randomized instruction set. Since an adversary trying to exploit vulnerabilities will not have knowledge about the random instruction set, injected code will not run properly and will cause the program to crash. Subsequent work by Sovarel et al. [32] discussed the effectiveness of instruction set randomization techniques against various attacks.

There are research approaches for analysis and reverse engineering of bytecode for high-level languages such as Java [9], [33]. However, these approaches assume that the syntax and semantics of the bytecode are public or already known. This assumption fails to hold for malware constructed using emulators such as Themida, Code Virtualizer, or VMProtect [23], [24], [35]. These emulators perform a random translation from bytecode to destination ISA, so the connection between the bytecode and final ISA is unknown.

To overcome these emulation-based obfuscation techniques, we need analyzers that can reverse engineer the emulator model and extract the bytecode syntax and semantics. This is a new research area. In a related area, protocol reverse engineering techniques [7], [17], [37] have been proposed to understand network protocol formats by automatically extracting the syntax of the protocol messages. Tupni [10] automatically reverse engineers the formats of all general inputs to a program. The analysis techniques for extracting the input or network message syntax assume that they can be found at predefined locations in the program. In contrast, one of the main challenges in malware emulator analysis is to find where the bytecode program resides.

### Conclusion

In this paper, we presented a new approach for automatic reverse engineering of malware emulators. We described the algorithms and techniques to extract a bytecode trace and compute the syntax and semantics of the bytecode instructions by dynamically analyzing a decode-dispatch-based emulator. We developed Rotalumé, a proof-of-concept system, and evaluated it on synthetic and real programs obfuscated with Code Virtualizer and VMProtect. The results showed that Rotalumé was able to extract bytecode traces and syntax and semantic information. For future work, we plan to address the challenges of reverse engineering other types of emulators. We also plan to develop algorithms to extract higher-level instruction semantics that include data-flow information and to completely convert an extracted bytecode trace back to x86 form. We hope that our work will help spawn research in several other related areas, such as reverse engineering of script interpreters.

### Acknowledgments

The authors would like to thank Paul Royal for providing the malware samples used in our experiments and the anonymous reviewers for their constructive feedback. This material is based upon work supported in part by the National Science Foundation under grants no. 0716570 and 0831300 and the Department of Homeland Security under contract no. FA8750-08-2-0141. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the National Science Foundation or the Department of Homeland Security.

### References

[1] A. Aho, M. Lam, R. Sethi, and J. Ullman. Compilers—Principles, Techniques, & Tools. Addison Wesley, 2006.
[2] Avira Antivirus. http://www.free-av.com. Last accessed Mar. 6, 2009.
[23] Oreans Technologies: Code Virtualizer. http://www.oreans.com/codevirtualizer.php. Last accessed Mar. 6, 2009.
[24] Oreans Technologies: Themida. http://www.oreans.com/. Last accessed Mar. 6, 2009.
[25] S. Pearce. Viral polymorphism. Technical report, VX Heavens, 2003.
[26] I. V. Popov, S. K. Debray, and G. R. Andrews. Binary obfuscation using signals. In Proceedings of the USENIX Security Symposium, 2007.
[27] P. Royal, M. Halpin, D. Dagon, R. Edmonds, and W. Lee. PolyUnpack: Automating the hidden-code extraction of unpack-executing malware. In Proceedings of the Annual Computer Security Applications Conference (ACSAC), 2006.
[28] M. Sharif, A. Lanzi, J. Griffin, and W. Lee. Rotalumé: A tool for automatically reverse engineering malware emulators. Technical Report GT-CS-09-05, School of Computer Science, Georgia Institute of Technology, 2009. http://www.cc.gatech.edu/research/reports/GT-CS-09-05.pdf.
[29] Silicon Realms. Armadillo/software passport professional. http://siliconrealms.com/. Last accessed Mar. 6, 2009.
[30] R. L. Sites, A. Chernoff, M. B. Kerk, M. P. Marks, and S. G. Robinson. Binary translation. Communication of the ACM, 36(2), Feb. 1993.
[31] J. E. Smith and R. Nair. Virtual Machines: Versatile platforms for systems and processes. Morgan Kaufmann, 2005.
[32] A. N. Sovarel, D. Evans, and N. Paul. Where’s the FEEB? the effectiveness of instruction set randomization. In Proceedings of the USENIX Security Symposium, 2005.
[33] R. Stata and M. Abadi. A type system for Java bytecode subroutines. ACM Transactions on Programming Languages and Systems (TOPLAS), 21(1), Jan. 1999.
[34] Virus Total. http://www.virustotal.com/. Last accessed Mar. 6, 2009.
[35] VMPsoft VMProtect. http://www.vmprotect.ru/. Last accessed Mar. 6, 2009.
[36] J. Wilhelm and T.-c. Chiueh. A forced sampled execution approach to kernel rootkit identification. In Proceedings of the International Symposium on Recent Advances in Intrusion Detection (RAID), 2007.
[37] G. Wondracek, C. Kruegel, and E. Kirda. Automatic network protocol analysis. In Proceeding of the Annual Network and Distributed System Security Symposium (NDSS), 2008.
[38] H. Yin, D. Song, M. Egele, C. Kruegel, and E. Kirda. Panorama: Capturing system-wide information flow for malware detection and analysis. In Proceedings of the ACM Conference on Computer and Communications Security (CCS), 2007.
[3] G. Balakrishnan and T. Reps. Recovery of variables and heap structure in x86 executables. Technical Report 1533, Computer Sciences Department, University of Wisconsin–Madison, 2005.
[4] E. G. Barrantes, D. H. Ackley, S. Forrest, T. S. Palmer, D. Stefanovic, and D. D. Zovi. Randomized instruction set emulation to disrupt binary code injection attacks. In Proceedings of the ACM Conference on Computer and Communications Security (CCS), 2003.
[5] J. R. Bell. Threaded code. Communications of the ACM, 16(6), June 1973.
[6] F. Bellard. QEMU, a fast and portable dynamic translator. In USENIX Annual Technical Conference, 2005.
[7] J. Caballero, H. Yin, Z. Liang, and D. Song. Polyglot: Automatic extraction of protocol format using dynamic binary analysis. In Proceedings of the ACM Conference on Computer and Communications Security (CCS), 2007.
[8] C. Collberg, C. Thomborson, and D. Low. Manufacturing cheap, resilient, and stealthy opaque constructs. In Proceedings of the ACM Symposium on Principles of Programming Languages (POPL), 1998.
[9] J. J. Cook. Reverse execution of Java bytecode. The Computer Journal, 45(6), 2002.
[10] W. Cui, M. Peinado, K. Chen, H. Wang, and L. Irun-Briz. Tupni: Automatic reverse engineering of input formats. In Proceedings of the ACM Conference on Computer and Communications Security, 2008.
[11] E. H. Debaere and J. M. V. Campenhout. Interpretation and Instruction Path Coprocessing. MIT Press, Cambridge, MA, 1990.
[12] A. Dinaburg, P. Royal, M. Sharif, and W. Lee. Ether: Malware analysis via hardware virtualization extensions. In Proceedings of the ACM Conference on Computer and Communications Security (CCS), 2008.
[13] The IDA Pro Disassembler and Debugger. http://www.hex-rays.com/idapro/. Last accessed Mar. 6, 2009.
[14] M. G. Kang, P. Poosankam, and H. Yin. Renovo: a hidden code extractor for packed executables. In Proceedings of the ACM Workshop on Recurring Malcode (WORM), 2007.
[15] G. S. Kc, A. D. Keromytis, and V. Prevelakis. Countering code-injection attacks with instruction-set randomization. In Proceedings of the ACM Conference on Computer and Communications Security (CCS), 2003.
[16] P. Klint. Interpretation techniques. Software Practice and Experience, 11(9), Sept. 1981.
[17] Z. Lin, D. Xu, and X. Zhang. Automatic protocol format reverse engineering through context-aware monitored execution. In Proceeding of the Annual Network and Distributed System Security Symposium (NDSS), 2008.
[18] C. Linn and S. Debray. Obfuscation of executable code to improve resistance to static disassembly. In Proceedings of the ACM Conference on Computer and Communications Security (CCS), 2003.
[19] P. S. Magnusson and D. Samuelsson. A compact intermediate format for SimICS. Technical report, Swedish Institute of Computer Science, 1994.
[20] L. Martignoni, M. Christodorescu, and S. Jha. OmniUnpack: Fast, generic, and safe unpacking of malware. In Proceedings of the Annual Computer Security Applications Conference (ACSAC), 2007.
[21] A. Moser, C. Kruegel, and E. Kirda. Exploring multiple execution paths for malware analysis. In Proceedings of the IEEE Symposium of Security and Privacy, 2007.
[22] Oreans Technologies. http://www.oreans.com/. Last accessed Mar. 6, 2009.