### Figures and Captions

**Figure 9: Relative Control-Flow Graph (CFG) Size of Tinba Malware**
- **Y-Axis:** Relative CFG Size
- **X-Axis:** Time (min)
- **Description:** The figure shows the relative size of the control-flow graph (CFG) for the Tinba malware, with the first wave of dynamically generated code and code injections marked.

**Figure 10: Relative Control-Flow Graph (CFG) Size of Gapz Malware**
- **Y-Axis:** Relative CFG Size
- **X-Axis:** Time (min)
- **Description:** The figure shows the relative size of the control-flow graph (CFG) for the Gapz malware, with the first wave of dynamically generated code and code injections marked.

### 7.5 Relevance of Approach on Recent Malware

To demonstrate the relevance of our approach, we matched Tartarus with a recent collection of malware samples. Specifically, we analyzed 934 Portable Executable (PE) files submitted to VirusTotal in April and May of 2017. Each sample was flagged as malicious by at least 40 anti-malware vendors. We evaluated the effectiveness of our approach by counting the number of processes into which each sample injected code and whether it used code-reuse attacks. Each sample was executed for 600 seconds.

We found that 373 samples (approximately 40% of the total) injected code into other processes. In contrast, a report from Palo Alto Networks on new and evasive malware from March 2013 [33] indicated that code injection was observed in only 13.5% of samples. This represents an almost threefold increase over four years. Among the 373 samples, 223 injected code into four or fewer processes, and 120 samples used code-reuse attacks as part of their code injection. In 118 of these cases, only one code-reuse attack was used, while in the remaining two cases, a chain of two code-reuse attacks was employed. This suggests that while code injection is increasingly common, chained code-reuse attacks within code injections remain rare.

### 8. Limitations and Future Work

In this work, we focused on tracing malware propagations within the host and identifying code injections and code waves, with special attention to the use of code-reuse attacks. Here, we discuss the limitations of our approach and some of the remaining challenges in capturing and describing malware propagations.

**Limitation 1: Single System Execution**
Our approach currently considers malware propagations that occur within a single system execution. However, some malware, such as Gapz, employ propagation strategies that span multiple system reboots. For example, Gapz injects into `explorer.exe`, drops a bootkit, and modifies the master boot record (MBR) or volume boot record (VBR). During the next boot, the modified MBR or VBR loads the bootkit, allowing Gapz to continue its execution. Dynamic analysis of this behavior requires extending the analysis over several system boots, which has not been done before. Further research could explore how much additional information can be automatically leveraged with this approach.

**Limitation 2: Multiprocessor Environment**
Our current techniques assume a single-core execution environment. While we believe the identification of code injections and code waves can follow similar strategies in a multi-core guest environment, Tartarus has not yet been tested in such a setting. In a multi-core environment, we would need to manage many more parallel execution contexts, and the order of the malware execution trace may not be reliable.

**Limitation 3: Control-Flow Within Code Waves**
We focused on identifying control-flow aspects between processes based on code injections and code waves. However, we have not extensively examined the control-flow within each code wave. In most cases, we can identify the control-flow within a code wave from the instruction execution order and disassembly. If a malware sample writes memory to another process with multiple independent entry points, our approach will recognize only one code injection and consider the written memory as a single code wave. A more accurate approach would be to discover multiple code injections within the same code wave, which would provide a more precise understanding of the control-flow. One potential strategy is to refine the definition of a code wave, similar to Ugarte et al. who divide the memory of a code wave into unpacking frames. However, this would require relaxing our code injection identification and may introduce false positives in the control-flow graph.

**Limitation 4: Detection of Dynamic Analysis**
Malware can detect the use of dynamic analysis, a problem shared by any dynamic analysis environment. For example, malware can detect the presence of QEMU and alter its behavior to avoid detection. We do not currently implement countermeasures against such detection. Techniques to harden QEMU for malware analysis exist, but they are not a general solution. To make it harder for malware to detect the analysis environment, one approach is to use more transparent dynamic analysis environments, such as Ether [12], which utilize hardware virtualization extensions.

**Fundamental Limitation: Taint Analysis**
Our techniques rely on taint analysis for capturing malware propagation, inheriting the limitations of taint analysis. Attackers can deploy information-flow evasive behaviors to avoid analysis. Techniques like multipath exploration via symbolic execution can help defeat evasive behaviors, but exploring the entire state space of most malware samples is infeasible. Therefore, the key challenge is identifying evasive behaviors. Once detected, various techniques, including symbolic execution, can guide the analysis down the path of interest. For a more detailed discussion on the limitations of taint analysis in malware analysis, see Cavallaro et al. [7].

### 9. Related Work

Dynamic taint analysis has numerous applications in automating malware analysis tasks. Panorama by Yin et al. [46] was the first to propose system-wide fine-grained malware analysis using taint information. Built on QEMU, Panorama offers features like keylogger detection and malware tracing. Tartarus differs from Panorama by considering code-reuse attacks and initially tainting more memory. Panorama does not abstract the execution trace, while Tartarus abstracts it into code waves and code injections to construct a system-wide control-flow graph (CFG). The evaluation in this work is the first to focus on taint analysis for malware tracing.

Other related work includes Egele et al. [13] using dynamic taint analysis for spyware detection and Moser et al. [32] combining dynamic taint analysis with linear constraint solvers to explore multiple execution paths in malware. TaintDroid [14] and DroidScope [44] have explored dynamic taint analysis in Android. SemTrax [26] uses dynamic taint analysis to aid manual reverse engineering by visualizing relationships on tainted data.

Full-system dynamic binary analysis platforms, such as DECAF [20] and PANDA, have gained attention in malware analysis. DECAF, built on QEMU, performs fast and bitwise taint analysis. PANDA records non-deterministic data for replay, allowing stepwise analysis. S2E [9] focuses on augmenting symbolic execution with full-system analysis, using an x86-to-LLVM QEMU backend and the KLEE symbolic execution engine.

Automated unpackers and tools for handling self-modifying code include Codisasm [5], Ugarte et al. [40], Renovo [22], OmniUnpack [30], EtherUnpack [12], RePEconstruct [24], and Polyunpack [37]. These tools monitor write-then-execute patterns, with varying levels of granularity.

Memory forensics, such as Volatility [15], provides solutions for identifying how malware infects a system. Unlike memory forensics, which relies on snapshots, our approach analyzes the execution, making it possible to observe the execution of shellcode even if the original instructions are restored.

### 10. Conclusion

In this paper, we addressed the automatic analysis of host-based malware propagations, dividing the problem into two tasks: tracing malware across multiple processes and code-reuse attacks, and raising the collected execution trace into higher-level semantics of dynamically generated code and code injections.

We proposed three techniques and implemented them in Tartarus, a malware analysis environment that traces malware execution using taint analysis and a model of code-reuse attacks. Tartarus abstracts the execution trace into code waves and identifies intrinsic characteristics of code injection techniques, combining these abstractions into a system-wide control-flow graph.

We tested Tartarus with ground-truth applications and showed that it accurately captures malware propagations without prior knowledge. Our comparative evaluation demonstrated that Tartarus improves the capture of malware execution traces over state-of-the-art dynamic analysis tools. We also evaluated Tartarus's performance, which ranges from a few minutes to 15 minutes depending on the sample's complexity. Finally, we demonstrated the relevance of our approach by matching Tartarus with a recent malware dataset, showing that the number of malware samples injecting code has increased almost threefold since 2013.

### Acknowledgments

The authors would like to thank our anonymous reviewers, Pedro Antonino, and Julien Vanegue for their valuable feedback and insightful critiques. We also thank VirusTotal for providing malware samples and Udi Yavo and Tal Liberman of enSilo for sharing their code injection techniques. Special thanks to Xunchao Hu for his assistance with DECAF. This work is funded by the National Science Foundation Grant #1664315 and DARPA Grant #FA8750-16-C-0044.

### References

[1] Andrea Allievi and Holger Unterbrink. 2015. CryptoWall 4: The Evolution Continues. (2015).

[2] Magal Baz and Or Safran. 2017. Dridex’s Cold War: Enter AtomBombing. (2017).

[3] Fabrice Bellard. 2005. QEMU, a Fast and Portable Dynamic Translator. In Proceedings of the Annual Conference on USENIX Annual Technical Conference (ATEC '05). USENIX Association, Berkeley, CA, USA, 41–41. <http://dl.acm.org/citation.cfm?id=1247360.1247401>

[4] Tyler Bletsch, Xuxian Jiang, Vince W. Freeh, and Zhenkai Liang. 2011. Jump-oriented Programming: A New Class of Code-reuse Attack. In Proceedings of the 6th ACM Symposium on Information, Computer and Communications Security (ASIACCS '11). ACM, New York, NY, USA, 30–40. <https://doi.org/10.1145/1966913.1966919>

[5] Guillaume Bonfante, Jose Fernandez, Jean-Yves Marion, Benjamin Rouxel, Fabrice Sabatier, and Aurélien Thierry. 2015. CoDisasm: Medium Scale Concatic Disassembly of Self-Modifying Binaries with Overlapping Instructions. In Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security (CCS '15). ACM, New York, NY, USA, 745–756. <https://doi.org/10.1145/2810103.2813627>

[6] Erik Buchanan, Ryan Roemer, Hovav Shacham, and Stefan Savage. 2008. When Good Instructions Go Bad: Generalizing Return-oriented Programming to RISC. In Proceedings of the 15th ACM Conference on Computer and Communications Security (CCS '08). ACM, New York, NY, USA, 27–38. <https://doi.org/10.1145/1455770.1455776>

[7] Lorenzo Cavallaro, Prateek Saxena, and R. Sekar. 2008. On the Limits of Information Flow Techniques for Malware Analysis and Containment. In Proceedings of the 5th International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment (DIMVA '08). Springer-Verlag, Berlin, Heidelberg, 143–163. <https://doi.org/10.1007/978-3-540-70542-0_8>

[8] Stephen Checkoway, Ariel J. Feldman, Brian Kantor, J. Alex Halderman, Edward W. Felten, and Hovav Shacham. 2009. Can DREs Provide Long-lasting Security? The Case of Return-oriented Programming and the AVC Advantage. In Proceedings of the 2009 Conference on Electronic Voting Technology/Workshop on Trustworthy Elections (EVT/WOTE'09). USENIX Association, Berkeley, CA, USA, 6–6.

[9] Vitaly Chipounov, Volodymyr Kuznetsov, and George Candea. 2012. The S2E Platform: Design, Implementation, and Applications. ACM Trans. Comput. Syst. 30, 1, Article 2 (Feb. 2012), 49 pages. <https://doi.org/10.1145/2110356.2110358>

[10] Lucas Davi, Ahmad-Reza Sadeghi, Daniel Lehmann, and Fabian Monrose. 2014. Stitching the Gadgets: On the Ineffectiveness of Coarse-grained Control-Flow Integrity Protection. In Proceedings of the 23rd USENIX Conference on Security.