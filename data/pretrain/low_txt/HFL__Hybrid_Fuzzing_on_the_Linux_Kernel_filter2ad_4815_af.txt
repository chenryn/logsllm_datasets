以下是经过优化的文本，使其更加清晰、连贯和专业：

---

**参考文献**

[1] "Sanitizer," https://github.com/google/kmsan, 2018.

[2] "Undefined Behavior Sanitizer," https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html, 2018.

[3] T. Avgerinos, A. Rebert, S. K. Cha, and D. Brumley, "Enhancing symbolic execution with veritesting," in Proceedings of the 36th International Conference on Software Engineering (ICSE), Hyderabad, India, May–June 2014.

[4] R. Baldoni, E. Coppa, D. C. D'Elia, C. Demetrescu, and I. Finocchi, "A survey of symbolic execution techniques," ACM Computing Surveys (CSUR), vol. 51, no. 3, p. 50, 2018.

[5] R. Baldoni, E. Coppa, D. C. D'Elia, C. Demetrescu, and I. Finocchi, "A survey of symbolic execution techniques," ACM Computing Surveys (CSUR), vol. 51, no. 3, pp. 1–39, 2018.

[6] C. Cadar, D. Dunbar, D. R. Engler et al., "Klee: Unassisted and automatic generation of high-coverage tests for complex systems programs," in Proceedings of the 8th USENIX Symposium on Operating Systems Design and Implementation (OSDI), San Diego, CA, December 2008.

[7] C. Cadar, V. Ganesh, P. Pawlowski, D. Dill, and D. Engler, "EXE: A system for automatically generating inputs of death using symbolic execution," in Proceedings of the 13th ACM Conference on Computer and Communications Security (CCS), Alexandria, VA, October–November 2006.

[8] C. Cadar and K. Sen, "Symbolic execution for software testing: three decades later," Communications of the ACM, vol. 56, no. 2, pp. 82–90, 2013.

[9] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley, "Unleashing mayhem on binary code," in Proceedings of the 33rd IEEE Symposium on Security and Privacy (Oakland), San Francisco, CA, May 2012.

[10] V. Chipounov, V. Kuznetsov, and G. Candea, "S2E: A platform for in-vivo multi-path analysis of software systems," ACM SIGPLAN Notices, vol. 46, no. 3, pp. 265–278, 2011.

[11] J. Corina, A. Machiry, C. Salls, Y. Shoshitaishvili, S. Hao, C. Kruegel, and G. Vigna, "Difuze: Interface-aware fuzzing for kernel drivers," in Proceedings of the 24th ACM Conference on Computer and Communications Security (CCS), Dallas, TX, October–November 2017.

[12] EPFL, "S2E: Selective Symbolic Execution Platform," http://s2e.systems/docs/Howtos/Coverage/index.html, 2018.

[13] The Linux Foundation, "LLVMLinux," https://wiki.linuxfoundation.org/llvmlinux, 2017.

[14] D. Gens, S. Schmitt, L. Davi, and A.-R. Sadeghi, "K-Miner: Uncovering memory corruption in Linux," in Proceedings of the 2018 Annual Network and Distributed System Security Symposium (NDSS), San Diego, CA, February 2018.

[15] P. Godefroid, M. Y. Levin, and D. Molnar, "SAGE: Whitebox fuzzing for security testing," Queue, vol. 10, no. 1, p. 20, 2012.

[16] Google, "ClusterFuzz: All Your Bug Are Belong to Us," https://github.com/google/clusterfuzz, 2019.

[17] NCC Group, "Triforce Linux Syscall Fuzzer," https://github.com/nccgroup/TriforceLinuxSyscallFuzzer, 2016.

[18] I. Haller, A. Slowinska, M. Neugschwandtner, and H. Bos, "Dowsing for overflows: A guided fuzzer to find buffer boundary violations," in Proceedings of the 22nd USENIX Security Symposium (Security), Washington, DC, August 2013.

[19] H. Han and S. K. Cha, "IMF: Inferred model-based fuzzer," in Proceedings of the 24th ACM Conference on Computer and Communications Security (CCS), Dallas, TX, October–November 2017.

[20] Intel, "Circumventing Fuzzing Roadblocks with Compiler Transformations," https://lafintel.wordpress.com/2016/08/15/circumventing-fuzzing-roadblocks-with-compiler-transformations/, 2016.

[21] D. R. Jeong, K. Kim, B. Shivakumar, B. Lee, and I. Shin, "Razzer: Finding kernel race bugs through fuzzing," in Proceedings of the 38th IEEE Symposium on Security and Privacy (Oakland), San Francisco, CA, May 2019.

[22] D. Jones, "Trinity: Linux System Call Fuzzer," https://github.com/kernelslacker/trinity, 2011.

[23] S. Y. Kim, S. Lee, I. Yun, W. Xu, B. Lee, Y. Yun, and T. Kim, "Cab-Fuzz: Practical concolic testing techniques for COTS operating systems," in Proceedings of the 2017 USENIX Annual Technical Conference (ATC), Santa Clara, CA, July 2017.

[24] G. Klees, A. Ruef, B. Cooper, S. Wei, and M. Hicks, "Evaluating fuzz testing," in Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security, ACM, 2018, pp. 2123–2138.

[25] Y. Li, B. Chen, M. Chandramohan, S.-W. Lin, Y. Liu, and A. Tiu, "Steelix: Program-state based binary fuzzing," in Proceedings of the 16th European Software Engineering Conference (ESEC) / 25th ACM SIGSOFT Symposium on the Foundations of Software Engineering (FSE), Paderborn, Germany, September 2017.

[26] A. Machiry, C. Spensky, J. Corina, N. Stephens, C. Kruegel, and G. Vigna, "Dr. Checker: A soundy analysis for Linux kernel drivers," in 26th USENIX Security Symposium (USENIX Security 17), 2017, pp. 1007–1024.

[27] R. Majumdar and K. Sen, "Hybrid concolic testing," in Proceedings of the 29th International Conference on Software Engineering (ICSE), Minneapolis, MN, May 2007.

[28] S. Pailoor, A. Aday, and S. Jana, "Moonshine: Optimizing OS fuzzer seed selection with trace distillation," in Proceedings of the 27th USENIX Security Symposium (Security), Baltimore, MD, USA, August 2018.

[29] B. S. Pak, "Hybrid fuzz testing: Discovering software bugs via fuzzing and symbolic execution," School of Computer Science, Carnegie Mellon University, 2012.

[30] J. Pan, G. Yan, and X. Fan, "DigTool: A virtualization-based framework for detecting kernel vulnerabilities," in 26th USENIX Security Symposium (USENIX Security 17), 2017, pp. 149–165.

[31] H. Peng, Y. Shoshitaishvili, and M. Payer, "T-Fuzz: Fuzzing by program transformation," in SP18.

[32] D. A. Ramos and D. R. Engler, "Under-constrained symbolic execution: Correctness checking for real code," in Proceedings of the 24th USENIX Security Symposium (Security), Washington, DC, August 2015.

[33] S. Rawat, V. Jain, A. Kumar, L. Cojocar, C. Giuffrida, and H. Bos, "VUZZER: Application-aware evolutionary fuzzing," in Proceedings of the 2017 Annual Network and Distributed System Security Symposium (NDSS), San Diego, CA, February–March 2017.

[34] Rode0day, "Archived Results: Final Scores for Rode0day-18.10," https://rode0day.mit.edu/results/4, 2018.

[35] S. Schumilo, C. Aschermann, R. Gawlik, S. Schinzel, and T. Holz, "KAFL: Hardware-assisted feedback fuzzing for OS kernels," in Proceedings of the 26th USENIX Security Symposium (Security), Vancouver, BC, Canada, August 2017.

[36] K. Sen, D. Marinov, and G. Agha, "CUTE: A concolic unit testing engine for C," in ACM SIGSOFT Software Engineering Notes, vol. 30, no. 5, ACM, 2005, pp. 263–272.

[37] Y. Shoshitaishvili, C. Kruegel, G. Vigna, R. Wang, C. Salls, N. Stephens, M. Polino, A. Dutcher, J. Grosen, S. Feng et al., "SoK: (State of) the art of war: Offensive techniques in binary analysis," in Proceedings of the 37th IEEE Symposium on Security and Privacy (Oakland), San Jose, CA, May 2016.

[38] D. Song, F. Hetzelt, D. Das, C. Spensky, Y. Na, S. Volckaert, G. Vigna, C. Kruegel, J.-P. Seifert, and M. Franz, "Periscope: An effective probing and fuzzing framework for the hardware-OS boundary," in Proceedings of the 2019 Annual Network and Distributed System Security Symposium (NDSS), San Diego, CA, February 2019.

[39] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta, Y. Shoshitaishvili, C. Kruegel, and G. Vigna, "Driller: Augmenting fuzzing through selective symbolic execution," in Proceedings of the 2016 Annual Network and Distributed System Security Symposium (NDSS), San Diego, CA, February 2016.

[40] Y. Sui and J. Xue, "SVF: Interprocedural static value-flow analysis in LLVM," in Proceedings of the 25th International Conference on Compiler Construction, ACM, 2016.

[41] D. Vyukov, "Syzkaller," https://github.com/google/syzkaller, 2015.

[42] P. Wang, J. Krinke, K. Lu, G. Li, and S. Dodier-Lazaro, "How double-fetch situations turn into double-fetch vulnerabilities: A study of double fetches in the Linux kernel," in 26th USENIX Security Symposium (USENIX Security 17), 2017, pp. 1–16.

[43] W. Wang, K. Lu, and P.-C. Yew, "Check it again: Detecting lacking-recheck bugs in OS kernels," in Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security, ACM, 2018, pp. 1899–1913.

[44] V. M. Weaver and D. Jones, "Perf Fuzzer: Targeted fuzzing of the perf event open() system call," Technical Report UMAINEVMW-TR-PERF-FUZZER, University of Maine, Tech. Rep., 2015.

[45] M. Xu, C. Qian, K. Lu, M. Backes, and T. Kim, "Precise and scalable detection of double-fetch bugs in OS kernels," in 2018 IEEE Symposium on Security and Privacy (SP), IEEE, 2018, pp. 661–678.

[46] I. Yun, S. Lee, M. Xu, Y. Jang, and T. Kim, "QSYM: A practical concolic execution engine tailored for hybrid fuzzing," in Proceedings of the 27th USENIX Security Symposium (Security), Baltimore, MD, USA, August 2018.

[47] M. Zalewski, "American Fuzzy Lop," http://lcamtuf.coredump.cx/afl, 2014.

[48] L. Zhao, Y. Duan, H. Yin, and J. Xuan, "Send hardest problems my way: Probabilistic path prioritization for hybrid fuzzing," in Proceedings of the 2019 Annual Network and Distributed System Security Symposium (NDSS), San Diego, CA, February 2019.

[49] Y. Zheng, A. Davanian, H. Yin, C. Song, H. Zhu, and L. Sun, "Firm-AFL: High-throughput greybox fuzzing of IoT firmware via augmented process emulation," in 28th USENIX Security Symposium (USENIX Security 19), 2019, pp. 1099–1114.

---

**附录**

**A. 静态依赖分析**

表VII展示了我们静态依赖分析的结果。从技术角度来看，我们的静态指针分析方法借鉴了Razzer [26]的方法。具体来说，我们根据子系统分类对内核源代码进行分区，并在每个分区上分别进行分析。这种分区方法不仅显著减轻了分析开销，还将每个分区适当地归类到相应的系统调用类别中。考虑到这些因素，我们认为这种方法能够有效地识别出符合我们目的的潜在依赖关系，尽管由于跨分区的依赖关系缺失可能会导致一些假阴性结果。由于这种分析在我们的工作中是一次性的任务，因此其非微不足道的开销不会影响HFL的整体性能。

| 类别 | 分析目标 | 大小 (.bc) | 分析时间 (小时) | 候选对数量 |
|------|-----------|-------------|------------------|--------------|
| 文件系统 | fs/ | 75 MB | 7 | 110 K |
| 网络 | net/ | 255 MB | 90 | 530 K |
| 驱动程序 | drivers/ | 322 MB | 83 | 460 K |

**B. 混合模糊测试统计**

表VIII详细说明了覆盖实验（§VI-B3）中的混合特定特征。表中，Prog和ProgS分别表示具体执行和符号执行的程序。第四列InputS表示由符号执行新生成的输入程序。一个值得注意的现象是，在符号执行的程序（ProgS）中，有相当一部分并未产生新的输入，尽管它们应该触发特定路径上的紧分支。这主要是由于内部内核实例的非确定状态不在我们的控制范围内。如第五列和第六列所示，正如预期的那样，新的输入程序（InputS）不仅贡献了新的代码路径（即Input'S），还对未来输入生成产生了显著影响，从而提高了覆盖率。这是因为这些新的输入会被推入语料库并作为变异的来源重新使用，从而帮助触发其他新的路径。

| 类别 | 具体执行的程序 (Prog) | 符号执行的程序 (ProgS) | 新生成的输入 (InputS) | 实际贡献的新路径 (Input'S) |
|------|------------------------|------------------------|-----------------------|----------------------------|
| 文件系统 | 4.6 M | 1,526 | 521 | 343 |
| 网络 | 5.1 M | 2,121 | 1,225 | 632 |
| 驱动程序 | 5.0 M | 2,034 | 1,472 | 851 |

**表IX：已知漏洞列表**

| 内核版本 | 组件 | 漏洞类型 | 描述 |
|----------|------|----------|------|
| 4.19-rc8 | fs/xfs/xfs_message.c | 整数溢出 | 整数溢出 |
| 4.17.19 | fs/btrfs/ctree.c | 整数溢出 | 整数溢出 |
| 4.19-rc8 | net/core/skbuff.c | 整数溢出 | 整数溢出 |
| 5.0-rc2 | fs/open.c | 未定义行为 | 未定义行为 |
| 4.18.20 | __alloc_pages_slowpath | 警告 | 警告 |
| 4.20.0 | truncate_inode_pages_range | 任务挂起 | 任务挂起 |
| 4.19-rc2 | __ext4_handle_dirty_metadata | 警告 | 警告 |
| 4.19-rc2 | usb_submit_urb | 警告 | 警告 |
| 4.18-rc4 | alloc_vmap_area | 无法处理内核分页请求 | 无法处理内核分页请求 |
| 4.20.2 | net/core/sock.c | 未定义行为 | 未定义行为 |
| 4.17.19 | blk_mq_get_tag | 任务挂起 | 任务挂起 |
| 4.17.19 | __fdget_pos | 任务挂起 | 任务挂起 |
| 5.0-rc2 | __flush_work | 任务挂起 | 任务挂起 |

**表X：HFL中使用的工具修改**

| 工具 | 组件 | 代码行数 | 语言 |
|------|------|---------|------|
| syzkaller | Fuzzer | 840 | Go |
| s2e-2.0 | 符号分析器 | 420 | C++ |
| gcc-7.3 | 内核转换器 | 820 | C |
| 协调器 | - | 480 | Python |

注：协调器在模糊器和符号分析器之间的通信中起到粘合剂的作用（例如，用户程序转换）。

---