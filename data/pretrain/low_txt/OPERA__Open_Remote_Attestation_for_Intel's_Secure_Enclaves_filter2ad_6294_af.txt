### 文献引用

1. Mona Vij. 2018. Integrating Remote Attestation with Transport Layer Security. CoRR abs/1801.05863 (2018). arXiv:1801.05863. [链接](http://arxiv.org/abs/1801.05863)

2. Arseny Kurnikov, Klaudia Krawiecka, Andrew Paverd, Mohammad Mannan, and N. Asokan. 2018. Using SafeKeeper to Protect Web Passwords. In Companion Proceedings of the The Web Conference 2018 (WWW ’18). International World Wide Web Conferences Steering Committee, Republic and Canton of Geneva, Switzerland.

3. Dmitrii Kuvaiskii, Oleksii Oleksenko, Sergei Arnautov, Bohdan Trach, Pramod Bhatotia, Pascal Felber, and Christof Fetzer. 2017. SGXBOUNDS: Memory Safety for Shielded Execution. In 12th European Conference on Computer Systems. ACM.

4. Sinisa Matetic, Mansoor Ahmed, Kari Kostiainen, Aritra Dhar, David Sommer, Arthur Gervais, Ari Juels, and Srdjan Capkun. 2017. ROTE: Rollback Protection for Trusted Execution. In 26th USENIX Security Symposium (USENIX Security 17). Vancouver, BC.

5. Frank McKeen, Ilya Alexandrovich, Alex Berenzon, Carlos Rozas, Hisham Shafi, Vedvyas Shanbhogue, and Uday Savagaonkar. 2013. Innovative Instructions and Software Model for Isolated Execution. In 2nd International Workshop on Hardware and Architectural Support for Security and Privacy. ACM.

6. Olga Ohrimenko, Felix Schuster, Cedric Fournet, Aastha Mehta, Sebastian Nowozin, Kapil Vaswani, and Manuel Costa. 2016. Oblivious Multi-Party Machine Learning on Trusted Processors. In 25th USENIX Security Symposium. USENIX Association.

7. Thomas Ristenpart, Eran Tromer, Hovav Shacham, and Stefan Savage. 2009. Hey, you, get off of my cloud: Exploring information leakage in third-party compute clouds. In Proceedings of the 16th ACM conference on Computer and Communications Security. ACM.

8. Mark Russinovich. 2017. Introducing Azure confidential computing. [链接](https://azure.microsoft.com/en-us/blog/introducing-azure-confidential-computing/)

9. Vinnie Scarlata, Simon Johnson, James Beaney, and Piotr Zmijewski. 2018. Supporting Third Party Attestation for Intel SGX with Intel Data Center Attestation Primitives. [链接](https://software.intel.com/sites/default/files/managed/f1/b8/intel-sgx-support-for-third-party-attestation.pdf)

10. F. Schuster, M. Costa, C. Fournet, C. Gkantsidis, M. Peinado, G. Mainar-Ruiz, and M. Russinovich. 2015. VC3: Trustworthy Data Analytics in the Cloud Using SGX. In 36th IEEE Symposium on Security and Privacy.

11. Jaebaek Seo, Byoungyoung Lee, Seongmin Kim, Ming-Wei Shih, Insik Shin, Dongsu Han, and Taesoo Kim. 2017. SGX-Shield: Enabling Address Space Layout Randomization for SGX Programs. In The Network and Distributed System Security Symposium.

12. Shweta Shinde, Dat Le Tien, Shruti Tople, and Prateek Saxena. 2017. Panoply: Low-TCB Linux Applications With SGX Enclaves. In The Network and Distributed System Security Symposium.

13. Rohit Sinha, Sriram Rajamani, Sanjit Seshia, and Kapil Vaswani. 2015. Moat: Verifying Confidentiality of Enclave Programs. In 22nd ACM Conference on Computer and Communications Security. ACM.

14. Claudio Soriente, Ghassan Karame, Wenting Li, and Sergey Fedorov. 2019. ReplicaTEE: Enabling Seamless Replication of SGX Enclaves in the Cloud. In Proceedings of the 2019 IEEE European Symposium on Security and Privacy.

15. Raoul Strackx and Frank Piessens. 2016. Ariadne: A Minimal Approach to State Continuity. In 25th USENIX Security Symposium. USENIX Association.

16. Yogesh Swami. 2017. SGX Remote Attestation is not Sufficient. Cryptology ePrint Archive, Report 2017/736. [链接](https://eprint.iacr.org/2017/736)

17. Sandeep Tamrakar, Jian Liu, Andrew Paverd, Jan-Erik Ekberg, Benny Pinkas, and N. Asokan. 2017. The Circle Game: Scalable Private Membership Test Using Trusted Hardware. In ACM on Asia Conference on Computer and Communications Security. ACM.

18. Florian Tramer, Fan Zhang, Huang Lin, Jean-Pierre Hubaux, Ari Juels, and Elaine Shi. 2017. Sealed-Glass Proofs: Using Transparent Enclaves to Prove and Sell Knowledge. In Proceedings of the 2017 IEEE European Symposium on Security and Privacy.

19. D. Tychalas, N. G. Tsoutsos, and M. Maniatakos. 2017. SGXCrypter: IP protection for portable executables using Intel’s SGX technology. In 22nd Asia and South Pacific Design Automation Conference.

20. Jo Van Bulck, Marina Minkin, Ofir Weisse, Daniel Genkin, Baris Kasikci, Frank Piessens, Mark Silberstein, Thomas F. Wenisch, Yuval Yarom, and Raoul Strackx. 2018. Foreshadow: Extracting the Keys to the Intel SGX Kingdom with Transient Out-of-Order Execution. In 27th USENIX Security Symposium (USENIX Security 18). USENIX Association, Baltimore, MD.

21. Stephan van Schaik, Alyssa Milburn, Sebastian Österlund, Pietro Frigo, Giorgi Maisuradze, Kaveh Razavi, Herbert Bos, and Cristiano Giuffrida. 2019. RIDL: Rogue In-flight Data Load. In 40th IEEE Symposium on Security and Privacy.

22. Venkatanathan Varadarajan, Yinqian Zhang, Thomas Ristenpart, and Michael Swift. 2015. A Placement Vulnerability Study in Multi-Tenant Public Clouds. In USENIX Security Symposium.

23. Samuel Weiser and Mario Werner. 2017. SGXIO: Generic Trusted I/O Path for Intel SGX. In Proceedings of the Seventh ACM on Conference on Data and Application Security and Privacy (CODASPY ’17). ACM, New York, NY, USA.

24. Fan Zhang, Ethan Cecchetti, Kyle Croman, Ari Juels, and Elaine Shi. 2016. Town Crier: An Authenticated Data Feed for Smart Contracts. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security (CCS ’16). ACM, New York, NY, USA.

25. Fan Zhang, Ittay Eyal, Robert Escriva, Ari Juels, and Robbert Van Renesse. 2017. REM: Resource-Efficient Mining for Blockchains. In 26th USENIX Security Symposium. USENIX Association.

26. Wenting Zheng, Ankur Dave, Jethro G. Beekman, Raluca Ada Popa, Joseph E. Gonzalez, and Ion Stoica. 2017. Opaque: An Oblivious and Encrypted Distributed Analytics Platform. In 14th USENIX Symposium on Networked Systems Design and Implementation. USENIX Association.

27. Guy Zyskind, Oz Nathan, and Alex Pentland. 2015. Enigma: Decentralized Computation Platform with Guaranteed Privacy. CoRR abs/1506.03471 (2015). arXiv:1506.03471. [链接](http://arxiv.org/abs/1506.03471)

### ProVerif 代码

以下是用于安全证明的 ProVerif 代码：

```proverif
(* EPID 方案 *)
type epidikey.
type epidvkey.
fun epidvk(epidikey): epidvkey.
type epidmkey.
type epidpkow.
type epidcert.
fun epidpk(epidmkey, bitstring): epidpkow.
fun epidct(epidpkow, epidikey, bitstring): epidcert.
fun epidsign(bitstring, epidmkey, epidcert): bitstring.
reduc forall m: bitstring, k: epidmkey, c: epidcert;
getepidmsg(epidsign(m, k, c)) = m.
reduc forall m: bitstring, mk: epidmkey, ik: epidikey, nonce: bitstring;
checkepidsign(
epidsign(m, mk, epidct(epidpk(mk, nonce), ik, nonce)),
epidvk(ik)
) = m.
fun vk2bs(epidvkey): bitstring.
reduc forall vk: epidvkey; bs2vk(vk2bs(vk)) = vk.
fun pk2bs(epidpkow): bitstring.
reduc forall pk: epidpkow; bs2pk(pk2bs(pk)) = pk.
fun ct2bs(epidcert): bitstring.
reduc forall ct: epidcert; bs2ct(ct2bs(ct)) = ct .

(* 对称加密 *)
type sekey.
fun senc(bitstring, sekey): bitstring.
reduc forall m: bitstring, k: sekey;
sdec(senc(m, k), k) = m.

(* Diffie-Hellman *)
type G.
type exponent.
const g: G [data].
fun exp(G, exponent): G.
equation forall x: exponent, y: exponent;
exp(exp(g, x), y) = exp(exp(g, y), x).
fun G2sek(G): sekey.
fun G2bs(G): bitstring.
reduc forall gxy: G; bs2G(G2bs(gxy)) = gxy.

(* SGX 相关 *)
type sgxsp.
type mrenc.
type rpkey.
fun mr(sgxsp): mrenc.
fun egetrpkey(sgxsp): rpkey.
fun ereport(sgxsp, mrenc, bitstring): bitstring.
reduc forall sFrom: sgxsp, rTo: mrenc, m: bitstring;
egetreport(ereport(sFrom, rTo, m)) = m.
reduc forall sFrom: sgxsp, rTo: mrenc, m: bitstring;
egetmrfrom(ereport(sFrom, rTo, m)) = mr(sFrom).
reduc forall sFrom: sgxsp, sTo: sgxsp, m: bitstring;
everif(ereport(sFrom, mr(sTo), m), egetrpkey(sTo)) = m.

(* 自由名称 *)
free ae_ie: channel.
free ie_qe: channel.
free ae_qe: channel.
free la: channel.
free ra: channel.
free c: channel.
free epidikIntel: epidikey [private].
free sgxIntelQE: sgxsp [private].
free sgxIssueE: sgxsp [private].
free sgxAttestE: sgxsp [private].
free sgxIsvE: sgxsp [private].
free s: bitstring [private].

(* 查询 *)
query attacker(s).

(* 协议 *)
let IntelQE(sp: sgxsp, mk: epidmkey, ct: epidcert, la: channel) =
in(la, erpt: bitstring);
let rpt = everif(erpt, egetrpkey(sp)) in
let mrf = egetmrfrom(erpt) in
out(la, epidsign((mrf , rpt), mk, ct)).

let IssueE(sp: sgxsp, epidik: epidikey, aem: mrenc,
qem: mrenc, qec: channel, ae: channel) =
(* 消息 1 *)
in(ae, req: bitstring);
(* 获取 IAS 报告 *)
let vk = epidvk(epidik) in
out(qec, ereport(sp, qem, vk2bs(vk)));
in(qec, cert: bitstring);
new nonce: bitstring;
(* 消息 2 *)
out(ae, (nonce, cert));
(* 消息 3 *)
in(ae, quotepk: bitstring);
let (mrf : mrenc, pk: bitstring)
= checkepidsign(quotepk, epidvk(epidikIntel)) in
(* 安全检查：验证 AttestE 的身份 *)
if mrf = aem then
(* 消息 4 *)
out(ae, epidct(bs2pk(pk), epidik, nonce)).

let AttestE(sp: sgxsp, qem: mrenc, qec: channel,
ie: channel, la: channel) =
(* 消息 1 *)
new req: bitstring;
out(ie, req);
(* 消息 2 *)
in(ie, (nonce: bitstring, cert: bitstring));
new mk: epidmkey;
let pk = epidpk(mk, nonce) in
(* 获取 IAS 报告 *)
out(qec, ereport(sp, qem, pk2bs(pk)));
in(qec, quotepk: bitstring);
(* 消息 3 *)
out(ie, quotepk);
(* 消息 4 *)
in(ie, ct: bitstring);
(* 远程认证 *)
in(la, erpt: bitstring);
let rpt = everif(erpt, egetrpkey(sp)) in
let mrf = egetmrfrom(erpt) in
out(la, (epidsign((mrf , rpt), mk, bs2ct(ct)), cert)).

let IsvE(sp: sgxsp, aem: mrenc, la: channel, ra: channel) =
(* 接收 ISV 挑战 *)
in(ra, (gx: G, nonce: bitstring));
new y: exponent;
let dhsk = G2sek(exp(gx, y)) in
let enonce = senc(nonce, dhsk) in
(* 获取 OPERA 报告 *)
out(la, ereport(sp, aem, (exp(g, y), enonce)));
in(la, (quote: bitstring, cert: bitstring));
(* 发送响应 *)
out(ra, (quote, cert));
(* 接收 ISV 密钥 *)
in(ra, emsg: bitstring).

let IsvClient(isvm: mrenc, iem: mrenc, ra: channel) =
(* 发送挑战 *)
new x: exponent;
new nonce: bitstring;
out(ra, (exp(g, x), nonce));
(* 接收响应 *)
in(ra, (quote: bitstring, cert: bitstring));
let (mrfie: mrenc, asvk: bitstring)
= checkepidsign(cert, epidvk(epidikIntel)) in
(* 安全检查：验证 IssueE 的身份 *)
if mrfie = iem then
let (mrf : mrenc, (gy: G, enonce: bitstring))
= checkepidsign(quote, bs2vk(asvk)) in
(* 安全检查：验证被认证 enclave 的身份 *)
if mrf = isvm then
let dhsk = G2sek(exp(gy, x)) in
if sdec(enonce, dhsk) = nonce then
(* 发送密钥 *)
out(ra, senc(s, dhsk)).

process
let epidvkIntel = epidvk(epidikIntel) in out(c, epidvkIntel);
new epidmkQE1: epidmkey;
new epidmkQE2: epidmkey;
new nonceQE1: bitstring;
new nonceQE2: bitstring;
let mrQE = mr(sgxIntelQE) in out(c, mrQE);
let mrIE = mr(sgxIssueE) in out(c, mrIE);
let mrAE = mr(sgxAttestE) in out(c, mrAE);
let mrISVE = mr(sgxIsvE) in out(c, mrISVE);
new epidikAS: epidikey;
(
IntelQE(sgxIntelQE, epidmkQE1,
epidct(epidpk(epidmkQE1, nonceQE1),
epidikIntel, nonceQE1), ie_qe) |
IssueE(sgxIssueE, epidikAS, mrAE, mrQE, ie_qe, ae_ie) |
IntelQE(sgxIntelQE, epidmkQE2,
epidct(epidpk(epidmkQE2, nonceQE2),
epidikIntel, nonceQE2), ae_qe) |
AttestE(sgxAttestE, mrQE, ae_qe, ae_ie, la) |
IsvE(sgxIsvE, mrAE, la, ra) |
IsvClient(mrISVE, mrIE, ra)
)
```

### 会议信息
**Session 10B: TEE IICCS ’19**
- **日期**: 2019年11月11日至15日
- **地点**: 英国伦敦