# References

1. Trend Micro. "Android much less secure than iPhone." *Electronista News*, January 2011. [Link](http://www.electronista.com/articles/11/01/11/trend.micro.warns.android.inherently.vulnerable/)

2. PCWorld News. "Why Android App Security Is Better Than for the iPhone." August 2010. [Link](http://www.pcworld.com/businesscenter/article/202758/why-android-app-security-is-better-than-for-the-iphone.html)

3. CNET News. "iPhone Security Different but Matched." July 2010. [Link](http://news.cnet.com/8301-270803-20009362-245.html)

4. InformationWeek. "Smartphone Security Smackdown: iPhone vs. Android." July 2011. [Link](http://www.informationweek.com/news/security/mobile/231000953)

5. A. P. Felt, E. Chin, S. Hanna, D. Song, and D. Wagner. "Android Permissions Demystified." In *Proceedings of the 18th ACM Conference on Computer and Communications Security*, 2011, pp. 627–638.

6. C. Sorrel. "Apple Approves, Pulls Flashlight App with Hidden Tethering Mode." *Wired*. July 2010. [Link](http://www.wired.com/gadgetlab/2010/07/apple-approves-pulls-flashlight-app-with-hidden-tethering-mode)

7. H. Lockheimer. "Android and Security." *Google Mobile Blog*, February 2, 2012. [Link](http://googlemobile.blogspot.com/2012/02/android-and-security.html)

8. A. P. Felt, E. Ha, S. Egelman, A. Haney, E. Chin, and D. Wagner. "Android Permissions: User Attention, Comprehension, and Behavior." In *Proceedings of the Symposium on Usable Privacy and Security (SOUPS)*, 2012.

9. Android API level 14, Manifest.permission. [Link](http://developer.android.com/reference/android/Manifest.permission.html)

10. Apple, Entitlement Key Reference. [Link](http://developer.apple.com/library/mac/#documentation/Miscellaneous/Reference/EntitlementKeyReference/Chapters/AboutEntitlements.html)

11. G. Paller, Dedexer. [Link](http://dedexer.sourceforge.net/)

12. M. Weiser. "Program Slicing." In *Proceedings of the 5th International Conference on Software Engineering*, 1981.

13. J. Sawin and A. Rountev. "Improving Static Resolution of Dynamic Class Loading in Java Using Dynamically Gathered Environment Information." *Automated Software Engineering*, vol. 16, pp. 357–381, June 2009.

14. Hex-Rays. "IDApro, a Multi-Processor Disassembler and Debugger." [Link](http://www.hex-rays.com/products/ida/index.shtml)

15. Nemo. "The Objective-C Runtime: Understanding and Abusing." *Phrack*, Volume 4, Issue 66. [Link](http://www.phrack.org/issues.html?issue=66&id=4)

16. M. Egele, C. Kruegel, E. Kirda, and G. Vigna. "PiOS: Detecting Privacy Leaks in iOS Applications." In *Proceedings of the Network and Distributed System Security Symposium (NDSS)*, San Diego, CA, February 2011.

17. XE Currency. iOS: [Link](http://itunes.apple.com/app/xe-currency/id315241195), Android: [Link](https://play.google.com/store/apps/details?id=com.xe.currency)

18. Words With Friends. iOS: [Link](http://itunes.apple.com/app/words-with-friends-free/id321916506), Android: [Link](https://play.google.com/store/apps/details?id=com.zynga.words)

19. AdWhirl Developer’s Resources. [Link](https://www.adwhirl.com/home/dev)

20. Flurry Product Updates. [Link](http://blog.flurry.com/updates/bid/33715/New-Flurry-SDK-Available-for-iPhone-OS-4-0-iOS)

21. A. Lineberry, D. L. Richardson, and T. Wyatt. "These Are Not the Permissions You Are Looking For." Def Con 18 Hacking Conference, 2010.

22. H. Shacham. "The Geometry of Innocent Flesh on the Bone: Return-Into-LIBC Without Function Calls (on the x86)." In *Proceedings of the 14th ACM Conference on Computer and Communications Security*, 2007, pp. 552–561.

23. L. Davi, A. Dmitrienko, A.-R. Sadeghi, and M. Winandy. "Privilege Escalation Attacks on Android." In *Proceedings of the 13th International Conference on Information Security*, 2011, pp. 346–360.

24. A. P. Felt, H. J. Wang, A. Moshchuk, S. Hanna, and E. Chin. "Permission Re-Delegation: Attacks and Defenses." In *Proceedings of the 20th USENIX Conference on Security*, 2011.

25. S. Bugiel, L. Davi, A. Dmitrienko, T. Fischer, A.-R. Sadeghi, and B. Shastry. "Towards Taming Privilege-Escalation Attacks on Android." In *19th Annual Network & Distributed System Security Symposium*, February 2012.

26. W. Enck, M. Ongtang, and P. McDaniel. "Understanding Android Security." *IEEE Security and Privacy*, 2009.

27. W. Enck, D. Octeau, P. McDaniel, and S. Chaudhuri. "A Study of Android Application Security." In *Proceedings of the 20th USENIX Security Symposium*, 2011.

28. Y. Zhou, Z. Wang, W. Zhou, and X. Jiang. "Hey, You, Get Off of My Market: Detecting Malicious Apps in Official and Alternative Android Markets." In *19th Annual Network & Distributed System Security Symposium (NDSS)*, February 2012.

29. L.-K. Yan and H. Yin. "Droidscope: Seamlessly Reconstructing the OS and Dalvik Semantic Views for Dynamic Android Malware Analysis." In *Proceedings of the 21st USENIX Security Symposium*, 2012.

30. D. Barrera, H. G. u. c. Kayacik, P. C. van Oorschot, and A. Somayaji. "A Methodology for Empirical Analysis of Permission-Based Security Models and Its Application to Android." In *Proceedings of the 17th ACM Conference on Computer and Communications Security*, 2010, pp. 73–84.

31. M. Ongtang, S. McLaughlin, W. Enck, and P. McDaniel. "Semantically Rich Application-Centric Security in Android." In *Proceedings of the Annual Computer Security Applications Conference*, 2009, pp. 340–349.

32. P. Hornyack, S. Han, J. Jung, S. Schechter, and D. Wetherall. "These Aren’t the Droids You’re Looking For: Retrofitting Android to Protect Data from Imperious Applications." In *Proceedings of the 18th ACM Conference on Computer and Communications Security*, 2011, pp. 639–652.

33. M. Grace, Y. Zhou, Z. Wang, and X. Jiang. "Systematic Detection of Capability Leaks in Stock Android Smartphones." In *19th Annual Network & Distributed System Security Symposium*, February 2012.

34. R. Xu, H. Saidi, and R. Anderson. "Aurasium: Practical Policy Enforcement for Android Applications." In *Proceedings of the 21st USENIX Security Symposium*, 2012.

35. S. Shekhar, M. Dietz, and D. S. Wallach. "Adsplit: Separating Smartphone Advertising from Applications." In *Proceedings of the 21st USENIX Security Symposium*, 2012.

36. P. Pearce, A. P. Felt, G. Nunez, and D. Wagner. "Addroid: Privilege Separation for Applications and Advertisers in Android." In *Proceedings of the 7th ACM Symposium on Information, Computer and Communications Security*, 2012.

37. T. Vidas, N. Christin, and L. Cranor. "Curbing Android Permission Creep." In *Proceedings of the Web 2.0 Security and Privacy 2011 Workshop*, May 2011.

38. W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung, P. McDaniel, and A. N. Sheth. "Taintdroid: An Information-Flow Tracking System for Realtime Privacy Monitoring on Smartphones." In *Proceedings of the 9th USENIX Conference on Operating Systems Design and Implementation*, 2010.

39. A. P. Fuchs, A. Chaudhuri, and J. S. Foster. "Scandroid: Automated Security Certification of Android Applications." University of Maryland, Tech. Rep., 2009.

40. E. Chin, A. P. Felt, K. Greenwood, and D. Wagner. "Analyzing Inter-Application Communication in Android." In *Proceedings of the 9th International Conference on Mobile Systems, Applications, and Services*, 2011, pp. 239–252.

41. N. Seriot. "iPhone Privacy." BlackHat Technical Security Conference DC, 2010. [Link](http://seriot.ch/resources/talks_papers/iPhonePrivacy.pdf)

42. G. Salton, A. Wong, and C. S. Yang. "A Vector Space Model for Automatic Indexing." *Communications of the ACM*, vol. 18, pp. 613–620, November 1975.

43. V. Levenshtein. "Binary Codes Capable of Correcting Deletions, Insertions and Reversals." *Soviet Physics Doklady*, vol. 10, p. 707, 1966.

## Appendix A: Cross-Platform Applications in Candidate Sets

As shown in Table X, the conditions for selecting applications in each candidate set depend on the similarity of three attributes: application name, developing company, and application description. We use the Vector Space Model [42], one of the classical models in information retrieval, to compare the descriptions. The similarity between two application descriptions is calculated using:

\[
\text{sim}(d_1, d_2) = \frac{\sum_{i=1}^{t} w_{i,1} \cdot w_{i,2}}{\sqrt{\sum_{i=1}^{t} w_{i,1}^2} \cdot \sqrt{\sum_{i=1}^{t} w_{i,2}^2}}
\]

where \(d_1\) and \(d_2\) denote the descriptions of two applications (one on Android and the other on iOS), after removing stop words, pure numbers, and HTML tags (such as `<br>`, `<p>`). \(w_{i,j}\) is the weighting for the \(i\)-th term in description \(d_j\), which is assigned based on the frequency of the term. The threshold for high/low similarity score is set to 0.45 by manual tuning to obtain a good trade-off between the number of false positives and false negatives.

The similarity of the application names (as used in the rule of candidate set CS4) is measured with Levenshtein Distance [43], as names are usually short strings containing only a few characters. One example of cross-platform applications with similar names is ActDroid on Android and ActPhone on iOS – their name distance is 4, and their description similarity is 0.56.

We apply the corresponding rules to the entire application data set collected, and the number of application pairs in each candidate set is shown in Table X. The percentage shown in the table is calculated based on the total number of Android applications collected, which is 312,171. After obtaining these candidate sets, we then randomly choose 60 application pairs in each set to perform a manual validation. We manually read the descriptions of these two applications, examine their companies, icons, and screenshots to judge whether they are actually cross-platform applications. During our manual verification, no false positives are found in the CS1 set, but one false positive is found in the CS2 set, which is caused by a parsing error of non-unicode characters.

The results presented in Table X enable us to estimate the total amount of cross-platform applications that exist on both Android and iOS. Applying the formula \(\sum_{i} \text{PercentCS}_i \times \text{TPR}_{\text{CS}_i}\), where \(i \in \{1, 2, \ldots, 5\}\) and \(\text{TPR}_{\text{CS}_i}\) is the true positive rate of the corresponding candidate set, we get the result of 12.2%. This indicates that, among the existing third-party applications on Android, approximately 1/8 of them have a replica application provided for iOS.

### Table X: Candidate Sets for Cross-Platform Applications: Conditions and Statistical Results

| **App Candidate Set** | **Conditions** | **Unique App Pairs** | **Percentage** | **True Positive Rate** |
|-----------------------|----------------|----------------------|----------------|------------------------|
| CS1                   | Same app name, same company, high similarity description | 20,171 | 6.46% | 100% |
| CS2                   | Same app name, same company, low similarity description | 2,230 | 0.71% | > 98.3% |
| CS3                   | Same app name, different company, high similarity description | 8,870 | 2.84% | 83.3% |
| CS4                   | Similar app name, same company, high similarity description | 10,837 | 3.47% | 68.3% |
| CS5                   | Same app name, different company, low similarity description | 14,046 | 4.50% | 6.67% |

*Note: The high/low similarity threshold for Description is set to 0.45, and the edit distance threshold for similar app names is set to ≤ 5.*

## Appendix B: API Resolving Rate of Analysis Tools

On the Android platform, Java reflection is commonly used [5], which is also confirmed by our observation. Among the 1,300 Android applications tested, we found that 951 (73%) use Java reflections to make API calls. However, the absolute number of reflections invoked is only 9,943, which means each application makes an average of 7.6 reflection calls. This is a small amount (0.07%) compared to the 10,778 API calls made by each application on average. Among all the reflections observed, our Android static analysis tool is able to resolve 7,859 (79%) reflections. This indicates that out of thousands of API calls issued per application, only 1.6 API calls are not resolved on average. Our tool failed to resolve the reflection call if the method name or class name is not generated statically. For example, some reflections invoke `java.lang.Class.getDeclaredMethods` with no parameters, which simply return an array of methods, and then according to some dynamic rules, the code will pick one of the methods to invoke. Cases like this are very difficult to resolve in a static manner [13], which is one of the limitations in our current implementation.

When applying our static analysis tool to the 1,300 iOS applications, we find that, on average, 16.63% of the instructions in each application belong to C/C++ code and 83.12% belong to Objective-C code; while the rest 0.25% are dummy instructions or the instructions that our tool is unable to interpret. Our tool is able to capture all the invocations for the API calls that are invoked through C/C++ functions; while for the API calls in the disassembled Objective-C code, our tool is able to resolve 89.7% of the `objc_msgSend` encountered. There are at least two cases where a given `objc_msgSend` cannot be resolved: 1) The corresponding class instance is passed from the runtime as an argument of a callback function. 2) The class instance is retrieved from a collection object such as an array that can hold any types of objects. Such a limitation also exists in other static analysis tools on the iOS platform [16]. Although not all `objc_msgSend` methods are able to be resolved, it has quite limited influence in our experiments. The reason is that a number of API invocations for the same SS-API type are usually observed in an application, so missing a small portion of API calls will not make our tool overlook the corresponding SS-API type in most cases.

## Appendix C: Analysis Results of Paid Applications

We performed the analysis on the most popular 100 pairs of paid cross-platform applications. For the 20 different SS-API types that are supported on both iOS and Android, the results show that the 100 paid applications on Android use a total of 297 SS-API types, while the corresponding 100 paid applications on iOS use 508 SS-API types. 79 of the iOS applications use additional SS-API types compared to their Android versions. These results are consistent with our main findings on popular free applications. Although paid applications contain fewer advertising libraries, our results show that the applications' own code contributes more to the difference in SS-API usage, as shown in Table XI.

### Table XI: Top 5 SS-API Types Accessed Differently by Paid Applications

| **SS-API Type** | **iOS Apps** | **Android Apps** | **Only iOS** | **Exclusive Lib/App Ratio** |
|-----------------|--------------|------------------|--------------|-----------------------------|
| CAMERA          | 51           | 79               | 41           | 14% / 64%                   |
| READ DEVICE ID  | 68           | 35               | 40           | 12% / 53%                   |
| WAKE LOCK       | 79           | 9                | 38           | 0% / 100%                   |
| ACCESS LOCATION | 41           | 38               | 32           | 63% / 32%                   |
| ACCESS NETWORK INFO | 12        | 56               | 26           | 2% / 97%                    |