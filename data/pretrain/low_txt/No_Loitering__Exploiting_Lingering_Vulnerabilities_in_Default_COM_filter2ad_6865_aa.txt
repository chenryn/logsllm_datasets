# Title: No Loitering: Exploiting Lingering Vulnerabilities in Default COM Objects

## Authors:
- David Dewey†‡
- Patrick Traynor‡

**† Advanced Technology Group, IBM Security**  
**‡ Converging Infrastructure Security (CISEC) Lab, Georgia Institute of Technology**

### Abstract
The Component Object Model (COM) facilitates the creation of software plugins for applications running on Microsoft Windows. ActiveX, a common instantiation of this infrastructure, uses COM to create plugins for Internet Explorer. As vulnerabilities in COM objects included in the default Windows installation have been discovered, Microsoft has responded by blacklisting their use in specific applications. In this paper, we demonstrate that the defense mechanisms protecting vulnerable COM objects can be easily circumvented. Specifically, our attack exploits systemic transitive trust among COM objects, allowing for the instantiation and exploitation of several hundred known flawed controls. After demonstrating this weakness on fully patched Windows XP, Windows Vista, and Windows 7 machines, we design and implement a system-wide enforcement architecture called COMBlocker. This system checks the instantiation of COM objects against a global policy. We show that COMBlocker is an effective mitigation for such attacks while imposing minimal overhead (approximately 0.5ms per policy check). Our techniques make the exploitation of default COM objects significantly more difficult.

### 1. Introduction
The Component Object Model (COM) is a language-neutral design philosophy that allows for the creation of discrete software components that can be integrated into other applications. Each COM object exposes a standard interface, enabling developers to create extensible applications with well-defined plugin architectures. Other developers can leverage these standard interfaces to create COM objects that can be consumed by additional applications, allowing for more creative and enhanced solutions to user demands. ActiveX extends this architecture to browsers, enabling web developers to force the execution of native code in the context of the browser through the COM-based plugin infrastructure in Internet Explorer.

Such extensible functionality has frequently been targeted for malicious purposes. To aid in securing ActiveX, a configuration policy known as the "killbit" list was added to Internet Explorer. This allows users and vendors to manage a list of controls that should never be loaded by the browser. If a vulnerability is discovered in a control, the killbit list can prevent its instantiation in IE. By adding vulnerable controls to this list, a popular attack vector used by hackers can be mitigated. The killbit list also serves as the basis for security policies in a small number of additional applications. For example, Microsoft Office applications will prompt the user if a document contains a COM object listed in the killbit list.

In this paper, we demonstrate that this mitigation mechanism is insufficient to protect systems against the exploitation of vulnerable COM objects. Specifically, implementing and enforcing security policies through the killbit list on a per-application basis is inadequate for mitigating attacks against vulnerable COM objects that are part of the default operating system installation. We show that individual applications do not have a broad enough view into the behavior of the COM objects they load to effectively enforce a security policy.

Our contributions include:
- **Discovering and characterizing a systemic weakness in the COM security infrastructure:** We demonstrate that the existing killbit list security policies governing the instantiation of COM objects can easily be circumvented. Due to a weakness in the underlying COM architecture, many COM objects that are part of the default installation of the operating system can load other objects without consulting any policy.
- **Confirming the ability to exploit several hundred known flawed and vulnerable COM objects installed by default in Windows:** Over the past several years, the common response to security vulnerabilities reported in COM objects has been to use existing policy mechanisms to prevent their instantiation in a few discrete applications. Because the COM objects themselves are often not corrected, our circumvention identifies a significant security risk. The attack described in this paper takes advantage of controls already installed on Windows and does not require the victim to install or load a control created by the adversary.
- **Designing and implementing a prototype policy enforcement infrastructure for COM objects:** We design and implement a prototype infrastructure for system-wide COM instantiation policy enforcement, which we call COMBlocker. This system quickly compares (average lookup time of 554µs) the instantiation of COM objects against a global policy. Our approach uses binary rewriting to force all COM object instantiations to be compared against the global policy, thus mitigating the above attack. We compare our proposed solution to the patch recently issued by Microsoft (Security Bulletin MS10-036), which was created in response to our private disclosure of the vulnerability.

Through the security weakness documented in this paper, we demonstrate that Windows is susceptible to attacks against several hundred known flawed controls, which are already resident on the system. Many of the vulnerabilities left "loitering" on Windows due to unpatched COM objects, when exploited, allow adversaries to execute arbitrary code. These vulnerabilities can potentially be exploited to install malware. In demonstrating the weaknesses of the existing security mechanisms associated with COM, we show that adversaries have a large number of existing vulnerabilities to target, providing them with complete control of a system.

The remainder of this paper is organized as follows:
- **Section 2** discusses important related research efforts.
- **Section 3** provides background information related to COM objects and their extensibility.
- **Section 4** illustrates the process by which the killbit list can be bypassed, reenabling the ability to exploit hundreds of previously documented vulnerabilities.
- **Section 5** describes our mitigation architecture, which creates a centralized point for COM object policy enforcement.
- **Section 6** offers experimental results and discussion.
- **Section 7** provides concluding remarks.

### 2. Related Work
ActiveX has garnered significant attention from security experts over the past several years. Attacks against these controls range in severity from downloading files to an adversary-supplied location to arbitrary code execution. As various vulnerabilities have been found in COM objects included with the default installation of their operating systems, Microsoft has generally prevented the exploitation of the objects by adding them to the killbit list. Dowd, Smith, and Dewey demonstrated that it was possible to bypass the killbit settings in Internet Explorer using a vulnerability for ActiveX controls. However, while this weakness was patched for Internet Explorer, the general susceptibility of the COM architecture and applications relying upon it has not previously been investigated.

The issue of securing the execution of content published by potentially untrusted third parties is not unique to COM or Windows. Java applets, for example, expose a web browser to similar classes of threats encountered by ActiveX. Security of Java applets has been studied extensively, with several solutions proposed to verify the publisher of the content and enforce access rights on the content as it executes. Jaeger et al. and Islam et al. developed systems based on public key cryptography to verify the publisher of dynamically downloadable executable content. They then proposed solutions for the enforcement of access controls on the code as it executes.

Security policies have been developed to address whether COM objects should be loaded by Internet Explorer. The killbit list attempts to prevent the instantiation of known bad controls. As documented by Loscocco et al., ActiveX controls can be signed similarly to the way that was proposed for Java. Additionally, ActiveX supports the concept of "Safe for Scripting," which allows a control to tell Internet Explorer whether it can be safely loaded by the script engine. Microsoft has implemented additional security policies governing the instantiation of COM objects in other applications, including the MS Office suite. However, policies governing the instantiation of COM objects are implemented by the COM container itself.

Security retrofits to well-established software infrastructures such as COM generally require significant effort. Several researchers have investigated the problem of retrofitting legacy systems with security infrastructure. These efforts use a range of approaches, including static analysis of code and monitoring program behavior to determine security-sensitive operations. The work by Ganapathy et al. demonstrates the injection of authorization policy enforcement code into existing legacy applications, including web and proxy servers, and the Linux Security Module infrastructure. Fraser et al. perform a similar deployment of authorization hooks in MINIX. This builds on the concept of inlined reference monitoring as described by Bauer et al., Erlingsson, and Evans and Twyman. Each of these demonstrates how an existing application can be modified to perform functions not originally designed into the code. The closed nature of the COM architecture requires that our solution rely on binary rewriting techniques rather than those used on source code.

### 3. COM Background
To understand the attack outlined in this paper and our proposed solution, it is necessary to understand the architecture of COM. This section provides a brief overview of COM and how it is implemented.

#### 3.1 Introduction to COM
The Component Object Model (COM) is a language-neutral design philosophy for the creation of software components in the Microsoft Windows operating system. Each COM object must extend the IUnknown interface, as documented by Microsoft. This base interface allows a developer to query an object to learn more about its behavior and how it can be implemented. There are several other interfaces available that can be extended by objects depending on their intended use. One such interface is IDispatch, which provides generic methods allowing for the interaction with object-specific methods and properties, similar to other object-oriented architectures.

Each COM object installed on the system is listed in the Windows registry under a unique identifier called a Class ID (CLSID). On an average Windows system, there are tens of thousands of COM objects registered. An application choosing to instantiate one of these objects simply needs to supply the corresponding CLSID and the desired type of interface to one of the appropriate Win32 APIs. Each of these APIs looks up the CLSID in the registry, loads the library listed in the registry for that object, and returns a handle to the object. Whichever interface was specified will allow access to a set of methods and properties corresponding to that interface.

An interesting feature of COM is its ability to persist object state across instantiations. There are several interfaces, such as IPersistStorage, IPersistStream, and IPersistStreamInit, which, if implemented by an object, can be used to save the runtime state and/or resurrect saved state during instantiation. In each of these cases, the state of the object is serialized and written to disk. Conversely, the serialized data can be read from disk at instantiation time and used to resurrect the object state. It is up to the developer of the object to determine which object properties are to be persisted and their data type. As shown in Figure 1, an object called MSVidAnalogTunerDevice contains the properties Channel and CountryCode. The values of these properties can be set at instantiation using the IPersistStream::Load() method or saved to a binary stream using IPersistStream::Save().

#### 3.2 COM Security
COM exposes some limited information that an application can use to determine an object's security. Applications can instantiate the IObjectSafety interface of a COM object if one is supplied by the object. This interface allows the application to determine whether the object defines itself as being "Safe for Scripting" and/or "Safe for Initialization." Safe for Scripting indicates whether a COM object deems itself safe to be interoperated with through the Internet Explorer scripting engines. Safe for Initialization indicates whether a COM object deems itself safe to be initialized from persisted object state data using the methods described above. In addition to the COM interface, an object can register the same information in the Windows registry. Specifically, two subkeys can be created under the Implemented Categories key under the CLSID for the object. The main problem with this interface is that the object itself informs the application about its own security properties. In the absence of any other security-related information, an application has no choice but to believe what the object tells it.

There are several applications on an average Windows installation that allow a third party to determine which COM objects should be instantiated. Internet Explorer, for example, can be told to load a specific COM object required for the operation of the page it is displaying. In the context of IE, this is called ActiveX. Another example is Microsoft Office, which allows document authors to embed rich content such as images, movies, or even other documents in the body of a Word document or Excel spreadsheet. In each of these cases, a potentially untrusted third party makes a determination about which COM objects should be loaded by applications on an end user's workstation.

The IObjectSafety interface and its registry-based equivalent are not sufficient to provide any reasonable level of protection. Due to the widespread use of Internet Explorer and the ease with which a user can be redirected to malicious content, IE has received the majority of the focus with regard to security from Microsoft. Specifically, a security configuration option known as the "killbit" list was created. The killbit list is a blacklist maintained in the Windows registry that contains CLSIDs of COM objects that should not be instantiated.