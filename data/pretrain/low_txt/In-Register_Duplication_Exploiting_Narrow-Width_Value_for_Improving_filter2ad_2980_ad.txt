### Table 2: Characterization of Soft Errors Injected into the Register File System

| Benchmark | Active (e-5) | Inactive (e-5) | Self-recovery (e-5) | Total (e-5) | Active (e-4) | Inactive (e-4) | Self-recovery (e-4) | Total (e-4) |
|-----------|--------------|----------------|---------------------|-------------|--------------|----------------|--------------------|-------------|
| gcc       | 339          | 947            | 399                 | 1685        | 333          | 516            | 560.8              | 1409.8      |
| mcf       | 1716         | 320            | 549                 | 2585        | 193          | 418            | 276                | 887         |
| crafty    | 372          | 457            | 535                 | 1364        | 201          | 287            | 210                | 698         |
| parser    | 246          | 333            | 516                 | 1095        | 288          | 179            | 278                | 745         |
| eon       | 320          | 549            | 372                 | 1241        | 107          | 119            | 214                | 440         |
| perlbmk   | 947          | 399            | 1716                | 3062        | 262          | 162            | 303                | 727         |
| gap       | 399          | 535            | 246                 | 1180        | 119          | 288            | 303                | 710         |
| vortex    | 457          | 372            | 457                 | 1286        | 179          | 278            | 303                | 760         |
| bzip2     | 535          | 246            | 333                 | 1114        | 288          | 247            | 303                | 838         |
| twolf     | 246          | 333            | 516                 | 1095        | 107          | 119            | 214                | 440         |
| **Avg**   | **560.8**    | **Error Rate: e-5** | **43.5%**           | **43.5%**   | **302.2**    | **Error Rate: e-4** | **43.5%**          | **43.5%**   |
| **Total** | **3603**     | **9555**       | **3760**            | **16931**   | **3432**     | **5904**       | **3564**           | **12900**   |

### Figure 7: Characterization of Erroneous Reads for Input Operands
(a) Distribution of error sources.
(b) Breakdown of erroneous reads with single-bit and multiple-bit errors.
(Left bar for e-5, right bar for e-4)

### Figure 8: Soft Error Detection in the IRD Scheme
(a) Duplicate value comparison.
(b) Parity checking.
(Left bar for e-5, right bar for e-4)

### Figure 9: Normalized Erroneous Reads and Error Recovery in the IRD Scheme
(a) Normalized erroneous reads and error detection for narrow-width values.
(b) Error recovery rate of detected errors.
(Error injection rates: 10^-5 (left bar) and 10^-4 (right bar))

### Results and Discussion

The number of erroneous reads of narrow-width values is reduced to 49% of those presented in Figure 8. Of these erroneous narrow-width values, the IRD scheme detects 99.7% of the errors, which is highly encouraging. Once errors are detected, the IRD scheme makes the following decision:
- If the duplicate in the upper 32-bit half passes the parity check, the duplicate is used for error recovery.
- Otherwise, an ERROR exception is generated, and the operating system handles the error recovery. An additional 1000 cycles are introduced for this ERROR exception handler.

Each detected erroneous regular value triggers this ERROR exception. However, during IRD recovery, if the duplicate was also corrupted but passed the parity check (due to an even number of bit errors), a false recovery using the corrupted duplicate occurs. Figure 9(b) shows that, of the detected errors in narrow-width input operands, IRD recovers 99.7% (99.2%) of the errors with non-corrupted duplicates (IRD True Recovery). The false recovery rate (IRD False Recovery) is 0% (0.1%) at error rates e-5 (e-4). The operating system handles the remaining 0.3% (0.7%) of the detected errors. A performance comparison is shown in Figure 6(b), indicating that the performance overhead due to error recovery is negligible at these two error rates.

Overall, these results confirm that our in-register duplication scheme, which exploits narrow-width values, is very effective in detecting and recovering soft errors occurring in the register file, bypass network, or result writeback bus, while incurring only minor microarchitectural modifications.

### Conclusions and Future Work

In this work, we propose exploiting narrow-width register values to design high-performance, reliable register files. Instead of allocating an additional copy register for storing the duplicate, our in-register duplication (IRD) scheme duplicates a replica of the narrow-width value in its upper 32-bit half, thus eliminating the hardware complexity required for acquiring and maintaining copy registers in previous schemes. Evaluation via software error injection demonstrates that our IRD scheme achieves superior error detection and recovery rates at minimal hardware cost, making it a suitable design for high-performance, highly reliable microprocessors.

For future work, we plan to extend the current IRD framework to support hardware recovery for error-corrupted regular values. We are also working on evaluating the power consumption of the IRD scheme. Another interesting direction is to apply the idea of in-register duplication for protecting the data cache.

### References

[1] Hp nonstop himalaya. http://nonstop.compaq.com/.
[2] T. Austin. Diva: A reliable substrate for deep submicron microarchitecture. In Proc. the 32nd Annual IEEE/ACM International Symposium on Microarchitecture, pages 196–207, November 1999.
[3] E. Borch et al. Loose loops sink chips. In Proc. of HPCA-8, pages 270–281, February 2002.
[4] D. Brooks and M. Martonosi. Dynamically exploiting narrow width operands to improve processor power and performance. In Proc. of HPCA-5, January 1999.
[5] D. Burger and T. M. Austin. The simplescalar tool set, version 2.0. Technical Report 1342, Computer Sciences Department, University of Wisconsin, 1997.
[6] O. Ergin et al. Register packing: Exploiting narrow-width operands for reducing register file pressure. In Proc. of MICRO-37, pages 304–315, Portland, OR, 2004.
[7] M. Gomaa, C. Scarbrough, T. Vijaykumar, and I. Pomeranz. Transient-fault recovery for chip multiprocessors. In Proc. the International Symposium on Computer Architecture, pages 98–109, June 2003.
[8] M. Gomaa and T. N. Vijaykumar. Opportunistic transient-fault detection. In Proceedings of the 32nd Annual International Symposium on Computer Architecture (ISCA), June 2005.
[9] J. S. Hu, G. M. Link, J. K. John, S. Wang, and S. G. Ziavras. Resource-driven optimizations for transient-fault detecting superscalar microarchitectures. In Proc. of Tenth Asia-Pacific Computer Systems Architecture Conference (ACSAC 05), Singapore, October 24-26 2005.
[10] G. S. S. J. Adam Butts. Use-based register caching with decoupled indexing. In Proceedings of 31st Annual International Symposium on Computer Architecture (ISCA’04), pages 302–313, 2004.
[11] S. Kim and A. Somani. Area efficient architectures for information integrity checking in cache memories. In Proceedings of International Symposium on Computer Architecture (ISCA), pages 246–255, May 1999.
[12] L. Li et al. Soft error and energy consumption interactions: A data cache perspective. In Proc. of ISLPED’04, pages 132–137, 2004.
[13] M. H. Lipasti et al. Physical register inlining. In Proc. of ISCA-31, pages 325–335, June 2004.
[14] G. H. Loh. Exploiting data-width locality to increase superscalar execution bandwidth. In Proc. of MICRO-35, 2002.
[15] R. E. Lyons and W. Vanderkulk. The use of triple-modular redundancy to improve computer reliability. IBM Journal, April 1962.
[16] G. Memik, M. H. Chowdhury, A. Mallik, and Y. I. Ismail. Engineering over-clocking: Reliability-performance trade-offs for high-performance register files. In International Conference on Dependable Systems and Networks (DSN’05), pages 770–779, 2005.
[17] G. Memik et al. Increasing register file immunity to transient errors. In Proc. of DATE 2005, Munich, Germany, May 2005.
[18] A. Mendelson and N. Suri. Designing high-performance and reliable superscalar architectures: The out of order reliable superscalar (O3RS) approach. In Proc. of the International Conference on Dependable Systems and Networks, June 2000.
[19] S. S. Mukherjee, M. Kontz, and S. K. Reinhardt. Detailed design and evaluation of redundant multithreading alternatives. In Proc. the 29th Annual International Symposium on Computer Architecture, pages 99–110, May 2002.
[20] S. S. Mukherjee, C. T. Weaver, J. Emer, S. K. Reinhardt, and T. Austin. A systematic methodology to compute the architectural vulnerability factors for a high-performance microprocessor. In Proc. the 36th Annual IEEE/ACM International Symposium on Microarchitecture, December 2003.
[21] M. Namjoo and E. McCluskey. Watchdog processors and detection of malfunctions at the system level. Technical Report 81-17, CRC, December 1981.
[22] A. Parashar, S. Gurumurthi, and A. Sivasubramaniam. A complexity-effective approach to ALU bandwidth enhancement for instruction-level temporal redundancy. In Proc. the 31st Annual International Symposium on Computer Architecture, June 2004.
[23] R. P. Preston et al. Design of an 8-issue superscalar RISC microprocessor with simultaneous multithreading. In Proc. IEEE International Solid-State Circuits Conference, 2002.
[24] J. Ray, J. Hoe, and B. Falsaﬁ. Dual use of superscalar datapath for transient-fault detection and recovery. In Proc. the 34th Annual IEEE/ACM International Symposium on Microarchitecture, pages 214–224, December 2001.
[25] S. Reinhardt and S. Mukherjee. Transient fault detection via simultaneous multithreading. In Proc. the 27th Annual International Symposium on Computer Architecture, pages 25–36, June 2000.
[26] E. Rotenberg. AR-SMT: A microarchitectural approach to fault tolerance in microprocessors. In Proc. the International Symposium on Fault-Tolerant Computing, pages 84–91, June 1999.
[27] T. Sherwood et al. Automatically characterizing large scale program behavior. In Proc. of ASPLOS X, October 2002.
[28] P. Shivakumar et al. Modeling the effect of technology trends on the soft error rate of combinational logic. In Proc. International Conference on Dependable Systems and Networks, pages 389–398, June 2002.
[29] T. J. Slegel et al. IBM’s S/390 G5 microprocessor design. IEEE Micro, 19(2):12–23, March/April 1999.
[30] J. Smolens, J. Kim, J. C. Hoe, and B. Falsaﬁ. Efficient resource sharing in concurrent error detecting superscalar microarchitecture. In ACM/IEEE International Symposium on Microarchitecture (MICRO), December 2004.
[31] K. Sundaramoorthy, Z. Purser, and E. Rotenburg. Slipstream processors: Improving both performance and fault tolerance. In Proc. the 9th International Conference on Architectural Support for Programming Languages and Operating systems, pages 257–268, 2000.
[32] T. Vijaykumar, I. Pomeranz, and K. Cheng. Transient-fault recovery via simultaneous multithreading. In Proc. the 29th Annual International Symposium on Computer Architecture, pages 87–98, May 2002.
[33] C. Weaver et al. Techniques to reduce the soft errors rate in a high-performance microprocessor. In Proc. of ISCA-31, 2004.
[34] K. C. Yager. The MIPS R10000 superscalar microprocessor. IEEE Micro, 16(2):28–40, April 1996.
[35] J. F. Ziegler et al. IBM experiments in soft fails in computer electronics (1978 - 1994). IBM Journal of Research and Development, 40(1):3–18, January 1996.