### Process Explorer

- **Process Suspension**: Can suspend a process, effectively freezing all its threads so they do nothing.
- **CPU Usage Monitoring**: Can identify which thread in a process is consuming the most CPU resources.

**Note**: It is advisable to use Process Explorer alongside Process Monitor because Process Explorer provides additional features that enable the analyst to interact with the process and further analyze the behavior of the malicious process.

For a quick review of the system and running processes, Process Explorer offers an option to look up all hashes on VirusTotal and display the number of detections. For example, in the image below, the user can see that the process 'malware.exe' (a child process of 'explorer.exe') has 61 out of 70 detections, indicating a high probability that this application is malicious.

By examining the Properties window (opened by double-clicking on the process), the analyst can access another set of useful information, such as:
- The user under which the process is running
- Strings in memory
- Active threads
- Active network connections initiated by the malware
- The full path of the executable on the disk

**Figure 22: Process Explorer – 'malware.exe' Properties**

Process Explorer is part of the SysInternals Suite and can be downloaded from the following website:
- [https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer)

---

### Regshot

Regshot is a tool that allows an analyst to take two snapshots of the Windows Registry (before and after the infection) to identify changes made in the registry or files dropped by the malicious executable. This information can then be used to create Indicators of Compromise (IoCs).

**Usage Steps for Regshot:**
1. Take the first snapshot of the system’s registry when the system is clean.
2. Run the malware sample.
3. Take the second snapshot of the system’s registry after the infection.
4. Press the 'Compare' button to compare the two generated snapshots.
5. Analyze the report generated.
6. Start over on a new, clean system.

**Figure 23: Regshot – Snapshot Sequence**

In the example below, after running and comparing the second snapshot with the first one, the analyst identified that the executable 'malware.exe' creates data in the registry at `HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\malware`:
- `C:\WINDOWS\SysWOW64\malware.exe` to gain persistence on the system.

Checking the entire registry report, which tracks all changes, will help the analyst understand the behavior of the malicious application.

**Figure 24: Regshot – Snapshot Report**

Regshot can be downloaded from the following website:
- [https://sourceforge.net/projects/regshot](https://sourceforge.net/projects/regshot)

---

### INetSim

INetSim is a Linux-based software suite that allows the user to simulate multiple standard Internet services on a virtual machine used for investigations. By using this tool, the analyst can monitor the network behavior of the malware sample without connecting it to the Internet. If you are conducting investigations in Windows, the easiest way to use this tool is to configure a Linux VM (where INetSim is running) as a gateway for the Windows VM.

**Setup of INetSim:**
- **Configuration File**: To change the configuration setup for adding or removing services, modify the file `etc/inetsim/inetsim.conf`.
- **Service Emulation**: When running, INetSim records all inbound and outbound connections, allowing the analyst to build IoCs based on the connections the malicious file is trying to make.

**Figure 25: INetSim – Setup**

**Figure 26: INetSim – Running Services Output**

INetSim can be downloaded from the following website:
- [https://www.inetsim.org/downloads.html](https://www.inetsim.org/downloads.html)

---

### Sandboxing

To limit the spread of infection and protect their environment, malware analysts run the malware sample inside a sandbox solution. Sandbox tools usually offer the option to dump the process memory, providing a better understanding of what is happening in the RAM.

Malware authors often implement checks to detect if their sample is running inside a virtual machine or sandbox. For more information on these checks, refer to the section on malware self-protection in Chapter 2.

Several free sandboxing solutions are available online where analysts can upload the sample and wait for the report. Some of the best-known include:
- [www.malwr.com](http://www.malwr.com)
- [www.hybrid-analysis.com](http://www.hybrid-analysis.com)
- [www.any.run](http://www.any.run)
- [www.joesandbox.com](http://www.joesandbox.com)
- [www.cuckoosandbox.org](http://www.cuckoosandbox.org)
- [www.sandbox.anlyz.io](http://www.sandbox.anlyz.io)
- [www.analyze.intezer.com](http://www.analyze.intezer.com)

**Cuckoo Sandbox**

This handbook will focus on Cuckoo Sandbox, known as the leading open-source automated malware analysis system. Cuckoo can automate the task of analyzing any malicious file under Windows, macOS, Linux, or Android. The sandbox can be deployed locally and requires a host (management software) and multiple sandbox clients (virtual machines for analysis).

**Features of Cuckoo Sandbox:**
- Takes screenshots of the execution of the malware
- Intercepts deleted and downloaded files
- Dumps memory of the malware processes
- Runs concurrent analyses on multiple machines
- Dumps generated network traffic in PCAP format
- Recursively monitors newly spawned processes
- Traces relevant API calls for behavioral analysis
- Acquires full memory dumps of the VM

**Figure 27: Cuckoo – Sandbox Architecture**

Due to its modular design, Cuckoo can be used as a standalone application or integrated into larger frameworks. The sandbox is accessible via a web console, where malware samples are submitted for analysis.

**Figure 28: Cuckoo – Sandbox Web Console**

After the files are submitted, they are executed, and all activities are logged and included in the final report. The analyst can access and read the report through the web console. Cuckoo supports several reporting formats, including human-readable, MAEC (Malware Attribute Enumeration and Characterization) format, and the ability to export data reports to other formats.

More information on the installation and usage of Cuckoo Sandbox can be found at:
- [https://cuckoo.readthedocs.io/en/latest/installation/host/installation](https://cuckoo.readthedocs.io/en/latest/installation/host/installation)

**Windows Sandbox**

In Windows 10, Version 1903 (May 2019 Update), Microsoft introduced a new feature called Windows Sandbox. This environment does not require many system resources and uses only around 100 MB of disk space.

**Figure 29: Windows – Sandbox GUI**

**Requirements for Windows Sandbox:**
- x64 architecture
- Virtualization capabilities enabled in BIOS
- At least 4GB of RAM (8GB recommended)
- At least 1 GB of free disk space (SSD recommended)
- At least 2 CPU cores (4 cores with hyperthreading recommended)

Each time the analyst runs the Windows Sandbox, it creates a new clean installation of Windows 10. After the analysis, closing the Sandbox environment deletes everything within it, ensuring the work environment remains safe and clean.

One important aspect is that it requires the user to activate Microsoft’s hypervisor. The Sandbox also offers customization options, such as:
- Enabling or disabling the virtualized GPU
- Enabling or disabling networking in the sandbox
- Sharing folders from the host
- Running a startup script or program

To enable these options, the Sandbox looks for a configuration file with a `.WSB` extension. More information on how to enable and configure the Windows Sandbox can be found on the Microsoft Community blog:
- [https://techcommunity.microsoft.com/t5/windows-kernel-internals/windows-sandbox/ba-p/301849](https://techcommunity.microsoft.com/t5/windows-kernel-internals/windows-sandbox/ba-p/301849)

---

### Debuggers

At first glance, a debugger may seem similar to a disassembler, as both display code in assembly and offer lists of functions and strings. However, a debugger provides detailed monitoring of malicious code execution, including insight into memory, registers, stack, and control elements. Debugging allows the analyst to run the code, control the execution (instruction by instruction, breakpoints, etc.), and see specific values in registers, function parameters, and return values, providing a deeper understanding of the code.

**Open-Source Debuggers:**
- WinDbg
- x64dbg
- Immunity Debugger
- OllyDbg

The following examples use x64dbg.

**Setting Breakpoints:**
When a suspicious specimen was analyzed in IDA, the `InternetWriteFile` API function call was identified at addresses `0x004010D5` and `0x004010E4`. This function sends data via the network. The parameters define the destination (`hFile`), data to be sent (`lpBuffer`), length of data (`dwNumberOfBytesToWrite`), and amount of data sent (`lpdwNumberOfBytesWritten`).

**Figure 30: IDA – Parameters of InternetWriteFile Function**

The destination is hardcoded in the executable and has already been discovered. It is clear that the function at address `0x004010E4` sent the `\n` character. However, the kind of data sent at address `0x004010D5` is still unknown.

To analyze this, set a breakpoint in the debugger:
1. Open the executable in x64dbg.
2. Right-click in the code area and choose 'Go to' > 'Expression' (or press CTRL+G).
3. Fill in the address in the dialog box and click OK.
4. Set the breakpoint at the required address by right-click > 'Breakpoint' > 'Toggle' (or press F2).
5. The address with the breakpoint is highlighted in red.

**Figure 31: x64dbg – Setting a Breakpoint on the Specific Address**

Enable the debugger to run the executable by pressing F9 (or through the menu 'Debug' > 'Run'). The debugger reaches the breakpoint and stops. The data sent by `InternetWriteFile` is now visible in the stack area.

**Figure 32: x64dbg – Stack Memory**

**Symbols and Intermodular Calls:**
If the address of interest is unknown, a survey of functions and their cross-references must be conducted. x64dbg has built-in features for this: symbols and intermodular calls.

To see a list of symbols (imported external functions):
1. Switch to the 'Symbols' tab.
2. Choose the executable name from all modules (or press CTRL+N).

**Figure 33: x64dbg - Symbols**

Intermodular calls are shown via right-click > 'Search for' > 'Current Module' > 'Intermodular calls'. A table appears containing information about how, where, and what imported functions are called. It is possible to set breakpoints on these calls by pressing F2 or to investigate them in the code area by double-clicking on them.

**Figure 34: x64dbg - Intermodular Calls**

**Deobfuscation:**
Debuggers also help with deobfuscating uncompiled scripts. The following example demonstrates an analysis of an obfuscated JavaScript file `malware.js`.

**Figure 35: Obfuscated JavaScript**

A JavaScript file needs to be executed by a script interpreter. Windows has a native script engine `wscript.exe` located in the `C:\Windows\System32\` directory. Such obfuscated JavaScript is often designed to drop or download a new malicious file and execute it. To analyze this, load `wscript.exe`, tell it to process the malicious JavaScript file, set a breakpoint at `ShellExecute`, and analyze its context when triggered:

1. Load `wscript.exe` (File > Open > `C:\windows\system32\wscript.exe`).
2. Add `malware.js` as a parameter (File > Change Command Line and add the path to the malicious file; e.g., `"C:\Windows\system32\wscript.exe" C:\malware.js`).
3. Switch to the 'Breakpoints' panel > right-click > 'Add dll breakpoint' and fill in `shell32.dll`.
4. Run the execution and wait until the `shell32.dll` breakpoint is triggered.
5. Switch to the 'Symbols' panel > choose `shell32.dll` among modules > filter 'Execute' functions and set breakpoints.
6. Switch back to the 'Breakpoints' panel and disable the DLL breakpoint from step 4.
7. Run the execution and wait for one of the 'Execute' breakpoints to be triggered to examine the parameters in the stack memory.

**Figure 36: x32dbg – JavaScript Debugging and DLL Breakpoint**

One of the breakpoints stops code execution at the `ShellExecuteExA` function. The function has one parameter, a pointer to the `SHELLEXECUTEINFOA` structure. To examine it, right-click on the pointer value > 'Follow DWORD in Dump' > 'Dump 1'. The fifth item of the structure is the file/object/command to be executed. For details, right-click on it in the 'Dump 1' area > 'Follow DWORD in Dump' > 'Dump 2' and adjust the format by right-clicking > 'Text' > 'Extended ASCII'.

In this case, it is a command initiating...