我们借鉴了这一理念，并将其作为Perl的一般原则：对于常用或频繁输入的内容，必须保持简单和简洁。然而，另一方面，这也会导致某种程度上的不规则性（irregularity）。正如自然语言中常见的那样，最常用的动词往往是最不规则的。

因此，在这种情况下，需要增加更多的差异。我非常喜欢的一本书是翁贝托·艾柯（Umberto Eco）所著的《探寻完美语言》（The Search for the Perfect Language），这本书并不是关于计算机语言的，而是探讨哲学语言，其大意是古代的语言可能是完美的，我们应该重新引入它们。

所有这类语言都错误地假设相似的事物应该始终以相似的方式编码。但这并不是我们的沟通方式。如果你的农场中有许多动物，它们的名字非常相似，当你想宰杀一只鸡时说“去把Blerfoo宰了”，而你的本意是宰杀Blerfee，结果可能是一头牛被误杀了。在这种情况下，我们需要更好地将单词区分开来，以增加通信信道的冗余度。常用的单词应该具有更多的差异性。

为了实现更有效的通信，还需要一种自同步（self-clocking）编码。例如，UPC标签（条形码）就是一种自同步编码，每对“条”和“空”总是以七个列宽为单位，这样你就知道“条”的总宽度总是固定的。这就是自同步。

在电子设备中也有另一种自同步编码。在旧式的串行传输协议中，有启动位和停止位，用于保持同步。自然语言中也存在类似机制。例如，在日语书写中，不需要使用空格。由于书写方式的原因，他们会在每个词组的开头使用汉字字符，然后用平假名（syllabary）中的字符结尾。

**LV: 是平假名，对吗？**

LW: 是的，平假名。因此，在这个系统中，每个词组的开头非常重要。同样，在古希腊语中，大多数动词都是经过变位（declined 或 conjugated）的，所以它们的标准结尾是一种自同步机制。在他们的书写体系中，空格也是可有可无的——空格是在后来才引入的发明。

在计算机语言中也是如此，某些值也可以进行自同步编码。在Perl中，我们大量依赖这种方法，而在Perl 6中，这种依赖更为显著。当你使用表达式时，你可能会得到一个词或一个中缀操作符。当你期望得到一个词时，你可能会得到一个前缀操作符，它位于相同的位置；同样，当你期望得到一个中缀操作符时，你也可能会得到一个后缀操作符。

但反过来，如果编译器确切地知道它想要什么，你可以稍微重载（overload）它们，其他部分则由Perl处理。例如，斜线“/”后面跟着单词时会被视为正则表达式，而在字符串中则被视为除法。但我们并不会重载所有内容，因为这会失去自同步冗余。

通常情况下，我们提供的语法错误消息较为清晰，这是因为在一行中发现了两个关键字，我们会尝试找出为什么会出现这种情况——“哦，你一定漏掉了上一行的分号”。因此，与许多其他按部就班的解析器相比，我们可以生成更好的错误消息。

**LV: 为什么Perl 6花了15年的时间？当每个人对事物有不同的看法时，管理起来一定非常困难，而且正确与错误并不是绝对的。**

LW: 这确实需要非常小心地平衡。一开始有很多好的想法——好吧，我并不是说所有的想法都是好的。也有很多令人头疼的地方，比如有361份RFC（功能建议文件），而我可能只想要20份。我们需要坐下来仔细阅读这些文件，并忽略其中的解决方案，因为它们通常过于表面化且视野狭隘。几乎每一份文件都只针对一件事情，如果我们把它们全部拼凑起来，那简直是一团糟。

> “掌握平衡时需要格外小心。毕竟在刚开始的时候总会有许多的好主意。”

因此，我们必须基于人们在使用Perl 5时的真实感受重新整理，寻找统一、深层次的解决方案。许多RFC文档都提到了类型系统的不足。通过引入更加结构化的类型系统，我们可以解决很多问题，并使代码既聪明又紧凑。

同时，我们开始关注如何统一特性并重用不同领域的思想，而不必让它们在底层完全相同。我们有一种标准的配对（pair）写法——实际上，在Perl中有两种！但使用冒号写配对的方法同样可以用于基数计数法或其他进制的文本编号。同样的方法也可以用于其他形式的引用（quoting）。在Perl中，我们称之为“奇妙的一致”。

> “做了Perl 6早期实现的朋友们握着我的手说：‘我们真的需要一位语言设计者。’”

同样的想法不断涌现，你会说：“我已经熟悉了语法是如何工作的，但我看到它也被用在其他地方。”因此，只有从相同的视角出发，才能找到这种一致性。那些提出各种想法并进行了Perl 6早期实现的人们回来看我，握着我的手说：“我们真的需要一位语言设计者。您能成为我们的仁慈独裁者（benevolent dictator）吗？”

所以我成为了语言的设计者，但总是听到：“不要管具体的实现（implementation）！我们目睹了你在Perl 5中所做的，我们不想历史重演！”这让我忍俊不禁，因为他们起步的核心与原先Perl 5的内部结构几乎没有什么区别，这可能是为什么一些早期实现做得并不好的原因。

因为我们仍在摸索整个设计，实际上做了许多关于虚拟机（VM）该做什么和不该做什么的假设，最终这个东西就像面向对象的汇编语言一样。类似的问题在项目初期无处不在。然后Pugs出现了，他说：“试试Haskell吧，它会让你清醒地认识到自己正在做什么，让我们用它来明确底层的语义模型（semantic model）。”

因此，我们明确了其中的一些语义模型，更重要的是，我们开始建立符合这些语义模型的测试套件。之后，Parrot VM继续开发，另一个基于.NET的实现Niecza也出现了，是由一个年轻人搞出来的。他很聪明，实现了Perl 6的一个很大的子集。不过他还是一个人干，并没有找到什么好方法让别人介入他的项目。

与此同时，Parrot项目变得过于庞大，以至于任何人都无法真正深入掌控它，并且很难重构。Rakudo项目的开发者觉得我们可能需要在更多平台上运行它，而不仅仅是Parrot VM。于是他们发明了一个名为NQP（Not Quite Perl）的可移植层。他们首先将它移植到JVM（Java虚拟机）上运行，同时还在秘密开发一个名为MoarVM的虚拟机，直到去年才为人所知。

无论是MoarVM还是JVM，在回归测试（regression test）中的表现都非常接近——在许多方面，Parrot已经落后。这种不挑剔虚拟机的做法非常好，我们也能开始考虑将NQP发扬光大。谷歌夏季编程大赛（Google Summer of Code project）的目标是针对JavaScript的NQP，这应该是可行的，因为MoarVM也同样使用Node.js进行日常处理。

我们可能要把今年剩下的时间投入到MoarVM上，直到6.0版本发布，才能稍作休息。

**LV: 去年英国政府开展了编程年活动（Year of Code），旨在激发年轻人对编程的兴趣。关于活动的建议五花八门——有人认为应该从低级语言开始教授，以便让人们准确理解内存的使用，或者从高级语言开始。你怎么看？**

LW: 到目前为止，Python社区在低级教学方面做得比我们要好。我们也希望在这方面做些努力，这也是我们选择蝴蝶标志的部分原因，以此吸引七岁左右的女孩！

![Perl 6 : Camelia](/data/attachment/album/201510/19/231006ycxctieklmkevthk.png)

> “到目前为止，Python社区在低级教学方面做得比我们要好。”

我们认为将Perl 6作为第一门语言来学习是可行的。有许多人将Perl 5作为第一门语言来学习，这让我们感到惊讶。你知道，在Perl 5中有很多相当大的概念，如闭包、词法作用域以及一些通常在函数式编程中见到的特性。在Perl 6中更是如此。

Perl 6之所以花了这么长时间，部分原因是我们试图坚持近50种不同的原则，但在设计语言的最后阶段，关于“哪些规则最重要”的问题仍然悬而未决。有很多问题需要讨论。有时我们做出了决定，并已经工作了一段时间，才发现这个决定并不完全正确。

之前我们并没有针对并发编程设计或指定很多内容，直到Jonathan Worthington的出现，他非常巧妙地权衡了各个方面。他结合了一些其他语言（如Go和C#）的想法，编写了非常好的并发原语。可组合性（composability）是一个语言至关重要的部分。

许多编程系统的并发和并行处理得并不好——比如线程和锁，有很多不良的操作方式。因此，我认为花额外的时间看看Go或C#等高级原语的开发是非常值得的——这是一种表面上看似矛盾但实际上非常棒的方法。

---

via: 
作者：[Mike Saunders](http://www.linuxvoice.com/author/mike/) 译者：[martin2011qi](https://github.com/martin2011qi) 校对：[wxy](https://github.com/wxy)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创翻译，[Linux中国](https://linux.cn/) 荣誉推出