### The TLS Handshake Protocol and Its Modified Version

**Figure 2: The TLS Handshake Protocol (Key Exchange Method: RSA) and its modified version.**

For SSL/TLS and SSH, we demonstrate that they satisfy implicit disjointness. For detailed proofs and other protocols, see [22].

#### Implicit Disjointness of SSL/TLS

The cryptographic core of the TLS Handshake Protocol with RSA encryption is depicted in Figure 2 on the left (considering the variant where the client authenticates itself using digital signatures). Here, \( NC \) and \( NS \) are nonces generated by the client \( C \) and the server \( S \), respectively. The premaster secret \( PMS \) is chosen randomly by the client and encrypted under the public key of the server (\( {|PMS|}kS \)). Constants \( c0, \ldots, c4 \) are distinct, and \( F \) is a pseudo-random function. The master secret \( MS \) is derived from \( PMS \) as follows:
\[ MS = F(PMS, c0 \| NC \| NS) \]
The notation \( \{m\}k1,k2 \) denotes MAC-then-encrypt, i.e., \( \{m\}k1,k2 = \{m, mack1(m)\}k2 \). Symmetric encryption and MAC keys \( EKCS, EKSC, IKCS, IKSC \) are derived from \( MS \) using \( F \) and the nonces \( NC \) and \( NS \) as seeds. The term "handshake" represents the concatenation of all previous messages:
\[ handshake = c1 \| NC \| S \| kS \| c2 \| NS \| C \| kC \| {|PMS|}kS \]

In Step 3 of the protocol, the server performs the following checks (dropping the message if any check fails):
1. Decrypts the first ciphertext using \( Fcrypto \).
2. Verifies that the signature is over the expected message.
3. Verifies the signature \( sigkC(handshake) \) using \( Fcrypto \).
4. Derives the keys \( MS, EKCS, \) etc., and decrypts the second ciphertext.
5. Verifies the MAC within the plaintext.

Modeling this protocol as a multi-session real protocol \( PTLS = !MC | !MS \) that uses \( Fcrypto \) for all cryptographic operations (public-key and symmetric encryption, key derivation, digital signatures, and MAC) is straightforward. The protocol \( PTLS \) realizes \( Fkey-use \), allowing parties to send encryption and decryption requests to \( MC \) and \( MS \), which are MACed and encrypted under the corresponding keys. Corruption is defined such that the adversary can corrupt the public/private keys of parties via \( Fcrypto \) and can corrupt instances of \( MC \) and \( MS \) when they are created. The adversary can gain complete control over a party by corrupting their public/private keys and all their instances of \( MC \) and \( MS \).

We provide a proof sketch that \( PTLS \) satisfies implicit disjointness (see [22] for details). The proof does not need to exploit the security of symmetric encryption and only requires syntactic arguments since \( Fcrypto \) is used for the cryptographic primitives.

The partnering function \( τTLS \) for \( PTLS \) is defined as follows:
- Let \( ρ \) be a run of \( E|PTLS|Fcrypto \) for some environment \( E \) and \( α \) be the projection of \( ρ \) to an instance of \( Mr \) for some user \( (p, lsid, r) \) where \( r \in \{C, S\} \).
- If \( (p, lsid, r) \) is corrupted, then \( τTLS(α) := ⊥ \).
- Otherwise, if \( r = C \) and \( α \) contains at least the first two messages of the protocol, then \( τTLS(α) := (NC, NS) \), where \( NS \) is the server's nonce received and \( NC \) is the nonce generated; analogously for the case \( r = S \).

It is easy to see that \( τTLS \) is valid for \( PTLS \) because ideal nonces (generated using \( Fcrypto \)) do not collide.

**Theorem 5.** \( PTLS \) satisfies implicit disjointness w.r.t. \( τTLS \).

**Proof Sketch.**
- All symmetric keys (e.g., \( PMS, MS, EKSC, \) etc.) are, by definition, not explicitly shared: \( PMS \) is a freshly generated symmetric key, and \( MS \) is derived from \( PMS \); all other keys are derived from \( MS \).
- We only need to show (b) of Definition 2 for public-key encryption and digital signatures. Specifically, the relevant cases are when the server performs a decryption request with \( kS \) (to obtain \( PMS \)) or when it verifies the signature of the client.
- Consider the case of a decryption request with \( kS \). Assume an uncorrupted instance of the server, say \( \hat{MS} \), performed an accepted and ideal decryption request. Let \( NC \) be the nonce \( \hat{MS} \) received, \( NS \) be the nonce generated by \( \hat{MS} \), \( kS \) be its public key, \( kC \) be the public key received, and \( ct \) be the ciphertext received (containing \( PMS \)) and on which \( \hat{MS} \) performed the decryption request.
- Since the decryption request is accepted, the handshake message has the required format and the signature verified. This implies an uncorrupted instance made a signing request to \( Fcrypto \) with the private key of \( kC \) and the message handshake. This instance must be in role \( C \) (say, the instance is \( \hat{MC} \)), as uncorrupted server instances do not produce signatures.
- Since the handshake contains \( NC \) and \( NS \), these are the nonces generated and received, respectively, by \( \hat{MC} \). Consequently, \( \hat{MC} \) and \( \hat{MS} \) are partners according to \( τTLS \). Since the ciphertext \( ct \) and the public key \( kS \) are contained in the handshake, \( \hat{MC} \) must have encrypted \( PMS \) under \( kS \) and obtained the ciphertext \( ct \) from \( Fcrypto \). Thus, the partner \( \hat{MC} \) of \( \hat{MS} \) has issued the corresponding encryption request.

#### Implicit Disjointness of SSH

The cryptographic core of the key exchange protocol of SSH, for which we show implicit disjointness, is depicted in Figure 3, with \( K = gxy \) and \( sid = H(NC, NS, kS, gx, gy, K) \), where \( H \) is a hash function. Symmetric encryption and MAC keys \( EKCS, EKSC, IKCS, IKSC \) are derived from \( K \) using \( H \) and \( sid \) as seeds. By \( \{m\}k1,k2 \) we denote encrypt-and-MAC, i.e., \( \{m\}k1,k2 = \{m\}k2, mack1(m) \).

The formal model of SSH as a multi-session real protocol \( PSSH = !MC | !MS \) is similar to the one for TLS. However, \( PSSH \) only uses \( Fcrypto \) for digital signatures; all other cryptographic operations (encryption, MAC, hashing) are carried out by \( MC \) and \( MS \) themselves because \( Fcrypto \) does not support Diffie-Hellman key exchange yet. In the proof that \( PSSH \) satisfies implicit disjointness, we only need to do a reduction argument to the collision resistance of the hash function, as \( PSSH \) uses \( Fcrypto \) for digital signatures, and the security of the encryption scheme, MAC scheme, or Diffie-Hellman key exchange is not needed.

The partnering function \( τSSH \) for \( PSSH \) is defined similarly to TLS, except that the SID is \( sid = H(NC, NS, kS, gx, gy, K) \) instead of \( (NC, NS) \). To show that it is valid, we need the hash function to be collision resistant. Alternatively, one could define \( sid = (NC, NS) \), in which case collision resistance is not needed to show that \( τSSH \) is valid, but then collision resistance would be necessary to show implicit disjointness. With \( τSSH \), implicit disjointness of \( PSSH \) follows easily since \( sid \) is part of every signature.

**Theorem 6.** \( PSSH \) satisfies implicit disjointness w.r.t. \( τSSH \).

### References

[1] M. R. Albrecht, K. G. Paterson, and G. J. Watson. Plaintext Recovery Attacks against SSH. In S&P 2009, pages 16–26. IEEE Computer Society, 2009.

[2] B. Barak, Y. Lindell, and T. Rabin. Protocol Initialization for the Framework of Universal Composability. Technical Report 2004/006, Cryptology ePrint Archive, 2004. http://eprint.iacr.org.

[3] M. Bellare, D. Pointcheval, and P. Rogaway. Authenticated Key Exchange Secure against Dictionary Attacks. In B. Preneel, editor, EUROCRYPT 2000, volume 1807 of LNCS, pages 139–155. Springer, 2000.

[4] M. Bellare and P. Rogaway. Entity Authentication and Key Distribution. In D. Stinson, editor, CRYPTO’93, volume 773 of LNCS, pages 232–249. Springer, 1993.

[5] M. Bellare and P. Rogaway. Provably Secure Session Key Distribution: The Three Party Case. In STOC’95, pages 57–66. ACM, 1995.

[6] B. Blanchet. Computationally Sound Mechanized Proofs of Correspondence Assertions. In CSF 2007, pages 97–111. IEEE Computer Society, 2007.

[7] R. Canetti. Universally Composable Security: A New Paradigm for Cryptographic Protocols. In FOCS 2001, pages 136–145. IEEE Computer Society, 2001.

[8] R. Canetti. Universally Composable Security: A New Paradigm for Cryptographic Protocols. Technical Report 2000/067, Cryptology ePrint Archive, December 2005. http://eprint.iacr.org.

[9] R. Canetti and H. Krawczyk. Analysis of Key-Exchange Protocols and Their Use for Building Secure Channels. In B. Pfitzmann, editor, EUROCRYPT 2001, volume 2045 of LNCS, pages 453–474. Springer, 2001.

[10] R. Canetti and H. Krawczyk. Security Analysis of IKE’s Signature-Based Key-Exchange Protocol. In M. Yung, editor, CRYPTO 2002, volume 2442 of LNCS, pages 143–161. Springer, 2002.

[11] R. Canetti and T. Rabin. Universal Composition with Joint State. In CRYPTO 2003, volume 2729 of LNCS, pages 265–281. Springer, 2003.

[12] I. Cervesato, A. D. Jaggard, A. Scedrov, J.-K. Tsay, and C. Walstad. Breaking and Fixing Public-key Kerberos. Inf. Comput., 206(2-4):402–424, 2008.

[13] K.-K. R. Choo and Y. Hitchcock. Security Requirements for Key Establishment Proof Models: Revisiting Bellare-Rogaway and Jeong-Katz-Lee Protocols. In C. Boyd and J. M. G. Nieto, editors, ACISP 2005, volume 3574 of LNCS, pages 429–442. Springer, 2005.

[14] A. Datta, A. Derek, J. C. Mitchell, and B. Warinschi. Computationally Sound Compositional Logic for Key Exchange Protocols. In CSFW 2006, pages 321–334. IEEE Computer Society, 2006.

[15] J. P. Degabriele and K. G. Paterson. On the (In)Security of IPsec in MAC-then-Encrypt Configurations. In CCS 2010. ACM, 2010.

[16] S. Gajek, M. Manulis, O. Pereira, A. Sadeghi, and J. Schwenk. Universally Composable Security Analysis of TLS. In J. Baek, F. Bao, K. Chen, and X. Lai, editors, ProvSec 2008, volume 5324 of LNCS, pages 313–327. Springer, 2008.

[17] K. Kobara, S. Shin, and M. Strefler. Partnership in key exchange protocols. In W. Li, W. Susilo, U. K. Tupakula, R. Safavi-Naini, and V. Varadharajan, editors, ASIACCS 2009, pages 161–170. ACM, 2009.

[18] H. Krawczyk. SIGMA: The ‘SIGn-and-MAc’ Approach to Authenticated Diffie-Hellman and Its Use in the IKE-Protocols. In D. Boneh, editor, CRYPTO 2003, volume 2729 of LNCS, pages 400–425. Springer, 2003.

[19] R. Küsters. Simulation-Based Security with Inexhaustible Interactive Turing Machines. In CSFW 2006, pages 309–320. IEEE Computer Society, 2006.

[20] R. Küsters and M. Tuengerthal. Joint State Theorems for Public-Key Encryption and Digital Signature Functionalities with Local Computation. In CSF 2008, pages 270–284. IEEE Computer Society, 2008.

[21] R. Küsters and M. Tuengerthal. Universally Composable Symmetric Encryption. In CSF 2009, pages 293–307. IEEE Computer Society, 2009.

[22] R. Küsters and M. Tuengerthal. Composition Theorems Without Pre-Established Session Identifiers. Technical Report 2011/406, Cryptology ePrint Archive, 2011. http://eprint.iacr.org.

[23] R. Küsters and M. Tuengerthal. Ideal Key Derivation and Encryption in Simulation-based Security. In A. Kiayias, editor, CT-RSA 2011, volume 6558 of LNCS, pages 161–179. Springer, 2011.

[24] G. Lowe. An attack on the Needham-Schroeder public-key authentication protocol. Information Processing Letters, 56:131–133, 1995.

[25] M. Ray and S. Dispensa. Renegotiating TLS. November 2009. Available at http://extendedsubset.com/Renegotiating_TLS.pdf.

[26] P. Rogaway and T. Stegers. Authentication without Elision: Partially Specified Protocols, Associated Data, and Cryptographic Models Described by Code. In CSF 2009, pages 26–39. IEEE Computer Society, 2009.

[27] E. Tews and M. Beck. Practical Attacks against WEP and WPA. In D. A. Basin, S. Capkun, and W. Lee, editors, WiSec 2009, pages 79–86. ACM, 2009.