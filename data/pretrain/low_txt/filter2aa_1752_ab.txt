### 第 8 章 内存管理

#### 8.2 内存调整
- **8.2.2 调整内存大小** ... 262
- **8.2.3 内存管理** ... 264
- **8.2.4 对内存的优化** ... 266

#### 8.3 段的管理 ... 270

#### 8.4 内存映射
- **8.4.1 内存映射** ... 272
- **8.4.2 映射 /dev/zero** ... 274

#### 8.5 内存分配 ... 275
- **8.5.1 使用 `malloc_usable_size()` 和 `malloc_trim()` 进行调整** ... 277

#### 8.6 调整内存 ... 278
- **8.6.1 内存调整策略** ... 278

#### 8.7 内存使用 ... 280
- **8.7.1 内存使用的分析** ... 282
- **8.7.2 内存使用示例** ... 283

#### 8.8 内存管理工具 ... 284

#### 8.9 内存操作 ... 286
- **8.9.1 设置内存参数** ... 286
- **8.9.2 内存读取** ... 287
- **8.9.3 内存写入** ... 288
- **8.9.4 内存复制** ... 289
- **8.9.5 内存比较** ... 290

#### 8.10 内存空间
- **8.10.1 内存空间概述** ... 291
- **8.10.2 内存空间分配** ... 292
- **8.10.3 内存空间回收** ... 293
- **8.10.4 内存空间碎片化** ... 294
- **8.10.5 页管理与内存** ... 294

#### 8.11 性能优化
- **8.11.1 超大内存处理** ... 295

---

### 第 9 章 信号

#### 9.1 信号基础 ... 297
- **9.1.1 信号介绍** ... 298
- **9.1.2 Linux 中的信号** ... 298

#### 9.2 信号处理 ... 304
- **9.2.1 信号处理函数** ... 305
- **9.2.2 子进程信号处理** ... 306
- **9.2.3 信号掩码** ... 309
- **9.2.4 信号映射** ... 310

#### 9.3 信号发送 ... 311
- **9.3.1 发送信号给自身** ... 311
- **9.3.2 发送信号给子进程** ... 312
- **9.3.3 发送信号给当前进程** ... 312
- **9.3.4 发送信号给其他进程** ... 313

#### 9.4 信号捕获 ... 313
- **9.4.1 信号捕获机制** ... 314

#### 9.5 信号集 ... 316
- **9.5.1 更改信号集** ... 316

#### 9.6 信号处理函数 ... 317
- **9.6.1 处理多个信号** ... 318
- **9.6.2 信号集的操作** ... 318

#### 9.7 信号信息
- **9.7.1 `siginfo_t` 结构** ... 321
- **9.7.2 `si_code` 的世界** ... 323

#### 9.8 信号传递 ... 325
- **9.8.1 子进程信号传递** ... 326

#### 9.9 信号总结 ... 326

---

### 第 10 章 时间管理

#### 10.1 时间的基础
- **10.1.1 原始时间表示** ... 330
- **10.1.2 时间戳** ... 331
- **10.1.3 时间格式** ... 331
- **10.1.4 时间转换** ... 332
- **10.1.5 进程时间** ... 333

#### 10.2 POSIX 时间
- **10.2.1 POSIX 时间接口** ... 333

#### 10.3 时间操作 ... 334

#### 10.4 时间管理
- **10.4.1 更精细的时间控制** ... 336
- **10.4.2 时间同步** ... 337
- **10.4.3 进程时间管理** ... 338

#### 10.5 设置时间
- **10.5.1 时间设置方法** ... 340
- **10.5.2 设置系统时间** ... 340

#### 10.6 时间校准 ... 341

#### 10.7 调整和校准时钟 ... 343

#### 10.8 实时时间
- **10.8.1 实时时间介绍** ... 347
- **10.8.2 Linux 中的实时时间** ... 347
- **10.8.3 实时时间的应用** ... 348
- **10.8.4 实时时间的方法** ... 350
- **10.8.5 `sleep` 的实时实现** ... 353
- **10.8.6 超时处理** ... 353
- **10.8.7 实时时间示例** ... 354

#### 10.9 定时器
- **10.9.1 单次定时器** ... 354
- **10.9.2 重复定时器** ... 355
- **10.9.3 定时器管理** ... 358
- **10.9.4 设置定时器** ... 360

---

### 附录 A GCC 对 C 语言的扩展

#### A.1 GNU C 扩展 ... 365
- **A.1.1 内联函数** ... 365
- **A.1.2 内部函数** ... 366
- **A.1.3 变长数组** ... 367
- **A.1.4 灵活数组成员** ... 368
- **A.1.5 属性** ... 368
- **A.1.6 内存对齐** ... 368
- **A.1.7 调试信息** ... 369
- **A.1.8 将函数标记为 deprecated** ... 369
- **A.1.9 将变量标记为 used** ... 370
- **A.1.10 将变量标记为 unused** ... 370
- **A.1.11 将结构体打包** ... 370
- **A.1.12 内存对齐属性** ... 371
- **A.1.13 将变量声明为线程局部存储** ... 372
- **A.1.14 字符串字面量连接** ... 372
- **A.1.15 静态断言** ... 373
- **A.1.16 格式字符串检查** ... 373
- **A.1.17 内存对齐属性** ... 374
- **A.1.18 内联汇编** ... 375
- **A.1.19 函数名修饰** ... 375
- **A.1.20 Case 范围** ... 376
- **A.1.21 void 类型的操作** ... 377
- **A.1.22 更多更强大的特性** ... 377

---

### 附录 B 参考书目

#### B.1 C 语言编程相关书籍 ... 380
#### B.2 Linux 编程相关书籍 ... 381
#### B.3 Linux 内核相关书籍 ... 381
#### B.4 操作系统设计相关书籍 ... 382

---

### 第 1 章 简介和主要概念

#### 1.1 系统编程
系统编程涉及编写直接与操作系统交互的程序。这些程序通常通过调用系统 API 来访问底层资源，如文件、网络和设备。Linux 提供了丰富的系统调用接口，使开发者能够高效地进行系统编程。

##### 1.1.1 系统调用
系统调用是操作系统提供的一种机制，允许用户空间程序请求内核服务。常见的系统调用包括 `read()`、`write()`、`open()` 等。在 i386 架构上，系统调用通过中断 `int 0x80` 触发，并将系统调用号和其他参数传递给内核。

##### 1.1.2 调用系统调用
用户空间程序通过特定的指令触发系统调用。例如，在 i386 上，程序通过将系统调用号放入寄存器 `eax` 并执行 `int 0x80` 来触发系统调用。内核根据系统调用号执行相应的处理。

##### 1.1.3 C 库
C 库（如 glibc）提供了更高层次的接口来封装系统调用，简化了编程。库函数如 `fopen()`、`fprintf()` 等内部调用了系统调用，为开发者提供了更方便的接口。

##### 1.1.4 C 编译器
GCC 是 Linux 上常用的 C 编译器。它不仅支持标准 C 语言，还提供了许多扩展功能，如内联函数、变长数组等，增强了编程的灵活性和性能。

#### 1.2 API 和 ABI
API（应用程序编程接口）定义了软件组件之间的交互方式，而 ABI（应用程序二进制接口）则规定了不同组件之间如何进行二进制级别的交互。两者共同确保了程序的可移植性和兼容性。

##### 1.2.1 API
API 是一组定义好的函数、数据结构和常量，用于实现特定的功能。API 使得开发者可以利用已有的代码库，而不必从头开始编写所有功能。

##### 1.2.2 ABI
ABI 定义了程序在二进制级别上的行为，包括调用约定、数据对齐、系统调用编号等。不同的平台可能有不同的 ABI，因此了解目标平台的 ABI 对于编写可移植的代码非常重要。

#### 1.3 标准
Unix 程序员经常参考的标准包括 POSIX 和 SUS（Single Unix Specification）。这些标准定义了 Unix 系统的行为，确保了跨平台的一致性。

##### 1.3.1 POSIX 和 SUS 的历史
POSIX（Portable Operating System Interface）和 SUS 是一系列标准，旨在规范 Unix 系统的行为。POSIX 最初由 IEEE 在 1988 年发布，随后经过多次更新，最新的版本是 POSIX.1-2008。SUS 是基于 POSIX 的扩展，提供了更多的功能和规范。

##### 1.3.2 C 语言标准
C 语言的标准由 ISO 组织制定，最新的标准是 C11。这些标准定义了 C 语言的语法和语义，确保了 C 语言程序在不同平台上的可移植性。

##### 1.3.3 Linux 和标准
Linux 努力遵守 POSIX 和 SUS 标准，但也有一些自己的扩展和改进。Linux 提供了许多符合 POSIX 的系统调用和库函数，但同时也引入了一些新的特性和优化。

##### 1.3.4 本书和标准
本书涵盖了 Linux 系统编程的主要概念和技术，同时参考了 POSIX 和 SUS 标准。通过学习本书，读者可以掌握 Linux 系统编程的基本技能，并了解如何编写符合标准的高质量代码。

#### 1.4 Linux 编程概念
Linux 编程涉及许多核心概念，如文件系统、进程管理和内存管理。理解这些概念对于编写高效的 Linux 程序至关重要。

##### 1.4.1 文件和文件系统
文件是 Linux 系统中的基本单位，可以通过各种系统调用进行读写操作。文件系统提供了对文件的组织和管理，支持多种类型的文件和目录结构。

##### 1.4.2 普通文件
普通文件是最常见的文件类型，可以包含任意数据。Linux 提供了多种方式来操作普通文件，包括读写、截断和映射到内存中。理解文件的生命周期和管理方式对于编写高效的文件操作代码非常重要。

希望这些优化后的文本更加清晰、连贯和专业。如果有进一步的需求或修改，请随时告知！