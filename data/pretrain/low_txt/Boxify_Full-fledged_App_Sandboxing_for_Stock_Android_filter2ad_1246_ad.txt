### Boxify Environment Management and Security

#### Package Management
The Boxify environment manages the installed packages. Any call to a system service that is not emulated by the Core Logic Layer is passed to the Virtualization Layer, which then forwards it to the underlying Android system. Other system services, such as the `LocationManager`, which are not necessarily required, can be instantiated at this layer. This allows encapsulated apps to use the local, Boxify service implementation instead of the native Android service. For example, sandboxed apps can be served with fake location data. Therefore, this layer decides whether an Android API call is emulated using a replicated service or forwarded to the system via the Virtualization Layer. It also manages Inter-Process Communication (IPC) between different sandboxed apps, functioning like an "ICC switch."

#### Policy Enforcement Points (PEP)
The Core Logic Layer implements PEPs for Binder IPC services and syscalls. The API Layer already bridges the semantic gap between kernel-level IPC and Android application framework semantics, removing the need to handle low-level semantics in the IPC PEPs. We emulate the integration of enforcement points into native Android services by integrating these points into our mandatory service proxies. This allows us to instantiate security models from the realm of OS security extensions at the application layer. One default security model provided by Boxify is the permission enforcement and same-origin model of Android. For instance, the replicated `ActivityManager` enforces permissions on calls between components of two sandboxed apps. Additional security models from related work on OS security extensions are discussed in §5.4. Future work may include a programmable interface for extending Core Logic Layer security, similar to ASM [37] and ASF [14]. For calls not protected by permissions, the Broker can enable direct communication between the target app and the requested Android system service, improving performance for non-critical services like `SurfaceFlinger` (for GUI updates), though at the cost of losing the ability to mediate calls to these services.

#### Syscall PEP
The syscall PEP enforces system call policies, particularly for network and filesystem operations. Its responsibilities are twofold: First, it acts as a transparent compatibility layer by emulating the filesystem structure of the Android data partition (e.g., chroot of sandboxed apps by emulating a home directory for each sandboxed app within the home directory of the Boxify app). Second, it emulates the access control of the Linux kernel, ensuring compartmentalization of sandboxed apps. This prevents them from accessing private files of other apps and enforces permissions (e.g., preventing a sandboxed app without Internet permission from creating a network socket).

#### Virtualization Layer
The sandbox environment must support communication between sandboxed apps and the Android application framework, as certain system resources cannot be efficiently emulated (e.g., `SurfaceFlinger` for GUI) or not emulated at all (e.g., hardware resources like the camera). The sandbox must be transparent to the target app and all interactions with the application framework must appear as in a regular app. At the same time, the sandbox must be opaque to the application framework, hiding sandboxed apps from it to avoid runtime (security) exceptions.

In Boxify, the Virtualization Layer translates bi-directional communication between the Android application framework and the target. It uses a technique abstractly described as "ICC Network Address Translator." On outgoing calls from the target to the framework, it ensures that all ICC appears as coming from the Boxify app instead of the sandboxed app. All Binder handles of a target are substituted with handles of the Broker, which relays the calls to the system. During relay, the Virtualization Layer manipulates call arguments to hide components of sandboxed apps by substituting component identifiers with those of the Boxify app. On incoming calls from the framework, the Virtualization Layer substitutes the addressed Boxify component with the actual component of the sandboxed app and dispatches the call. To correctly substitute addressed components, the Virtualization Layer maintains a mapping between target and Boxify component names, or, if the target component is addressed by a Binder handle, the mapping is between the released Binder handle and its owning target component.

A concrete example is requesting the launch of a target `Activity` component from the application framework. The Virtualization Layer substitutes the `Activity` component with a generic `Activity` component of Boxify if a call to the `ActivityManager` occurs. When the service calls back for scheduling the `Activity` launch, the Virtualization Layer dispatches the scheduling call to the corresponding target `Activity` component. Lastly, we hook the application runtime of Boxify's Broker process to gain control over the processing of incoming Binder parcels, enabling the Broker to distinguish between parcels addressed to Boxify and those needing to be forwarded to the target processes.

#### System Integration
Sandboxed apps must be started through Boxify and are not regularly installed on the system. A straightforward solution is to provide a custom launcher with Boxify in the form of a dedicated `Activity`. Alternatively, Boxify could register as a launcher app and run the default launcher (or any launcher app of the user’s choice) in the sandbox, presenting the union of regularly installed apps and apps installed in the sandbox environment. Boxify launcher widgets can also be placed on the regular home screen to launch sandboxed apps from there.

Boxify integrates smoothly with app store applications like the Google Play Store. Since no special permissions are required to install apps into the sandbox, we can run store apps provided by Google, vendors, and third-parties in Boxify to install new apps. Clicking "install" in the sandboxed Play Store App will directly install the new app into Boxify. Furthermore, the Play Store (and vendor stores) automatically update all apps installed in Boxify, a feature that IRM systems have to manually re-implement.

Some resources of apps are statically registered in the system during app installation. Since sandboxed apps are not regularly installed, the system is unaware of their resources, particularly `Activity` components that can receive Intents for content sharing or package resources like icons. However, some resources like `BroadcastReceiver` components can be dynamically registered at runtime, and Boxify uses this as a workaround to dynamically register the Receivers declared statically in the Manifests of sandboxed apps.

#### Evaluation
We discuss the prototypical implementation of Boxify in terms of performance impact, security guarantees, and app robustness, and present concrete use-cases. Our prototype comprises 11,901 lines of Java code, of which 4,242 LoC are automatically generated (API Layer), and 3,550 lines of additional C/C++ code. All tests were performed on an LG Nexus 5 running Android 4.4.4, the most widely used version in the Android ecosystem.

##### Performance Impact
To evaluate the performance impact of Boxify on monitored apps, we compare the results of common benchmark apps and custom micro-benchmarks for encapsulated and native execution of apps. Tables 2 and 3 present the results of our micro-benchmarks for common Android API calls and syscall performance. Intercepting calls to the application framework imposes an overhead around 1%, with the exception of the very fast `Query Contacts` (12%). For syscalls, we measured the performance of calls that request file descriptors for file I/O in private app directories (or external storage) and that are proxied by the Broker. We observe a constant performance overhead of approximately 100µs, which corresponds to the required time of the additional IPC round trip for the communication with the Broker on our test platform. However, the syscall benchmarks depict a worst-case estimation: The overall performance impact on apps is much lower, since high-frequency follow-up operations on acquired file descriptors (e.g., read/write) do not need to be intercepted and therefore run with native speed. Table 4 shows an acceptable performance degradation of 1.6%–4.8%.

##### Runtime Robustness
To assess the robustness of encapsulated apps, we executed 1,079 of the most popular, free apps from Google Play (retrieved in August 2014) on top of Boxify. For each sandboxed app, we used the `monkeyrunner` tool to exercise the app’s functionality by injecting 500 random UI events. From the 1,079 apps, 93 (8.6%) experienced a crash during testing. Manual investigation revealed that most errors were caused by apps executing exotic syscalls or rarely used Android APIs, which are not covered by Boxify yet and thus fail due to the lack of privileges of the target process (fail-safe defaults). This leads to slightly lower robustness than reported for related work where bypassed hooks do not cause the untrusted app to crash but instead silently circumvent the reference monitor. The remaining issues were due to unusual application logic that relies on certain OS features (e.g., the `proc` pseudo-filesystem), which the current prototype of Boxify does not yet support. However, all of these are technical and not conceptual shortcomings of the current implementation of Boxify.

##### Portability
Table 5 summarizes the Android versions currently supported by our prototypical Boxify implementation. Our prototype supports all Android versions 4.1 through 5.1 and can be deployed on nine out of ten devices in the Android ecosystem. Android versions prior to 4.1 are not supported due to the lack of the isolated process feature.

##### Use-Cases
Boxify allows the instantiation of different security models from the literature on Android security extensions. Two selected use-cases on fine-grained permission control and domain isolation are presented.

**Fine-Grained Permission Control:**
The TISSA [64] OS extension empowers users to flexibly control in a fine-grained manner which personal information will be accessible to applications. We reimplemented the TISSA functionality as an extension to the Core Logic Layer of the Boxify Broker. We instrumented the mandatory proxies for core system services (e.g., `LocationManager`, `TelephonyService`) so that they can return a filtered or mock data set based on the user’s privacy settings. Users can dynamically adjust their privacy preferences through a management `Activity` added to Boxify. In total, the TISSA functionality required an additional 351 lines of Java code to the Core Logic Layer.

**Domain Isolation:**
For enterprise deployments, container solutions have been proposed to separate business apps from other (untrusted) apps. We implemented a domain isolation solution based on Boxify by installing business apps into the sandbox environment. The Broker provides its own version of the `PackageManager` to directly deliver inter-component communication to sandboxed applications without involving the regular `PackageManager`, enabling controlled collaboration between enterprise apps while isolating and hiding them from non-enterprise apps and the OS. To separate enterprise data from the user’s private data, we exploit the Broker's ability to run separate instances of system services (e.g., `Contacts`, `Calendar`) within the sandbox. Our custom `ActivityManager` proxy now selectively and transparently redirects `ContentProvider` accesses by enterprise apps to the sandboxed counterparts of those providers.

Alternatively, the domain isolation concept was used to implement a privacy mode for end users, where untrusted apps are installed into a Boxify environment with empty (or faked) system `ContentProviders`. Thus, users can test untrusted apps in a safe environment without risking harm to their mobile device or private data. The domain isolation extension required 986 additional lines of code in the Core Logic Layer of Boxify.

##### Security Discussion
Our solution builds on isolated processes as a fundamental security primitive. An isolated process is the most restrictive execution environment that stock Android currently offers, providing Boxify with better security guarantees than closest related work [38].

**Privilege Escalation:**
A malicious app could bypass the syscall and IPC interceptors, for instance, by statically linking `libc`. For IPC, this does not lead to a privilege escalation, as the application framework apps and services will refuse to cooperate with an isolated process. However, the kernel is unaware of the concept of an "isolated process" and will enforce access control on syscalls according to the process’ UID. Although the transient UIDs of isolated processes provide some protection, future security primitives of stock Android that would benefit Boxify and defensively programmed apps in general should be considered.