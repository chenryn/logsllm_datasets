# Programmer’s Manual, Volume 2: System Programming
**Revision 3.22, September 2012**

## References

1. N. Binkert, B. Beckmann, G. Black, S. K. Reinhardt, A. Saidi, A. Basu, J. Hestness, D. R. Hower, T. Krishna, S. Sardashti, R. Sen, K. Sewell, M. Shoaib, N. Vaish, M. D. Hill, and D. A. Wood. The gem5 simulator. *SIGARCH Comput. Archit. News*, 39(2):1–7, Aug. 2011.
2. Bluespec, Inc. Bluespec SystemVerilog.
3. J. Brown, J. Grossman, A. Huang, and T. F. Knight, Jr. A capability representation with embedded address and nearly-exact object bounds. Technical Report 5, MIT AI Lab, April 2000. Aries Project.
4. N. P. Carter, S. W. Keckler, and W. J. Dally. Hardware support for fast capability-based addressing. In *Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-VI)*, pages 319–327, 1994.
5. S. Chen, B. Falsaﬁ, P. B. Gibbons, M. Kozuch, T. C. Mowry, R. Teodorescu, A. Ailamaki, L. Fix, G. R. Ganger, B. Lin, and S. W. Schlosser. Log-based architectures for general-purpose monitoring of deployed code. In *1st Workshop on Architectural and System Support for Improving Software Dependability (ASID)*, pages 63–65. ACM, 2006.
6. R. P. Colwell, E. F. Gehringer, and E. D. Jensen. Performance effects of architectural complexity in the Intel 432. *ACM Trans. Comput. Syst.*, 6:296–339, August 1988.
7. J. Criswell, A. Lenharth, D. Dhurjati, and V. Adve. Secure virtual architecture: A safe execution environment for commodity operating systems. In *Proceedings of the Symposium on Operating Systems Principles*, October 2007.
8. D. Y. Deng and G. E. Suh. High-performance parallel accelerator for flexible and efficient run-time monitoring. In *IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)*, pages 1–12. IEEE Computer Society, 2012.
9. D. Johnson. The Intel 432: A VLSI Architecture for Fault-Tolerant Computer Systems. *Computer*, 17:40–48, August 1984.
10. H. M. Levy. Capability-Based Computer Systems. Digital Press, 1984.
11. P. J. Denning and S. C. Schwartz. Properties of the working-set model. *Communications of the ACM*, 15(3):191–198, March 1972.
12. J. B. Dennis and E. C. Van Horn. Programming semantics for multiprogrammed computations. *Communications of the ACM*, 9(3):143–155, March 1966.
13. J. Devietti, C. Blundell, M. M. K. Martin, and S. Zdancewic. HardBound: Architectural support for spatial safety of the C programming language. In *Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems*, pages 103–114, 2008.
14. U. Dhawan, A. Kwon, E. Kadric, C. Hriţcu, B. C. Pierce, J. M. Smith, A. DeHon, G. Malecha, G. Morrisett, T. F. Knight, Jr., A. Sutherland, T. Hawkins, A. Zyxnfryx, D. Wittenberg, P. Trei, S. Ray, and G. Sullivan. Hardware support for safety interlocks and introspection. In *SASO Workshop on Adaptive Host and Network Security*, Sept. 2012.
15. R. S. Fabry. Capability-based Addressing. *Communications of the ACM*, 17(7):403–412, July 1974.
16. E. A. Feustel. On the advantages of tagged architecture. *IEEE Transactions on Computers*, C-22(7):644–656, July 1973.
17. E. F. Gehringer and J. L. Keedy. Tagged architecture: How compelling are its advantages? In *Proceedings of the 12th International Symposium on Computer Architecture*, pages 162–170, 1985.
18. R. Greenblatt, T. Knight, Jr., J. Holloway, D. Moon, and D. Weinreb. The LISP machine. In *Interactive Programming Environments*. McGraw-Hill, 1984.
19. N. Hasabnis, A. Misra, and R. Sekar. Light-weight bounds checking. In *Proceedings of the Tenth International Symposium on Code Generation and Optimization*, pages 135–144, 2012.
20. J. L. Henning. SPEC CPU2006 benchmark descriptions. *SIGARCH Comput. Archit. News*, 34(4):1–17, September 2006.
21. M. E. Houdek, F. G. Soltis, and R. L. Hoffman. IBM System/38 Support for Capability-based Addressing. In *Proceedings of the Eighth Annual Symposium on Computer Architecture*, pages 341–348, 1981.
22. C. Hriţcu, M. Greenberg, B. Karel, B. C. Pierce, and G. Morrisett. All your IFCException are belong to us. In *34th IEEE Symposium on Security and Privacy*, pages 3–17. IEEE Computer Society Press, May 2013.
23. IBM. IBM System/360 Principles of Operation. 1968.
24. Intel Corporation. Intel64 and IA-32 Architectures Software Developer’s Manual, August 2012.
25. T. Jim, J. G. Morrisett, D. Grossman, M. W. Hicks, J. Cheney, and Y. Wang. Cyclone: A safe dialect of C. In *Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation*, pages 245–258, 2009.
26. S. Nagarakatte, J. Zhao, M. M. K. Martin, and S. Zdancewic. CETS: Compiler enforced temporal safety for C. In *Proceedings of the International Symposium on Memory Management*, pages 31–40, 2010.
27. G. C. Necula, J. Condit, M. Harren, S. McPeak, and W. Weimer. CCured: type-safe retrofitting of legacy software. *ACM Trans. Program. Lang. Syst.*, 27(3):477–526, May 2005.
28. R. M. Needham and R. D. H. Walker. The Cambridge CAP computer and its protection system. In *Proceedings of the Symposium on Operating Systems Principles*, pages 1–10, Nov. 1977.
29. E. I. Organick. The MULTICS System: An Examination of Its Structure. MIT Press, 1972.
30. E. I. Organick. Computer System Organization: The B5700/B6700 Series. Academic Press, 1973.
31. E. I. Organick. A Programmer’s View of the Intel 432 System. McGraw-Hill, 1983.
32. A. T. Phillips and J. S. Tan. Exploring security vulnerabilities by exploiting buffer overflow using the MIPS ISA. In *Proceedings of the SIGCSE technical symposium on Computer science education*, pages 172–176, New York, NY, USA, 2003. ACM.
33. O. Ruwase and M. S. Lam. A practical dynamic buffer overflow detector. In *Proceedings of the 11th Annual Network and Distributed System Security Symposium*, pages 159–169, 2004.
34. J. S. Shapiro, J. M. Smith, and D. J. Farber. Eros: a fast capability system. In *Proceedings of the Symposium on Operating Systems Principles*, pages 170–185. ACM, 1999.
35. R. L. Sites. Alpha AXP Architecture. *Digital Technical Journal*, 4(4):1–17, 1992. Special Issue.
36. R. N. M. Watson, J. Anderson, B. Laurie, and K. Kennaway. Capsicum: practical capabilities for UNIX. In *Proceedings of the 19th USENIX Security Symposium*, Washington, DC, August 2010.
37. R. N. M. Watson, P. G. Neumann, J. Woodruff, J. Anderson, R. Anderson, N. Dave, B. Laurie, S. W. Moore, S. J. Murdoch, P. Paeps, M. Roe, and H. Saidi. CHERI: a research platform deconflating hardware virtualization and protection. In *Proc. RESoLVE*, March 2012.
38. M. V. Wilkes and R. M. Needham. The Cambridge CAP Computer and Its Operating System. North Holland, 1979.
39. W. Wulf, E. Cohen, W. Corwin, A. Jones, R. Levin, C. Pierson, and F. Pollack. Hydra: The kernel of a multiprocessor operating system. *Communications of the ACM*, 17(6):337–345, June 1974.
40. W. A. Wulf, R. Levin, and S. P. Harbison. HYDRA/C.mmp: An Experimental Computer System. McGraw-Hill, 1981.
41. Xilinx, Inc. Virtex-6 FPGA ML605 Evaluation Kit.
42. Xilinx, Inc., 2100 Logic Drive, San Jose, CA 95124. Virtex-6 FPGA Data Sheet: DC and Switching Characteristics, September 2011. DS512.
43. Xilinx, Inc., 2100 Logic Drive, San Jose, CA 95124. LogiCORE IP Floating-Point Operator v6.0, January 2012.
44. Y. Younan, P. Philippaerts, L. Cavallaro, R. Sekar, F. Piessens, and W. Joosen. Paricheck: an efficient pointer arithmetic checker for C programs. In *Proceedings of the 5th ACM Symposium on Information, Computer and Communications Security*, pages 145–156, 2010.

## Pipeline Modifications for BIMA Encoding

### Execute/Memory Stage
In the Execute/Memory stage, we move the update distance circuit (Update Distance) to the Validate/Writeback stage. Figure 10 illustrates the resulting pipeline configuration.

### Impact on Non-Pointer Computations
This modification does not affect bypasses or stalls for any non-pointer computations. The number of pipeline stages remains the same, and all other units remain unchanged.

### lw-addp Pair
For an `lw-addp` pair in this pipeline:
- The `addp` can execute immediately as the value (pointer) from memory can be bypassed in one cycle (dotted bypass in Fig. 10).
- While `addp` is computing the new address, Decode 2 in the Validate/Writeback stage will have finished decoding the distances.
- The distances needed for `addp` will be available before the Validate/Writeback stage, eliminating the need for stall cycles.

### addp-addp Pair
Similarly, an `addp-addp` pair does not cause any stalls because we can bypass the `Dunder` and `Dover` in the same fashion (dashed bypass in Fig. 10).

### addp-lw Pair
To avoid stalls for an `addp-lw` pair, we use speculative execution:
- The target address is available by the end of the Execute stage.
- We bypass the updated address and load the value, assuming the pointer is in bounds.
- If the `addp` distance update completes and the pointer used is out-of-bounds, we kill the load result, flush the pipeline, and trap to the error handler.

### Performance
As a result, we maintain the same clock rate and stall conditions as the baseline processor without the Pointer Unit. The BIMA encoding runs just as fast as the baseline processor without spatial safety checking (0% runtime overhead).

## Conclusions
We have demonstrated how it is possible to support fully mediated, fine-grained spatial safety without sacrificing performance. An appropriately low-fat pointer encoding keeps the memory impact small (64-bit pointers for a 46-bit address space) while ensuring small and fast hardware decoding and minimal (<3%) memory fragmentation overhead. Even with an additional 8-bit tag on every word, the total memory overhead is under 16%. Suitable pipelining ensures that the extra work for decoding the low-fat pointer encoding does not create new stall cycles for the processor pipeline. Pointer updates are no more complex than additions, guaranteeing they do not degrade the processor clock cycle. Given the large attack surface area presented by software (millions of lines of code in modern applications and kernels), there is a significant benefit to this approach.

## Appendix: Dynamic Instruction Impact

### Methodology
Our main focus is to show the benefit of native hardware support to enforce spatial memory safety on every instruction. If we were to enforce the same level of checking using a conventional processor, we would need to replace several primitive operations with instruction sequences like those shown in Table 1. 

### Overhead
We evaluate the impact of the additional instructions for performing spatial checks on memory using the SPEC2006 Benchmark Suite [20]. Instruction traces are produced using the gem5 [1] environment, simulating a 64-bit ALPHA ISA [35]. Since the ALPHA ISA does not differentiate between pointers and integers, we perform a pre-pass dataflow analysis to mark all registers used as addresses in load and store operations as pointers and propagate this type information through their lifetimes.

Figure 1 shows the estimated dynamic instructions in a non-fat pointer hardware ALPHA architecture performing spatial checks in software compared to our proposed architecture with hardware support for fat pointers. From the figure, we observe a maximum of 300% and, on average, about 220% overhead in the number of dynamic instructions executed for performing spatial checks in software.

### Table 1: Spatial Checking for Processors with No Fat Pointer Hardware Support

| **Primitive Operation** | **ALPHA Operations** |
|-------------------------|----------------------|
| Pointer Arithmetic       | `$d←$s+$t` (Sec. 4.8.3) |
| Store Non-Pointer        | `mem[$s]←$t` (Sec. 4.8.4) |
| Store Pointer            | `mem[$s]←$t` (Sec. 4.8.4) |
| Load Non-Pointer         | `$t←mem[$s]` (Sec. 4.8.5) |
| Load Pointer             | `$t←mem[$s]` (Sec. 4.8.5) |
| Register Target          | `PC←$s` |

### Additional Instructions for Spatial Checks
- **Pointer Arithmetic:**
  - `addq $d.A, $s.A, $t`
  - `cmpult $q,$d.A,$s.base`
  - `cmpult $r,$s.bound,$d.A`
  - `or $q,$q,$r`
  - `blbs $q, bounds error`
  - `lda $d.base,$s.base,0`
  - `lda $d.bound,$s.bound,0`
- **Store Non-Pointer:**
  - `cmpult $q,$s.A,$s.base`
  - `cmpult $r,$s.bound,$s.A`
  - `or $q,$q,$r`
  - `blbs $q,bounds error`
  - `stq $t,0($s)`
- **Store Pointer:**
  - `cmpult $q,$s.A,$s.base`
  - `lda $r,$s.A,2`
  - `cmpult $r,$s.bound,$r`
  - `or $q,$q,$r`
  - `blbs $q,bounds error`
  - `stq $t.A,0($s.A)`
  - `stq $t.base,1($s.A)`
  - `stq $t.bound,2($s.A)`
- **Load Non-Pointer:**
  - `cmpult $q,$s.A,$s.base`
  - `cmpult $r,$s.bound,$s.A`
  - `or $q,$q,$r`
  - `blbs $q,bounds error`
  - `ldq $t,0($s)`
- **Load Pointer:**
  - `cmpult $q,$s.A,$s.base`
  - `lda $r,$s.A,2`
  - `cmpult $r,$s.bound,$r`
  - `or $q,$q,$r`
  - `blbs $q,bounds error`
  - `ldq $t.A,0($s.A)`
  - `ldq $t.base,1($s.A)`
  - `ldq $t.bound,2($s.A)`
- **Register Target:**
  - `cmpult $q,$s.A,$s.base`
  - `cmpult $r,$s.bound,$s.A`
  - `or $q,$q,$r`
  - `blbs $q,bounds error`
  - `jr $s.A`

By annotating all registers, we can identify which operations must be `addp` in our fat pointer architecture and which load and store operations are moving pointers to and from memory. Once identified, we perform a weighted sum of operations using the instruction counts from Table 1.