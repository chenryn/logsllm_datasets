# 前言
假设你面对一个黑盒测试环境，可以上传任意文件。上传完成后，系统将读取文件内容并显示在网页上。如何利用这一点进行攻击？如果你的答案仅限于“构造突破上传路径”、“尝试突破文件扩展名以getshell”或“尝试利用解析漏洞”，那么本文的探讨可能会为你提供一些新的思路。

# 环境及确认
这个问题源于我在解决一道CTF（Capture The Flag）题目时遇到的情况。该题目提供了一个网站，要求用户上传一个ZIP压缩包。程序会解压该压缩包，并返回指定文件的内容到网页上。我们首先尝试上传一个包含`1.txt`文件（内容为`hello world`）的压缩包，结果页面正确地返回了`hello world`。

# 尝试攻击读取路径
接下来，我们试图通过跨目录读取文件来获取站点目录结构。当请求不存在的`2.txt`时，系统返回了一条警告信息：`Warning: file_get_contents(/tmp/dir_hackme5_5809325816847423574698891475912692524028/2.txt): failed to open stream: No such file or directory in /home/hackme5/task/index.php on line 41`。这揭示了当前文件的位置。然而，直接使用相对路径如`../../../../../../../../../../home/hackme5/task/index.php`或绝对路径`/home/hackme5/task/index.php`均因过滤机制而失败。进一步尝试通过Burp Suite对特殊字符进行模糊测试也未取得成功。最终得出结论，基于路径的攻击方法不可行。

# 尝试构造特殊压缩文件
鉴于路径攻击无效，转而探索构造特定类型的压缩文件。尝试创建指向敏感文件的软链接（例如`../../../../../home/hackme5/task/shell.php`），并通过Burp Suite对其内部路径进行模糊测试，但未能成功执行命令注入。此外，观察到即使在压缩包中存在多级目录结构，程序依然能够正确处理和提取目标文件，表明其具备一定的安全防护措施。经过多次实验后发现，无论怎样构造压缩包，都无法绕过现有防护机制。

# 思考与解决方案
回顾整个过程，分析程序逻辑如下：
- 压缩包被解压至随机生成的临时目录。
- 用户只能请求位于该临时目录下的具体文件，无法指定完整路径。
- 解压过程中不会允许跳转到其他目录。

考虑到上述限制，唯一可能的攻击点在于读取文件本身。因此想到了Linux中的符号链接（symlink）。通过创建指向目标文件的符号链接并将其打包进压缩文件内，可以实现间接访问原本不可达的文件。具体操作步骤包括使用`ln -s`命令建立符号链接以及`zip -y`选项确保打包的是链接而非实际文件。经验证，这种方法确实能够成功读取受保护资源，如`index.php`文件中的FLAG。

# 更多思考
此次实践展示了符号链接在Web应用安全测试中的潜在用途。它不仅可用于绕过某些形式的访问控制，还可能影响应用程序的正常逻辑判断。参考相关案例研究（如GitLab任意文件读取漏洞、CVE-2016-1247等），可以看出此类技术对于识别和修复安全漏洞具有重要意义。需要注意的是，基于符号链接的攻击存在一定局限性，特别是在涉及文件删除操作时效果有限。尽管如此，它仍为我们提供了宝贵的安全测试视角。