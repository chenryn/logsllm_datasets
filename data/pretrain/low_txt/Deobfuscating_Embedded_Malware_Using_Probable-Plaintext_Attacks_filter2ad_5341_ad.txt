### Deobfuscation of Embedded Malware

We apply Kandi to the collected embedded malware. Due to minor modifications by the malware authors, it is not always possible to extract a valid PE (Portable Executable) file. To verify the success of a deobfuscation attempt, we use a PE checker that looks for specific strings such as Windows API functions (e.g., `LoadLibrary`, `GetProcAddress`, `GetModuleHandle`) and library names found in the import table (e.g., `kernel32.dll`, `user32.dll`). Additionally, we check for the MZ and PE header signatures and the DOS stub. A deobfuscation attempt is considered successful if either a valid PE file is extracted or at least five function or library names are revealed in the document.

We observe that for 359 of the samples, no deobfuscation is necessary, as the embedded malware is already in clear text. Kandi identifies such malware by returning an obfuscation key of `0x00`. We support this finding by applying the PE checker described earlier. The remaining 1,258 samples are assumed to be obfuscated. Every fourth of these samples contains malware obfuscated with the Vigenère cipher and is successfully deobfuscated by Kandi. This means our method automatically cracks the obfuscation of 334 samples and extracts the embedded malware—possibly multiple files per sample. Table 3 details the results for the individual datasets. A manual analysis of the remaining files on a sample basis does not reveal obvious indicators for the Vigenère cipher, leading us to conclude that Kandi effectively deobfuscates most variants used in real-world embedded malware.

Figure 8(a) shows the distribution of key lengths discovered by Kandi. The majority of samples are obfuscated with a single-byte key, which is within reach for brute-forcing. However, precisely locating the encrypted file is not trivial. Our method also identifies samples with longer keys ranging from 3 to 8 bytes, which would have been missed without Kandi's assistance. Surprisingly, some samples use 3 bytes as a key. While one might suspect these to be false positives, we have manually verified that these are correctly deobfuscated by our method.

### Deobfuscating Embedded Malware Using Probable-Plaintext Attacks

As the final step of this experiment, we analyze the extracted malware binaries with 46 different anti-virus scanners provided by VirusTotal. Since some of these scanners are prone to errors when it comes to manipulated PE headers, we consider only those 242 deobfuscated malware binaries that are valid PE files (conforming to the format specification). The number of detections for each of these files is shown in Figure 8(b). Several binaries are poorly detected by the anti-virus scanners at VirusTotal. For instance, 19% (46) of the binaries are identified by less than 10 of the available scanners. This result suggests that the extracted binaries are unknown to a large portion of the anti-virus companies—likely due to the lack of tools for automatic deobfuscation.

Finally, the analyzed binaries also contain several samples of the MiniDuke malware, discovered in early February 2013 [6]. A few months back, this threat was completely unknown, suggesting that binaries deobfuscated by Kandi can help in the discovery of new and previously unknown malware.

### Limitations

The previous evaluation demonstrates the capabilities of Kandi in automatically deobfuscating embedded malware. Our approach targets a specific form of obfuscation and thus cannot uncover arbitrarily obfuscated code in documents. We discuss limitations resulting from this setting and present potential extensions of Kandi.

#### Obfuscation with Other Ciphers
Our approach builds on classic attacks against Vigenère ciphers. If a different cryptographic cipher is used for the obfuscation, our method cannot recover the original binary. For example, the RC4-based obfuscation used in the trojan Taidoor [28] is resistant to probable-plaintext attacks as used for Kandi. However, the usage of standard cryptographic primitives, such as RC4 and AES, can introduce detectable patterns in native code, thereby exposing the presence of embedded malware in documents [see 4]. To stay under the radar of detection tools, attackers need to carefully balance the strength of obfuscation and its detectability, which provides room for further cryptographic attacks.

#### Availability of Plaintexts
The efficacy of probable-plaintext attacks critically depends on a sufficiently large set of plaintexts. If no or very few plaintexts are available, the obfuscation cannot be reliably broken. As a result, attackers might try to eliminate predictable plaintexts from their code, for example, by removing header information or avoiding common libraries. Designing malware that does not contain predictable plaintexts is feasible but requires considerable effort. In practice, many targeted attacks use multiple layers of obfuscation, where only a few indicative patterns are visible at each layer. Our evaluation demonstrates that this strategy is often insufficient, as Kandi succeeds in breaking the obfuscation of every fourth sample we analyzed.

#### Other Forms of Vigenère-Based Obfuscation
Our implementation of Kandi is designed to deobfuscate streams of bytes as generated by native obfuscation code. Consequently, the method cannot be directly applied to other encodings, such as those employed in malicious PDF documents using JavaScript code. However, with minor modifications, Kandi can be extended to support other data streams, such as Unicode characters (16-bit) and integers (32-bit). In combination with techniques for detecting and normalizing common encodings, such as Base64 and URI encoding, Kandi might also help in breaking Vigenère-based obfuscations in PDF documents and drive-by-download attacks. Extending the Vigenère cipher by, for instance, introducing chaining, defines a different (although related) obfuscation and cannot be handled with the current implementation of Kandi. We leave this to future work.

### Related Work

The analysis of embedded malware has been a vibrant area of research in recent years, particularly due to the increasing usage of malicious documents in targeted attacks [e.g., 1, 6, 28]. Several concepts and techniques have been proposed to locate and examine malicious code in documents. Our approach is related to several of these, as we discuss below.

#### Analysis of Embedded Malware
Early methods for identifying malware in documents were proposed by Stolfo et al. [27] and Li et al. [15]. Both approaches use content-based anomaly detection to learn profiles of regular documents and detect malicious content as deviations from these profiles. This work was further extended by Shaﬁq et al. [21], who refined the static analysis of documents to locate regions likely containing malware. Although effective in spotting suspicious content, these methods are not designed to deobfuscate code and thus are unsuitable for in-depth analysis of embedded malware.

Another branch of research has focused on analyzing malicious documents at runtime, thereby avoiding the direct deobfuscation of embedded code [e.g., 8, 15, 20]. These dynamic analysis methods involve opening the documents in a sandbox environment to monitor the behavior of the application processing the documents and detect malicious activities. These approaches are not obstructed by obfuscation and can reliably detect malicious code in documents. However, the monitoring at runtime induces a significant overhead, which is prohibitive for large-scale analysis or detection of malware at end hosts.

Recently, a large body of work has focused on malicious PDF documents. Due to the flexibility of this format and its support for JavaScript code, these documents are frequently used to transport malware [25]. Several contrasting methods have been proposed to spot attacks and malware in JavaScript code [e.g., 5, 13] and the structure of PDF files [e.g., 23, 29]. While some malicious PDF documents use Vigenère-based obfuscation, other hiding strategies, such as the dynamic construction of code, are more prominent in the wild. As a consequence, we have not considered PDF documents in this work, but the proposed deobfuscation techniques also apply to Vigenère ciphers used in this document format.

#### Deobfuscating and Unpacking Malware
Aside from specific work on embedded malware, the deobfuscation of malicious code has been a long-standing topic in security research. Several methods have been developed to dynamically unpack malware binaries, such as PolyUnpack [18], OmniUnpack [17], and Ether [7]. These methods monitor memory usage and identify unpacked code created at runtime. A similar approach is devised by Sharif et al. [22], which defeats emulation-based packers using dynamic taint analysis. These unpackers enable a generic deobfuscation of malicious code, but they operate at runtime and suffer from a runtime overhead.

Due to the inherent limitations of static analysis, only a few approaches have been proposed that can statically inspect obfuscated malware. An example is the method by Jacob et al. [11], which, similar to Kandi, exploits statistical artifacts preserved through packing to analyze malware. The method does not focus on deobfuscation but rather efficiently compares malware binaries and determines variants of the same family without dynamic analysis.

#### Probable-Plaintext Attacks
Attacks using probable and known plaintexts are among the oldest methods in cryptography. The Kasiski examination used in Kandi dates back to 1863 [12], and similarly, the key elimination of Vigenère ciphers is an ancient approach in cryptanalysis [see 19]. Given the long history of research and the presence of several strong cryptographic methods, it might seem that attacks against weak ciphers are largely irrelevant today. Unfortunately, these weak ciphers regularly slip into software implementations, and probable-plaintext attacks based on classic techniques are still successful, as seen in the cases of WordPerfect [2] and PKZIP [24].

To the best of our knowledge, Kandi is the first method that applies these classic attacks to obfuscation used in embedded malware. While some high-profile attack campaigns have moved to stronger ciphers, such as RC4 or TEA, the convenience of simple cryptography and the risk of introducing detectable patterns with more complex approaches continue to motivate attackers to use weak ciphers for obfuscation.

### Conclusion

Malicious documents are a popular infection vector for targeted attacks. For this purpose, malware binaries are embedded in benign documents and executed by exploiting vulnerabilities in the program opening them. To limit the chances of being detected by anti-virus scanners, these embedded binaries are usually obfuscated. In practice, this obfuscation is often realized as a simple Vigenère cipher. In this paper, we propose Kandi, a method that exploits well-known weaknesses of these ciphers and is capable of efficiently decrypting Vigenère-based obfuscation. Empirically, we demonstrate the efficacy of this approach on real malware, where our method is able to uncover the code of every fourth malware in popular document and image formats.

While our approach targets only one of many possible obfuscation strategies, it helps to strengthen current defenses against embedded malware. Our method is fast enough to be applied on end hosts, enabling regular anti-virus scanners to directly inspect deobfuscated code and better identify some types of embedded malware. Moreover, by statically exposing details of the obfuscation, such as the key and the operations used, our method can also be applied for the large-scale analysis of malicious documents and is complementary to time-consuming dynamic approaches.

### Acknowledgments

The authors would like to thank Emiliano Martinez and Stefano Zanero for support with the acquisition of malicious documents. The authors gratefully acknowledge funding from the German Federal Ministry of Education and Research (BMBF) under the project PROSEC (FKZ 01BY1145).

### References

1. Bencsáth, B., Pék, G., Felegyhazi, L.B., Duqu, M.: Analysis, detection, and lessons learned. In: European Workshop on System Security (EUROSEC) (2012)
2. Bergen, H.A., Caelli, W.J.: File security in WordPerfect 5.0. Cryptologia 15(1), 57–66 (1991)
3. Boldewin, F.: OfficeMalScanner, http://www.reconstructer.org/code.html
4. Calvet, J., Fernandez, J.M., Marion, J.Y.: Aligot: Cryptographic function identification in obfuscated binary programs. In: ACM Conference on Computer and Communications Security (CCS), pp. 169–182 (2012)
5. Cova, M., Kruegel, C., Vigna, G.: Detection and analysis of drive-by-download attacks and malicious JavaScript code. In: International World Wide Web Conference (WWW), pp. 281–290 (2010)
6. CrySyS Malware Intelligence Team: Miniduke: Indicators. Budapest University of Technology and Economics (February 2013)
7. Dinaburg, A., Royal, P., Sharif, M., Lee, W.: Ether: Malware analysis via hardware virtualization extensions. In: ACM Conference on Computer and Communications Security (CCS), pp. 51–62 (2008)
8. Engelberth, M., Willems, C., Holz, T.: MalOffice: Detecting malicious documents with combined static and dynamic analysis. In: Virus Bulletin Conference (2009)
9. Friedman, W.: The index of coincidence and its applications in cryptology. Tech. rep., Riverbank Laboratories, Department of Ciphers (1922)
10. Friedman, W., Callimahos, L.: Military Cryptanalytics. Aegean Park Press (1985)
11. Jacob, G., Comparetti, P.M., Neugschwandtner, M., Kruegel, C., Vigna, G.: A static, packer-agnostic filter to detect similar malware samples. In: Flegel, U., Markatos, E., Robertson, W. (eds.) DIMVA 2012. LNCS, vol. 7591, pp. 102–122. Springer, Heidelberg (2013)
12. Kasiski, F.W.: Die Geheimschriften und die Dechiffrier-Kunst. E. S. Mittler und Sohn (1863)
13. Laskov, P., Šrndić, N.: Static detection of malicious JavaScript-bearing PDF documents. In: Annual Computer Security Applications Conference (ACSAC), pp. 373–382 (2011)
14. Lewand, R.: Cryptological mathematics. Classroom Resource Materials, The Mathematical Association of America (2000)
15. Li, W.J., Stolfo, S., Stavrou, A., Androulaki, E., Keromytis, A.D.: A study of malcode-bearing documents. In: Hämmerli, B.M., Sommer, R. (eds.) DIMVA 2007. LNCS, vol. 4579, pp. 231–250. Springer, Heidelberg (2007)
16. Malware Tracker Ltd.: Cryptam, http://www.cryptam.com (visited June 2013)
17. Martignoni, L., Christodorescu, M., Jha, S.: OmniUnpack: Fast, generic, and safe unpacking of malware. In: Annual Computer Security Applications Conference (ACSAC), pp. 431–441 (2007)
18. Royal, P., Halpin, M., Dagon, D., Edmonds, R., Lee, W.: PolyUnpack: Automating the hidden-code extraction of unpack-executing malware. In: Annual Computer Security Applications Conference (ACSAC), pp. 289–300 (2006)
19. Schneier, B.: Applied Cryptography. John Wiley and Sons (1996)
20. Schreck, T., Berger, S., Göbel, J.: BISSAM: Automatic vulnerability identification of office documents. In: Flegel, U., Markatos, E., Robertson, W. (eds.) DIMVA 2012. LNCS, vol. 7591, pp. 204–213. Springer, Heidelberg (2013)
21. Shafiq, M.Z., Khayam, S.A., Farooq, M.: Embedded malware detection using Markov n-grams. In: Zamboni, D. (ed.) DIMVA 2008. LNCS, vol. 5137, pp. 88–107. Springer, Heidelberg (2008)
22. Sharif, M., Lanzi, A., Griffin, J., Lee, W.: Automatic reverse engineering of malware emulators. In: IEEE Symposium on Security and Privacy, pp. 94–109 (2009)
23. Smutz, C., Stavrou, A.: Malicious PDF detection using metadata and structural features. In: Annual Computer Security Applications Conference (ACSAC), pp. 239–248 (2012)
24. Stay, M.: ZIP attacks with reduced known plaintext. In: Matsui, M. (ed.) FSE 2001. LNCS, vol. 2355, p. 125. Springer, Heidelberg (2002)
25. Stevens, D.: Malicious PDF documents explained. IEEE Security & Privacy 9(1), 80–82 (2011)
26. Stevens, D.: XORSearch, http://blog.didierstevens.com/programs/xorsearch/ (visited June 2013)
27. Stolfo, S., Wang, K., Li, W.J.: Towards stealthy malware detection. In: Christodorescu, M., Jha, S., Maughan, D., Song, D., Wang, C. (eds.) Malware Detection. Advances in Information Security, vol. 27, pp. 231–249. Springer, US (2007)
28. The Taidoor campaign: An in-depth analysis. Trend Micro Incorporated (2012)
29. Šrndić, N., Laskov, P.: Detection of malicious PDF files based on hierarchical document structure. In: Network and Distributed System Security Symposium (NDSS) (2013)