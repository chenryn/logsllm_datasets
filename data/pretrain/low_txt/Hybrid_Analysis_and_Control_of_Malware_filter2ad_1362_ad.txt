### Introduction of Code-Slicing Capabilities in Dyninst

We have integrated code-slicing capabilities into Dyninst, which will enable SD-Dyninst to resolve many indirect control transfers at parse time. This enhancement significantly improves the tool's ability to handle dynamically unpacked and modified code.

### Comparative Analysis with Existing Tools

In Table 2, we compare the overall performance of our techniques with the most efficient tools for identifying dynamically unpacked and modified code: Renovo [23], "Saffron for Intel PIN" [41], and EtherUnpack [17]. We executed Saffron and EtherUnpack on our own hardware, but since Renovo is not yet publicly available, we compared against its self-reported execution times for packed `notepad.exe` executables, focusing on the top packer tools analyzed in their study.

- **Hardware Specifications:**
  - **SD-Dyninst and Saffron:** Intel Core 2 Duo T2350 1.6GHz CPU with 2.5GB of memory.
  - **Renovo:** Intel Core 2 Duo E6660 2.4GHz CPU with 4GB of memory.
  - **EtherUnpack:** Intel Xeon E5520 2.27GHz CPU with 6GB of memory.

These numbers reflect the post-startup time it took for each tool to execute the instrumented metacode of various packer tools.

### Performance Comparison

As seen in Table 2, except in the case of our unoptimized analysis of the WinUPack executable, our pre-payload execution times are comparable to those of Renovo, Saffron, and EtherUnpack. Notably, our tool also analyzes the code, while the other tools only identify its dynamically unpacked portions. Saffron partially unpacked the ASPack and MEW executables, stopping at the first occurrence of written-then-executed code.

### Instrumentation Efficiency

Our use of analysis-guided instrumentation helps to amortize our analysis costs. Saffron instruments the program at every instruction, while Renovo instruments at all control transfers and write instructions (EtherUnpack's single-step mechanism does not rely on instrumentation). We estimated Saffron's use of instrumentation by modifying its source code to maintain a count of unique instrumented instructions and estimated Renovo's use based on their algorithm description. Table 2 shows that our structural analysis allows us to instrument the program at fewer than a 100th of the locations instrumented by Saffron and Renovo, as our analysis limits instrumentation to instructions whose targets are statically unresolved.

### Malware Analysis with SD-Dyninst

Using SD-Dyninst for malware analysis requires no more skill from the analyst than performing the same task with Dyninst on a conventional binary. We developed a malware analysis factory that uses SD-Dyninst to perform code-coverage of malicious program executions by instrumenting every basic block in the program, both statically present and dynamically unpacked blocks, and removing the instrumentation once it has executed. The factory halts the malware when it attempts its first network communication, exits, or reaches a 30-minute timeout. At this point, the factory prints out a traversal of the program’s call stacks and outputs a Control Flow Graph (CFG) of the binary, identifying calls to Windows DLL functions and annotating executed and non-executed blocks.

### Example Analysis: Conﬁcker A

Figures 5 and 6 show the analysis products for the Conﬁcker A malware binary. Figure 5a displays the annotated CFG of the Conﬁcker A binary in its entirety, while Figure 5b highlights an excerpt, showing static and dynamic code, both in the executable and in Windows DLLs, and distinguishing between executed and non-executed blocks. Figure 6 shows our traversal of Conﬁcker’s call stacks at its first call to the `select` routine, demonstrating the ability to identify stack frames of functions lacking symbol information.

### Experimental Setup and Results

We set up our malware analysis factory on an air-gapped system with a 32-bit Intel-x86 processor running Windows XP with Service Pack 2 inside of VMware Server. We analyzed 200 malware samples collected by Offensive Computing [3] in December 2009. Our tool detected code unpacking in 27% of the samples, code overwrites in 16%, and signal-based control flow in 10%. Additionally, 33% of the malicious code analyzed by our hybrid techniques was not part of the dynamic execution trace and would not have been identified by dynamic analysis alone.

### Conclusion

We have developed a hybrid analysis algorithm that enables the intuitive and efficient analysis and control of malicious program binaries. Our combination of static and dynamic analysis allows us to provide analysis-guided instrumentation on obfuscated, packed, and self-modifying program binaries for the first time. We implemented these ideas in SD-Dyninst and demonstrated their effectiveness on popular packing tools used in current malware. Ongoing research in the Dyninst project aims to address the limitations of our work, including anti-tampering detection and parsing of conditional control transfers.

### Acknowledgments

This work is supported in part by grants from the Department of Energy, Department of Homeland Security, and National Science Foundation Cybertrust. The U.S. Government is authorized to reproduce and distribute reprints for governmental purposes.

### References

[References listed as provided in the original text]

This optimized version of the text is more coherent and professional, with clear headings and improved readability.