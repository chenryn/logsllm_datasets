### 5.2 Experience With New Vulnerabilities

To date, our analysis has assumed a perfect frontend that exclusively identifies guilty suspects. We now present our experience with integrating our system with RATS [2], a real static vulnerability detection tool capable of identifying buffer overflows and, with user extensions, integer overflows.

We applied our system to several recent software versions. The first application was on ipgrab-0.9.9. RATS reported 106 potential buffer overflow vulnerabilities. We systematically evaluated each suspect using our system and identified the 48th suspect as a genuine vulnerability. This vulnerability, detailed in Figure 6, is located at line 357 in `file.c` and is caused by an integer overflow. 

Initially, we used a randomly generated benign input, which was straightforward to obtain as any input packet would trigger the suspect. Our mutator altered the lineage of `header.inc_len` to `MAXUINT`, leading to a segmentation fault at line 357. This occurred because the parameter passed to `malloc` was 0, while `fread` attempted to read `MAXUINT` bytes. Thus, through a single round of mutation, we confirmed the existence of this vulnerability.

Using the same methodology, we discovered and verified two additional integer overflows in dcraw-7.94 and epstool-3.3. We have reported these vulnerabilities to the respective developers, who promptly acknowledged the defects.

### 5.3 Performance and Space Overhead

We used nine benchmark programs to measure the performance and space overhead of the lineage tracing module, which is the primary performance bottleneck in our system. The setup and results are presented in Table 3.

Without logging, the performance slowdown factor ranges from 16 to 2441. When logging is enabled, the performance overhead increases to between 23 and 7243 times. The significant overhead for utility programs is largely due to the inclusion of Valgrind's startup and shutdown times, which are substantial compared to the actual execution time. For daemon programs, the overhead factors (ranging from 16 to 66) more accurately reflect the real slowdown, as we excluded Valgrind's overhead by inserting performance monitors into the programs. Note that network latency is not a concern here, as we used a local network interface.

The use of roBDD significantly benefits performance. Performing set operations on thousands of elements during each execution step would otherwise be highly inefficient. Another observation is that for data-intensive applications like gnuPG, the log file can be very large (nearly 10MB), causing significant runtime overhead. Due to historical reasons, we used an older version of Valgrind, which incurs a tenfold slowdown even without instrumentation. Additionally, we have not yet optimized the system, as performance is not currently a critical factor.

In terms of space overhead, as shown in Table 3, a link-list-based approach consumes much more space than our roBDD-based approach, especially for data-intensive applications.

### 6 Related Work

Recent years have seen significant advancements in automated code-based test generation [9, 10, 11, 13]. These techniques could theoretically be applied to our problem of automated evidence generation. However, they have practical limitations. First, most of these techniques are designed for unit testing and face scalability issues. Second, they combine concrete execution with constraint solving to explore all potential program paths, which can be computationally expensive. Third, symbolic constraint solving requires users to specify symbolic variables in the source code, demanding both access to the source code and a certain level of understanding.

In contrast, our technique is a lightweight, whole-program approach that explores a subset of program paths without requiring source code access or deep program understanding.

TaintCheck [15] is another relevant dynamic technique. Our method can be seen as a generalization of TaintCheck, which uses a single bit to mark program execution as input-relevant or input-irrelevant. We "taint" each execution point with a set of relevant input values, making our scenario more challenging due to the varying sizes of these sets. TaintCheck is designed for online attack detection, focusing on minimizing runtime overhead. Similarly, other dynamic techniques such as control flow integrity checking [16] and data flow integrity checking [17] aim to reduce runtime overhead. Our technique, however, is designed for offline evidence generation.

### 7 Conclusions

In this paper, we propose a data lineage tracing-based dynamic approach to generate evidence for remote exploitable vulnerabilities in software. Specifically, it associates an execution point suspect with a set of input bytes, which are then mutated offline to create an exploit (evidence). Our approach is both efficient and effective. Using our system, we successfully reproduced exploits for all known vulnerabilities we studied and identified and confirmed several new vulnerabilities, all of which were promptly acknowledged by the developers. Our evaluation also shows that the system has reasonable overhead for offline diagnosis.

### Acknowledgments

We thank the anonymous reviewers for their detailed and helpful comments. This work is supported in part by NSF grants CNS-0720516, CNS-0708464, and CNS-0716444.

### References

[1] http://www.dwheeler.com/ﬂawﬁnder/
[2] http://www.fortifysoftware.com/security-resources/rats.jsp
[3] http://diablo.elis.ugent.be
[4] Buddy, a binary decision diagram package. Department of Information Technology, Technical Univ. of Denmark.
[5] C. Meinel and T. Theobald. Algorithms and data structures in VLSI design, 1998. Springer.
[6] Valgrind: A Framework for Heavyweight Dynamic Binary Instrumentation. N. Nethercote and J. Seward. In Proc. of ACM PLDI, June 2007.
[7] B.P. Miller, L. Fredriksen, and B. So. An Empirical Study of the Reliability of UNIX Utilities. Communications of the ACM 33, 12, Dec. 1990.
[8] J. E. Forrester and B. P. Miller. An Empirical Study of the Robustness of Windows NT Applications Using Random Testing. In Proc. of the 4th USENIX Windows System Symposium, 2000.
[9] C. Cadar, V. Ganesh, P. Pawlowski, D. Dill, and D. Engler. Exe: automatically generating inputs of death. In Proc. of ACM CCS, Nov. 2006.
[10] K. Sen, D. Marinov, and G. Agha. Cute: A concolic unit testing engine for C. In Proc. of ACM ESEC/FSE-13, 2005.
[11] P. Godefroid, N. Klarlund, and K. Sen. Dart: Directed automated random testing. In Proc. of ACM PLDI, 2005.
[12] A. Moser, C. Kruegel, and E. Kirda. Exploring multiple execution paths for malware analysis. In Proc. of 2007 IEEE Symposium on Security and Privacy, May 2007.
[13] P. Godefroid, M. Levin, and D. Molnar. Automated whitebox fuzz testing. In Proc. of NDSS, San Diego, CA, Feb. 2008.
[14] M. Egele, C. Kruegel, E. Kirda, H. Yin, and D. Song. Dynamic Spyware Analysis. In Proc. of the 2007 USENIX Annual Technical Conference, Santa Clara, CA, June 2007.
[15] J. Newsome and D. Song. Dynamic taint analysis for automatic detection, analysis, and signature generation of exploits on commodity software. In Proc. of NDSS, Feb. 2005.
[16] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti. Control-Flow Integrity: Principles, Implementations, and Applications. In Proc. of ACM CCS, Nov. 2005.
[17] M. Castro, M. Costa, and T. Harris. Securing Software by Enforcing Data-Flow Integrity. In Proc. of OSDI, Nov. 2006.
[18] D. Wagner, J. S. Foster, E. A. Brewer, and A. Aiken. A first step towards automated detection of buffer overrun vulnerabilities. In Proc. of NDSS, Feb. 2000.
[19] D. Larochelle and D. Evans. Statically Detecting Likely Buffer Overflow Vulnerabilities. In Proc. of USENIX Security, 2001.
[20] M. Zitser, D. Shaw, T. Leek, and R. Lippman. Testing Static Analysis Tools Using Exploitable Buffer Overflows From Open Source Code. In Proc. of ACM ESEC/FSE-11, 2004.
[21] Y. Xie, A. Chou, and D. Engler. Archer: using symbolic, path-sensitive analysis to detect memory access errors. In Proc. of ACM ESEC/FSE-10, 2003.
[22] J. Ferrante, K. Ottenstein, J. Warren. The program dependence graph and its use in optimization. ACM Trans. on Programming Languages and Systems, 9(3), 1987.
[23] M. Weiser. Program slicing. In Proc. of ICSE, 1981.
[24] X. Zhang, R. Gupta, and Y. Zhang. Efficient forward computation of dynamic slices using reduced ordered binary decision diagrams. In Proc. of ICSE, 2004.