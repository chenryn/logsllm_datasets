### References

1. I. Cascudo and B. David. 2017. SCRAPE: Scalable Randomness Attested by Public Entities. In *International Conference on Applied Cryptography and Network Security (ACNS)*. Springer, 537–556.
2. M. Castro and B. Liskov. 2002. Practical Byzantine Fault Tolerance and Proactive Recovery. *ACM Transactions on Computer Systems* 20, 4 (2002).
3. B. Chor, S. Goldwasser, S. Micali, and B. Awerbuch. 1985. Verifiable Secret Sharing and Achieving Simultaneity in the Presence of Faults. In *26th IEEE Symposium on Foundations of Computer Science (FOCS)*. 383–395.
4. R. Cramer, R. Gennaro, and B. Schoenmakers. 1997. A Secure and Optimally Efficient Multi-Authority Election Scheme. In *Advances in Cryptology – EUROCRYPT 1997*. 103–118.
5. I. Damgård, V. Pastro, N. Smart, and S. Zakarias. 2012. Multiparty Computation from Somewhat Homomorphic Encryption. In *Advances in Cryptology – CRYPTO 2012 (LNCS)*, Vol. 7417. 643–662.
6. Y. Desmedt and Y. Frankel. 1991. Shared Generation of Authenticators and Signatures. In *Advances in Cryptology – CRYPTO 1991*. 457–469.
7. Y. Desmedt and S. Jajodia. 1997. Redistributing Secret Shares to New Access Structures and Its Applications. Technical Report ISSE TR-97-01. George Mason University.
8. Y. Deswarte, L. Blain, and J.-C. Fabre. 1991. Intrusion Tolerance in Distributed Computing Systems. In *IEEE Symposium on Security and Privacy*. 110–121.
9. S. Duan, M. K. Reiter, and H. Zhang. 2017. Secure Causal Atomic Broadcast, Revisited. In *International Conference on Dependable Systems and Networks (DSN)’17*. 61–72.
10. C. Dwork, N. Lynch, and L. Stockmeyer. 1988. Consensus in the Presence of Partial Synchrony. *J. ACM* 35, 2 (April 1988), 288–323.
11. P. Feldman. 1987. A Practical Scheme for Non-Interactive Verifiable Secret Sharing. In *28th IEEE Symposium on Foundations of Computer Science (FOCS)*. 427–438.
12. Y. Frankel, P. Gemmell, P. D. MacKenzie, and M. Yung. 1997. Optimal-Resilience Proactive Public-Key Cryptosystems. In *IEEE Symposium on Foundations of Computer Science (FOCS) 1997*. 384–393.
13. M. Franklin and M. Yung. 1992. Communication Complexity of Secure Computation (Extended Abstract). In *ACM Symposium on Theory of Computing (STOC) 1992*. 699–710.
14. G. R. Ganger, P. K. Khosla, M. Bakkaloglu, M. W. Bigrigg, G. R. Goodson, S. Oguz, V. Pandurangan, C. A. N. Soules, J. D. Strunk, and J. J. Wylie. 2000. Survivable Storage Systems. *IEEE Computer* 33, Issue 8 (2000), 61–68.
15. G. G. Gueta, I. Abraham, S. Grossman, D. Malkhi, B. Pinkas, M. K. Reiter, D.-A. Seredinschi, O. Tamir, and A. Tomescu. 2019. SBFT: A Scalable and Decentralized Trust Infrastructure. In *49th International Conference on Dependable Systems and Networks (DSN)*.
16. M. P. Herlihy and J. D. Tygar. 1988. How to Make Replicated Data Secure. In *Advances in Cryptology – CRYPTO ’87 (LNCS)*, Vol. 293. 379–391.
17. M. P. Herlihy and J. M. Wing. 1990. Linearizability: A Correctness Condition for Concurrent Objects. *ACM Transactions on Programming Languages and Systems* 12, Issue 3 (July 1990), 463–492.
18. A. Herzberg, M. Jakobsson, S. Jarecki, H. Krawczyk, and M. Yung. 1997. Proactive Public Key and Signature Systems. In *4th ACM Conference on Computer and Communications Security (CCS)*. 100–110.
19. A. Herzberg, S. Jarecki, H. Krawczyk, and M. Yung. 1995. Proactive Secret Sharing or: How to Cope with Perpetual Leakage. In *Advances in Cryptology – CRYPTO ’95*, Vol. 963. 339–352.
20. A. Kate, G. M. Zaverucha, and I. Goldberg. 2010. Constant-Size Commitments to Polynomials and Their Applications. In *Advances in Cryptology – ASIACRYPT 2010 (LNCS)*, Vol. 6477. 177–194.
21. E. Kokoris-Kogias, E. C. Alp, S. D. Siby, N. Gailly, L. Gasser, P. Jovanovic, E. Syta, and B. Ford. 2018. CALYPSO: Auditable Sharing of Private Data over Blockchains. *Cryptology ePrint Archive*, Report 2018/209. https://eprint.iacr.org/2018/209.
22. R. Kotla, L. Alvisi, M. Dahlin, A. Clement, and E. L. Wong. 2009. Zyzzyva: Speculative Byzantine Fault Tolerance. *ACM Transactions on Computer Systems* 27, 4 (2009).
23. R. Kotla, A. Clement, E. Wong, L. Alvisi, and M. Dahlin. 2008. Zyzzyva: Speculative Byzantine Fault Tolerance. *Commun. ACM* 51, 11 (2008), 86–95.
24. H. Krawczyk. 1994. Secret Sharing Made Short. In *Advances in Cryptology – CRYPTO ’93 (LNCS)*, Vol. 773. 136–146.
25. S. K. D. Maram, F. Zhang, L. Wang, A. Low, Y. Zhang, A. Juels, and D. Song. 2019. CHURP: Dynamic-Committee Proactive Secret Sharing. *Cryptology ePrint Archive*, Report 2019/017. https://eprint.iacr.org/2019/017.
26. J.-P. Martin and L. Alvisi. 2006. Fast Byzantine Consensus. *IEEE Transactions on Dependable and Secure Computing* 3, 3 (July 2006), 202–215.
27. I. Miers, C. Garman, M. Green, and A. D. Rubin. 2013. Zerocoin: Anonymous Distributed E-Cash from Bitcoin. In *IEEE Symposium on Security and Privacy 2013*. 397–411.
28. A. Miller, Y. Xia, K. Croman, E. Shi, and D. Song. 2016. The Honey Badger of BFT Protocols. In *23rd ACM Conference on Computer and Communications Security (CCS)*. 31–42.
29. M. Naor, B. Pinkas, and O. Reingold. 1999. Distributed Pseudo-Random Functions and KDCs. In *Advances in Cryptology – EUROCRYPT ’99 (LNCS)*, Vol. 1592. 327–346.
30. V. Nikov and S. Nikova. 2005. On Proactive Secret Sharing Schemes. In *International Workshop on Selected Areas in Cryptography 2004*. 308–325.
31. M. Nojoumian and D. R. Stinson. 2013. On Dealer-Free Dynamic Threshold Schemes. *Advances in Mathematics of Communications* 7, 1 (Feb. 2013), 39–56.
32. P. S. Nordhold and M. Veeningen. 2018. Minimising Communication in Honest-Majority MPC by Batchwise Multiplication Verification. In *International Conference on Applied Cryptography and Network Security (ACNS) 2018 (LNCS)*, Vol. 10892. 321–339.
33. T. P. Pedersen. 1992. Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing. In *Advances in Cryptology – CRYPTO ’91 (LNCS)*, Vol. 576. 129–140.
34. M. K. Reiter and K. P. Birman. 1994. How to Securely Replicate Services. *ACM Transactions on Programming Languages and Systems* 16, 3 (May 1994), 986–1009.
35. T. Rocket, M. Yin, K. Sekniqi, R. van Renesse, and E. G. Sirer. 2019. Scalable and Probabilistic Leaderless BFT Consensus through Metastability. *arXiv preprint arXiv:1906.08936* (2019).
36. E. Ben Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer, and M. Virza. 2014. Zerocash: Decentralized Anonymous Payments from Bitcoin. In *IEEE Symposium on Security and Privacy 2014*. 459–474.
37. D. Schultz, B. Liskov, and M. Liskov. 2010. MPSS: Mobile Proactive Secret Sharing. *ACM Transactions on Information and System Security* 13, 4 (Dec. 2010), 1–32.
38. A. Shamir. 1979. How to Share a Secret. *Commun. ACM* 22, 11 (Nov. 1979), 612–613.
39. M. Tompa and H. Woll. 1988. How to Share a Secret with Cheaters. *Journal of Cryptology* 1 (1988), 133–138.
40. T. M. Wong, C. Wang, and J. M. Wing. 2002. Verifiable Secret Redistribution for Archive Systems. In *International IEEE Security in Storage Workshop 2002*.
41. M. Yin, D. Malkhi, M. K. Reiter, G. G. Gueta, and I. Abraham. 2019. HotStuff: BFT Consensus with Linearity and Responsiveness. In *38th ACM Conference on Principles of Distributed Computing (PODC)*.
42. L. Zhou and F. B. Schneider. 2005. APSS: Proactive Secret Sharing in Asynchronous Systems. *ACM Transactions on Information and System Security* 8, 3 (Aug. 2005), 259–286.

### Appendix A: Security

In this appendix, we demonstrate why our composition of Verifiable Secret Sharing and Recovery (VSSR) along with PBFT is secure. We achieve this by first examining the conditions under which the share recovery protocol will terminate. To show linearizability and liveness, we map every execution of our modified PBFT algorithm to the original PBFT algorithm. Since the original PBFT algorithm satisfies linearizability and liveness, so does our modified algorithm. We then address privacy separately.

#### Share Recovery Protocol Termination

We claim that the share recovery protocol will always terminate if \( f + 1 \) replicas have successfully completed the sharing and the network eventually delivers all messages. This is because a replica that is missing its share needs the output of `vssRecoverContrib*` from \( f + 1 \) replicas. If \( f + 1 \) replicas are honest, they will faithfully call `vssRecoverContrib*` and send the output to the replica that is missing its share. The missing share can then be recovered using `vssRecover*`, thereby terminating the share recovery protocol.

#### Normal Case Protocol

In the normal case protocol, we only modify how the client constructs requests. If a client is honest, we can ignore the secrets being shared in the request and have the client send regular requests in the original run of the PBFT algorithm. The requests are consistent due to the binding property of our verifiable secret sharing (VSS) scheme. If a client is dishonest and sends an invalid share to the replica, the original PBFT protocol will drop the request message to the replica. In the modified protocol, this is handled using the share recovery protocol, so we wait to deliver the request messages in the original run until the share recovery protocol terminates. If the share recovery protocol never terminates in the modified protocol, it means that fewer than \( f + 1 \) honest replicas have the request, making it impossible for the request to be prepared. Therefore, if the modified normal case protocol never terminates, neither does the original protocol. Thus, liveness is unchanged from the original PBFT protocol.

Additionally, through the binding property of our underlying VSS scheme, we know that if a request has been committed, all secret values must be consistently shared. Thus, the linearizability property follows from the linearizability in the original protocol along with the binding property.

#### Checkpoint Protocol

The checkpoint protocol is identical to a case where the state of the replicated service contains only the commitments of the secret values instead of the secret values themselves. By the binding property of the underlying VSS scheme, there is a one-to-one mapping from a run of the checkpoint protocol for our modified PBFT algorithm to the original PBFT algorithm. Therefore, if the original PBFT’s checkpoint algorithm provides liveness and linearizability, so does our modified algorithm.

#### State Transfer Protocol

The state transfer protocol can be mapped back similarly to the normal case protocol. A replica receiving the value of a key using the share recovery protocol in our modified PBFT would have been receiving the plaintext value of the key in the original PBFT algorithm. We simply delay the plaintext value of the key until the share recovery protocol completes in our modified PBFT protocol. Additionally, in the state transfer protocol, we know that the share recovery protocol will complete since at least \( 2f + 1 \) replicas have the state at the last checkpoint. This means that at least \( f + 1 \) honest replicas have the state, which is sufficient to guarantee termination during periods of synchrony.

#### Privacy

Our modified PBFT protocol achieves privacy through the hiding property of the VSS protocol. The hiding property ensures that a legitimate adversary (one that has at most \( f \) shares of the secret) cannot do non-negligibly better than guessing the secret at random. Thus, privacy is satisfied unless an adversary gets at least \( f + 1 \) shares of a value. However, this would mean that some correct replica has shared the secret with the adversary, which contradicts our threshold assumption. Therefore, our modified PBFT protocol preserves linearizability and liveness while also guaranteeing privacy.

### Appendix B: Instantiation of Pedersen VSS

We describe how to fit the secret sharing scheme from Pedersen [42] into our framework.

- **vssInit(1κ, k, n)**: First, choose a safe prime \( q = 2q' + 1 \) at least \( κ \) bits in length, for \( q' \) a prime. Let \( g \) and \( h \) be two distinct generators of the quadratic residues \( QR(\mathbb{Z}_q^*) \) of \( \mathbb{Z}_q^* \) such that \( \log_g(h) \) is unknown. Set \( vpk_i \) to \( \langle g, h \rangle \) for all \( i \). Set \( vsk_i \) to \( \perp \) for all \( i \). The return value of `vssInit` is \( \langle q, \{ \langle vpk_i, vsk_i \rangle \}_{i \in [n]} \rangle \).

- **vssShare(s, q, {vpk_i}i∈[n])**: Extract the public key and get \( g \) and \( h \) as defined in `vssInit`. Set \( s_j \) to be the coefficient of the \( x^j \) term in \( s \) and \( s(i) \) to be the evaluation of \( s \) at point \( i \). Pick \( t \in \mathbb{Z}_q[x] \) to be a random polynomial of degree \( k - 1 \). Similarly, let \( t_j \) be the coefficient of the \( x^j \) term in \( t \) and \( t(i) \) be the evaluation of \( t \) at point \( i \). Set \( u_i \) to be \( \langle s(i), t(i) \rangle \). Here, all linear operations on \( u_i \) values are done element-wise. Set \( c \) to be \( \{ g^{s_j} h^{t_j} \}_{j \in [k]} \). Then, `vssShare` returns \( \langle c, \{ u_i \}_{i \in [n]} \rangle \).

- **vssVerify(vpk_i, c, u_i)**: Extract \( \{ g^{s_j} h^{t_j} \}_{j \in [k]} \) from \( c \). Then, extract \( s(i) \) and \( t(i) \) from \( u_i \). Return true if \( g^{s(i)} h^{t(i)} = \prod_{j=0}^{k-1} (g^{s_j} h^{t_j})^i \) and false otherwise.

- **vssReconstruct(c, {⟨vpk_i, u_i⟩}i∈I)**: Call `vssVerify(vpk_i, c, u_i)` for all \( i \in I \). If all `vssVerify` calls return true, continue. Otherwise, `vssReconstruct` returns \( \perp \). Extract \( s(i) \) and \( t(i) \) from each \( u_i \). Finally, perform Lagrange interpolation to identify the unique degree \( k - 1 \) polynomial in \( \mathbb{Z}_q[x] \) that goes through the points \( (i, s(i)) \) for all \( i \in I \) and return that value.

- **vssMakeSecret(q, {⟨x_i, y_i⟩}i∈I)**: This is identical to Kate et al.'s [29] instantiation described in Section 3.7.1.

- **vssCombineCommitments(c, ˆc)**: Extract \( \{ g^{s_j} h^{t_j} \}_{j \in [k]} \) from \( c \) and \( \{ g^{\hat{s}_j} h^{\hat{t}_j} \}_{j \in [k]} \) from \( \hat{c} \). Then, return \( \{ (g^{\hat{s}_j} h^{\hat{t}_j})(g^{s_j} h^{t_j}) \}_{j \in [k]} \).

### Appendix C: PBFT State Transfer and View Change

#### C.1 View Change Protocol

The view change protocol changes the leader. The core mechanism for transferring safe values across views is for a new leader to collect a set \( P \) of view-change messages from a quorum of \( 2f + 1 \) replicas. Each replica sends a view-change message containing the replica's local state: its local request-log and the commit-certificate with the highest view number it responded to with a commit message, if any.

The leader processes the set \( P \) as follows:
1. Initially, it sets a leader-log \( G \) to an empty log.
2. If any view-change message contains a valid commit-certificate, it selects the one with the highest view number and copies its log to \( G \). Share recovery is triggered for any requests in \( G \) that the leader is missing its private share.
3. The leader sends a new-view message to all replicas. The message includes the new view number, the set \( P \) of view-change messages the leader collected as a leader-proof for the new view, and the leader-log \( G \). A replica accepts a new-view message if it is valid and adopts the leader log. It may need to roll back speculatively executed requests and process new ones. Processing may entail triggering share-recovery for any requests where the replica is missing its private share.

#### C.2 State Transfer Protocol

We present a modified version of the PBFT state transfer protocol that is simpler and more suited when TCP is used for the underlying network protocol. When a replica has fallen behind, it sends a state transfer request along with its current sequence number to at least \( f + 1 \) replicas. Some replica will respond with the most recent valid checkpoint messages and the messages from the normal case protocol that were missed by the slow replica. In addition, the response will contain only the values of the keys that have changed since the sequence number known to the slow replica, as well as the full requests that came after the last checkpoint.