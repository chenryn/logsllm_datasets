### Our Experience with SELINKS

Our experience using SELINKS to write these applications has been highly positive. The access control policies were straightforward to define and implement, with the policy code comprising approximately 200 lines, including helper functions. The access control and login policy code was modular enough to be shared entirely by the two applications. The provenance policy, consisting of about 100 lines of code, was also easy to use. Unlike the provenance policy described in Section 3.2, SEWIKI provenance labels track only direct data flows to and from other documents. This simplifies programming, as fewer program operations need to be mediated by the policy.

To support richer policies while reducing the programming burden, we are investigating an approach related to aspect-oriented programming [21]. This approach, given a policy specification, automatically transforms a program to insert the appropriate label manipulations. We also plan to include limited support for type inference to better integrate the use of FABLE-style dependent types with standard LINKS types in SELINKS.

### Related Work

Dependently-typed languages have found applications in a wide variety of contexts [44, 43, 3, 5]. In the context of security, Zheng and Myers [46] formalize support for dynamic security labels that can be associated with data to express information flow policies. The technical machinery for associating labels with terms in their system is similar to ours. However, there are two main differences. First, in their system, the security policy—an information flow policy with a particular label model—is expressed directly in the type system, whereas in FABLE, both the security policy and the label model are customizable. As discussed in Section 3.3, dynamic labels for information flow policies can be encoded in FABLE as a combination of our dynamic provenance and static information flow policies. Second, FABLE allows non-values to appear in types, such as `lub l m` in Figure 7. This permits a combination of static and dynamic policy checking, but at the cost of potentially undecidable type checking. Our SELINKS implementation uses heuristics to ensure that type-checking never diverges.

Walker’s “type system for expressive security policies” [42] is also dependently typed. Labels in Walker’s language are uninterpreted predicates rather than arbitrary expressions. Walker’s system can enforce policies expressed as security automata, which can capture any safety property. This kind of policy is also enforceable in FABLE when extended with substructural types. However, in Walker’s system, the policy is always enforced via runtime checks. To recover some amount of static checking, Walker suggests adding additional rules to the type system, though he does not specify how this would be done. These additional rules would need to be proven correct with respect to a desired security property.

It has been observed that dependent types can be used to express a kind of customized type system [43], and FABLE’s policy functions fit this description. For example, the `sub` function in the policy of Figure 7 effectively introduces a subsumption rule into the type system. Researchers have explored how user-defined type systems can be supported directly via customizable type qualifiers. Shankar et al. [35] have used lattice-based type qualifiers in CQual [13] to track dataflow properties like taintedness [35], and Zhang et al. [45] and Fraser et al. [15] have used qualifiers to check complete mediation in access control systems. Millstein et al. [8, 1] have developed an approach in which programmers can indicate data invariants that custom type qualifiers are intended to signify. In some cases, they can automatically verify that these invariants are correctly enforced by the custom type rules. While their invariants are relatively simple, we ultimately aim to develop a framework in a similar vein, where correctness properties for FABLE’s enforcement policies can be at least partially automated. Marino et al. [27] have proposed using proof assistants for this purpose, and we plan to explore this idea in the context of FABLE policies.

Li and Zdancewic show how to encode information flow policies in Haskell [25]. They define a meta-language that makes the control-flow structure of a program available for inspection within the program itself. Their enforcement mechanism relies on Haskell's lazy evaluation strategy, which allows the control flow graph to be inspected for information leaks before evaluation. While their encoding permits the use of custom label models, they only demonstrate an encoding of an information flow policy. It is unclear whether their system could encode the range of policies discussed here.

In other work, Li and Zdancewic [24] have proposed labeling types with functions that describe conditions under which a type is allowed to be relabeled. Their goal is to control what information is declassified by a program, whereas we aim to enforce a variety of policies.

Our technique of separating the enforcement policy from the rest of the program is based on Grossman et al.’s colored brackets [18]. They use these brackets to model type abstraction, whereas we use them to ensure that the privilege of unlabeling and relabeling terms is not mistakenly granted to application code. As a result, we do not need to specially designate application code that may arise within policy terms, keeping things simpler. We plan to investigate the use of different colored brackets to distinguish different enforcement policies, following Grossman et al.’s support for multiple agents.

Finally, since we have targeted the LINKS web-programming language [12] as the platform on which to build FABLE, our work is related to Swift [9] and SIF [11], two Jif-based projects that aim to secure web applications. Swift is a technique that allows a web application to be split according to a policy into JavaScript code that runs on the client and Java code on the server, while SIF is a framework for building secure servlets. As discussed in Section 4, LINKS provides similar functionality, except it additionally integrates database access code into the framework. With our new security checking features in SELINKS, as in Swift, practical, verified, end-to-end security for multi-tiered applications is within reach.

### Conclusions

This paper presents FABLE, a core formalism for a programming language in which programmers can specify security policies and reason that these policies are properly enforced. We have shown that FABLE is flexible enough to implement a wide variety of security policies, including access control, provenance, and static information flow, among others. We have also argued that FABLE’s design simplifies proofs that programs using these policies do so correctly. We have implemented FABLE as part of the LINKS web programming language, and we have used the resulting language, which we call SELINKS, to build two substantial applications: a secure wiki and a secure online store. While more work remains to make SELINKS a fully satisfactory platform, to our knowledge, no existing framework enables the enforcement of such a wide variety of security policies with an equally high level of assurance.

### Acknowledgements

We thank Jeff Foster, Boniface Hicks, Polyvios Pratikakis, Peter Sewell, and the anonymous reviewers for their helpful comments on a draft of this paper. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the Army Research Laboratory or the U.S. Government.