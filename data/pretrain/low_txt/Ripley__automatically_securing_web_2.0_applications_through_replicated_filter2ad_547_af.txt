### References

1. **Web Programming Without Tiers**. In *Formal Methods for Components and Objects*, pages 266–296. Springer, October 2007.
2. **D. Flanagan**. *JavaScript: The Definitive Guide*. O’Reilly, 4th edition, 2002.
3. **S. Fogie, J. Grossman, R. Hansen, A. Rager, and P. D. Petkov**. *XSS Attacks: Cross Site Scripting Exploits and Defense*. Syngress, 2007.
4. **Google Gears**. <http://gears.google.com>.
5. **Google Web Toolkit**. <http://code.google.com/webtoolkit>.
6. **A. Guha, S. Krishnamurthi, and T. Jim**. Using static analysis for Ajax intrusion detection. In *Proceedings of the International Conference on World Wide Web*, pages 561–570, April 2009.
7. **V. Haldar, D. Chandra, and M. Franz**. Dynamic taint propagation for Java. In *Proceedings of the Annual Computer Security Applications Conference*, pages 303–311, December 2005.
8. **A. Hartman**. *Exploring Adobe Flash CS4*. Delmar Learning, 2009.
9. **B. Hoffman**. Ajax security dangers. <http://www.spidynamics.com/assets/documents/AJAXdangers.pdf>, 2006.
10. **B. Hoffman and B. Sullivan**. *Ajax Security*. Addison-Wesley Professional, 2007.
11. **G. Hoglund and G. McGraw**. *Exploiting Online Games: Cheating Massively Distributed Systems*. Addison-Wesley Professional, 2007.
12. **J. Howell, C. Jackson, H. J. Wang, and X. Fan**. MashupOS: Operating system abstractions for client mashups. In *Proceedings of the USENIX Workshop on Hot topics in operating systems*, pages 1–7, May 2007.
13. **Y.-W. Huang, F. Yu, C. Hang, C.-H. Tsai, D.-T. Lee, and S.-Y. Kuo**. Securing web application code by static analysis and runtime protection. In *Proceedings of the International Conference on World Wide Web*, pages 40–52, May 2004.
14. **S. Jha, S. Katzenbeisser, and H. Veith**. Enforcing semantic integrity on untrusted clients in networked virtual environments. In *Proceedings of the IEEE Symposium on Security and Privacy*, pages 179–186, May 2007.
15. **T. Jim, N. Swamy, and M. Hicks**. Defeating script injection attacks with browser-enforced embedded policies. In *Proceedings of the International Conference on World Wide Web*, pages 601–610, May 2007.
16. **N. Jovanovic, C. Kruegel, and E. Kirda**. Pixy: A static analysis tool for detecting web application vulnerabilities. In *Proceedings of the IEEE Symposium on Security and Privacy*, pages 258–263, May 2006.
17. **A. Judson**. Tamper data Firefox add-on. <https://addons.mozilla.org/en-US/firefox/addon/966>.
18. **R. Kennell and L. H. Jamieson**. Establishing the genuineness of remote computer systems. In *Proceedings of the USENIX Security Symposium*, pages 21–21, August 2003.
19. **R. Lerner**. At the forge: Firebug. *Linux Journal*, 2007(157):8, 2007.
20. **B. Livshits and E. Kiciman**. Doloto: Code splitting for network-bound Web 2.0 applications. In *Proceedings of the ACM SIGSOFT International Symposium on Foundations of Software Engineering*, pages 350–360, September 2008.
21. **B. Livshits and M. S. Lam**. Finding security errors in Java programs with static analysis. In *Proceedings of the USENIX Security Symposium*, pages 18–18, August 2005.
22. **D. Malkhi and M. K. Reiter**. Secure and scalable replication in Phalanx. In *Proceedings of the IEEE Symposium on Reliable Distributed Systems*, page 51, October 1998.
23. **D. Manolescu, B. Beckman, and B. Livshits**. Volta: Developing distributed applications by recompiling. *IEEE Software*, 25(5):53–59, October 2008.
24. **M. Martin, B. Livshits, and M. S. Lam**. SecuriFly: Runtime vulnerability protection for web applications. Technical report, Stanford University, 2006.
25. **Microsoft Corporation**. Microsoft Live Labs Deepfish. <http://labs.live.com/deepfish/>, 2006.
26. **Microsoft Corporation**. Microsoft Live Labs Volta. <http://research.microsoft.com/~emeijer/CloudProgrammability.html>, 2007.
27. **Microsoft Corporation**. Silverlight. <http://silverlight.net>, 2007.
28. **P. Montesinos, M. Hicks, S. T. King, and J. Torrellas**. Capo: A software-hardware interface for practical deterministic multiprocessor replay. In *Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems*, pages 73–84, March 2009.
29. **S. Narayanasamy, G. Pokam, and B. Calder**. Bugnet: Continuously recording program execution for deterministic replay debugging. *SIGARCH Computer Architecture News*, 33(2):284–295, May 2005.
30. **A. Nguyen-Tuong, S. Guarnieri, D. Greene, J. Shirley, and D. Evans**. Automatically hardening web applications using precise tainting. In *Proceedings of the IFIP International Information Security Conference*, pages 372–382, June 2005.
31. **T. Pietraszek and C. V. Berghe**. Defending against injection attacks through context-sensitive string evaluation. In *Proceedings of the Recent Advances in Intrusion Detection*, September 2005.
32. **J. Richter**. *CLR via C#*. Microsoft Press, 2006.
33. **A. Russell**. Comet: Low latency data for the browser. <http://alex.dojotoolkit.org/wp-content/LowLatencyData.pdf>, 2006.
34. **F. B. Schneider**. Implementing fault-tolerant services using the state machine approach: a tutorial. *ACM Computing Surveys*, 22(4):299–319, December 1990.
35. **S. Segan**. For Skyfire’s mobile web, the secret’s in the server. <http://www.pcmag.com/print_article2/0,1217,a%253D223932,00.asp>, January 2008.
36. **M. Serrano, E. Gallesio, and F. Loitsch**. Hop: A language for programming the web 2.0. In *Companion to the Conference on Object-Oriented Programming Systems, Languages, and Applications*, pages 975–985, October 2006.
37. **S. Smith**. Capacity and performance planning. In *European Microsoft SharePoint Conference 2007*, February 2007.
38. **C. Stockwell**. What’s coming in IE8. <http://blogs.msdn.com/ie/archive/2008/08/26/ie8-performance.aspx>, 2008.
39. **J. D. Strunk, G. R. Goodson, M. L. Scheinholtz, C. A. N. Soules, and G. R. Ganger**. Self-securing storage: Protecting data in compromised systems. In *Proceedings of the Conference on Symposium on Operating System Design and Implementation*, pages 12–12, October 2000.
40. **The Samy worm**. <http://namb.la/popular>.
41. **F. Tip**. A survey of program slicing techniques. *Journal of Programming Languages*, 3:121–189, 1995.
42. **Y. Xie and A. Aiken**. Static detection of security vulnerabilities in scripting languages. In *Proceedings of the USENIX Security Symposium*, August 2006.
43. **J. Yan**. Security design in online games. In *Proceedings of the Annual Computer Security Applications Conference*, page 286, December 2003.
44. **F. Yang, J. Shanmugasundaram, M. Riedewald, and J. Gehrke**. Hilda: A high-level language for data-driven web applications. In *Proceedings of the International Conference on Data Engineering*, pages 32–43, April 2006.
45. **D. Yu, A. Chander, H. Inamura, and I. Serikov**. Better abstractions for secure server-side scripting. In *Proceedings of the International Conference on World Wide Web*, pages 507–516, April 2008.
46. **D. Yu, A. Chander, N. Islam, and I. Serikov**. JavaScript instrumentation for browser security. In *Proceedings of the Symposium on Principles of Programming Languages*, pages 237–249, January 2007.
47. **S. Zdancewic and A. C. Myers**. Secure information flow and CPS. *Lecture Notes in Computer Science*, 2028:46–61, 2001.
48. **S. Zdancewic, L. Zheng, N. Nystrom, and A. C. Myers**. Untrusted hosts and confidentiality: Secure program partitioning. In *Proceedings of the Symposium on Operating System Principles*, pages 1–14, 2001.
49. **L. Zheng, S. Chong, A. C. Myers, and S. Zdancewic**. Using replication and partitioning to build secure distributed systems. In *Proceedings of the IEEE Symposium on Security and Privacy*, pages 236–250, May 2003.

### Appendix

#### A. Benchmark Applications

In this section, we describe the benchmark applications used to test RIPLEY. All these applications have been developed on top of Volta. A summary of the information about these applications is provided in Figure 7.

Our choice of applications was inspired by previous application benchmarks [7] and the attacks presented in the books "Exploiting Online Games" [21] and "Ajax Security" [19]. We aimed to demonstrate how the AJAX model allows us to migrate virtually the entire computation to the client with a minimum of RPCs, and how, when RIPLEY is applied, this approach does not lead to a reduction in integrity.

##### A.1 Client-Side Shopping Cart

This application simulates a typical shopping cart within an e-commerce platform. Users can add and remove items, update quantities, and check out. The application supports coupons (C5, C10, and C15) that provide 5%, 10%, and 15% discounts, respectively, on the total cart value.

**Security Threats**: A malicious user might attempt to manipulate the discount calculation by using invalid or multiple coupons, or by manually setting the total amount before it is sent to the server.

**Benefits of RIPLEY**: With RIPLEY, the computations can be performed on the client side, maintaining application responsiveness. The server maintains an abstract state of the cart and verifies the total amount upon receiving it from the client.

##### A.2 Game of Sudoku

This online game presents one of five hard-coded Sudoku puzzles for the user to solve. The solution is checked on the client and sent to the server for recording user ratings. As the game progresses, validation checks are performed after each number is entered and when the user submits the solution.

**Security Threats**: A malicious user can bypass both local and global validation checks, leading to false puzzle completion.

**Benefits of RIPLEY**: When the final solution is submitted, RIPLEY verifies its validity based on the event stream received as input. This ensures that the solution is correct without creating extra network traffic.

##### A.3 AJAX Blog

This online blog application allows users to view, post, and edit blog entries.

**Security Threats**: The primary concern is protecting the benign client from script injection and worm attacks. By default, the blog application does not perform extensive data sanitization, making it vulnerable to cross-site scripting (XSS) attacks. Worms can amplify the effects of XSS, potentially posting content on behalf of unsuspecting users.

**Benefits of RIPLEY**: In the case of a JavaScript worm, RIPLEY detects the mismatch in the stream of RPCs, as the client replica runs in .NET on the server side, making it impervious to JavaScript code injection. This ensures that client-side checks are reliably performed.

##### A.4 Speed Typing Test

This application randomly selects words from a dictionary and displays them to the user as a paragraph. The user must type as many words as possible within one minute. The application calculates the word-per-minute count and accuracy, and highlights correctly spelled words in real-time.

**Security Threats**: A malicious user might tamper with per-word spelling checks and manipulate time measurements to rig the test.

**Benefits of RIPLEY**: RIPLEY performs its own computations within the replica, ignoring any circumvented checks on the client.

##### A.5 Online Quiz

This quiz application presents trivia questions one by one. The next question's difficulty is determined by the correctness of the current answer. After answering ten questions, the user's score is calculated and sent to the server for recording. Each answer consists of a single word.

**Security Threats**: The confidentiality of the data on the client is crucial. If a client can easily learn and enter the correct answers, cheating becomes trivial. RIPLEY does not address confidentiality concerns, which are left to the developer.

**Benefits of RIPLEY**: To preserve confidentiality, hash values of the correct answers are sent instead of the answers themselves. This allows for comparison with the provided answers. RIPLEY ensures that integrity issues like bypassing solution checking are handled by replicating the checks on the server side.

#### B. RIPLEY Guarantees

In this section, we outline the integrity preservation property of RIPLEY, as intuitively described in Section 2. A full formalization is subject to future work and will likely require modeling Volta applications in a small, well-controlled language that is easy to reason about.

For a given non-distributed program \( P_0 \), there are three separate server-based versions to consider:

- **\( P_0 \)**: Original Web 1.0 program that has not been tier-split.
- **\( P_S \)**: Tier-split program \( C + S \) with \( C \) running within a full-fledged browser on the server.
- **\( P_R \)**: RIPLEY-replicated program \( C + S \) with replica \( C \) running within a RIPLEY emulator.

All three variants of \( P_0 \) are executed entirely on the server, relying only on user input. We assume the program is connected to a permanent database store, which is the only form of persistent state maintained by the application. We aim to ensure that this store cannot be affected by malicious client actions. We also assume that the programs do not have the forms of non-determinism described in Section 5. We can then show the following:

**Property**: For any run of \( P_0 \) and \( P_R \) given a stream of input events \( \{e_1, e_2, \ldots, e_n\} \), the sequence of SQL database calls issued by \( P_0 \) and \( P_R \) are exactly the same.

This property protects the integrity of persistent server-side state: starting with the same database state, we will end up with the same database state for both \( P_0 \) and \( P_R \). This is what we mean when we say that RIPLEY restores the integrity guarantees to their Web 1.0 state. Given the same set of (untrusted) inputs communicated to the program and assumptions of determinism, both the RIPLEY and the original application will arrive at the same answer.

**Proof of the Property**: The proof proceeds by showing that there is a bi-simulation between \( P_0 \) and \( P_S \) and another bi-simulation between \( P_S \) and \( P_R \). This transitively makes \( P_0 \) and \( P_R \) bi-similar, which implies the property.