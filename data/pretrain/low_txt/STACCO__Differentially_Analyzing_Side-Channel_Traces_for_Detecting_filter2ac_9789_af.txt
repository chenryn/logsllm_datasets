### References

1. **An Untrusted Operating System on Trusted Hardware**. In 19th ACM Symposium on Operating Systems Principles. ACM.

2. **Chi-Keung Luk, Robert Cohn, Robert Muth, Harish Patil, Artur Klauser, Geoff Lowney, Steven Wallace, Vijay Janapa Reddi, and Kim Hazelwood. 2005. Pin: Building Customized Program Analysis Tools with Dynamic Instrumentation**. In ACM SIGPLAN Notices, Vol. 40. ACM, 190–200.

3. **James Manger. 2001. A Chosen Ciphertext Attack on RSA Optimal Asymmetric Encryption Padding (OAEP) as Standardized in PKCS#1 v2.0**. In Annual International Cryptology Conference. Springer, 230–238.

4. **Sinisa Matetic, Mansoor Ahmed, Kari Kostiainen, Aritra Dhar, David Sommer, Arthur Gervais, Ari Juels, and Srdjan Capkun. 2017. ROTE: Rollback Protection for Trusted Execution**. IACR Cryptology ePrint Archive 2017 (2017), 48.

5. **Jonathan McCune, Bryan Parno, Adrian Perrig, Michael Reiter, and Hiroshi Isozaki. 2008. Flicker: An Execution Infrastructure for TCB Minimization**. In ACM SIGOPS Operating Systems Review, Vol. 42. ACM, 315–328.

6. **Frank McKeen, Ilya Alexandrovich, Alex Berenzon, Carlos Rozas, Hisham Shafi, Vedvyas Shanbhogue, and Uday Savagaonkar. 2013. Innovative Instructions and Software Model for Isolated Execution**. HASP@ISCA 10 (2013).

7. **Christopher Meyer, Juraj Somorovsky, Eugen Weiss, Jörg Schwenk, Sebastian Schinzel, and Erik Tews. 2014. Revisiting SSL/TLS Implementations: New Bleichenbacher Side Channels and Attacks**. In 23rd USENIX Security Symposium (USENIX Security 14). 733–748.

8. **Bodo Möller, Thai Duong, and Krzysztof Kotowicz. 2014. This POODLE Bites: Exploiting the SSL 3.0 Fallback**. (2014). https://www.openssl.org/~bodo/ssl-poodle.pdf.

9. **Nicholas Nethercote and Julian Seward. 2007. Valgrind: A Framework for Heavy-Weight Dynamic Binary Instrumentation**. In ACM SIGPLAN Notices, Vol. 42. ACM, 89–100.

10. **Olga Ohrimenko, Felix Schuster, Cédric Fournet, Aastha Mehta, Sebastian Nowozin, Kapil Vaswani, and Manuel Costa. 2016. Oblivious Multi-Party Machine Learning on Trusted Processors**. In USENIX Security Symposium. 619–636.

11. **Harish Patil, Cristiano Pereira, Mack Stallcup, Gregory Lueck, and James Cownie. 2010. Pinplay: A Framework for Deterministic Replay and Reproducible Analysis of Parallel Programs**. In 8th Annual IEEE/ACM International Symposium on Code Generation and Optimization. ACM, 2–11.

12. **Dan R. K. Ports and Tal Garfinkel. 2008. Towards Application Security on Untrusted Operating Systems**. In 3rd Conference on Hot Topics in Security.

13. **Ashay Rane, Calvin Lin, and Mohit Tiwari. 2015. Raccoon: Closing Digital Side-Channels through Obfuscated Execution**. In USENIX Security Symposium. 431–446.

14. **Eric Rescorla. 2006. The Transport Layer Security (TLS) Protocol Version 1.1**. Transport (2006).

15. **Felix Schuster, Manuel Costa, Cédric Fournet, Christos Gkantsidis, Marcus Peinado, Gloria Mainar-Ruiz, and Mark Russinovich. 2015. VC3: Trustworthy Data Analytics in the Cloud Using SGX**. In 2015 IEEE Symposium on Security and Privacy. IEEE, 38–54.

16. **Michael Schwarz, Samuel Weiser, Daniel Gruss, Clémentine Maurice, and Stefan Mangard. 2017. Malware Guard Extension: Using SGX to Conceal Cache Attacks**. Springer International Publishing, Cham, 3–24. https://doi.org/10.1007/978-3-319-60876-1_1.

17. **Jaebaek Seo, Byounyoung Lee, Seongmin Kim, Ming-Wei Shih, Insik Shin, Dongsu Han, and Taesoo Kim. 2017. SGX-Shield: Enabling Address Space Layout Randomization for SGX Programs**. In 2017 Annual Network and Distributed System Security Symposium (NDSS), San Diego, CA.

18. **Ming-Wei Shih, Sangho Lee, Taesoo Kim, and Marcus Peinado. 2017. T-SGX: Eradicating Controlled-Channel Attacks Against Enclave Programs**. In 2017 Annual Network and Distributed System Security Symposium (NDSS), San Diego, CA.

19. **Shweta Shinde, Zheng Leong Chua, Viswesh Narayanan, and Prateek Saxena. 2016. Preventing Page Faults from Telling Your Secrets**. In 11th ACM Symposium on Information, Computer and Communications Security.

20. **Shweta Shinde, Dat Le Tien, Shruti Tople, and Prateek Saxena. 2017. Panoply: Low-TCB Linux Applications with SGX Enclaves**. In 2017 Annual Network and Distributed System Security Symposium (NDSS), San Diego, CA.

21. **Rohit Sinha, Manuel Costa, Akash Lal, Nuno Lopes, Sriram Rajamani, Sanjit Seshia, and Kapil Vaswani. 2016. A Design and Verification Methodology for Secure Isolated Regions**. In 37th ACM SIGPLAN Conference on Programming Language Design and Implementation. ACM.

22. **Juraj Somorovsky. 2016. Systematic Fuzzing and Testing of TLS Libraries**. In 2016 ACM SIGSAC Conference on Computer and Communications Security. ACM, 1492–1504.

23. **Richard Ta-Min, Lionel Litty, and David Lie. 2006. Splitting Interfaces: Making Trust Between Applications and Operating Systems Configurable**. In 7th USENIX Symposium on Operating Systems Design and Implementation.

24. **Florian Tramer, Fan Zhang, Huang Lin, Jean-Pierre Hubaux, Ari Juels, and Elaine Shi. 2017. Sealed-Glass Proofs: Using Transparent Enclaves to Prove and Sell Knowledge**. In 2017 IEEE European Symposium on Security and Privacy. IEEE, 19–34.

25. **Chia-Che Tsai, Kumar Saurabh Arora, Nehal Bandi, Bhushan Jain, William Jannen, Jitin John, Harry Kalodner, Vrushali Kulkarni, Daniela Oliveira, and Donald Porter. 2014. Cooperation and Security Isolation of Library OSes for Multi-Process Applications**. In Ninth European Conference on Computer Systems. ACM.

26. **Serge Vaudenay. 2002. Security Flaws Induced by CBC Padding—Applications to SSL, IPSEC, WTLS...**. In International Conference on the Theory and Applications of Cryptographic Techniques. Springer, 534–545.

27. **Josef Weidendorfer, Markus Kowarschik, and Carsten Trinitis. 2004. A Tool Suite for Simulation-Based Analysis of Memory Access Behavior**. In International Conference on Computational Science. Springer, 440–447.

28. **Yuanzhong Xu, Weidong Cui, and Marcus Peinado. 2015. Controlled-Channel Attacks: Deterministic Side Channels for Untrusted Operating Systems**. In 2015 IEEE Symposium on Security and Privacy. IEEE, 640–656.

29. **Jisoo Yang and Kang Shin. 2008. Using Hypervisor to Provide Data Secrecy for User Applications on a Per-Page Basis**. In 4th ACM SIGPLAN/SIGOPS International Conference on Virtual Execution Environments (VEE). ACM.

30. **Charles Yount, Harish Patil, Mohammad Islam, and Aditya Srikanth. 2015. Graph-Matching-Based Simulation-Region Selection for Multiple Binaries**. In Performance Analysis of Systems and Software (ISPASS), 2015 IEEE International Symposium on. IEEE, 52–61.

31. **Fan Zhang, Ethan Cecchetti, Kyle Croman, Ari Juels, and Elaine Shi. 2016. Town Crier: An Authenticated Data Feed for Smart Contracts**. In 2016 ACM SIGSAC Conference on Computer and Communications Security. ACM, 270–282.

32. **Fengzhe Zhang, Jin Chen, Haibo Chen, and Binyu Zang. 2011. CloudVisor: Retrofitting Protection of Virtual Machines in Multi-Tenant Cloud with Nested Virtualization**. In 23rd ACM Symposium on Operating Systems Principles. ACM.

33. **Xiaokuan Zhang, Yuan Xiao, and Yinqian Zhang. 2016. Return-Oriented Flush-Reload Side Channels on ARM and Their Implications for Android Devices**. In 2016 ACM SIGSAC Conference on Computer and Communications Security. ACM, 858–870.

34. **Yinqian Zhang, Ari Juels, Michael Reiter, and Thomas Ristenpart. 2014. Cross-Tenant Side-Channel Attacks in PaaS Clouds**. In 2014 ACM SIGSAC Conference on Computer and Communications Security. ACM, 990–1003.

### Examples of Sensitive Control-Flow Vulnerabilities

#### A.1 Padding Oracles in mbedTLS(-SGX)

In mbedTLS v2.4.1 and mbedTLS-SGX, a decryption oracle can be constructed by monitoring the functions `sha1_process_wrap()` and `mbedtls_sha1_process()`. Specifically, as shown in Listing 3, the function `ssl_decrypt_buf()` calls `mbedtls_md_process()`, which is a wrapper function that calls both `sha1_process_wrap()` and `mbedtls_sha1_process()`, to conceal the timing difference caused by removing paddings before calculating the MAC. However, the number of times `mbedtls_md_process()` is called depends on the value of `extra_run`, which is calculated from the length of the padding, `padlen`. When the padding is incorrect, `padlen` will be 0, and `mbedtls_md_process()` is called only once. Therefore, the number of calls to `sha1_process_wrap()` and `mbedtls_sha1_process()`, which are located on different pages, has been exploited as the oracle in our demonstrated attacks. We note that the padding oracle is created due to the improper constant-time implementation of defenses to existing attacks.

```c
Listing 3: Snippet of ssl_decrypt_buf()
...
padlen &= correct * 0x1FF;
...
size_t j, extra_run = 0;
extra_run = ( 13 + ssl->in_msglen + padlen + 8 ) / 64
- ( 13 + ssl->in_msglen + 8 ) / 64;
extra_run &= correct * 0xFF;
mbedtls_md_hmac_update(
&ssl->transform_in->md_ctx_dec, ssl->in_ctr, 8 );
mbedtls_md_hmac_update(
&ssl->transform_in->md_ctx_dec, ssl->in_hdr, 3 );
mbedtls_md_hmac_update(
&ssl->transform_in->md_ctx_dec, ssl->in_len, 2 );
mbedtls_md_hmac_update(
&ssl->transform_in->md_ctx_dec, ssl->in_msg,
ssl->in_msglen );
mbedtls_md_hmac_finish(
&ssl->transform_in->md_ctx_dec,
/* Call mbedtls_md_process at least once due to cache
ssl->in_msg + ssl->in_msglen );
for( j = 0; j < extra_run; j++ )
    mbedtls_md_process(&ssl->transform_in->md_ctx_dec, ssl->in_msg);
...
```

#### A.2 Bleichenbacher Attack Oracles in OpenSSL

The oracle in OpenSSL 1.0.2j is created by the function `RSAerr()`. As shown in Listing 5, in `RSA_padding_check_PKCS1_type_2()`, when any error is detected during the PKCS decoding procedure, `mlen` will be set to -1. Thus, `RSAerr()` will be called to report the error before the function returns. After returning to the caller function `RSA_eay_private_decrypt()` (shown in Listing 4), `RSAerr()` is called one more time. These two calls to `RSAerr()` reveal a non-PKCS-conformant formatting, which can be exploited as an oracle for Bleichenbacher attacks. The vulnerability in OpenSSL is not due to a failed constant-time implementation but rather the redundant error reporting and logging mechanisms. One possible suggestion is to avoid repeated error reporting that are due to different reasons.

```c
Listing 4: RSA_eay_private_decrypt()
...
switch (padding) {
case RSA_PKCS1_PADDING:
    r = RSA_padding_check_PKCS1_type_2(to, num,
                                       buf, j, num);
    break;
...
}
if (r < num)
    goto err;
...

Listing 5: RSA_padding_check_PKCS1_type_2()
...
if (mlen == -1) {
    RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2,
           RSA_R_DATA_TOO_LARGE);
    return -1;
}
...
```

#### A.3 Bleichenbacher Oracles in GnuTLS

Similar to OpenSSL, the RSA decryption oracle in GnuTLS is also due to error logging and reporting. As shown in Listing 6, the function `_gnutls_debug_log()` is called for either an incorrect PKCS format or incorrect version numbers. Although GnuTLS applies the countermeasure against Bleichenbacher attacks by using constant-time implementations, the error logging still provides an exploitable side channel.

```c
Listing 6: Snippet of _gnutls_debug_log()
...
if (mlen == -1 || session->internals.priorities.allow_wrong_pms == 0
    && _gnutls_get_adv_version_minor(session) != plaintext.data[1])) {
    _gnutls_debug_log("auth_rsa: Possible PKCS #1 version check format attack\n");
}
...
```

These examples highlight the importance of careful implementation and thorough testing to prevent such vulnerabilities.