### Unauthorized (a) Direct and (b) Indirect Transfers

**Figure 2.** Unauthorized (a) direct and (b) indirect transfers.

#### 1. No Authorization
The first column identifies several buses that fail to authorize transfers. These buses do not selectively associate individual devices with isolated-application objects or enforce read-write permissions for I/O transfers. Consequently, a device can access another device’s data registers without providing its identity in the I/O transfers. For example, PCI buses, System Management Buses, CAN buses, and ARM Advanced High-performance Bus (AHB) buses do not require I/O requests to include device identities for sender authentication [24], [25], [26], [27]. This allows device peer-to-peer (P2P) transfers. Sender devices have the same privilege as bus controllers in accessing configuration and data registers of recipient devices. This enables unauthorized transfers; i.e., a write over the recipient device data registers or a read from the recipient device. When devices are connected to these buses, isolated but malicious drivers can manipulate them to perform unauthorized direct and indirect P2.P transfers to other devices, as illustrated below.

- **Example 1: Unauthorized Direct Transfers**
  - As shown in Figure 2(a), a malicious driver \(i\) can configure its device \(i\) to perform a device P2P transfer and access device \(j\) of another isolated application without any authorization, thereby breaking I/O separation.

- **Example 2: Unauthorized Indirect Transfers**
  - Figure 2(b) shows Indirect Transfer 1, where a PCI device \(i\) configures another PCI device \(h\) via a P2P transfer and enables it to read/write I/O objects of otherwise isolated device \(j\) on \(i\)'s behalf. Here, device \(i\) can embed the identity of an I/O object of device \(j\) into its maliciously configured device \(h\), instead of issuing reads/writes to the I/O object directly. Thus, direct transfers of device \(i\) to device \(h\) do not break I/O separation. Instead, transfers of device \(h\) to device \(j\) do.
  - In Indirect Transfer 2 of Figure 2(b), device \(i\) writes over one of its own transfer descriptors, enabling device \(i\) to issue an unauthorized cross-boundary transfer to device \(j\).

#### 2. Non-Selective Authorization
The second column of Figure 1 shows I/O buses that fail to support individual device association with isolated-driver objects and enforce their read-write permissions; i.e., access authorization is non-selective. Instead, these commodity bus controllers can only associate buses with these objects and enforce read-write permissions for buses. For example, some IOMMUs [9], [10] authorize accesses at the granularity of PCI bus controllers via PCIe-to-PCI bridges instead of individual devices. Similarly, when issuing requests on behalf of their individual DMA devices, USB host controllers [8] use their own identities instead of those of individual devices. In both cases, the IOMMU regards all DMA device transfers as originating from the I/O bus controller. Hence, it cannot authorize transfers selectively per individual device.

- **Example 3: Non-Selective Authorization of Transfers**
  - As shown in Figure 3, device \(i\) is manipulated by malicious driver \(i\) to read or write a DMA memory region of another device \(j\) across an isolation boundary, even though the IOMMU is correctly configured. For selective authorization of transfers, devices of different isolated applications must be connected to different PCIe-to-PCI bridges, yielding restricted hardware configurations [4]. ARM TrustZone authorizes I/O transfers selectively between the normal and secure world, but it cannot authorize transfers selectively within a single world.

#### 3. Selective-Authorization Failure from Optimization
The last column of Figure 1 illustrates the best hardware for selective (per device) authorization. Unfortunately, commodity OS kernels using this hardware often trade transfer-authorization assurance for added performance. For example, to decrease the significant cost of selective authorization via an IOMMU [28], commodity OS kernels perform all transfers into one shared kernel buffer-pool and then authorize kernel transfers. This works well for low-assurance kernels (e.g., Linux), but adds substantially more complex code to high-assurance micro-hypervisors [13], [14] or micro-kernels [12], [15] and causes significant performance degradation due to frequent switches to/from them.

- **Example 4: Unauthorized Transfers to/from Isolated Applications**
  - This performance–I/O isolation trade-off is illustrated in Figure 4, which shows the vulnerability caused by deferred clearing of IOMMU's IOTLB entries up to 10 ms [28], [11]. During this delay, the DMA device is allocated to a malicious (red) driver, which is isolated in another application, on demand. The malicious (red) driver instructs the DMA device to issue a transfer whose target virtual address is translated using the undeleted IOTLB entry (green circle), breaching red-green separation. Similar vulnerabilities can be caused by green applications, which could breach the isolation of other green applications.

### Threats
The examples above show how an adversary can breach the confidentiality and/or integrity of sensitive I/O data across isolated applications. The emerging attack pattern is simple: the adversary either compromises an OS driver or provides an isolated application containing a deliberately compromised driver. Then the compromised driver can mis-configure its device to set up unauthorized I/O transfers either directly or indirectly. These attacks appear in all commodity OSes—even when they benefit from formally verified micro-hypervisors and micro-kernels that isolate device drivers.

We assume that attackers control drivers of their devices. Note that an attacker need not corrupt device firmware to launch the I/O separation attacks; e.g., surreptitiously modify the device controller’s firmware by re-flashing [29], [30], [31] or by supply-chain compromise [32], [33], [34], [35]. Techniques to verify the correct device firmware and register contents after re-flashing are known [36] and hence are not addressed here. Also, we assume that legitimate backdoors are disabled before system operation; e.g., hardware debugging interfaces for privileged access to I/O devices [37]. As customary, we also assume that device hardware is non-malicious. Denial-of-service and covert-channel attacks in I/O transfers are also irrelevant to the I/O separation model.

### Model Motivation and Layered Approach
The challenges of building an I/O separation model are to provide security guarantees for (1) different I/O hardware designs, different types of I/O accesses (e.g., P2P, broadcast), direct and indirect transfers; and (2) different I/O kernels, ranging from high-assurance, such as Wimpy kernel (WK) [21] and the GPU separation kernel (GSK) [38], to low-assurance OS kernels (Linux) [28], [11]. The model must apply to all trusted execution environments and hardware-supported enclaves. We outline why these challenges are important and how to meet them via a layered modeling approach.

#### A. Motivation
- **Application to Different I/O Hardware Designs**
  - It must be possible to instantiate the formal model on any commodity I/O configurations regardless of the hardware ability, or lack thereof, to authorize I/O transfers. The reality is that a large variety of commodity processors which support application isolation (e.g., via trusted execution environments [39], partitions [16], [17], pieces of application logic [40], [13], [14], and enclaves [41], [15]) will continue to be interconnected to I/O hardware that fails to adequately authorize separate device transfers. This is both for high-performance and low-cost; e.g., in cyber-physical systems (CPS) [42] and vehicular computing [42], [26]. Our formalism suggests specific ways to handle inadequate I/O hardware.

  - **No Authorization**
    - In this case, an I/O kernel defines separate device-driver associations and transfer permissions. Driver code is either (a) formally verified not to violate the defined authorizations or (b) de-privileged, exported to isolated applications, and have all its device accesses authorized by the I/O kernel at run time, or a mixture of both (a) and (b). In case (a), verified drivers are authenticated at boot time (via secure and trusted boot) and configured within the I/O kernel. This is practical only for systems with few devices; e.g., CPS [42] and vehicular computing [42], [26]. In case (b), unverified driver accesses to devices could incur substantial overhead and hence could only be used for drivers that access devices infrequently. In both cases, the model shows how authorization is formally specified and verified; using transitive closures of transfer descriptors; see Section IV-B.

  - **Non-Selective Authorization**
    - In this case, the I/O kernel has two non-exclusive options, and is more scalable than the no-authorization remedy above. First, only the driver code of devices connected to the same PCI bus needs to be formally verified to satisfy individual device-transfer authorization, and only these drivers need to be authenticated and configured within the I/O kernel during boot. Second, whenever practical, I/O configurations are restricted to a single device per PCI bus and this is enforced at boot time. The drivers of these devices are untrusted and can be exported to isolated applications.

  - **Selective-Authorization Failure**
    - Here, a formal model applied to micro-hypervisors and I/O kernel verification shows that all separated but malicious drivers are de-privileged and safely exported to isolated applications along with their local buffers. This solves the I/O separation breaches shown in Example 4 of Section II-B and substantially simplifies both formal micro-hypervisor and I/O kernel verification and naturally avoids performance penalties (Section VIII-B). To enable this, the I/O kernel relies on the I/O hardware to enforce transfer authorization late, and the benefits of late authorization are discussed in Section IV-D.

- **Application to Different I/O Kernels**
  - Different I/O kernels isolate drivers in different ways: some isolate them within the I/O kernels themselves, while others isolate them within applications; e.g., in partitions of separation kernels, isolated pieces of application logic supported by micro-hypervisors, trusted execution environments, or hardware-isolated enclaves. Some I/O kernels support device activation on demand whereas others support only static activation during system boot. Despite their differences, all I/O kernels support a notion of separation to encapsulate drivers and their associated I/O objects (e.g., data buffers and configuration registers) and devices of isolated applications. Hence, any model must support this notion, and we do this via I/O partitions; i.e., at any given time, each device, driver, and object belongs to one and only one partition, and they can move from one partition to another. Then two security policy properties that an I/O separation model should naturally enforce are, at a high level: (1) no cross-partition transfers, and (2) no object data reuse in a new partition in on-demand I/O. We will make these more concrete in Section IV. The formal application of the model to an I/O kernel is discussed in Section V, whereas the informal application to other I/O kernels is in Section VIII-A.

#### B. Layered Modeling
- **Figure 5.** Model Refinements and Automated Code Generation
  - Our layered modeling approach yields a verified assembly implementation of the Wimpy kernel. We use Dafny and start from an abstract I/O separation model and use a hierarchy of verified refinements. The abstract I/O separation model specifies key device and driver components and operations, formalizes the notion of I/O partitions, and specifies I/O authorization and properties.
  - The second layer comprises Concrete I/O models, which are obtained from (verified) refinement of the abstract model, have more details, including specific types of I/O hardware authorization capabilities and I/O separation policy, as discussed above. The soundness of a Concrete I/O model is proven by leveraging the simulation relation between the abstract I/O separation model and the Concrete I/O model.
  - The third layer is I/O kernel designs whose formal specifications represent the (verified) refinement of the Concrete I/O model in different device classes, whereby some or all mechanisms for device identification, initialization, transfer authorization may differ among these classes. This allows the instantiation of different I/O kernels for typical OS device classes: a Wimpy kernel, a GPU separation kernel (see Figure 5), a NIC kernel, etc. Then the soundness of an I/O kernel design specification is proven by the simulation relation between the Concrete I/O model and the I/O kernel design specifications.

#### C. Code Sizes, Level of Effort, and Model Reusability
- All the models and refinement proofs shown in the gray box of Figure 5 are formally specified and verified.
- **Code sizes:**
  - The I/O separation model takes 28,518 lines of Dafny code (LOC).
  - The concrete model takes 47,120 LOC.
  - The WK design takes 55,426 LOC.
  - The WK implementation takes 136,815 LOC of Dafny and Vale.
  - The WK implementation is more than double the size of the design specifications because it requires formal refinement of subjects, objects, and operations for x86 platforms. The automatically generated code ensures correctness and efficiency.