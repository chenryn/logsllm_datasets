### 与现代基于模板的垃圾邮件引擎相比

与现代基于模板的垃圾邮件引擎相比，该方法很少（或从未）被使用。

### 表V展示了在Pushdo和Allaple数据集上的结果

对于某些基因型，REANIMATOR并未提供显著的额外覆盖。这些基因型对应于每次运行时恶意软件都会执行的行为，例如Pushdo释放有效载荷。尽管如此，在Anubis中未能成功执行某些功能的情况下，我们仍然获得了一些额外的覆盖（8个样本）。在这种特定情况下，是因为无法连接到Pushdo命令和控制服务器。对于垃圾邮件行为，REANIMATOR提供了显著的覆盖率提升。

### 性能

在本节中，我们将简要讨论REANIMATOR的基因型模型提取和基因型模型匹配技术的性能。

- **基因型模型提取**：在Anubis中对单个二进制文件进行五分钟的执行并提取基因型模型所需时间不到两分钟，这在标准桌面硬件上是可行的。因此，在大规模恶意软件分析系统（如Anubis）的工作流程中集成模型提取是实际可行的。
  
- **基因型模型匹配**：REANIMATOR使用的基因型模型匹配技术非常高效。在标准桌面硬件上，将整个2.5GB的IRC机器人数据集（包含超过一万个样本）进行匹配总共耗时2,511秒。这意味着每个二进制文件的匹配时间约为0.25秒。这种性能相对于动态分析的成本来说可以忽略不计。

### 限制

在我们的实验中，我们发现我们的基因型匹配技术能够成功地静态分析真实世界的恶意代码，并找到休眠的功能。然而，恶意软件作者可以通过开发专门针对我们工具的逃避技术来增加REANIMATOR进行匹配的难度，例如通过语义保持的控制流图混淆。例如，他们可以在程序的整个控制流图中插入大量的虚假节点和边。这种技术可以通过使用更强大、语义感知的模型来进行对抗[27]。

另一方面，恶意软件作者可能更倾向于使用能够击败多种分析和检测方法的通用逃避技术。这一目标可以通过高级打包技术（如基于仿真的打包和条件代码混淆）来实现，这些技术不能轻易地被通用解包方法击败。虽然最近的研究已经解决了基于仿真的打包问题[20]，但在某些情况下，条件代码混淆[21]可以提供强有力的保证，使得代码无法被静态分析。这是REANIMATOR或其他依赖静态分析的工具所面临的一个限制。

我们方法的另一个限制是，为了生成基因型模型，REANIMATOR需要在动态分析运行中至少观察一次相应行为的执行。因此，如果行为在沙箱中从未被执行，则无法被检测到。因此，类似于其他动态分析方法，REANIMATOR可以被检测到分析沙箱并拒绝运行的恶意软件所绕过。此外，它也无法检测到直到至少一个样本触发的时间炸弹或逻辑炸弹。然而，有可能将我们的技术与其他改进动态分析覆盖率的方法结合使用，例如多路径探索[4]。通过使用REANIMATOR，可以将应用于单个恶意软件执行的计算密集型技术的见解扩展到其他样本，从而提供更多信息。

### 相关工作

许多相关工作探讨了静态和动态方法来分析恶意软件样本。正如我们在第一部分中所观察到的，开发REANIMATOR的一个动机是动态分析存在部分覆盖不足的问题。为了解决这个问题，先前的研究提出了多次运行样本并通过构造输入来反转条件分支的结果（可能的触发器）[3]，[4]，或者简单地强制执行不同的路径[5]。不幸的是，使用这些技术可能会非常昂贵，因为需要分析的路径数量可能呈指数级增长。路径爆炸问题同样影响着使用符号执行来执行更多代码路径以查找更多漏洞的动态软件测试系统，例如EXE[28]、DART[29]和SAGE[30]。

结构特征，尤其是控制流图（CFG），已在静态分析中广泛使用。除了我们在工作中利用的[9]中的结果外，[31]中也提出了一种类似的方法。不同之处在于[31]的作者应用了规范化技术来减少已知代码变异技术的影响。经过规范化后，他们使用跨过程的CFG，将程序中每个函数的CFG链接在一起。

结构代码特征也被用于识别程序二进制文件之间的相似性。例如，[32]和[33]的作者都定义了一种基于函数调用图的恶意软件样本距离函数。在[32]中，作者建议使用这种距离函数来分类恶意软件并创建恶意软件二进制文件的系统发育树。SMIT[33]还使用函数调用图的属性来在大型恶意软件数据集中实现高效的最近邻搜索。函数调用图可以提供整个二进制文件的整体视图，因此适合全局比较二进制文件。然而，这些技术通常不适合检测较大程序中的小代码片段。此外，它们没有将任何语义（关于表型的信息）与调用图关联起来。

除了使用控制流或指令图之外，其他形式化方法也被用于识别病毒代码序列。在[11]中，模型检查被用来识别实现预先指定的恶意代码模板的程序部分。这种方法可以对抗常见的混淆技术。该技术后来在[27]中得到了扩展，允许使用更通用的代码模板并采用先进的静态分析技术。在[34]中，模型检查也用于通过时态逻辑规范语义地识别恶意软件。所有这些系统都有一个共同的限制，即必须手动指定每种行为实例化的模型。相比之下，REANIMATOR只需要通用的行为模型（表型），然后能够自动识别实现该行为的代码（基因型）。此外，这些技术在很大程度上与我们的工作是正交的。一旦REANIMATOR识别出一个基因型，就可以潜在地使用这些更复杂（且计算成本高昂）的检测技术来进行基因型匹配。

类似于我们的系统，AGIS[35]使用动态和静态技术的组合来分析恶意软件。具体而言，该系统使用静态分析来识别导致与恶意活动相关的系统调用的指令序列。这些指令序列随后被用作感染（检测）签名。与我们的系统的一个显著区别是，AGIS简单地将所有导致有趣系统调用的指令包含在签名中。而我们的系统则试图仅提取那些实际上负责观察到的行为的代码部分。这是通过REANIMATOR的过滤和萌发步骤实现的。

通过源代码分析进行剽窃检测是一个研究得相当充分的主题。除了MOSS[25]之外，该领域的其他重要工作还包括CCFinder[36]、Dup[37]和CP-Miner[6]。一些工具基于文本分析，比较代码行；另一些工具比较令牌序列[36]、[37]或代码的树表示[38]。还有一些工具使用程序依赖图（即函数的控制和数据流依赖关系）[39]，这在概念上接近于汇编代码中的CFG使用。二进制文件上的剽窃检测发展较少。在[26]中，作者扩展了一个先前的系统[38]，使其适用于汇编指令，通过一些规范化技术和设计新的模型来紧凑地表示与二进制指令相关的信息。同样，检测到的克隆没有关联任何语义信息，并且该方法在处理由于不同编译器选项引起的微小代码更改方面远不如我们的方法稳健（如第五部分所述）。

### 结论

动态恶意软件分析系统提供了关于野外发现的恶意代码能力的重要信息。然而，它们通常只执行单一的执行路径。因此，这些系统往往无法观察到恶意软件样本实现的大部分功能。在本文中，我们介绍了REANIMATOR，这是一种新颖的系统，用于识别恶意软件中的休眠功能。我们系统的主要洞察是，我们可以利用在一个恶意软件样本中观察到的一次恶意行为来检测其他恶意程序中的相同功能（即使它们在动态分析中未表现出这种行为）。为了实现这一目标，我们的系统分为三个步骤。首先，我们使用简单的规则在动态分析过程中识别恶意软件样本输出和事件中的安全相关行为（表型）。其次，我们自动定位并建模负责这种行为的代码（基因型）。第三，我们重用之前为特定行为生成的基因型模型，以静态方式检测在动态分析中未表现出这种行为的恶意软件中的类似代码。

我们的方法使我们能够揭示恶意软件程序中的休眠功能。因此，与仅使用动态分析的结果相比，我们可以显著提高对恶意代码能力的了解。我们的实验表明，生成的模型准确地捕获了负责各种恶意行为的代码部分（基因型）。此外，它们显示REANIMATOR可以显著提高动态分析系统的覆盖率。

### 致谢

作者感谢Michael Bailey和Jon Oberheide为我们提供了评估中使用的僵尸网络源代码样本，以及Thorsten Holz和Morgan Marquis-Boire在恶意软件解包方面的帮助。我们还要感谢Federico Maggi在绘图和校对方面的帮助。这项工作得到了欧洲委员会通过IST-216026-WOMBAT项目在第七框架计划下的部分支持，以及ONR的N000140911042号资助和国家科学基金会（NSF）的0845559号资助的支持。

### 参考文献

[1] “Anubis,” http://anubis.iseclab.org/.

[2] “CWSandbox,” http://www.cwsandbox.org/, 2008.

[3] D. Brumley, C. Hartwig, Z. Liang, J. Newsome, P. Poosankam, D. Song, and H. Yin, “Automatically identifying trigger-based behavior in malware,” in Botnet Detection, 2008.

[4] A. Moser, C. Kruegel, and E. Kirda, “Exploring multiple execution paths for malware analysis,” in IEEE Symp. on Security and Privacy, 2007.

[5] J. Wilhelm and T. Chiueh, “A Forced Sampled Execution Approach to Kernel Rootkit Identification,” in Symp. on Recent Advances in Intrusion Detection (RAID), 2007.

[6] Z. Li, S. Lu, S. Myagmar, and Y. Zhou, “CP-Miner: A Tool for Finding Copy-paste and Related Bugs in Operating System Code,” in USENIX Symp. on Operating System Design and Implementation (OSDI), 2004.

[7] H.-A. Kim and B. Karp, “Autograph: toward automated, distributed worm signature detection,” in USENIX Security Symposium, 2004.

[8] J. Newsome, B. Karp, and D. Song, “Polygraph: Automatically generating signatures for polymorphic worms,” in IEEE Symposium on Security and Privacy, 2005.

[9] C. Kruegel, E. Kirda, D. Mutz, W. Robertson, and G. Vigna, “Polymorphic worm detection using structural information of executables,” in Symp. on Recent Advances in Intrusion Detection (RAID), 2005.

[10] M. Christodorescu, S. Jha, S. A. Seshia, D. Song, and R. E. Bryant, “Semantics-aware malware detection,” in IEEE Symp. on Security and Privacy, 2005, pp. 32–46.

[11] M. Christodorescu and S. Jha, “Static analysis of executables to detect malicious patterns,” in 12th USENIX Security Symposium, 2003.

[12] M. Christodorescu, S. Jha, and C. Kruegel, “Mining specifications of malicious behavior,” in 6th Joint European software engineering conf. and ACM SIGSOFT Symp. on Foundations of Software Engineering (ESEC-FSE), 2007.

[13] G. Jacob, H. Debar, and E. Filiol, “Malware behavioral detection by attribute-automata using abstraction from platform and language,” in Symp. on Recent Advances in Intrusion Detection (RAID), 2009.

[14] L. Martignoni, E. Stinson, M. Fredrikson, S. Jha, and J. C. Mitchell, “A Layered Architecture for Detecting Malicious Behaviors,” in Symp. on Recent Advances in Intrusion Detection (RAID), 2008.

[15] M. G. Kang, P. Poosankam, and H. Yin, “Renovo: a hidden code extractor for packed executables,” in ACM Workshop on Recurring malcode (WORM), 2007.

[16] L. Martignoni, M. Christodorescu, and S. Jha, “Omniunpack: Fast, generic, and safe unpacking of malware,” in Annual Computer Security Applications Conf. (ACSAC), 2007.

[17] H. Agrawal and J. Horgan, “Dynamic Program Slicing,” in Conf. on Programming Language Design and Implementation (PLDI), 1990.

[18] U. Bayer, I. Habibi, D. Balzarotti, E. Kirda, and C. Kruegel, “Insights into current malware behavior,” in 2nd USENIX Workshop on Large-Scale Exploits and Emergent Threats (LEET), 2009.

[19] P. Royal, M. Halpin, D. Dagon, R. Edmonds, and W. Lee, “Polyunpack: Automating the hidden-code extraction of unpack-executing malware,” in 22nd Annual Computer Security Applications Conf. (ACSAC), 2006.

[20] M. Sharif, A. Lanzi, J. Griffin, and W. Lee, “Automatic reverse engineering of malware emulators,” in IEEE Symp. on Security and Privacy, 2009.

[21] M. I. Sharif, A. Lanzi, J. T. Griffin, and W. Lee, “Impeding malware analysis using conditional code obfuscation,” in Network and Distributed System Security (NDSS), 2008.

[22] A. Decker, D. Sancho, L. Kharouni, M. Goncharov, and R. McArdle, “A study of the Pushdo / Cutwail Botnet,” http://us.trendmicro.com/imperia/md/content/us/pdf/threats/securitylibrary/study of pushdo.pdf, 2009.

[23] “F-Secure Malware Information Pages - Allaple.A,” http://www.f-secure.com/v-descs/allaple a.shtml, 2008.

[24] J. Oberheide, M. Bailey, and F. Jahanian, “PolyPack: An Automated Online Packing Service for Optimal Antivirus Evasion,” in USENIX Workshop on Offensive Technologies (WOOT), 2009.

[25] S. Schleimer, D. S. Wilkerson, and A. Aiken, “Winnowing: local algorithms for document fingerprinting,” in ACM SIGMOD Int. Conf. on Management of Data, 2003.

[26] A. Sæbjørnsen, J. Willcock, T. Panas, D. Quinlan, and Z. Su, “Detecting code clones in binary executables,” in 18th Int. Symp. on Software testing and analysis (ISSTA), 2009.

[27] M. D. Preda, M. Christodorescu, S. Jha, and S. Debray, “A semantics-based approach to malware detection,” in Principles of Programming Languages (POPL), 2007.

[28] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and D. R. Engler, “Exe: Automatically generating inputs of death,” ACM Trans. Inf. Syst. Secur., vol. 12, no. 2, pp. 1–38, 2008.

[29] P. Godefroid, N. Klarlund, and K. Sen, “DART: directed automated random testing,” in ACM SIGPLAN Conf. on Programming language design and implementation, 2005.

[30] P. Godefroid, M. Levin, and D. Molnar, “Automated White-box Fuzz Testing,” in 15th Symp. on Network and Distributed System Security (NDSS), 2008.

[31] D. Bruschi, L. Martignoni, and M. Monga, “Detecting self-mutating malware using control-flow graph matching,” in Detection of Intrusions and Malware and Vulnerability Assessment (DIMVA), 2006.

[32] E. Carrera and G. Erdelyi, “Digital genome mapping–advanced binary malware analysis,” in Virus Bulletin Conf., 2004, pp. 187–197.

[33] X. Hu, T. Chiueh, and K. Shin, “Large-scale malware indexing using function-call graphs,” in ACM Conf. on Computer and Communications Security (CCS), 2009.

[34] J. Kinder, S. Katzenbeisser, C. Schallhart, and H. Veith, “Detecting malicious code by model checking,” in Detection of Intrusions and Malware and Vulnerability Assessment (DIMVA), 2005.

[35] Z. Li, X. Wang, Z. Liang, and M. K. Reiter, “AGIS: Towards automatic generation of infection signatures,” in DSN, 2008.

[36] T. Kamiya, S. Kusumoto, and K. Inoue, “CCFinder: A Multilingual Token-Based Code Clone Detection System for Large Scale Source Code,” IEEE Trans. on Soft. Eng., pp. 654–670, 2002.

[37] B. Baker, “On finding duplication and near-duplication in large software systems,” in Working Conf. on Reverse Engineering (WCRE), 1995.

[38] L. Jiang, G. Misherghi, Z. Su, and S. Glondu, “Deckard: Scalable and accurate tree-based detection of code clones,” in 29th Int. Conf. on Software Engineering (ICSE), 2007.

[39] J. Krinke, “Identifying similar code with program dependence graphs,” in 8th Working Conf. on Reverse Engineering (WCRE), 2001.