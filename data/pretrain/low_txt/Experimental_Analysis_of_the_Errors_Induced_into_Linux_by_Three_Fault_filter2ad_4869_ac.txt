### Function and Error Codes

The "Invalid Argument" error code is generated independently, which explains its isolated presence. Figures 4a and 4b provide a more detailed breakdown of the results from Figures 3a and 3b, respectively. These figures show that, for a given kernel call, except in the case of `nanosleep`, all error codes generated by the two injection techniques at the API level are of the same nature. Although the overall error code rate is nearly identical and the generated error codes are the same, they are not always statistically equivalent, with exceptions such as `setpriority`, `gettimeofday`, and `wait4`.

Thus, further refinement is necessary to derive meaningful insights. The most common error code is "Bad Address," which appears in five out of six kernel calls for both techniques. These five kernel calls involve either a read pointer data type or a write pointer data type.

#### API Invalid Parameters
- **Error Code Distribution:**
  - 100% for `setitimer`
  - 100% for `sched_setscheduler`
  - 83% for `gettimeofday`
  - 81% for `nanosleep`
  - 47% for `setpriority`
  - 43% for `wait4`

- **Error Codes:**
  - "Invalid Argument"
  - "Bad Address"
  - "Non Existent Process"
  - "Interrupted Kernel Call"
  - "No Child Process"

#### Bit-Flip in API Parameters
- **Error Code Distribution:**
  - 57% for `setitimer`
  - 58% for `sched_setscheduler`
  - 43% for `gettimeofday`
  - 31% for `nanosleep`
  - 11% for `setpriority`
  - 100% for `wait4`

- **Error Codes:**
  - "Invalid Argument"
  - "Bad Address"
  - "Non Existent Process"
  - "Interrupted Kernel Call"
  - "No Child Process"

### Detailed Analysis

A more in-depth analysis supports this observation. Figure 5 provides an example of the insights gained from the experiments. This figure shows that two types of error codes, "Non Existent Process" and "Invalid Argument," were observed when flipping bits in the first parameter of the Permission flag class of the `setpriority` kernel call. The "Non Existent Process" error code was triggered by flipping one of the first two bits (0 and 1), while the "Invalid Argument" error code was triggered by flipping any of the remaining bits (2-31). Only the values `-1` and `ULONG_MAX` injected into this parameter caused the "Invalid Argument" error code, and none of them caused the "Non Existent Process" error code.

The `setpriority` kernel call sets the scheduling priority of a process, a process group, or user processes. The first parameter determines which scheduling priority will be modified by setting one of these flags: `PRIO_PROCESS` (0), `PRIO_PGRP` (1), or `PRIO_USER` (2), which are encoded in the first two bits. The second parameter is interpreted based on the value of the first parameter, and it can be a process identifier, a process group identifier, or a user identifier. The workload uses the `setpriority` kernel call to modify the scheduling priority of one process (`PRIO_PROCESS`). By flipping one of the first two bits of the first parameter, we obtain either `PRIO_PGRP` or `PRIO_USER`. The second parameter no longer matches the resulting values of the first parameter. It is also important to note the impact of the system state. If the second parameter contains a valid process group after corrupting `PRIO_PROCESS` to `PRIO_PGRP`, the kernel will not detect the error, and the application result, if not the entire system state, will likely be corrupted.

### Observations

These observations further support the view that flipping single bits in kernel call parameters at the API level produces more erroneous behaviors than applying invalid parameters.

### Conclusion

In this paper, we compared the impact of three types of SWIFI techniques. Two of them target kernel call parameters with different fault models: i) bit-flip and ii) invalid parameters, and the third targets the parameters of the kernel calls' underlying functions. We developed a fault injection environment to support these three techniques. The results presented in this paper target the Linux-kernel scheduling component and concern six kernel calls invoked by this component. The comparison of the results relies on typical kernel failure modes (e.g., exceptions and kernel hangs) and the error detection mechanisms provided by the kernel.

The bit-flip injection technique showed different erroneous behaviors compared to the other two techniques. Many hardware exceptions were triggered by this technique, and the rate of generated error codes was lower than for the other techniques. This suggests that internal software faults (residual design faults or device driver-caused faults) are unlikely to be easily emulated by injecting only at the API level, at least for the Linux kernel. Further work is in progress to better study this issue.

The bit-flip parameter injection technique is straightforward and does not require prior analysis of parameter data types. However, it requires a significant amount of time, as it needs 32 injections per parameter. The invalid parameter technique takes less time for a complete campaign but is more challenging, as it requires prior analysis, though this analysis could be done once, such as the Ballista-based POSIX test suite, which can be applied to all POSIX-compliant systems. From an efficiency standpoint, single-bit flip injections provoked more erroneous behaviors than the invalid parameter injection technique. We presented a detailed case where the invalid parameter injections were unable to reproduce an error code that was provoked by bit-flips. This indicates that we need to enrich the set of invalid parameters.

We plan to incorporate error detection mechanisms, such as assertions, into the kernel to enhance the observation of erroneous behaviors and obtain more detailed traces for analyzing error propagation channels. Additionally, we are analyzing errors produced by real faults already activated in Linux and published. Our ultimate goal is to compare the set of errors produced by injected faults to the set of errors produced by real faults to identify a set of representative faults to be injected to characterize the OS behavior in the presence of faults, i.e., benchmark the OS dependability.

### Acknowledgment

The work presented in this paper is partially supported by the European Community (Project IST-2000-25425 DBench: Dependability Benchmarking). This work has greatly benefited from many fruitful discussions with Jean-Claude Laprie from LAAS. We would like to thank Moslem Belkhiria, Benjamin Lussier, and Thomas Marteau, who contributed to the experiments during their training period at LAAS.

### References

[1] J. V. Carreira, D. Costa, and J. G. Silva, “Fault Injection for System Dependability,” IEEE Spectrum, vol. 36, pp. 50-55, 1999.

[2] D. T. Stott, G. Ries, M.-C. Hsueh, and R. K. Iyer, “Dependability Analysis of a High-Speed Network Using Software-Implemented Fault Injection and Simulated Fault Injection,” IEEE Trans. on Computers, vol. 47, no. 1, pp. 108-119, 1998.

[3] E. Fuchs, “Validating the Fail-Silence of the MARS Architecture,” in Proc. DCCA-6, Grainau, Germany, 1998, pp. 225-247.

[4] H. Madeira, D. Costa, and M. Vieira, “On the Emulation of Software Faults by Software Fault Injection,” in Proc. DSN-2000, New York, NY, USA, 2000, pp. 417-426.

[5] J.-C. Fabre, F. Salles, M. Rodríguez Moreno, and J. Arlat, “Assessment of COTS Microkernels by Fault Injection,” in Proc. DCCA-7, San Jose, CA, USA, 1999, pp. 25-44.

[6] P. Koopman and J. DeVale, “Comparing the Robustness of POSIX Operating Systems,” in Proc. FTCS-29, Madison, WI, USA, 1999, pp. 30-37.

[7] J. E. Foster and B. P. Miller, “An Empirical Study of the Robustness of Windows NT Applications Using Random Testing,” in Proc. 4th USENIX Windows System Symposium, Seattle, WA, USA, 2000.

[8] I. T. Bowman, R. C. Holt, and N. V. Brewster, “Linux as a Case Study: Its Extracted Software Architecture,” in Proc. 21st Int. Conf. on Software Engineering, Los Angeles, CA, USA, 1999.

[9] R. Chillarege et al., “Orthogonal Defect Classification - A Concept for In-Process Measurements,” IEEE Trans. on Software Engineering, vol. 18, no. 11, pp. 943-956, 1992.

[10] http://www.wi.leidenuniv.nl/~wichert/strace.

[11] A. D. Alexandrov, M. Ibel, K. E. Schauser, and C. J. Scheiman, “Extending the Operating System at the User Level: the Ufo Global File System,” in Proc. USENIX, Anaheim, CA, USA, 1997, pp. 77-90.

[12] M. Rodríguez, F. Salles, J.-C. Fabre, and J. Arlat, “MAFALDA: Microkernel Assessment by Fault Injection and Design Aid,” in Proc. EDCC-3, Prague, Czech Republic, 1999, pp. 143-160.

[13] J. Christmansson, M. Hiller, and M. Rimén, “An Experimental Comparison of Fault and Error Injection,” in Proc. ISSRE'98, Paderborn, Germany, 1998, pp. 369-378.