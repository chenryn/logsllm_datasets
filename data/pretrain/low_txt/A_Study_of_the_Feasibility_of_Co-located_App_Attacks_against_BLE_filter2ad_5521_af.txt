# References and Citations

1. **Glucose Monitoring Profile: Bluetooth Profile Specification v1.0.1, December 2015.**

2. **BLUETOOTH SPECIAL INTEREST GROUP. Bluetooth Core Specification v5.0, December 2016.**

3. **BLUETOOTH SPECIAL INTEREST GROUP. Bluetooth Mesh Networking: An Introduction for Developers, 2017.**

4. **BRONZI, W., FRANK, R., CASTIGNANI, G., AND ENGEL, T.** Performance and Robustness Analysis of Bluetooth Low Energy for Inter-Vehicular Communications. *Ad Hoc Netw.* 37, P1 (February 2016), pp. 76–86.

5. **CYR, B., HORN, W., MIAO, D., AND SPECTER, M.** Security Analysis of Wearable Fitness Devices (Fitbit). Massachusetts Institute of Technology, 2014.

6. **DAS, A. K., PATHAK, P. H., CHUAH, C.-N., AND MOHAPATRA, P.** Uncovering Privacy Leakage in BLE Network Traffic of Wearable Fitness Trackers. In *Proceedings of the 17th International Workshop on Mobile Computing Systems and Applications* (2016), ACM, pp. 99–104.

7. **ANDROID.** Bluetooth Low Energy Overview, April 2018. [Online]. Available: https://developer.android.com/guide/topics/connectivity/bluetooth-le. [Accessed: 18 July 2018].

8. **DESNOS, A., ET AL.** Androguard: Reverse Engineering, Malware and Goodware Analysis of Android Applications... and More (ninja!). https://github.com/androguard/androguard.

9. **EGELE, M., BRUMLEY, D., FRATANTONIO, Y., AND KRUEGEL, C.** An Empirical Study of Cryptographic Misuse in Android Applications. In *Proceedings of the 2013 ACM SIGSAC Conference on Computer & Communications Security* (2013), ACM, pp. 73–84.

10. **ELKHODR, M., SHAHRESTANI, S., AND CHEUNG, H.** Emerging Wireless Technologies in the Internet of Things: A Comparative Study. *International Journal of Wireless & Mobile Networks (IJWMN)* 8, 5 (October 2016), pp. 67–82.

11. **FAWAZ, K., KIM, K.-H., AND SHIN, K. G.** Protecting Privacy of BLE Device Users. In *USENIX Security Symposium* (2016), pp. 1205–1221.

12. **FIDO ALLIANCE.** FIDO Bluetooth Specification, 2017. https://fidoalliance.org/specs/fido-u2f-bt-protocol-id-20150514.pdf.

13. **FRITZ, C., ARZT, S., AND RASTHOFER, S.** DroidBench: A Micro-Benchmark Suite to Assess the Stability of Taint-Analysis Tools for Android. https://github.com/secure-software-engineering/DroidBench.

14. **GOMEZ, C., OLLER, J., AND PARADELLS, J.** Overview and Evaluation of Bluetooth Low Energy: An Emerging Low-Power Wireless Technology. *Sensors (Basel, Switzerland)* 12, 9 (2012), pp. 11734–11753.

15. **GUO, X., YIN, Y., DONG, C., YANG, G., AND ZHOU, G.** On the Class Imbalance Problem. In *Natural Computation, 2008. ICNC’08. Fourth International Conference on* (2008), vol. 4, IEEE, pp. 192–201.

16. **HOFFMANN, J., USSATH, M., HOLZ, T., AND SPREITZENBARTH, M.** Slicing Droids: Program Slicing for Smali Code. In *Proceedings of the 28th Annual ACM Symposium on Applied Computing* (2013), ACM, pp. 1844–1851.

17. **IDC.** Worldwide Wearables Market Grows 7.3% in Q3 2017 as Smart Wearables Rise and Basic Wearables Decline, Says IDC. [Online]. Available: https://www.idc.com/getdoc.jsp?containerId=prUS43818418. [Accessed: 16-Feb-2017].

18. **JENI, L. A., COHN, J. F., AND DE LA TORRE, F.** Facing Imbalanced Data–Recommendations for the Use of Performance Metrics. In *Affective Computing and Intelligent Interaction (ACII), 2013 Humaine Association Conference on* (2013), IEEE, pp. 245–251.

19. **KARANI, R., DHOTE, S., KHANDURI, N., SRINIVASAN, A., SAWANT, R., GORE, G., AND JOSHI, J.** Implementation and Design Issues for Using Bluetooth Low Energy in Passive Keyless Entry Systems. In *India Conference (INDICON), 2016 IEEE Annual* (2016), IEEE, pp. 1–6.

20. **KOROLOVA, A., AND SHARMA, V.** Cross-App Tracking via Nearby Bluetooth Low Energy Devices. In *PrivacyCon 2017* (2017), Federal Trade Commission.

21. **KRÜGER, S., NADI, S., REIF, M., ALI, K., MEZINI, M., BODDEN, E., GÖPFERT, F., GÜNTHER, F., WEINERT, C., DEMMLER, D., ET AL.** CogniCrypt: Supporting Developers in Using Cryptography. In *Proceedings of the 32nd IEEE/ACM International Conference on Automated Software Engineering* (2017), IEEE Press, pp. 931–936.

22. **KRÜGER, S., SPÄTH, J., ET AL.** CogniCrypt_SAST: CrySL-to-Static Analysis Compiler. https://github.com/CROSSINGTUD/CryptoAnalysis/.

23. **NAVEED, M., ZHOU, X., DEMETRIOU, S., WANG, X., AND GUNTER, C. A.** Inside Job: Understanding and Mitigating the Threat of External Device Mis-Binding on Android. In *21st Annual Network and Distributed System Security Symposium, NDSS 2014, San Diego, California, USA, February 23-26, 2014* (2014).

24. **NORDIC SEMICONDUCTOR.** BLE on Android v1.0.1. [Online]. Available: https://devzone.nordicsemi.com/attachment/bdd561ff56924e10ea78057b91c5c642. [Accessed: 05 Feb 2018].

25. **ORACLE.** Java Cryptography Architecture (JCA) Reference Guide. [Online]. Available: https://docs.oracle.com/javase/8/docs/technotes/guides/security/crypto/CryptoSpec.html. [Accessed: 18 July 2018].

26. **PAUCK, F., BODDEN, E., AND WEHRHEIM, H.** Do Android Taint Analysis Tools Keep Their Promises? In *Proceedings of the 2018 26th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering* (New York, NY, USA, 2018), ESEC/FSE 2018, ACM, pp. 331–341.

27. **POEPLAU, S., FRATANTONIO, Y., BIANCHI, A., KRUEGEL, C., AND VIGNA, G.** Execute This! Analyzing Unsafe and Malicious Dynamic Code Loading in Android Applications. In *NDSS* (2014), vol. 14, pp. 23–26.

28. **QIU, L., WANG, Y., AND RUBIN, J.** Analyzing the Analyzers: FlowDroid/IccTA, AmanDroid, and DroidSafe. In *Proceedings of the 27th ACM SIGSOFT International Symposium on Software Testing and Analysis* (2018), ACM, pp. 176–186.

29. **RYAN, M.** Bluetooth: With Low Energy Comes Low Security. In *7th USENIX Workshop on Offensive Technologies, WOOT ’13, Washington, D.C., USA, August 13, 2013* (2013).

30. **SILVA, B. N., KHAN, M., AND HAN, K.** Internet of Things: A Comprehensive Review of Enabling Technologies, Architecture, and Challenges. *IETE Technical Review* 35, 2 (2018), pp. 205–220.

31. **UNIVERSITÉ DU LUXEMBOURG.** Lists of APKs. [Online]. Available: https://androzoo.uni.lu/lists. [Accessed: 12 Nov 2018].

32. **WEI, F., ROY, S., OU, X., ET AL.** Amandroid: A Precise and General Inter-Component Data Flow Analysis Framework for Security Vetting of Android Apps. In *Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security* (2014), ACM, pp. 1329–1341.

## Appendix A: BLECryptracer Logic

### Backtracing BLE Writes

BLE writes use one of the `setValue` methods listed in Table 2 to set the value that is to be written, before calling the method for performing the actual write. BLECryptracer identifies all calls to these methods and traces the origins of the data held in the registers passed as input to the methods.

For example, consider the smali code in Figure 8. The `setValue` method is invoked at Line 13 and is passed two registers as input. As `setValue` is an instance method, the first input, local register `v3`, holds the `BluetoothGattCharacteristic` object that the method is invoked on. The second input, parameter register `p2`, holds the data that is to be written to the BLE device, and is the second argument passed to the method `a` (Line 1). BLECryptracer identifies `p2` as the register holding the data of interest and traces backward to determine if this data is the result of some cryptographic processing.

To achieve this, the method(s) within the APK that invoke method `a` are identified, and the second input to each such method is traced. If the BLE data had come from a local register rather than a parameter register, BLECryptracer would trace back within method `a`'s instructions to determine the origin of the data. This backtracing is performed until either a crypto-library is referenced or a `const-<>` or `new-array` declaration is encountered, indicating no cryptography is used. Note that calls to any method within the crypto-libraries mentioned in Section 4.2 are accepted as evidence of the use of cryptography with BLE data. The tool stops processing an APK at the first instance where such a method call is identified.

During execution, BLECryptracer maintains a list of registers (set within the context of a method) to be traced for each `setValue` method call within the application code. This initially contains a single entry, which is the input to the `setValue` method. A new register is added to the list if it appears to have tainted the value of any of the registers already in the list. This could be due to simple operations such as `aget`, `aput`, or `move-<>` (apart from `move-result` variants), or it could be as a result of a comparison, arithmetic, or logic operation (in which case, the register holding the operand on which the operation is performed is added to the trace list). Similarly, if a register obtains a value from an instance field (via `sget` or `iget`), then all instances where that field is assigned a value are analyzed. However, the script does not analyze the order in which the field is assigned values, as this would require activity lifecycle awareness.

Where a register is assigned a value that is output from a method invocation via `move-result`, if the method is not an external method, then the instructions within that method are analyzed, beginning with the return value and tracing backwards. In some instances, the actual source of a register’s value is obfuscated due to the use of intermediate formatting functions. To overcome this, BLECryptracer traces the inputs to called methods as well. Further, if a register is used as input to a method, then all other registers that are inputs to the method are also added to the trace list. While this captures some indirect value assignments, it runs the risk of false positives. For this reason, we have included the concept of Confidence Levels for the code output.

If, for an APK, the input to the `setValue` method can be backtraced to cryptography directly, via only register value transfers and as immediate results of method invocations, then a confidence level of "High" is assigned to the result. If a register cannot be traced back directly to a cryptographic output but if an indirect trace identifies the use of a cryptography library, then a confidence level of "Medium" is assigned. Finally, in the event that no cryptography use is identified at High or Medium confidence levels, the script performs a less stringent search through all the instructions of the methods it previously analyzed. This risks including instances of cryptography use with functions unrelated to BLE and is therefore assigned a "Low" confidence level.

### Forward-Tracing BLE Reads

With BLE reads, a `getValue` variant is invoked, and the output, i.e., the value that is read, is moved to a register. To trace this value, BLECryptracer identifies all calls to `getValue` variants, then traces the output registers and all registers they taint until either a crypto-library is referenced or the register value changes. Such value changes can occur due to `new-array`, `new-instance`, and `const` declarations, as well as by being assigned the output of various operations (such as method invocations or arithmetic/logic operations).

With forward-tracing, the register holding the BLE data is considered to taint another if, for example, the source register is used in a method invocation or comparison/arithmetic/logic operation, whose result is assigned to the destination register. The destination register is then added to the trace list. When a register is used as input to a method, then along with the output of that method, the use of the register within the method is also analyzed.

This method of analysis tends to result in a "tree" of traces. For example, considering the smali code in Figure 9, the byte array output from the BLE read is stored in register `v0` (Line 4). This taints register `v3` via a format conversion function (Lines 10 and 11), which in turn taints `v2` via a `java.lang.StringBuilder` function (Lines 12 and 13). At this point, all three registers are tainted and will be traced until their values change.

The forward-tracing mode also assigns one of three confidence levels to its output. "High" is assigned when cryptographically-processed data is identified via the tracing mechanism above; "Medium" is when the use of cryptography is identified by tracing classes that implement interfaces. "Low" is assigned when a less stringent search through all encountered methods results in identification of a reference to a cryptography library (similar to the backtracing case).

### Handling Obfuscation

APKs sometimes employ obfuscation techniques to protect against reverse-engineering, and the question then arises as to whether these techniques may impact the results of our analysis. We briefly discuss different obfuscation techniques and why they do not impact our tool.

One of the most common techniques is identifier renaming, where identifiers within the code are replaced with short, meaningless names. However, because Androguard operates on smali (rather than Java) code, BLECryptracer is able to overcome the challenges posed by this technique. String encryption is another obfuscation mechanism, but it again does not affect the output of our tool as BLECryptracer does not search for hard-coded strings. Further, our tool was verified successfully against three out of four benchmarking applications that utilized reflection. The most complex obfuscation techniques are packing and runtime-based obfuscation, but these are typically employed by malware. Because we are looking for vulnerable (not malicious) applications, we do not consider these techniques. Therefore, in general, we believe our analysis to be unaffected by most benign obfuscation mechanisms.