Java's robust security model and versatile features make it an ideal foundation for developing agent systems. Java adheres to a sandbox security model, which isolates memory and method access, ensuring mutually exclusive execution domains. The language enforces strong type safety through various mechanisms, including static type checking (byte code verification) to ensure the safety of downloaded code, as well as dynamic checks during runtime. Untrusted downloaded code is maintained in a distinct namespace, with inter-module references restricted to public methods. A security manager acts as a reference monitor, mediating all accesses to system resources.

Authorized licensed use limited to: Tsinghua University. Downloaded on March 25, 2021, at 07:07:44 UTC from IEEE Xplore. Restrictions apply.

A Java compiler generates byte codes for an abstract machine known as the Java Virtual Machine (JVM), which interprets these codes for the host computer. Multiple JVMs can operate simultaneously on a single host. Typically, a single JVM supports the execution environment for multiple agents (e.g., Aglets [6]), each running as an independent thread, rather than using multiple JVMs (e.g., Nomads [7]). The dynamic class loading and method invocation features of the JVM provide a simple yet effective way to support agent platform extensions.

Another feature supported by Java is the Java Archive (JAR) file format, which is based on the widely used ZIP archive format. JAR files are useful for managing collections of Java class files and resources, making them a convenient way to package an agent’s classes for initial distribution and subsequent movement among visited platforms. The contents of JAR files can be signed for authentication and integrity protection, enhancing the security and management of an agent’s code. Java also supports a password-protected key store, which contains private keys and their associated digital certificates, used for signing JAR files.

**Figure 5: A Java-based agent system with enhancements**

Java provides a system-wide policy file and an optional user policy file, along with tools for specifying other policies. Each entry in a policy file indicates the set of permissions authorized for code from a specified source. Policy rules are expressed using a grant-style specification language, where all permissions are denied unless explicitly assigned to a code source. Permissions represent authorized actions on system objects. The loader uses these permissions to manage the namespace and form a protection domain for any loaded code. Actions attempted by the code are checked against the domain permissions via the security manager. In addition to standard Java permissions, developers can define application-specific permissions.

**Figure 5** illustrates a Java-based mobile agent system and the necessary enhancements to enable processing of privilege management certificates. Each policy-setting principal, as a certificate issuer, must hold a cryptographic public key pair for certificate signing. In a Java-based agent system, this requirement results in a key store entry for each principal. The following sections discuss the implementation of these enhancements in detail.

### 3.1 Policy Certificates

In a Java-based agent system, the agent platform is a specialized application that runs on the JVM. Rather than inventing a new solution for policy specification and enforcement, these systems typically rely on the security policy mechanism provided by the JVM via the standard Java policy files. To capture existing policy information, the issuer of a policy certificate can encapsulate the relevant Java policy files within the certificate. Besides encapsulated policy files, the policy certificate conveys additional policy information related to policy-setting principals and permissions conveyed externally with agents.

To illustrate the kind of information useful in policy processing, the following features were included in the policy certificate:
- The ability to specify a policy hierarchy based on the class of policy-setting principal.
- The ability to govern certificate occurrence.
- The ability to stratify permissions into mutually exclusive sets controlled by each class of policy-setting principal.
- The ability for non-hosting principals to both lower and raise privileges.

The policy hierarchy specification was augmented with the ability to set the minimum and maximum occurrences of each type of certificate. This information allows the policy engine to determine whether an agent has sufficient certificates to begin processing and the order in which to apply the policy rules. For example, the hierarchy specification "Hosting1 > Using0 > Branding1" indicates that policies issued by hosting principals dominate those issued by using principals, which in turn dominate policies issued by branding principals. The subscripts and superscripts denote the minimum and maximum certificate occurrences for the class of principal. Therefore, every agent instance may have zero or one certificate issued by a using principal and exactly one certificate issued by a branding principal.

The policy hierarchy specification is conveyed in the "extensions" element of the policy certificate. Hosting principals, by default, dominate other policy-setting principals in the policy hierarchy to maintain control over their computational resources. However, hosting principals can perform selective allocation of privilege adjustment to other policy-setting principals through a sparse authorization matrix (principals x permissions) within the "attributes" element of the policy certificate. Each class of policy-setting principal can be granted rights to raise or lower an indicated permission. If that right is withheld, any unauthorized attempts to adjust the permission are ignored, and a security notification is issued.

The current version of Java includes features that allow controlled modification and extension of the runtime environment. These features include the ability to define new security properties, specify a replacement class for the standard policy class, define new permissions, and place trusted code in a directory where it is treated as part of the virtual machine for class loading and operations. By replacing the standard policy class, a new policy certificate-aware handler can be instantiated during JVM initialization. By defining new security properties, the handler can locate, validate, and translate the appropriate policy certificates into an internal form suitable for processing by the policy engine. By defining a new permission, the ability to adjust permissions can be controlled through a standard policy entry. Finally, by locating privilege management components within the virtual machine directory for trusted extensions, they obtain complete access to system-level resources.

Java policy is inherently platform-centric. Standard policy rules do not account for any policy-setting principals except those associated with the platform, such as the system administrator and home user, who are often synonymous. Under the grant-styled policy mechanism of Java, the most direct means of having external policy rules associated with an agent accepted and incorporated at a platform is to define a permission that allows the granting of those external permissions. Such a privilege-adjustment permission allows a platform to control the privilege not only with respect to a code source but also with respect to a specific set of policy-setting principals who issue one or the other variant of an attribute certificate. The information conveyed in the privilege-adjustment permission complements the more detailed information within the policy certificate regarding the specific permissions a class of policy-setting authority can adjust. Granting a privilege-adjustment permission to an agent opens the doorway to the room where specific permission adjustments may occur.

The form of the privilege-granting permission we used begins with its name, "privilegeAdjustment," followed by the key store aliases of the permitted certificate issuers (represented by "*"), and completed by either of the actions, "sealedBy" for branding principals or "launchedBy" for using principals. In simple terms, the permission grants an agent’s code source the right to gain the privileges expressed within an attribute certificate issued by some policy-setting principal to either the agent or an instance of the agent. For example, to permit any agent’s code base, sealed by a trusted reviewer (i.e., the enterprise security officer (ESO)) and launched by any trusted user (i.e., one having an entry in the key store), to adjust its platform privileges, the Java policy rule would be:

```java
Grant {
    Permission privilegeAdjustment "*", "sealedBy";
    Permission privilegeAdjustment "ESO", "launchedBy";
};
```

Thus, the standard Java policy mechanisms can be extended in a manner suitable for meeting the security policy requirements of most agent systems. Implementing the scheme as described does not affect the syntax or structure of Java policy files, which remain the primary means for expressing platform policy. Instead of replacing policy files, policy certificates incorporate their contents through reference. This approach allows policy certificates to be issued to any standard Java policy file by a policy-setting principal in the same manner as attribute certificates are issued to an agent—via a cryptographic hash of the contents of the policy file.

### 3.2 Attribute Certificates

An attribute certificate is an external XML representation of the policy rules assigned to an agent. In a Java environment, the policy is represented as standard Java permissions conveyed within the "attributes" element of the attribute certificate. The responsibility for maintaining relevant attribute certificates with an agent as it moves among platforms falls to the agent system. Java-based mobile agent systems usually allow the movement of mobile code as either individual class files or a JAR file. Because JAR files are the prescribed means within the Java framework for signing and verifying code, most security-conscious designers incorporate them into the agent system. In addition to the archived code, a signed JAR file contains a pair of files—a signature instruction and a digital signature file—for each signer of one or more of the files contained in the archive. These files are maintained in a special directory, the META-INF directory. Additional meta-information, such as the identity certificates of the entity that signed the code, may also be included within the META-INF directory to facilitate the verification and processing of the JAR contents by a recipient.

Due to its flexibility for conveying meta-information, an agent’s JAR file also makes a suitable container for attribute certificates issued to the agent. Once the agent's code resides within the JAR, it can be cryptographically bound to the certificate, which is placed within the META-INF directory for subsequent use. Multiple policy-setting principals can be accommodated to support policies involving multiple principals. It is important not to confuse the standard Java security features regarding signed JAR files with those of attribute certificates. In principle, they are distinct and can be applied either individually or jointly. The described JAR extensions follow this principle. However, some redundancy exists in situations where a branding principal issues an attribute certificate for an agent.