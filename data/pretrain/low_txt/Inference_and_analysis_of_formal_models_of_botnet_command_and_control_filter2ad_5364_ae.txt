### Experiment and Parallelization

The experiment does not parallelize perfectly due to the increased load on the same Tor servers. We envision that a more powerful, possibly highly-distributed, protocol inference infrastructure would parallelize more effectively.

To verify the accuracy of our models, we used an error probability (ε) of 10^-2 and a confidence factor (γ) of 10^-6 [3]. Achieving this level of accuracy required us to generate at least 1,798 uniformly random sampling queries for the MegaD C&C and 1,451 for MegaD and Postfix’s SMTP upon L* termination. Equivalence queries were executed in parallel and cached but not predicted, as predicting these queries would undermine their purpose (detecting missed states and prediction errors).

### Analysis of Critical Links

Attempts to dismantle large botnets are frequent but often costly and ineffective. The common practice is to run as many pools of bots as possible to cover a wide range of C&C servers, and then attempt to disable the entire botnet by simultaneously sending abuse notifications to all involved ISPs. This is an expensive exercise requiring careful coordination among all parties. Based on our analysis of critical links in the MegaD protocol, we discovered a less expensive alternative.

Using the technique explained in Section 5.1, we inferred complete models of communication with MegaD’s two different master servers and computed a projection of one model onto the alphabet of the other model, as shown in Figure 6. The figure illustrates the shared states and links between two different pools of bots communicating with different master servers. The projection reveals that the SMTP server is shared across these pools. Furthermore, the existence of the SMTP server is critical for MegaD's spamming capabilities. Specifically, a successful pre-spam notification dialog with the shared SMTP server (the NOTIFY:SS/SS:NOTIFY_RECVED edge) signals the bot to start spamming. We experimentally confirmed that MegaD bots do not initiate spamming without this notification. Therefore, disabling the SMTP server would halt spamming in all bot pools sharing that server. However, without attempting an attack on the SMTP part of MegaD’s infrastructure, it is difficult to assess the practical utility of this insight. For example, botmasters could replace the SMTP servers and use master servers to update bots with new SMTP server locations.

### Analysis of Design Flaws

Having a complete model of MegaD’s C&C enabled us to check several properties on the inferred state machine. We found an unexpectedly short path through the state machine to obtaining templates from the template server.

During a normal spam cycle, a MegaD bot follows the path 0 → 16 → 14 → 8 → 12 → 13 to reach the spamming state 13. Upon reaching state 13, the bot sends a GET_COMMAND message, and the master server responds with the location of a chosen template server. The bot then sends a GET_TEMPLATE request to the template server, including a 16-byte bot identifier issued by the master server, and receives the templates as a response.

Our inferred C&C protocol model reveals multiple shorter paths to obtaining spam templates. The shortest path is 0 → 1, where the bot emulator bypasses the master server, directly contacts the template server with a random 16-byte identifier, and obtains the templates. We successfully exploited this design flaw to regularly obtain fresh spam templates.

Without knowing the botnet developer’s intentions, one might argue that this could be a "feature" rather than a "flaw." For instance, it might facilitate reconfiguration of the template server location. However, we rule out this possibility because the protocol uses an encryption-protected 16-byte identifier issued by the master server in the GET_TEMPLATE request. Since this identifier can be spoofed, it is clearly a flaw.

### Analysis of Background-Channels

Our analysis revealed that the template server behaves differently depending on whether the bot has communicated with the master server or not. If the bot only talks to the template server (Figure 7a) by sending a GET_TEMPLATE request, the template server responds with RENEW and sends the templates only after the second request. Conversely, if the bot communicates with the template server after a regular exchange with the master server, the template server immediately responds to the first GET_TEMPLATE request with spam templates. This difference indicates communication between the master and template servers, as shown in Figure 7b.

### Analysis of Implementation Differences

We cross-checked our inference results with the SMTP standard [23] and compared the inferred model with MegaD’s non-standard SMTP implementation. To test the standard SMTP inference, we set up a Postfix SMTP 2.5.5 server on Mac OS X 10.6.3 and ran our inference technique against the server using the standard set of 14 SMTP commands and input types from the SMTP specification [23], as shown in Figure 8c. Figure 8a shows the inferred protocol model, with all self-loop transition edges removed for clarity. As discussed in Section 6.1, the discrepancy is at most ε = 10^-2 with confidence γ = 10^-6.

Our evaluation of standard SMTP shows that the protocol model obtained from our inference technique is equivalent to the SMTP standard, with one implementation-specific deviation. We found and confirmed that the Postfix SMTP 2.5.5 implementation deviates from the SMTP standard by terminating a connection with response code ‘221’ when it receives email contents sent without a prior DATA command; the standard specifies keeping the connection open while returning ‘500’ to indicate an unrecognized command. We further evaluated our model by comparing it against the SMTP model inferred by Prospex [10]. We manually translated our inferred Mealy machine into Prospex’s representation (Moore machine). The comparison reveals that a number of edges are missing from the SMTP model that Prospex inferred. On inter-state transitions alone, our complete SMTP model specifies the behavior of ten edges that Prospex missed. For example, the behavior of sending email contents without prior HELO or EHLO is described in our model but not in [10]. These missing edges are highlighted in Figure 8a. Clearly, our technology can infer complete models, unlike previous work.

Our model completely captures the protocol and is smaller (5 states) than the incomplete Prospex model (10 states). There are two reasons for this. First, we use Mealy machines, which are more compact. Second, since we infer complete minimal machines, minimization of the state machine can be done thoroughly. For example, sending either HELO or EHLO from the initial state transits to a single state in our model instead of two different states.

We also compared MegaD’s non-standard SMTP using the same standard set of 14 SMTP commands and input types. The inferred MegaD non-standard SMTP protocol model is shown in Figure 8b. A comparison of Figures 8a and 8b shows a high degree of resemblance, with two major differences: (1) States 0 and 1 in Figure 8a are merged into a single state in Figure 8b, indicating that the usual SMTP dialog with MegaD’s SMTP server may occur without a prior HELO or EHLO. (2) The server abruptly closes the connection once it receives a data terminator ‘.’ without a prior DATA command. This result suggests that our protocol model inference technique can be applied to fingerprint and identify MegaD’s SMTP masquerading servers.

### Limitations

In this section, we highlight the limitations of our protocol model inference and analysis techniques and discuss possible directions for future work.

Currently, we make no effort to obfuscate and hide our probing traffic from the botmaster’s potential detection. Since our protocol inference approach generates a large number of probing queries to the botnet C&C servers, the botmaster could potentially detect our queries. The botmaster may react by changing the locations or protocol configurations of the C&C servers, thwarting our inference efforts.