以下是优化后的文本，使其更加清晰、连贯和专业：

---

### 参考文献

1. K. Lu, C. Song, T. Kim, and W. Lee, “UniSan: Proactive Kernel Memory Initialization to Eliminate Data Leakages,” in *Proceedings of the 23rd ACM Conference on Computer and Communications Security (CCS)*, Vienna, Austria, Oct. 2016.
2. G. C. Mateusz Jurczyk, “Bochspwn: Identifying 0-days via System-wide Memory Access Pattern Analysis,” in *Black Hat USA Briefings (Black Hat USA)*, Las Vegas, NV, Aug. 2013.
3. P. Wang, J. Krinke, K. Lu, G. Li, and S. Dodier-Lazaro, “How Double-Fetch Situations Turn into Double-Fetch Vulnerabilities: A Study of Double Fetches in the Linux Kernel,” in *Proceedings of the 26th USENIX Security Symposium (Security)*, Vancouver, BC, Canada, Aug. 2017.
4. M. Jurczyk and G. Coldwind, “Identifying and Exploiting Windows Kernel Race Conditions via Memory Access Patterns,” 2013, [https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/42189.pdf](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/42189.pdf).
5. I. Institute, “Exploiting Windows Drivers: Double-fetch Race Condition Vulnerability,” 2016, [http://resources.infosecinstitute.com/exploiting-windows-drivers-double-fetch-race-condition-vulnerability](http://resources.infosecinstitute.com/exploiting-windows-drivers-double-fetch-race-condition-vulnerability).
6. C. Cadar, V. G. abd Peter M. Pawlowski, D. L. Dill, and D. R. Engler, “EXE: Automatically Generating Inputs of Death,” in *Proceedings of the 13th ACM Conference on Computer and Communications Security (CCS)*, Alexandria, VA, Oct.–Nov. 2006.
7. C. Cadar, D. Dunbar, and D. Engler, “KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs,” in *Proceedings of the 8th USENIX Symposium on Operating Systems Design and Implementation (OSDI)*, San Diego, CA, Dec. 2008.
8. P. Godefroid, M. Y. Levin, and D. Molnar, “Automated Whitebox Fuzz Testing,” in *Proceedings of the 15th Annual Network and Distributed System Security Symposium (NDSS)*, San Diego, CA, Feb. 2008.
9. Y. Padioleau, J. L. Lawall, and G. Muller, “Understanding Collateral Evolution in Linux Device Drivers,” in *Proceedings of the 1st European Conference on Computer Systems (EuroSys)*, Leuven, Belgium, Apr. 2006.
10. D. A. Ramos and D. Engler, “Under-Constrained Symbolic Execution: Correctness Checking for Real Code,” in *Proceedings of the 24th USENIX Security Symposium (Security)*, Washington, DC, Aug. 2015.
11. B. Niu and G. Tan, “Modular Control-Flow Integrity,” in *Proceedings of the 2014 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)*, Edinburgh, UK, Jun. 2014.
12. C. Tice, T. Roeder, P. Collingbourne, S. Checkoway, Ælfar Erlingsson, L. Lozano, and G. Pike, “Enforcing Forward-Edge Control-Flow Integrity in GCC & LLVM,” in *Proceedings of the 23rd USENIX Security Symposium (Security)*, San Diego, CA, Aug. 2014.
13. J. McCarthy and J. Painter, “Correctness of a compiler for arithmetic expressions,” *Mathematical Aspects of Computer Science*, vol. 1, 1967.
14. L. de Moura and N. Bjorner, “Generalized, Efficient Array Decision Procedures,” Microsoft Research, Tech. Rep., Sep. 2009.
15. L. De Moura and N. Bjørner, “Z3: An Efficient SMT Solver,” in *Proceedings of the 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS’08)*, Berlin, Heidelberg, Mar. 2008.
16. M. Schwarz, D. Gruss, M. Lipp, C. Maurice, T. Schuster, A. Fogh, and S. Mangard, “Automated Detection, Exploitation, and Elimination of Double-Fetch Bugs using Modern CPU Features,” ArXiv e-prints, Nov. 2017.
17. M. Musuvathi, S. Qadeer, T. Ball, G. Basler, P. A. Nainar, and I. Neamtiu, “Finding and Reproducing Heisenbugs in Concurrent Programs,” in *Proceedings of the 8th USENIX Symposium on Operating Systems Design and Implementation (OSDI)*, San Diego, CA, Dec. 2008.
18. E. Yahav, “Verifying Safety Properties of Concurrent Java Programs Using 3-valued Logic,” in *Proceedings of the 28th ACM Symposium on Principles of Programming Languages (POPL)*, London, United Kingdom, Jan. 2001.
19. M. Abadi, C. Flanagan, and S. N. Freund, “Types for Safe Locking: Static Race Detection for Java,” *ACM Trans. Program. Lang. Syst.*, vol. 28, no. 2, pp. 207–255, Mar. 2006.
20. D. Grossman, “Type-safe Multithreading in Cyclone,” in *Proceedings of the 2003 ACM SIGPLAN International Workshop on Types in Languages Design and Implementation (TLDI ’03)*, 2003.
21. J. W. Voung, R. Jhala, and S. Lerner, “RELAY: Static Race Detection on Millions of Lines of Code,” in *Proceedings of the 15th European Software Engineering Conference (ESEC) / 13th ACM SIGSOFT Symposium on the Foundations of Software Engineering (FSE)*, Dubrovnik, Croatia, Sep. 2007.
22. D. Engler and K. Ashcraft, “RacerX: Effective, Static Detection of Race Conditions and Deadlocks,” in *Proceedings of the 19th ACM Symposium on Operating Systems Principles (SOSP)*, Bolton Landing, NY, Oct. 2003.
23. C. Flanagan and S. N. Freund, “RedCard: Redundant Check Elimination for Dynamic Race Detectors,” in *Proceedings of the 27th European Conference on Object-Oriented Programming (ECOOP’13)*, 2013.
24. M. D. Bond, M. Kulkarni, M. Cao, M. Zhang, M. Fathi Salmi, S. Biswas, A. Sengupta, and J. Huang, “OCTET: Capturing and Controlling Cross-thread Dependences Efficiently,” in *Proceedings of the 24th Annual ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)*, Indianapolis, IN, Oct. 2013.
25. Y. Yu, T. Rodeheffer, and W. Chen, “RaceTrack: Efficient Detection of Data Race Conditions via Adaptive Tracking,” in *Proceedings of the 20th ACM Symposium on Operating Systems Principles (SOSP)*, Brighton, UK, Oct. 2005.
26. D. Rhodes, C. Flanagan, and S. N. Freund, “BigFoot: Static Check Placement for Dynamic Race Detection,” in *Proceedings of the 2017 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)*, Barcelona, Spain, Jun. 2017.
27. L. De Moura and N. Bjørner, “Satisfiability Modulo Theories: Introduction and Applications,” *Communications of the ACM*, vol. 54, no. 9, pp. 69–77, Sep. 2011.
28. J. Burnim and K. Sen, “Heuristics for Scalable Dynamic Test Generation,” University of California at Berkeley, Tech. Rep., Sep. 2008.
29. E. Reisner, C. Song, K.-K. Ma, J. S. Foster, and A. Porter, “Using Symbolic Evaluation to Understand Behavior in Configurable Software Systems,” in *Proceedings of the 32nd International Conference on Software Engineering (ICSE)*, Cape Town, South Africa, May 2010.
30. V. Chipounov, V. Kuznetsov, and G. Candea, “S2E: A Platform for In-Vivo Multi-Path Analysis of Software Systems,” in *Proceedings of the 16th ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)*, Newport Beach, CA, Mar. 2011.
31. D. Babić, L. Martignoni, S. McCamant, and D. Song, “Statically-directed dynamic automated test generation,” in *Proceedings of the International Symposium on Software Testing and Analysis (ISSTA)*, Toronto, Canada, Jul. 2011.
32. L. Martignoni, S. McCamant, P. Poosankam, D. Song, and P. Maniatis, “Path-exploration lifting: Hi-fi tests for lo-fi emulators,” in *Proceedings of the 17th ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)*, London, UK, Mar. 2012.
33. M. J. Renzelmann, A. Kadav, and M. M. Swift, “SymDrive: Testing Drivers Without Devices,” in *Proceedings of the 10th USENIX Symposium on Operating Systems Design and Implementation (OSDI)*, Hollywood, CA, Oct. 2012.
34. K. Lu, M.-T. Walter, D. Pfaff, S. Nürnberg, W. Lee, and M. Backes, “Unleashing Use-Before-Initialization Vulnerabilities in the Linux Kernel Using Targeted Stack Spraying,” in *Proceedings of the 2017 Annual Network and Distributed System Security Symposium (NDSS)*, San Diego, CA, Feb.–Mar. 2017.
35. S. Y. Kim, S. Lee, I. Yun, W. Xu, B. Lee, Y. Yun, and T. Kim, “CAB-Fuzz: Practical Concolic Testing Techniques for COTS Operating Systems,” in *Proceedings of the 2017 USENIX Annual Technical Conference (ATC)*, Santa Clara, CA, Jul. 2017.

---

### 附录：复杂的符号检查示例

图7展示了一个更为复杂的示例，以说明DEADLINE的符号执行过程。具体来说，该示例展示了DEADLINE的两个特性：
- 循环展开：两个`while`循环各展开一次，这在符号执行跟踪中反映为第9-16行和第22-35行（图7c）。
- 指针解析：在DEADLINE的内存模型中，如果DEADLINE能够证明两个指针值相同，则它们应该指向同一个对象，这在第20行（图7c）中得到体现。

此外，该示例还表明，尽管开发人员通常会采取预防措施来防止双重获取漏洞（例如，在第36行添加健全性检查），但这些检查可能并不充分，如第28行（图7c）所示。

```
// 第一批获取
if (get_user(ucmlen, &ucmsg->cmsg_len))
    tmp = ucmlen + sizeof(struct cmsghdr)
          - sizeof(struct compat_cmsghdr);
}
return -EFAULT;
kcmlen += tmp;
ucmsg = (char *)ucmsg + ucmlen;

// 计算消息长度
kcmlen = 0;
ucmsg = kmsg->msg_control;
while (ucmsg != NULL) {
    // 省略代码
}

// 复制整个消息
kcmsg = kbuf;
ucmsg = kmsg->msg_control;
while (ucmsg != NULL) {
    // 省略代码
}
```

```
// 初始化根SR
$0 = $PARM(0),
$1 = $PARM(1),

// 准备第一批获取
$2 = $PARM(0),
$3 = $PARM(1),

// 展开第一个循环
assert $2 != NULL
fetch(F1) is {A = $3 + 0, S = 4}
$4 = @3(0, 3, U0),
$5 = $4 - 12 + 16,
$6 = $2 + $5,
$7 = $3 + $4,
assert $7 == NULL (i.e., @7 = nil)

// 准备第二批获取
$8 = $PARM(0),
$9 = $PARM(1),

// 展开第二个循环
assert $9 != NULL
fetch(F2) is {A = $9 + 0, S = 4}
$10 = @3(0, 3, U1),
$11 = $10 - 12 + 16,
assert $1 + $6 - $8 >= $11

fetch(F3) is {A = $9 + 12, S = $10 - 12}
@8(12, $10 - 13, K) = @3(12, $10 - 13, U0)
$12 = $8 + $11,
$13 = $9 + $10,
assert $13 == NULL (i.e., @13 = nil)

// 检查获取重叠
assert F2.A 与 @3(0, 3, U) 可满足
assert F3.A 不可满足

// 检查双重获取漏洞
prove @3(0, 3, U0) == @3(0, 3, U1)
// --> 失败，因为 @3(0, 3, U0) >= @3(0, 3, U1)
```

(a) C源代码
(b) 内存访问模式
(c) 符号表示和检查

图7：`cmsghdr_from_user_compat_to_kern`中的一个双重获取漏洞，展示了如何符合双重获取漏洞的正式定义（图7b），以及DEADLINE的符号引擎如何找到它（图7c）。

---

### 循环展开

静态获取所有路径在程序包含无界循环时是不可能的。即使对于具有固定边界的循环，探索所有路径也是低效的。因此，我们对每个循环进行n次展开（n是可配置的），以尽可能覆盖更多的运行时路径。算法4展示了如何在CFG中展开循环。在合并过程中：对于CFG中的每个循环，如果没有嵌入的循环，我们将循环内的所有指令合并为一个节点，从而将CFG简化为有向无环图（DAG），在DAG中可以直接获取所有路径。展开过程接受DAG中的路径，并递归地展开循环节点n次，直到路径上没有循环节点。尽管这个展开算法很简单，但它被证明是高效且有效的。

---