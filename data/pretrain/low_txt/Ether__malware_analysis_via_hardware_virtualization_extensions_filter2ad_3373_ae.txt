# Effectiveness and Performance of Sandboxing Environments

## 5.2 Coarse-Grained Tracing: System Calls

In contrast to automated unpacking, system call tracing is a more coarse-grained method. It involves monitoring discrete system calls, which represent easily identifiable actions such as file and registry access, process and thread creation, and network activity. System call behavior is valuable for malware analysis because it can help identify malware startup mechanisms, command and control channels, and access to or theft of sensitive information.

### 5.2.1 Effectiveness

To evaluate Ether's ability to perform coarse-grained tracing, we developed EtherTrace, a tool for tracing Windows native API functions, which are the Windows equivalent of Unix system calls.

#### Evaluation Method

To assess the completeness of EtherTrace's functionality, we created a synthetic sample that performs a set of file and registry operations. These operations were chosen because they map directly to the Windows native API, making it easy to confirm EtherTrace's ability to perform successful tracing. To determine how EtherTrace would perform against modern malware, we packed our synthetic sample with the 15 most popular obfuscation tools identified from our malware survey. We compared EtherTrace against Anubis and Norman Sandbox; the results are presented in Table 2.

#### Results

To confirm that EtherTrace successfully traced a given sample, we ran the sample in the guest environment and inspected the generated trace logs. For testing Anubis and Norman Sandbox, we uploaded the samples to their web submission forms and examined the output. The results showed that all samples performed either all or none of the expected file and registry operations.

The results indicate that Armadillo, which is quite popular in current malware, provides strong anti-analysis protections and detected both Anubis and Norman Sandbox. Besides Armadillo, Anubis failed to trace tElock, which crashed after reporting failure of an internal CRC check. The reasons for Anubis' failure to trace ASProtect and Norman Sandbox's failure to trace yoda’s Protector are unclear.

In contrast, EtherTrace successfully traced all samples.

### 5.2.2 Performance

As a final experiment, we measured the performance of EtherTrace's system call tracing where return values are not needed. This type of tracing can serve as input to a wide variety of applications, ranging from host-based intrusion detection systems to file and registry access monitors. To perform our tests, we selected two tools: PCMark '05, an industry-standard benchmarking application, and WinRAR 3.71.

Using PCMark '05, we performed a standard series of tests provided by the application. To test using WinRAR, we compressed every file in the Program Files directory of a default Windows XP installation. The results of the testing appear in Table 3.

Tracing, as expected, adds extra latency to system calls. Benchmarks that are sensitive to latency, such as web browsing, incur a higher performance penalty. However, the majority of this latency is due to notification of the Ether userspace component; a full in-hypervisor implementation would have much lower latencies. Even in the current implementation, system calls that require I/O access are relatively unaffected by the extra latency.

## 6. Conclusion

In this paper, we presented Ether, a transparent and external malware analyzer based on hardware virtualization extensions such as Intel VT. Ether does not induce any unconditionally detectable side effects by completely residing outside of the target OS environment, making it undetectable by malware. In our experiments, we evaluated Ether and several other state-of-the-art analyzers on the obfuscation techniques used to obfuscate 25,000 recent malware samples. The results show that Ether remains transparent and defeats the obfuscation tools that evade existing approaches.

In future work, we will focus on improving resistance to timing attacks and memory hierarchy detection attacks.

## 7. Acknowledgments

The authors would like to thank Jonathon Giffin and Jon Larimer for their insightful feedback. Additional thanks go to Robert Edmonds for his assistance in performing the malware survey and CERT-LEXSI for providing us with the in-the-wild malware sample that checks for the presence of emulated hardware.

This material is based upon work supported in part by the National Science Foundation under Grant No. 0716570 and the Department of Homeland Security under Contract No. FA8750-08-2-0141. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the National Science Foundation and the Department of Homeland Security.

## 8. References

[1] Anubis: Analyzing Unknown Binaries. http://anubis.seclab.tuwien.ac.at.
[2] Armadillo. http://www.siliconrealms.com.
[3] BitBlaze Binary Analysis Platform. http://bitblaze.cs.berkeley.edu.
[4] DYNINST API. http://www.dyninst.org.
[5] FileMon for Windows. http://technet.microsoft.com/en-us/sysinternals/bb896642.aspx.
[6] Intel Virtualization Technology. http://www.intel.com/technology/virtualization.
[7] PEiD. http://www.peid.info.
[8] PEiDSO. http://handlers.sans.org/jclausing/userdb.txt.
[9] RegMon for Windows. http://technet.microsoft.com/en-us/sysinternals/bb896652.aspx.
[10] Themida. http://www.oreans.com/themida.php.
[11] VirtualPC. http://www.microsoft.com/windows/products/winfamily/virtualpc/.
[12] VMWare. http://www.vmware.com.
[13] Norman Sandbox Whitepaper. http://www.norman.com/documents/wp_sandbox.pdf, 2003.
[14] AMD64 Architecture Programmer’s Manual, Volume 2: System Programming, 2007.
[15] TEMU: The BitBlaze Dynamic Analysis Component. http://bitblaze.cs.berkeley.edu/temu.html, 2007.
[16] P. Bacher, T. Holz, M. Kotter, and G. Wicherski. Know your enemy: Tracking botnets. http://www.honeynet.org/papers/bots, 2005.
[17] M. Bailey, J. Oberheide, J. Andersen, Z. M. Mao, F. Jahanian, and J. Nazario. Automated Classification and Analysis of Internet Malware. In RAID, 2007.
[18] P. Barham, B. Dragovic, K. Fraser, S. Hand, T. Harris, A. Ho, R. Neugebauer, I. Pratt, and A. Warfield. Xen and the Art of Virtualization. In SOSP, pages 164–177, 2003.
[19] U. Bayer, C. Kruegel, and E. Kirda. TTanalyze: A Tool for Analyzing Malware. In EICAR, pages 180–192, 2006.
[20] F. Bellard. QEMU, a Fast and Portable Dynamic Translator. In ATEC, pages 41–41, 2005.
[21] M. Bishop. Computer Security: Art and Science. Addison-Wesley Professional, 2003.
[22] K. Borders, X. Zhao, and A. Prakash. Siren: Catching Evasive Malware (Short Paper). In S&P (Oakland), pages 78–85, 2006.
[23] J. Caballero, H. Yin, Z. Liang, and D. Song. Polyglot: Automatic Extraction of Protocol Message Format using Dynamic Binary Analysis. In CCS, 2007.
[24] M. Christodorescu, S. Jha, S. A. Seshia, D. Song, and R. E. Bryant. Semantics-Aware Malware Detection. In S&P (Oakland), pages 32–46, 2005.
[25] M. Christodorescu, C. Kruegel, and S. Jha. Mining Specifications of Malicious Behavior. In ESEC/FSE, pages 5–14, 2007.
[26] P. Ferrie. Attacks on Virtual Machine Emulators. Symantec Advanced Threat Research, 2006.
[27] P. Ferrie. Attacks on More Virtual Machines. http://pferrie.tripod.com/papers/attacks2.pdf, 2007.
[28] T. Garfinkel and M. Rosenblum. A Virtual Machine Introspection Based Architecture for Intrusion Detection. In NDSS, 2003.
[29] G. Hunt and D. Brubacher. Detours: Binary Interception of Win32 Functions. In WINSYM, pages 135–143, 1999.
[30] X. Jiang, X. Wang, and D. Xu. Stealthy Malware Detection Through VMM-Based "Out-of-the-Box" Semantic View Reconstruction. In CCS, pages 128–138, 2007.
[31] X. Jiang, D. Xu, H. J. Wang, and E. H. Spafford. Virtual Playgrounds for Worm Behavior Investigation. In RAID, pages 1–21, 2005.
[32] M. G. Kang, P. Poosankam, and H. Yin. Renovo: A Hidden Code Extractor for Packed Executables. In WORM, 2007.
[33] C. Kruegel, W. Robertson, and G. Vigna. Detecting Kernel-Level Rootkits Through Binary Analysis. In ACSAC, pages 91–100, 2004.
[34] L. Martignoni, M. Christodorescu, and S. Jha. OmniUnpack: Fast, Generic, and Safe Unpacking of Malware. In ACSAC, pages 431–441, 2007.
[35] F. Perigaud. New Pill? http://cert.lexsi.com/weblog/index.php/2008/03/21/223-new-pill, 2008.
[36] N. Provos and T. Holz. Virtual Honeypots: From Botnet Tracking to Intrusion Detection. Addison-Wesley Professional, Reading, 2007.
[37] T. Ptacek. Side-Channel Detection Attacks Against Unauthorized Hypervisors. http://www.matasano.com/log/930/side-channel-detection-attacks-against-unauthorized-hypervisors/, 2007.
[38] D. Quist and Valsmith. Covert Debugging: Circumventing Software Armoring. In Black Hat USA, 2007.
[39] T. Raffetseder, C. Kruegel, and E. Kirda. Detecting System Emulators. In ISC, pages 1–18, 2007.
[40] P. Royal, M. Halpin, D. Dagon, R. Edmonds, and W. Lee. PolyUnpack: Automating the Hidden-Code Extraction of Unpack-Executing Malware. In ACSAC, pages 289–300, 2006.
[41] M. Sipser. Introduction to the Theory of Computation. International Thomson Publishing, 1996.
[42] P. Szor. The Art of Computer Virus Research and Defense. Addison-Wesley Professional, 2005.
[43] A. Vasudevan and R. Yerraballi. Stealth Breakpoints. In ACSAC, pages 381–392, 2005.
[44] A. Vasudevan and R. Yerraballi. Cobra: Fine-grained Malware Analysis using Stealth Localized-executions. In S&P (Oakland), pages 264–279, 2006.
[45] C. Wang and S. Ju. The Dilemma of Covert Channels Searching. In ICISC, pages 169–174, 2005.
[46] Y.-M. Wang, D. Beck, X. Jiang, R. Roussev, C. Verbowski, S. Chen, and S. T. King. Automated Web Patrol with Strider HoneyMonkeys: Finding Web Sites That Exploit Browser Vulnerabilities. In NDSS, 2006.
[47] C. Willems, T. Holz, and F. Freiling. Toward Automated Dynamic Malware Analysis Using CWSandbox. IEEE Security and Privacy, 5(2), 2007.
[48] H. Yin, D. Song, M. Egele, C. Kruegel, and E. Kirda. Panorama: Capturing system-wide information flow for malware detection and analysis. In CCS, 2007.

## Appendix

### A. QEMU Detection Code

```c
#include <stdio.h>
#include <windows.h>
#include <excpt.h>

int seh_handler(
    struct _EXCEPTION_RECORD *exception_record,
    void *established_frame,
    struct _CONTEXT *context_record,
    void *dispatcher_context)
{
    printf("Not QEMU!\n");
    exit(0);
}

int main(int argc, char *argv[])
{
    uint32_t handler = (uint32_t)seh_handler;
    printf("Attempting detection\n");

    __asm {
        mov eax, handler
        push eax
        push fs:[0]
        mov fs:[0], esp
        .byte 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0x90
        mov eax, esp
        mov fs:[0], eax
        add esp, 8
    }

    printf("QEMU Detected!\n");
    return EXIT_SUCCESS;
}
```

This code snippet demonstrates a simple method to detect if the code is running inside a QEMU emulator. If the code runs without crashing, it prints "QEMU Detected!"; otherwise, it prints "Not QEMU!" and exits.