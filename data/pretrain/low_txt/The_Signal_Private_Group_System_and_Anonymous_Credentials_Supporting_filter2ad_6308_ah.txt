### References

- **[CHK+11]** Jan Camenisch, Kristiyan Haralambiev, Markulf Kohlweiss, Jorn Lapon, and Vincent Naessens. "Structure Preserving CCA Secure Encryption and Applications." In *ASIACRYPT 2011*, edited by Dong Hoon Lee and Xiaoyun Wang, volume 7073 of LNCS, pages 89–106. Springer, Heidelberg, December 2011.
  
- **[CL03]** Jan Camenisch and Anna Lysyanskaya. "A Signature Scheme with Efficient Protocols." In *SCN 2002*, edited by Stelvio Cimato, Clemente Galdi, and Giuseppe Persiano, volume 2576 of LNCS, pages 268–289. Springer, Heidelberg, September 2003.

- **[CL04]** Jan Camenisch and Anna Lysyanskaya. "Signature Schemes and Anonymous Credentials from Bilinear Maps." In *CRYPTO 2004*, edited by Matthew Franklin, volume 3152 of LNCS, pages 56–72. Springer, Heidelberg, August 2004.

- **[CMZ14]** Melissa Chase, Sarah Meiklejohn, and Greg Zaverucha. "Algebraic MACs and Keyed-Verification Anonymous Credentials." In *ACM CCS 2014*, edited by Gail-Joon Ahn, Moti Yung, and Ninghui Li, pages 1205–1216. ACM Press, November 2014.

- **[CPZ19]** Melissa Chase, Trevor Perrin, and Greg Zaverucha. "The Signal Private Group System and Anonymous Credentials Supporting Efficient Verifiable Encryption." *Cryptology ePrint Archive*, Report 2019/1416, 2019. [https://eprint.iacr.org/2019/1416](https://eprint.iacr.org/2019/1416).

- **[CS97]** J. Camenisch and M. Stadler. "Proof Systems for General Statements about Discrete Logarithms." *Technical Report TR 260*, Institute for Theoretical Computer Science, ETH Zürich, 1997.

- **[CS03]** Jan Camenisch and Victor Shoup. "Practical Verifiable Encryption and Decryption of Discrete Logarithms." In *CRYPTO 2003*, edited by Dan Boneh, volume 2729 of LNCS, pages 126–144. Springer, Heidelberg, August 2003.

- **[Cv91]** David Chaum and Eugène van Heyst. "Group Signatures." In *EUROCRYPT’91*, edited by Donald W. Davies, volume 547 of LNCS, pages 257–265. Springer, Heidelberg, April 1991.

- **[CV02]** Jan Camenisch and Els Van Herreweghen. "Design and Implementation of the Idemix Anonymous Credential System." In *ACM CCS 2002*, edited by Vijayalakshmi Atluri, pages 21–30. ACM Press, November 2002.

- **[DKPW12]** Yevgeniy Dodis, Eike Kiltz, Krzysztof Pietrzak, and Daniel Wichs. "Message Authentication, Revisited." In *EUROCRYPT 2012*, edited by David Pointcheval and Thomas Johansson, volume 7237 of LNCS, pages 355–374. Springer, Heidelberg, April 2012.

- **[FS87]** Amos Fiat and Adi Shamir. "How to Prove Yourself: Practical Solutions to Identification and Signature Problems." In *CRYPTO’86*, edited by Andrew M. Odlyzko, volume 263 of LNCS, pages 186–194. Springer, Heidelberg, August 1987.

- **[GM17]** Matthew Green and Ian Miers. "Bolt: Anonymous Payment Channels for Decentralized Currencies." In *ACM CCS 2017*, edited by Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu, pages 473–489. ACM Press, October/November 2017.

- **[Hal17]** Harry Halpin. "NEXTLEAP: Decentralizing Identity with Privacy for Secure Messaging." In *Proceedings of the 12th International Conference on Availability, Reliability and Security (ARES’17)*, pages 92:1–92:10. ACM, 2017.

- **[HdVLA19]** Mike Hamburg, Henry de Valence, Isis Lovecruft, and Tony Arcieri. "The Ristretto Group." 2019. [https://ristretto.group/](https://ristretto.group/).

- **[IHD16]** Marios Isaakidis, Harry Halpin, and George Danezis. "UnlimitID: Privacy-Preserving Federated Identity Management Using Algebraic MACs." In *Proceedings of the 2016 ACM on Workshop on Privacy in the Electronic Society (WPES 2016)*, page 139–142, 2016.

- **[JY09]** David Jao and Kayo Yoshida. "Boneh-Boyen Signatures and the Strong Diffie-Hellman Problem." In *PAIRING 2009*, edited by Hovav Shacham and Brent Waters, volume 5671 of LNCS, pages 1–16. Springer, Heidelberg, August 2009.

- **[KBC97]** Hugo Krawczyk, Mihir Bellare, and Ran Canetti. "HMAC: Keyed-Hashing for Message Authentication." IETF Internet Request for Comments 2104, February 1997.

- **[LdV17]** Isis Agora Lovecruft and Henry de Valence. "HYPHAES: Social Secret Sharing." 2017. [https://patternsinthevoid.net/hyphae/hyphae.pdf](https://patternsinthevoid.net/hyphae/hyphae.pdf).

- **[Lun17]** Joshua Lund. "Encrypted Profiles for Signal Now in Public Beta." September 2017. [https://signal.org/blog/signal-profiles-beta/](https://signal.org/blog/signal-profiles-beta/).

- **[Mar14]** Moxie Marlinspike. "Private Group Messaging." May 2014. [https://signal.org/blog/private-groups/](https://signal.org/blog/private-groups/).

- **[NPR99]** Moni Naor, Benny Pinkas, and Omer Reingold. "Distributed Pseudo-Random Functions and KDCs." In *EUROCRYPT’99*, edited by Jacques Stern, volume 1592 of LNCS, pages 327–346. Springer, Heidelberg, May 1999.

- **[NR95]** Moni Naor and Omer Reingold. "Synthesizers and Their Application to the Parallel Construction of Pseudo-Random Functions." In *36th FOCS*, pages 170–181. IEEE Computer Society Press, October 1995.

- **[oST13]** National Institute of Standards and Technology. "Federal Information Processing Standards Publication: Digital Signature Standard (DSS)." July 2013. FIPS PUB 186-4.

- **[PS16]** David Pointcheval and Olivier Sanders. "Short Randomizable Signatures." In *CT-RSA 2016*, edited by Kazue Sako, volume 9610 of LNCS, pages 111–126. Springer, Heidelberg, February/March 2016.

- **[PZ13]** C. Paquin and G. Zaverucha. "U-Prove Cryptographic Specification v1.1 (Revision 2)." 2013. Available online: [www.microsoft.com/uprove](http://www.microsoft.com/uprove).

- **[RCE15]** Kai Rannenberg, Jan Camenisch, and Ahmad Sabouri (Editors). "Attribute-Based Credentials for Trust, Identity in the Information Society." Springer, 2015. [https://doi.org/10.1007/978-3-319-14439-9](https://doi.org/10.1007/978-3-319-14439-9).

- **[RMS17]** Paul Rösler, Christian Mainka, and Jörg Schwenk. "More is Less: How Group Chats Weaken the Security of Instant Messengers Signal, WhatsApp, and Threema." *Cryptology ePrint Archive*, Report 2017/713, 2017. [http://eprint.iacr.org/2017/713](http://eprint.iacr.org/2017/713).

- **[RS06]** Phillip Rogaway and Thomas Shrimpton. "Deterministic Authenticated-Encryption: A Provable-Security Treatment of the Key-Wrap Problem." *Cryptology ePrint Archive*, Report 2006/221, 2006. [http://eprint.iacr.org/2006/221](http://eprint.iacr.org/2006/221).

- **[RST01]** Ronald L. Rivest, Adi Shamir, and Yael Tauman. "How to Leak a Secret." In *ASIACRYPT 2001*, edited by Colin Boyd, volume 2248 of LNCS, pages 552–565. Springer, Heidelberg, December 2001.

- **[Sig19]** Signal. "Technical Information (Specifications and Software Libraries)." 2019. [https://www.signal.org/docs/](https://www.signal.org/docs/).

- **[ZYHW16]** Zhenfeng Zhang, Kang Yang, Xuexian Hu, and Yuchen Wang. "Practical Anonymous Password Authentication and TLS with Anonymous Client Authentication." In *ACM CCS 2016*, edited by Edgar R. Weippl, Stefan Katzenbeisser, Christopher Kruegel, Andrew C. Myers, and Shai Halevi, pages 1179–1191. ACM Press, October 2016.

### Ideal Functionality for a Private Group System

In this section, we define a secure private group system as an ideal functionality. The functionality, denoted \( F \), is a trusted party that implements the system and interacts with both honest and malicious users (the attacker) and either an honest or malicious server.

#### Definition of \( F \)

The definition of \( F \) has two cases, depending on whether the server is honest or malicious.

- **When the Server is Honest (S):** 
  - All (honest) protocols are initiated by a user, and their UID (denoted \( \text{uid} \)) is sent to \( F \).
  - The ideal functionality shares information with a potentially malicious server \( S^* \) and allows \( S^* \) to decide whether to deviate from the protocol. For example, \( S^* \) may reject valid requests or return incorrect information.
  - In Figure 2, we describe \( F \) when the server \( S \) is honest. The main goal is to ensure that malicious users cannot cause the server to perform unauthorized group operations, corrupt the state of honest groups, or learn about the operations and membership of honest groups.

- **When the Server is Malicious (S^*):**
  - There are two cases, depending on whether the relevant group contains a malicious user.
  - If the group contains a malicious user, then between the malicious user and \( S^* \), they know all secrets (credential issuer secret keys and group secret key) for that group, and can learn all group members and their profile keys. They can also modify the group arbitrarily. This case is trivial from a security perspective, as no security is possible.
  - If the group does not contain any malicious users, \( S^* \) can still deviate from the protocol in various ways (e.g., delete members from a group, reject requests to add a new user, etc.). However, these deviations should not allow \( S^* \) to learn the members of the group. Informally, the group should remain confidential if all users in it are honest. Some amount of integrity is possible since \( S^* \) does not know the group key and cannot add arbitrary users to the group.
  - By comparing Figures 2 and 3, we can see how \( S^* \) can deviate from the honest server behavior, depending on whether the group is corrupted. \( S^* \) can also abort a protocol at any time, which is not explicitly included in our description.

#### Setup and Notation

- **State in \( F \)** is maintained in hash tables.
- **Setup** initializes tables \( T_U \) and \( T_G \).
  - \( T_U \) is a table of users in the system. Each row \( T_U[\text{uid}] \) contains:
    - \( T_U[\text{uid}].\text{Times} \): a set of times at which \( \text{uid} \) can authenticate.
    - \( T_U[\text{uid}].\text{ProfileKeys} \): a set of profile keys currently associated with \( \text{uid} \).
    - \( T_U[\text{uid}].\text{corrupt} \): a flag indicating whether \( \text{uid} \) is a corrupt user.
  - \( T_G \) is a table of groups in the system. Each row \( T_G[\text{gid}] \) contains:
    - \( T_G[\text{gid}][\text{uid}_1], \ldots, T_G[\text{gid}][\text{uid}_n] \): a set of members indexed by UID, each with a profile key \( T_G[\text{gid}][\text{uid}].\text{ProfileKey} \) that is currently in use.
    - \( T_G[\text{gid}][\text{uid}].\text{ProfileKeyHistory} \): a list of all profile keys used in this group.
    - \( T_G[\text{gid}].\text{UIDHistory} \): a list of all current and past members.
    - \( T_G[\text{gid}].\text{corrupt} \): a flag indicating whether the group contains a corrupted user.
- The corrupt flags default to 1 (corrupted) since \( S^* \) may create groups without interacting with \( F \).
- The function `index()` returns the position of an element in a list, or \( \bot \) if the element is not in the list.
- Authentication credentials are valid for a time period, denoted \( t \), and when requesting credentials, users may request a set of times, denoted \( T \).

#### Comments on the Honest Server Case

- The function `AuthAsMember` is used as a subroutine by \( F \) in other functions and is not exposed to users.
- In `AuthAsMember`, a user with UID \( \text{uid} \) authenticates as a member of the group with GID \( \text{gid} \). We also define `AuthAsInvitedMember` as the same except the check that the profile key is not \( \bot \) is omitted.
- The lines ensure that `AuthAsMember(...)` returns an error if `AuthAsMember` fails (similarly for `AuthAsInvitedMember`).
- Honest users call `CommitToProfileKey` to register a new random profile key with \( F \). This models the fact that honest users choose random profile keys. Malicious users may commit to (or update) an arbitrary profile key using `CommitToAdvProfileKey`.
- The function `UpdateProfileKey` allows a user to update their own profile key in a specific group or allows an invited member to set their profile key.
- A user \( \text{uid} \), who is a member of the group \( \text{gid} \), can add another user \( \text{uid}' \) with `AddGroupMember`. Note that this will overwrite an invitation, should one exist, for \( \text{uid}' \).

#### Comments on the Malicious Server Case

- We do not allow \( S^* \) to add arbitrary \( K' \) to model issuing bad profile credentials, since \( S^* \) can maintain its own data structure and behave as if \( K' \in \text{ProfileKeys} \).
- When the user is honest, \( S^* \) only learns that `GetProfileCredential` was called and can decide whether to issue the credential.

### Example Functions

- **GetAuthCred(T) from uid:**
  - If \( T_U[\text{uid}] \) is not defined, return "Error: invalid user."
  - Query \( S \) to ensure \( T \) is valid for \( \text{uid} \).
  - If \( T \) is invalid for \( \text{uid} \), return "Error: invalid time(s)."
  - Append \( T \) to \( T_U[\text{uid}].\text{Times} \).
  - Return 1.

- **CreateGroup(gid, K, t) from uid:**
  - If \( T_U[\text{uid}] \) is not defined, return "Error: invalid user."
  - If \( T_G[\text{gid}] \) is defined, return "Error: group exists."
  - If \( K \notin T_U[\text{uid}].\text{ProfileKeys} \), return "Error: invalid profile key."
  - If \( t \notin T_U[\text{uid}].\text{Times} \), return "Error: expired credential."
  - Set \( T_G[\text{gid}][\text{uid}].\text{ProfileKey} = K \).
  - Append \( K \) to \( T_G[\text{gid}][\text{uid}].\text{ProfileKeyHistory} \).
  - Append \( \text{uid} \) to \( T_G[\text{gid}].\text{UIDHistory} \).
  - If \( T_U[\text{uid}].\text{corrupt} \):
    - Create a new random \( K \).
    - Add \( K \) to \( T_U[\text{uid}].\text{ProfileKeys} \).
    - Return \( K \).

- **GetProfileCredential(uid, K):**
  - If \( K \in T_U[\text{uid}].\text{ProfileKeys} \), return 1.
  - Return 0.

- **AuthAsMember(gid, t) from uid:**
  - If \( T_G[\text{gid}] \) is not defined, return "Error: gid doesn’t exist."
  - If \( T_G[\text{gid}][\text{uid}].\text{ProfileKey} = \bot \), return "Error: user invited, not added."
  - If \( T_G[\text{gid}][\text{uid}] \) is not defined, return "Error: User not in group."
  - If \( t \notin T_U[\text{uid}].\text{Times} \), return "Error: expired credential."

This structured and detailed approach ensures clarity and coherence in the text, making it more professional and easier to understand.