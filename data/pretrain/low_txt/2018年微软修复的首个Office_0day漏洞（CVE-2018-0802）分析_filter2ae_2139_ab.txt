### 优化后的文本

#### 堆栈跟踪与异常分析
以下是堆栈跟踪信息，显示了调用路径和异常情况：
- `0019ee2c 0138a72f EqnEdt32!MFEnumFunc+0xc0a3`
- `0019ee44 013875da EqnEdt32!MFEnumFunc+0xbf32`
- `0019eea8 0137f926 EqnEdt32!MFEnumFunc+0x8ddd`
- `0019eed8 01356a98 EqnEdt32!MFEnumFunc+0x1129`
- `0019ef3c 755a04e8 EqnEdt32!AboutMathType+0x5a98`
- `0019ef58 75605311 RPCRT4!Invoke+0x2a`
- `0019f360 75ddd7e6 RPCRT4!NdrStubCall2+0x2d6`
- `0019f3a8 75ddd876 ole32!CStdStubBuffer_Invoke+0xb6 [d:\w7rtm\com\rpc\ndrole\stub.cxx @ 1590]`
- `0019f3f0 75ddddd0 ole32!SyncStubInvoke+0x3c [d:\w7rtm\com\ole32\com\dcomrem\channelb.cxx @ 1187]`
- `0019f43c 75cf8a43 ole32!StubInvoke+0xb9 [d:\w7rtm\com\ole32\com\dcomrem\channelb.cxx @ 1396]`
- `0019f518 75cf8938 ole32!CCtxComChnl::ContextInvoke+0xfa [d:\w7rtm\com\ole32\com\dcomrem\ctxchnl.cxx @ 1262]`
- `0019f534 75cf950a ole32!MTAInvoke+0x1a [d:\w7rtm\com\ole32\com\dcomrem\callctrl.cxx @ 2105]`
- `0019f560 75dddccd ole32!STAInvoke+0x46 [d:\w7rtm\com\ole32\com\dcomrem\callctrl.cxx @ 1924]`
- `0019f594 75dddb41 ole32!AppInvoke+0xab [d:\w7rtm\com\ole32\com\dcomrem\channelb.cxx @ 1086]`
- `0019f674 75dde1fd ole32!ComInvokeWithLockAndIPID+0x372 [d:\w7rtm\com\ole32\com\dcomrem\channelb.cxx @ 1724]`
- `0019f69c 75cf9367 ole32!ComInvoke+0xc5 [d:\w7rtm\com\ole32\com\dcomrem\channelb.cxx @ 1469]`

**警告**：堆栈展开信息不可用。以下帧可能不准确。
- `0019ec58 cb ce cc e5 00`
- `0019eacc 013717c8 EqnEdt32!FMDFontListEnum+0xbc7`
- `0019ebc4 01371980 EqnEdt32!FMDFontListEnum+0x534`
- `0019ecec 0138b463 EqnEdt32!FMDFontListEnum+0x6ec`
- `0019eda8 7545a24c EqnEdt32!MFEnumFunc+0xcc66`
- `0019ee08 0136775e kernel32!GlobalUnlock+0xba`
- `0019ee14 0138a8a0 EqnEdt32!EqnFrameWinProc+0x8c7e`
- `0019ee2c 0138a72f EqnEdt32!MFEnumFunc+0xc0a3`
- `0019ee44 013875da EqnEdt32!MFEnumFunc+0xbf32`
- `0019eea8 0137f926 EqnEdt32!MFEnumFunc+0x8ddd`
- `0019eed8 01356a98 EqnEdt32!MFEnumFunc+0x1129`
- `0019ef3c 755a04e8 EqnEdt32!AboutMathType+0x5a98`
- `0019ef58 75605311 RPCRT4!Invoke+0x2a`
- `0019f360 75ddd7e6 RPCRT4!NdrStubCall2+0x2d6`
- `0019f3a8 75ddd876 ole32!CStdStubBuffer_Invoke+0xb6 [d:\w7rtm\com\rpc\ndrole\stub.cxx @ 1590]`
- `0019f3f0 75ddddd0 ole32!SyncStubInvoke+0x3c [d:\w7rtm\com\ole32\com\dcomrem\channelb.cxx @ 1187]`
- `0019f43c 75cf8a43 ole32!StubInvoke+0xb9 [d:\w7rtm\com\ole32\com\dcomrem\channelb.cxx @ 1396]`
- `0019f518 75cf8938 ole32!CCtxComChnl::ContextInvoke+0xfa [d:\w7rtm\com\ole32\com\dcomrem\ctxchnl.cxx @ 1262]`
- `0019f534 75cf950a ole32!MTAInvoke+0x1a [d:\w7rtm\com\ole32\com\dcomrem\callctrl.cxx @ 2105]`
- `0019f560 75dddccd ole32!STAInvoke+0x46 [d:\w7rtm\com\ole32\com\dcomrem\callctrl.cxx @ 1924]`
- `0019f594 75dddb41 ole32!AppInvoke+0xab [d:\w7rtm\com\ole32\com\dcomrem\channelb.cxx @ 1086]`

**时间戳**：2017年12月26日 15:56:36.506（GMT+8）
- `ModLoad: 74f90000 74fdc000 C:\Windows\system32\apphelp.dll`

**时间戳**：2017年12月26日 15:56:36.584（GMT+8）
- `(304.784): Access violation - code c0000005 (first chance)`
- 第一次机会异常在任何异常处理之前报告。
- 此异常可能是预期并被处理的。

**寄存器状态**：
- `eax=00000021 ebx=0019ece8 ecx=0019ec24 edx=771470f4 esi=00000001 edi=00190001`
- `eip=01380c46 esp=0019ecd8 ebp=d32b8ac7 iopl=0 nv up ei pl nz na po nc`
- `cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010202`
- `EqnEdt32!MFEnumFunc+0x2449: 01380c46 c9 leave`

从日志中可以看到存在两次拷贝，通过栈回溯可以确定这两次拷贝是静态分析中对`sub_21174`的两次调用。第一次是`sub_214c6`对`sub_21174`的调用，第二次是`sub_21174`对自身的调用。第一次拷贝时明显发生了栈溢出。这里稍微提一下，`cb ce cc e5`代表的是宋体。

我们来详细计算一下需要溢出多少长度才能控制父函数(`sub_21174`)的返回地址。由图11可知，从`lfFaceName(-0x90)`溢出到`ret_addr(+0x4)`，一共需要`0x94`字节。超出`0x94`部分的字节会逐个从低地址开始覆盖返回地址。

对照POC中的数据来看，如图12所示，蓝色部分为溢出的前`0x94`字节，`25 00`为溢出的最后两个字节，`00`为终止符，拷贝时遇到`00`就停止。按照小端地址布局，POC运行时，EIP只会被覆盖低位的两个字节。这样做的目的是为了绕过ASLR。

#### 绕过ASLR
我们来看一下为什么区区两个字节就可以绕过ASLR。首先我们要清楚，补丁文件开启了ASLR，如图13所示。这样一来每次加载`EQNEDT32.EXE`时的基址都是随机的，所以溢出时需要考虑的第一个问题就是如何绕过ASLR。至于DEP，由图14可以看到，补丁文件的`EQNEDT32.EXE`未开启DEP，所以正常情况下无需考虑DEP。

不幸的是，攻击者显然对Windows系统机制和防御措施非常了解。因为在Windows平台上，32位进程的ASLR每次只随机化地址的高两个字节，而低两个字节保持不变。假如能在被覆盖的地址的同一片低`0xFFFF`空间内找到一个`ret`指令，并且满足形如`0xABCD00XY`的这种地址（其中`ABCD`及`XY`为任意十六进制数，地址中倒数第二个字节必须为`0x00`，因为复制完后需要精确截断），就可以直接利用这个`ret`跳转到栈上。由于无需绕过DEP，所以可以在栈上直接执行shellcode。

更加不幸的是，在`EQNEDT32.EXE`模块内，微软确实提供了一个满足条件的地址（图15），即`20025`，EIP中被覆盖的两个字节`25 00`是唯一的，没有第二个满足条件的`ret`。

我们来思考一下`sub_21174`原来的返回地址是什么？当然是`sub_214C6`调用`sub_21174`的下一条指令的地址，由图16可以看到这个地址的偏移为`214E2`。按照图12的覆盖方式，覆盖后的偏移变成了`20025`，由上面的分析及图17中可以看到，这个地址是一条`ret`指令。这条指令会弹出`sub_214C6`给`sub_21174`的第一个参数，并且将控制流切换到这个值去执行。雪上加霜的是，这第一个参数恰好为`lpLogFont`，正是用户所提供的`FontName`。所以`ret`执行后，控制流会被转移到栈上，并且恰好开始执行用户提供的`FontName`的第一个字节。

#### 样本A的Shellcode分析
在针对样本A改造的POC中，控制流劫持及shellcode部分的执行如图18所示：
- 由于递归的存在，从`sub_21774`函数中需要返回两次，这解释了前两个`ret jmp eax`指令后会马上调用`WinExec`，而命令行参数恰好为`calc.exe`，如图19所示。

#### 样本B的Shellcode分析
样本B绕过ASLR的方式和样本A一致，但shellcode部分与样本A不一样。样本B的shellcode会通过PEB找到`kernel32.dll`的导出表（图20和图21），然后通过特定的哈希算法（图21）在导出表中搜索所需函数的哈希值。所需函数的哈希值在shellcode中给出。随后，shellcode会将查找到的函数地址保存到之前存放哈希值的地方（图22）。

在成功查找到函数并且将地址保存到栈上后，先调用`ExpandEnvironmentStringsA`函数展开短路径（短路径保存在shellcode中），再调用`CopyFileA`将payload拷贝到Word插件目录下，从而让payload随着Word下次启动自动加载到内存。最后调用`ExitProcess`退出公式编辑器进程（图23）。整个过程并不影响文档的正常打开。

#### 总结
“噩梦公式二代”（CVE-2018-0802）所使用的0day漏洞堪称CVE-2017-11882的双胞胎漏洞。攻击样本中的一个漏洞针对未打补丁前的系统，另一个漏洞针对打补丁后的系统，利用两个OLE同时进行攻击，黑客精心构造的攻击完美兼容了系统漏洞补丁环境的不同情况。这个漏洞的利用技巧和绕过ASLR的方式都带有一定的巧合性，假如`EQNEDT32.EXE`模块内没有一条满足条件的`ret`指令可以用来绕过ASLR，假如`lpLogFont`不是`sub_21774`的第一个参数，假如CVE-2017-11882的补丁修复方式强制开启了DEP保护，“噩梦公式二代”将没有可乘之机。

最新的360安全产品已可以检测并防止此0day漏洞的攻击，同时我们建议用户及时更新2018年1月的微软安全补丁。

#### 参考
- 图11：栈溢出位置示意图
- 图12：POC中的数据布局
- 图13：`EQNEDT32.EXE`的ASLR状态为启用，DEP为非永久DEP
- 图14：`EQNEDT32.EXE`的DEP状态为停用
- 图15：满足条件的`ret`指令地址
- 图16：`sub_21174`的原始返回地址
- 图17：覆盖后的返回地址
- 图18：样本A的控制流劫持及shellcode执行
- 图19：`WinExec`调用
- 图20：样本B的shellcode中的哈希值及路径名称
- 图21：通过哈希值查找所需函数
- 图22：查找函数地址前后栈上数据的对比
- 图23：展开短路径，拷贝文件，退出进程