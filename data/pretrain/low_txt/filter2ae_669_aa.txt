**作者：天融信阿尔法实验室**
**原文链接：**

## 一、前言
在一次XSS测试中，我们尝试向可控参数中注入XSS Payload。发现目标服务将所有字母转换为大写。例如，输入`alert(1)`会被转换成`ALERT(1)`。除此之外，并没有其他限制。这时，我们了解到JavaScript可以执行无字母的语句，从而绕过这种限制来执行XSS Payload。

## 二、JavaScript基础
为了更好地理解如何利用无字母的JavaScript代码，我们先来看两段示例代码：

```javascript
([][[]]+[])[+!+[]]+([]+{})[+!+[]+!+[]]
([][[]]+[])[+!!~+!{}]+({}+{})[+!!{}+!!{}]
```

这两段代码都输出了字符串"nb"。下面我们将详细分析其工作原理。

### JavaScript运算符优先级
下表列出了JavaScript运算符的优先级，从高（20）到低（1）排列：

| 优先级 | 运算类型 | 关联性 | 运算符 |
| --- | --- | --- | --- |
| 20 | 圆括号 | n/a | ( … ) |
| 19 | 成员访问 | 从左到右 | … . … |
| 19 | 需计算的成员访问 | 从左到右 | … [ … ] |
| 19 | new (带参数列表) | n/a | new … ( … ) |
| 19 | 函数调用 | 从左到右 | … ( … ) |
| 19 | 可选链（Optional chaining） | 从左到右 | ?. |
| 18 | new (无参数列表) | 从右到左 | new … |
| 17 | 后置递增(运算符在后) | n/a | … ++ |
| 17 | 后置递减(运算符在后) | n/a | … -- |
| 16 | 逻辑非 | 从右到左 | ! … |
| 16 | 按位非 | 从右到左 | ~ … |
| 16 | 一元加法 | 从右到左 | + … |
| 16 | 一元减法 | 从右到左 | - … |
| 16 | 前置递增 | 从右到左 | ++ … |
| 16 | 前置递减 | 从右到左 | -- … |
| 16 | typeof | 从右到左 | typeof … |
| 16 | void | 从右到左 | void … |
| 16 | delete | 从右到左 | delete … |
| 16 | await | 从右到左 | await … |
| 15 | 幂 | 从右到左 | … ** … |
| 14 | 乘法 | 从左到右 | … * … |
| 14 | 除法 | 从左到右 | … / … |
| 14 | 取模 | 从左到右 | … % … |
| 13 | 加法 | 从左到右 | … + … |
| 13 | 减法 | 从左到右 | … - … |
| 12 | 按位左移 | 从左到右 | … << … |
| 12 | 有符号右移 | 从左到右 | … >> … |
| 12 | 无符号右移 | 从左到右 | … >>> … |
| 11 | 小于 | 从左到右 | … < … |
| 11 | 大于 | 从左到右 | … > … |
| 11 | 小于等于 | 从左到右 | … <= … |
| 11 | 大于等于 | 从左到右 | … >= … |
| 11 | in | 从左到右 | … in … |
| 11 | instanceof | 从左到右 | … instanceof … |
| 10 | 等号 | 从左到右 | … == … |
| 10 | 非等号 | 从左到右 | … != … |
| 10 | 全等号 | 从左到右 | … === … |
| 10 | 非全等号 | 从左到右 | … !== … |
| 9 | 按位与 | 从左到右 | … & … |
| 8 | 按位异或 | 从左到右 | … ^ … |
| 7 | 按位或 | 从左到右 | … | … |
| 6 | 逻辑与 | 从左到右 | … && … |
| 5 | 逻辑或 | 从左到右 | … || … |
| 4 | 条件运算符 | 从右到左 | … ? … : … |
| 3 | 赋值 | 从右到左 | … = … |
| 2 | yield* | 从右到左 | yield* … |
| 1 | 展开运算符 | n/a | ... … |
| 0 | 逗号 | 从左到右 | … , … |

### 分析示例代码
以第一段代码 `([][[]]+[])[+!+[]]+([]+{})[+!+[]+!+[]]` 为例，我们逐步解析其执行过程：

1. `([][[]]+[])`：
   - `[][[]]` 返回 `undefined`。
   - `undefined + []` 结果是 `"undefined"` 字符串。
   - `[+!+[]]` 中 `+!+[]` 计算结果为 `1`，因此 `[+!+[]]` 为 `["u"]`。
   - 最终 `("undefined")[1]` 返回 `"n"`。

2. `([]+{})[+!+[]+!+[]]`：
   - `[] + {}` 结果是 `"undefined"` 字符串。
   - `[+!+[]+!+[]]` 中 `+!+[]+!+[]` 计算结果为 `2`，因此 `[+!+[]+!+[]]` 为 `["d"]`。
   - 最终 `("undefined")[2]` 返回 `"b"`。

将两部分拼接起来，最终结果为 `"nb"`。

### JavaScript类型转换
在JavaScript中，当操作符两边的操作数类型不一致或者不是原始类型时，需要进行类型转换。JavaScript有五种原始类型：`Undefined`、`Null`、`Boolean`、`Number` 和 `String`。

- 乘号 (`*`)、除号 (`/`)、减号 (`-`) 会将操作数转换为 `Number` 类型进行数学运算。
- 加号 (`+`) 可能用于字符串拼接或数学运算，因此可能转换为 `Number` 或 `String` 类型。
- 取反 (`!`) 会将操作数转换为 `Boolean` 类型。
- 按位非 (`~`) 会将操作数转换为 `Number` 类型，然后取负再减1。

通过这些基本知识，我们可以更好地理解和编写无字母的JavaScript代码，以绕过某些安全限制。