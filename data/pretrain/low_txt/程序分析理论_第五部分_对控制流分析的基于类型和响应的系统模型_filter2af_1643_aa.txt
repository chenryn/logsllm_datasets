# 程序分析理论 第五部分：基于类型和响应的系统模型

## 译文声明
本文为翻译文章，仅供参考。具体内容及含义以原文为准。

## 前言
本篇是程序分析理论系列文章的第十一篇，主要探讨基于类型和响应的系统模型（Type and Effect Systems）。我们的目标是通过引入类型模型，在分析过程中触发响应模型，从而实现函数指向。

## 基于类型的系统模型 (Type System)

### 类型要素
基于类型的系统模型首先需要引入类型要素。这些要素包括布尔值（bool）、类型转换和整数（int）。

### 语法定义
我们分析的语句形式包括变量、布尔值（true/false）、表达式组合（e e）、函数（fn）、递归函数（fun）、并列语句（let in）等。具体语法如下：
- 常量：`c`
- 变量：`x`
- 函数：`fn_π x => e_0`
- 递归函数：`fun_π f x => e_0`
- 并列语句：`e_1 e_2`
- if 语句：`if e_0 then e_1 else e_2`
- 函数调用语句：`let x = e_1 in e_2`
- 判断语句：`e_1 op e_2`

其中，函数和递归函数中添加了断点 `π`。

### 类型判断
我们提出底层类型模型来实现类型判断。类型判断的表示形式为 `Γ |- e : t`，其中：
- `Γ` 表示类型环境
- `e` 表示抽象语句
- `t` 表示类型

具体规则如下：
- 任意常量 `c` 存在类型，如 `true : bool` 和 `7 : int`
- 对于任意判断语句，参数为 `int` 类型，结果为 `bool` 类型
- 具体规则应用到所有语句：
  - `Γ |- c : t_c`
  - `Γ |- x : t Γ(x) = t`
  - `Γ[x->t_x] |- e_0 : t_0 / Γ |- fn_π x=>e_0 : t_x -> t_0` （`x` 类型是 `t_x`，`e_0` 最后输出类型是 `t_0`）
  - `Γ[f -> t_x -> t_0][x->t_x] |- e_0 : t_0 / Γ |- fun_π f x=>e_0 : t_x -> t_0` （`x` 类型是 `t_x`，`e_0` 最后输出类型是 `t_0`，递归时 `f` 作为 `t_x` 进入以 `t_0` 输出）
  - `Γ |- e_1 : t_2 -> t_0 Γ |- e_2 : t_2 / Γ |- e_1 e_2 -> t_0` （`e_1` 将 `t_2` 类型转换成 `t_0`，`e_2` 是 `t_2` 类型。最后输出是 `t_0` 类型）
  - `Γ |- e_0 : bool Γ |- e_1 : t Γ |- e_2 : t / Γ |- if e_0 then e_1 else e_2 : t` （经过判断后执行语句）
  - `Γ |- e_1 : t_1 Γ[x -> t_1] |- e_2 : t_2 / Γ |- let e_1 in e_2 : t_2` （最终根据 `e_2` 确定类型）
  - `Γ |- e_1 : t_1 Γ |- e_2 : t_2 / Γ |- e_1 op e_2 : t` （判断语句两个参数是可以比较的类型，返回值是 `bool` 类型）

### 例子
- `let in` 结构：`Γ |- e_1 : t_1 Γ[x -> t_1] |- e_2 : t_2 / Γ |- let e_1 in e_2 : t_2`
- `fun` 结构：`Γ[f -> t_x -> t_0][x->t_x] |- e_0 : t_0 / Γ |- fun_π f x=>e_0 : t_x -> t_0`
- `fn` 结构：`Γ[x->t_x] |- y : t_0 / Γ |- fn_π x=>y : t_x -> t_0 Γ[x->t_x] |- z : t_0 / Γ |- fn_π x=>z : t_x -> t_0`
- `e_1 e_2` 结构：`Γ |- e_1 : t_2 -> t_0 Γ |- e_2 : t_2 / Γ |- e_1 e_2 -> t_0`

总结下来的操作就是 `[f -> (t -> t) -> (t -> t)] [x -> t -> t]`。递归函数中，不断循环 `fn y` 的操作，再执行 `fn z` 的操作。

由于存在多个相同的类型转换的函数抽象无法区别彼此，我们添加标记 `φ`。在之前的 `fn` 和 `fun` 结构中增加了断点，此时可以应用这些断点进行区别。

## 基于响应的系统模型 (Effect System)

### 响应思想
对于特定类型 `type_1` 和特定类型 `type_2` 形成对应关系的语句，我们应当作出相应的特定操作。这就是基于响应的思想。

- 对于控制流，我们要做的响应是抽象函数的调用。
- 对于异常，我们要做出不同特定的响应。
- 对于作用域，我们要对数据作用域作出响应。
- 对于交互，我们要对不同时间的信号作出响应。

要实现这样一个系统模型，我们需要使用基于类型的函数语言、底层类型系统以及响应系统的扩展。

### 响应系统的扩展
我们在之前的 `fn` 和 `fun` 结构中增加了断点，此时可以应用这些断点进行区别。上一个例子中，我们得到 `[f -> (t -> t) -> (t -> t)] [x -> t -> t]` 的结论，但转换之间调用的函数无法确定，此时我们应用 `φ`。

由于存在 `fn y` 和 `fn z`，所以同类 `φ` 中存在 `y` 和 `z` 两种方法，实际执行中可能是两种之中的一个。还有 `fun f`，同类 `φ` 中只有 `F`。至于 `g ()` 则不调用函数，为空。

最终得到 `[f -> (t – {Y, Z} -> t) – {F} -> (t – 空 -> t)] [x -> t – {Y, Z} -> t]`。

仅仅记录调用函数肯定不能直接实现程序分析，还要有值，即程序中一定存在某处是赋值语句。在控制流分析中，我们把赋值语句也当作了函数，或者说某个函数的返回值是一个值。因此，我们可以做出 `e -> v` 的归纳。

加上这一归纳后的语法也发生了一些变化：
- `c -> c`
- `fn_π x => e_0 — > fn_π x -> e_0`
- `fun_π f x -> e_0 — > fn_π x ->(e_0[f - > fun_π f x -> e_0])` （在递归过程中，不断分解成 `fn x -> e_0`）
- `e_1 —> fn_π x -> e_0 e_2 —> v_2 e_0[x -> v_2] —> v_0 / e_1 e_2 —> v_0` （`e_1` 是一个函数，`e_2` 是赋值，最终是将 `v_2` 当作 `x` 代入函数，返回值 `v_0`）
- `e_0 —> true e_1 —> v_1 / if e_0 then e_1 else e_2 —> v_1` （判断为 `true` 返回 `e_1` 的返回值）
- `e_0 —> false e_2 —> v_2 / if e_0 then e_1 else e_2 —> v_2` （判断为 `false` 返回 `e_2` 的返回值）
- `e_1 -> v_1 e_2[x->v_1] -> v_2 / let x = e_1 in e_2 -> v_2` （函数返回值为 `v_1` 代入 `e_2` 中得到 `v_2`）

通过这种方式，我们可以在控制流分析中更准确地跟踪和理解程序的行为。