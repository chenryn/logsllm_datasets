### Program Libraries and Code Debloating

Program libraries are designed to support a wide range of functionalities for different users. Library debloating customizes the general code base for each program, leading to significant code reduction. Mulliner et al. propose CodeFreeze, a method to remove unnecessary functionalities from Windows shared libraries [36]. Their approach begins with per-library control-flow analysis to identify the code dependencies of each exported function. They then examine the program binary to find all required library functions. By combining the required functions with the per-library control-flow graph (CFG), they rewrite the library to eliminate unreachable code regions.

Similarly, Quach et al. [40] present a library debloating technique through piece-wise compilation and loading. Instead of customizing the library for each program, they split the large library into smaller groups based on control-flow dependencies. At runtime, they use a customized loader to rewrite the library code and remove unnecessary functions. Jiang et al. [23, 22] propose methods to remove dead code from Android apps, Java Runtime Environments, and SDKs.

Our system, RAZOR, differs from these approaches in two key ways. First, previous work performs binary rewriting at the beginning of each process, leading to performance overhead for each execution. In contrast, RAZOR generates the debloated binary through static binary rewriting, which is performed only once and used indefinitely. Second, library debloating relies on static analysis to find unused code and must conservatively retain potentially useful code. RAZOR, however, uses dynamic execution traces to locate the code that is executed during tracing or inferred by our heuristics, and removes all other code.

### Delta Debugging

Delta debugging is a technique used to minimize bug-triggering inputs. For example, Regehr et al. [42] propose C-Reduce to efficiently generate smaller test cases. Sun et al. [49] introduce Perses, which leverages formal syntax to generate smaller, functionally equivalent programs in a timely manner. Recently, Heo et al. [15] proposed CHISEL, which uses reinforcement learning to speed up the delta debugging process. However, the programs generated by delta debugging are tailored to specific test cases, whereas real-world software often has an infinite number of test cases for certain functionalities. RAZOR, on the other hand, uses control-flow-based heuristics to infer additional related code necessary to complete the required functionalities.

### Source Code Debloating

Several recent works use program analysis to debloat source code. Bu et al. [8] propose a bloat-aware design paradigm that analyzes Java source code to optimize object allocations and avoid memory usage bloating at runtime. Sharif et al. [44] introduce Trimmer, which propagates user-provided configurations to program code and utilizes compiler optimizations to reduce code size. These systems, as well as those in [42, 49, 15], rely on complex analyses of program source code, which may not always be available for deployed programs. In contrast, RAZOR requires only program binaries, making it more practical for deployment.

### Container Debloating

Containers are becoming increasingly popular, but their code bases are often bloated. Guo et al. [14] proposed a method to monitor program execution to identify necessary resources and create a minimal container for the traced program. Rastogi et al. [41] developed Cimplifier, which uses dynamic analysis to collect resource usages for different programs and partitions the original container into smaller ones based on user-defined policies. The resulting containers have only the resources needed to run one or more executable programs. RAZOR's design is also applicable for debloating containers or other systems. For example, Intel PT supports tracing operating systems.

### Hardware Debloating

Hardware devices are also subject to bloat. For instance, general-purpose processors are often over-designed for specific applications such as implantables, wearables, and IoT devices. Cherupalli et al. [10] propose an approach to automatically remove unused gates from the design of a general-purpose processor to generate a bespoke processor for a specific application. On average, this approach can reduce the area by 62% and power consumption by 50%. Currently, software and hardware debloating are performed separately. An interesting direction is to consider both hardware and software together to find more opportunities for debloating.

### Conclusion

In this paper, we presented RAZOR, a framework for practical software debloating on program binaries. It utilizes a set of test cases and control-flow-based heuristics to collect the necessary code to support user-expected functionalities. The debloated binary offers a reduced attack surface, improved security, robust functionality, and efficient execution. Our evaluation shows that RAZOR is a practical framework for debloating real-world programs.

### Acknowledgment

We thank the anonymous reviewers and our shepherd, Michael Bailey, for their helpful feedback. This research was supported in part by the DARPA Transparent Computing program under contract DARPA-15-15-TC-FP006, and by the ONR under grants N00014-17-1-2895, N00014-15-1-2162, and N00014-18-1-2662. Any opinions, findings, conclusions, or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of DARPA and ONR.

### References

[1] Martín Abadi, Mihai Budiu, Úlfar Erlingsson, and Jay Ligatti. Control-Flow Integrity. In Proceedings of the 12th ACM Conference on Computer and Communications Security, 2005.
[2] Dennis Andriesse, Xi Chen, Victor van der Veen, Asia Slowinska, and Herbert Bos. An In-Depth Analysis of Disassembly on Full-Scale x86/x64 Binaries. In Proceedings of the 25th USENIX Security Symposium (USENIX), 2016.
[3] Dennis Andriesse, Asia Slowinska, and Herbert Bos. Compiler-Agnostic Function Detection in Binaries. In Proceedings of the 2nd IEEE European Symposium on Security and Privacy, 2017.
[4] Tiffany Bao, Jonathan Burket, Maverick Woo, Rafael Turner, and David Brumley. BYTEWEIGHT: Learning to Recognize Functions in Binary Code. In Proceedings of the 23rd USENIX Conference on Security Symposium, 2014.
[5] Erick Bauman, Zhiqiang Lin, and Kevin Hamlen. Superset Disassembly: Statically Rewriting x86 Binaries Without Heuristics. In Proceedings of the 25th Annual Network and Distributed System Security Symposium, 2018.
[6] Fabrice Bellard. QEMU, a Fast and Portable Dynamic Translator. In Proceedings of the 2005 USENIX Annual Technical Conference, 2005.
[7] Derek Bruening and Saman Amarasinghe. Efficient, Transparent, and Comprehensive Runtime Code Manipulation. PhD thesis, Massachusetts Institute of Technology, Department of Electrical Engineering and Computer Science, 2004.
[8] Yingyi Bu, Vinayak Borkar, Guoqing Xu, and Michael J. Carey. A Bloat-aware Design for Big Data Applications. In Proceedings of the 2013 International Symposium on Memory Management, 2013.
[9] Nathan Burow, Scott A. Carr, Joseph Nash, Per Larsen, Michael Franz, Stefan Brunthaler, and Mathias Payer. Control-Flow Integrity: Precision, Security, and Performance. ACM Comput. Surv., 2017.
[10] Hari Cherupalli, Henry Duwe, Weidong Ye, Rakesh Kumar, and John Sartori. Bespoke Processors for Applications with Ultra-low Area and Power Constraints. In Proceedings of the 44th Annual International Symposium on Computer Architecture, 2017.
[11] Stephen Crane, Christopher Liebchen, Andrei Homescu, Lucas Davi, Per Larsen, Ahmad-Reza Sadeghi, Stefan Brunthaler, and Michael Franz. Readactor: Practical Code Randomization Resilient to Memory Disclosure. In Proceedings of the 36th IEEE Symposium on Security and Privacy, 2015.
[12] Enes Göktas, Elias Athanasopoulos, Herbert Bos, and Georgios Portokalidis. Out of Control: Overcoming Control-Flow Integrity. In Proceedings of the 35th IEEE Symposium on Security and Privacy, 2014.
[13] Google. V8 JavaScript Engine. https://chromium.googlesource.com/v8/v8.git.
[14] Philip J. Guo and Dawson Engler. CDE: Using System Call Interposition to Automatically Create Portable Software Packages. In Proceedings of the 2011 USENIX Annual Technical Conference, 2011.
[15] Kihong Heo, Woosuk Lee, Pardis Pashakhanloo, and Mayur Naik. Effective Program Debloating via Reinforcement Learning. In Proceedings of the 25th ACM SIGSAC Conference on Computer and Communications Security, 2018.
[16] Gerard J. Holzmann. Code Inflation. IEEE Software, 32(2), Mar 2015.
[17] Hong Hu, Chenxiong Qian, Carter Yagemann, Simon Pak Ho Chung, William R. Harris, Taesoo Kim, and Wenke Lee. Enforcing Unique Code Target Property for Control-Flow Integrity. In Proceedings of the 25th ACM Conference on Computer and Communications Security, 2018.
[18] ImageTragick. ImageMagick Is On Fire: CVE-2016-3714. https://imagetragick.com/.
[19] Intel. Control-Flow Enforcement Technology Preview. https://software.intel.com/sites/default/files/managed/4d/2a/control-flow-enforcement-technology-preview.pdf.
[20] Intel Corporation. Intel® 64 and IA-32 Architectures Software Developer’s Manual, volume 3 (3A, 3B, 3C & 3D): System Programming Guide. November 2018.
[21] Yaoqi Jia, Zheng Leong Chua, Hong Hu, Shuo Chen, Prateek Saxena, and Zhenkai Liang. The Web/Local Boundary Is Fuzzy: A Security Study of Chrome’s Process-based Sandboxing. In Proceedings of the 23rd ACM SIGSAC Conference on Computer and Communications Security, 2016.
[22] Y. Jiang, D. Wu, and P. Liu. JRed: Program Customization and Bloatware Mitigation Based on Static Analysis. In 2016 IEEE 40th Annual Computer Software and Applications Conference, 2016.
[23] Yufei Jiang, Qinkun Bao, Shuai Wang, Xiao Liu, and Dinghao Wu. RedDroid: Android Application Redundancy Customization Based on Static Analysis. In Proceedings of the 29th IEEE International Symposium on Software Reliability Engineering, 2018.
[24] Volodymyr Kuznetsov, László Szekeres, Mathias Payer, George Candea, R. Sekar, and Dawn Song. Code-Pointer Integrity. In Proceedings of the 11th USENIX Conference on Operating Systems Design and Implementation, 2014.
[25] Chi-Keung Luk, Robert Cohn, Robert Muth, Harish Patil, Artur Klauser, Geoff Lowney, Steven Wallace, Vijay Janapa Reddi, and Kim Hazelwood. Pin: Building Customized Program Analysis Tools with Dynamic Instrumentation. In Proceedings of the 2005 ACM SIGPLAN Conference on Programming Language Design and Implementation, 2005.
[26] Haoyu Ma, Kangjie Lu, Xinjie Ma, Haining Zhang, Chunfu Jia, and Debin Gao. Software Watermarking Using Return-Oriented Programming. In Proceedings of the 10th ACM Symposium on Information, Computer and Communications Security, 2015.
[27] John Martellaro. Why Your iPhone Uses PNG for Screen Shots and JPG for Photos. https://www.macobserver.com/tmo/article/why-your-iphone-uses-png-for-screen-shots-and-jpg-for-photos.
[28] The Top 500 Sites on the Web. https://www.alexa.com/topsites.
[29] Dromaeo-DOM. http://dromaeo.com/?dom.
[30] Dromaeo-JS. http://dromaeo.com/?dromaeo.
[31] The Heartbleed Bug. http://heartbleed.com/.
[32] Function and Macro Index. https://www.gnu.org/software/libc/manual/html_node/Function-Index.html.
[33] Octane. https://chromium.github.io/octane.
[34] SunSpider. https://webkit.org/perf/sunspider-1.0.2/sunspider-1.0.2/driver.html.
[35] CVE-2014-0038: Privilege Escalation in X32 ABI. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0038, 2014.
[37] Ben Niu and Gang Tan. Per-Input Control-Flow Integrity. In Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security, 2015.
[38] The Chromium Projects. Site Isolation. https://www.chromium.org/Home/chromium-security/site-isolation.
[39] Anh Quach, Rukayat Erinfolami, David Demicco, and Aravind Prakash. A Multi-OS Cross-Layer Study of Bloating in User Programs, Kernel and Managed Execution Environments. In Proceedings of the 2017 Workshop on Forming an Ecosystem Around Software Transformation, 2017.
[40] Anh Quach, Aravind Prakash, and Lok Yan. Debloating Software through Piece-Wise Compilation and Loading. In Proceedings of the 27th USENIX Security Symposium, 2018.
[41] Vaibhav Rastogi, Drew Davidson, Lorenzo De Carli, Somesh Jha, and Patrick McDaniel. Cimplifier: Automatically Debloating Containers. In Proceedings of the 11th Joint Meeting on Foundations of Software Engineering, 2017.
[42] John Regehr, Yang Chen, Pascal Cuoq, Eric Eide, Chucky Ellison, and Xuejun Yang. Test-case Reduction for C Compiler Bugs. In Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation, 2012.
[43] Felix Schuster, Thomas Tendyck, Christopher Liebchen, Lucas Davi, Ahmad-Reza Sadeghi, and Thorsten Holz. Counterfeit Object-oriented Programming: On the Difficulty of Preventing Code Reuse Attacks in C++ Applications. In Proceedings of the 36th IEEE Symposium on Security and Privacy, 2015.
[44] Hashim Sharif, Muhammad Abubakar, Ashish Gehani, and Fareed Zaffar. TRIMMER: Application Specialization for Code Debloating. In Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering, 2018.
[45] Eui Chul Richard Shin, Dawn Song, and Reza Moazzezi. Recognizing Functions in Binaries with Neural Networks. In Proceedings of the 24th USENIX Conference on Security Symposium, 2015.
[36] Collin Mulliner and Matthias Neugschwandtner. Breaking Payloads with Runtime Code Stripping and Image Freezing. In Black Hat USA Briefings (Black Hat USA), Las Vegas, NV, August 2015.
[46] Igor Skochinsky. Compiler Internals: Exceptions and RTTI. http://www.hexblog.com/wp-content/uploads/2012/06/Recon-2012-Skochinsky-Compiler-Internals.pdf, 2012.
[47] Kevin Z. Snow, Fabian Monrose, Lucas Davi, Alexandra Dmitrienko, Christopher Liebchen, and Ahmad-Reza Sadeghi. Just-In-Time Code Reuse: On the Effectiveness of Fine-Grained Address Space Layout Randomization. In Proceedings of the 34th IEEE Symposium on Security and Privacy, 2013.
[48] Peter Snyder, Cynthia Taylor, and Chris Kanich. Most Websites Don’t Need to Vibrate: A Cost-Benefit Approach to Improving Browser Security. In Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security, 2017.
[49] Chengnian Sun, Yuanbo Li, Qirun Zhang, Tianxiao Gu, and Zhendong Su. Perses: Syntax-guided Program Reduction. In Proceedings of the 40th International Conference on Software Engineering, 2018.
[50] Caroline Tice, Tom Roeder, Peter Collingbourne, Stephen Checkoway, Úlfar Erlingsson, Luis Lozano, and Geoff Pike. Enforcing Forward-edge Control-Flow Integrity in GCC & LLVM. In Proceedings of the 23rd USENIX Security Symposium, 2014.
[51] Ruoyu Wang, Yan Shoshitaishvili, Antonio Bianchi, Aravind Machiry, John Grosen, Paul Grosen, Christopher Kruegel, and Giovanni Vigna. Ramblr: Making Reassembly Great Again. In Proceedings of the 24th Annual Network and Distributed System Security Symposium, 2017.
[52] Shuai Wang, Pei Wang, and Dinghao Wu. Reassemblable Disassembling. In Proceedings of the 24th USENIX Conference on Security Symposium, 2015.
[53] Mingwei Zhang and R. Sekar. Control Flow Integrity for COTS Binaries. In Proceedings of the 22nd USENIX Security Symposium, 2013.

### Appendix

#### Settings for Evaluating PathFinder

| Program | Training Set Size | Testing Set Size | Options |
|---------|-------------------|------------------|---------|
| bzip2   | 10                | 30               | -c      |
| chown   | 6                 | 17               | -h, -R  |
| date    | 22                | 33               | –date, -d, –rfc-3339, -utc |
| grep    | 19                | 38               | -a, -n, -o, -v, -i, -w, -x |
| gzip    | 10                | 30               | -c      |
| mkdir   | 12                | 24               | -m, -p  |
| rm      | 10                | 20               | -f, -r  |
| sort    | 12                | 28               | -r, -s, -u, -z |
| tar     | 10                | 30               | -c, -f  |
| uniq    | 24                | 40               | -c, -d, -f, -i, -s, -u, -w |

**Table 7:** Settings for evaluating PathFinder on the CHISEL benchmarks. We use the training set to debloat the binary and run the generated code with the testing set. The last column lists the options passed to the binaries during training and testing.