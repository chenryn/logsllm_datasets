### Simplifying Proofs
In [6], each pass must be independently proven to be both correct and CCT-preserving. In our work, we simplify this process by proving the correctness of each pass independently and performing the CCT-preserving proof only once.

### FACT Compiler
The FACT compiler [10] transforms information flow-secure programs into cryptographic constant-time (CCT) programs, protecting them against cache-based timing side-channels. Recent works, motivated by Spectre and other micro-architectural attacks, explore compiler-based mitigations under speculative execution. Guarnieri and Patrignani [16] analyze the (in)security of several common compiler-based mitigation techniques, including fence insertion and speculative load hardening, using speculative variants of CCT. Vassena et al. [22] design and implement a provably sound, automated compiler-based method for mitigating the BCB (bound check bypass) variant of Spectre attacks, though their approach is not machine-checked.

### Secure Compilation
Abate et al. [1] provide a systematic classification and comparison of different notions of secure compilation. This foundational work does not target specific compilers or address the deployment of secure compilers. Namjoshi and Tabajara [17] develop a translation validation framework for hyperproperties, demonstrating its application to common optimizations. The interaction between information flow and compilation has been extensively studied, with one line of work focusing on information flow type-preserving compilers [8, 11]. These works define information-flow type systems for source and target programs, showing that typable source programs are transformed into typable target programs. Sison and Murray [21] follow a different approach, defining an information flow type system for source programs and developing secure refinement methods to prove that typable source programs are compiled into programs satisfying (timing-sensitive) non-interference, with their proof mechanized using the Isabelle proof assistant.

### Cost Analysis
There is a vast body of work on automatically analyzing program efficiency, particularly in the fields of WCET (Worst-Case Execution Time) and cost analyses, which aim to provide upper and lower bounds of program execution. While many works in the WCET community consider precise cost models accounting for micro-architectural features, analyses are typically carried out on either source programs (for cost analysis) or low-level programs (for WCET). Few works connect the costs of source and target programs. One of the first works in this direction is [13], which develops a time bounds-certifying compiler from a safe dialect of C to assembly, focusing on upper rather than exact bounds and following the principles of certifying compilation. Our work, in contrast, focuses more on transferring the results of source-level cost analysis, making it more closely related to the CerCo compiler [4], which connects a cost analysis for source programs with the cost of target programs. CerCo provides realistic estimates of the time and space cost of basic blocks of the target programs via annotations in the source program. Carbonneaux et al. [9] provide upper bounds on stack usage of assembly programs generated by the CompCert verified compiler. In a functional setting, Paraskevopoulou and Appel [18] prove the preservation of stack space by closure conversion, while Gómez-Londoño et al. [15] prove a similar result for the CakeML compiler. All these works, except [13], support mechanized correctness proofs using proof assistants.

### Conclusion
We have introduced new tools—structured leakage and leakage transformers—for reasoning about the compilation of non-functional, quantitative properties such as cryptographic constant-time and cost. Using these tools, we have provided the first mechanized proof that the Jasmin compiler preserves CCT and a provably correct method for computing the cost of assembly programs. Future work will consider other observational non-interference properties and richer execution models that accommodate speculative and out-of-order execution.

### Acknowledgments
We thank our shepherd Chris Hawblitzel and the anonymous reviewers for their valuable suggestions. This work is partially supported by ONR Grant N00014-19-1-2292 and Project-ANR-18-CE25-0014.

### References
[1] Carmine Abate, Roberto Blanco, Deepak Garg, Catalin Hritcu, Marco Patrignani, and Jérémy Thibault. 2018. Exploring Robust Property Preservation for Secure Compilation. In Computer Security Foundations 2019. http://arxiv.org/abs/1807.04603

[2] José Bacelar Almeida, Manuel Barbosa, Gilles Barthe, Arthur Blot, Benjamin Grégoire, Vincent Laporte, Tiago Oliveira, Hugo Pacheco, Benedikt Schmidt, and Pierre-Yves Strub. 2017. Jasmin: High-Assurance and High-Speed Cryptography. In Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security. ACM.

[3] José Bacelar Almeida, Manuel Barbosa, Gilles Barthe, Benjamin Grégoire, Adrien Koutsos, Vincent Laporte, Tiago Oliveira, and Pierre-Yves Strub. 2020. The Last Mile: High-Assurance and High-Speed Cryptographic Implementations. In 2020 IEEE Symposium on Security and Privacy (S&P). 965–982. https://doi.org/10.1109/SP40000.2020.00028

[4] Roberto M. Amadio, Nicholas Ayache, François Bobot, Jaap Boender, Brian Campbell, Ilias Garnier, Antoine Madet, James McKinna, Dominic P. Mulligan, Mauro Piccolo, Randy Pollack, Yann Régis-Gianas, Claudio Sacerdoti Coen, Ian Stark, and Paolo Tranquilli. 2013. Certified Complexity (CerCo). In Foundational and Practical Aspects of Resource Analysis - Third International Workshop, FOPARA 2013, Bertinoro, Italy, August 29-31, 2013, Revised Selected Papers (Lecture Notes in Computer Science, Vol. 8552), Ugo Dal Lago and Ricardo Peña (Eds.). Springer, 1–18. https://doi.org/10.1007/978-3-319-12466-7_1

[5] Gilles Barthe, Gustavo Betarte, Juan Campo, Carlos Luna, and David Pichardie. 2014. System-level non-interference for constant-time cryptography. In Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security. ACM.

[6] Gilles Barthe, Sandrine Blazy, Benjamin Grégoire, Rémi Hutin, Vincent Laporte, David Pichardie, and Alix Trieu. 2020. Formal Verification of a Constant-Time Preserving C Compiler. Proceedings of the ACM on Programming Languages (POPL) (2020).

[7] Gilles Barthe, Benjamin Grégoire, and Vincent Laporte. 2018. Secure Compilation of Side-Channel Countermeasures: The Case of Cryptographic “Constant-Time”. In 2018 IEEE 31st Computer Security Foundations Symposium (CSF). 328–343. https://doi.org/10.1109/CSF.2018.00031

[8] Gilles Barthe, Tamara Rezk, and David A. Naumann. 2006. Deriving an Information Flow Checker and Certifying Compiler for Java. In 2006 IEEE Symposium on Security and Privacy (S&P 2006), 21-24 May 2006, Berkeley, California, USA. IEEE Computer Society, 230–242. https://doi.org/10.1109/SP.2006.13

[9] Quentin Carbonneaux, Jan Hoffmann, Tahina Ramananandro, and Zhong Shao. 2014. End-to-end verification of stack-space bounds for C programs. In ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI '14, Edinburgh, United Kingdom - June 09 - 11, 2014, Michael F. P. O’Boyle and Keshav Pingali (Eds.). ACM, 270–281. https://doi.org/10.1145/2594291.2594301

[10] Sunjay Cauligi, Gary Soeller, Brian Johannesmeyer, Fraser Brown, Riad S. Wahby, John Renner, Benjamin Grégoire, Gilles Barthe, Ranjit Jhala, and Deian Stefan. 2019. FaCT: a DSL for timing-sensitive computation. In Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI 2019, Phoenix, AZ, USA, June 22-26, 2019., Kathryn S. McKinley and Kathleen Fisher (Eds.). ACM, 174–189. https://doi.org/10.1145/3314221.3314605

[11] Juan Chen, Ravi Chugh, and Nikhil Swamy. 2010. Type-preserving compilation of end-to-end verification of security enforcement. In Proceedings of the 2010 ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI 2010, Toronto, Ontario, Canada, June 5-10, 2010, Benjamin G. Zorn and Alexander Aiken (Eds.). ACM, 412–423. https://doi.org/10.1145/1806596.1806643

[12] Michael R. Clarkson and Fred B. Schneider. 2008. Hyperproperties. In Proceedings of the 21st IEEE Computer Security Foundations Symposium, CSF 2008, Pittsburgh, Pennsylvania, USA, 23-25 June 2008. IEEE Computer Society, 51–65. https://doi.org/10.1109/CSF.2008.7

[13] Karl Crary and Stephanie Weirich. 2000. Resource Bound Certification. In POPL 2000, Proceedings of the 27th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Boston, Massachusetts, USA, January 19-21, 2000, Mark N. Wegman and Thomas W. Reps (Eds.). ACM, 184–198. https://doi.org/10.1145/325694.325716

[14] Vijay D’Silva, Mathias Payer, and Dawn Song. 2015. The Correctness-Security Gap in Compiler Optimization. In Security and Privacy Workshops (SPW), 2015 IEEE. 73–87. http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=7163211

[15] Alejandro Gómez-Londoño, Johannes Åman Pohjola, Hira Taqdees Syeda, Magnus O. Myreen, and Yong Kiam Tan. 2020. Do you have space for dessert? A verified space cost semantics for CakeML programs. Proc. ACM Program. Lang. 4, OOPSLA (2020), 204:1–204:29. https://doi.org/10.1145/3428272

[16] Marco Guarnieri and Marco Patrignani. 2019. Exorcising Spectres with Secure Compilers. CoRR abs/1910.08607 (2019). arXiv:1910.08607 http://arxiv.org/abs/1910.08607

[17] Kedar S. Namjoshi and Lucas M. Tabajara. 2020. Witnessing Secure Compilation. In Verification, Model Checking, and Abstract Interpretation - 21st International Conference, VMCAI 2020, New Orleans, LA, USA, January 16-21, 2020, Proceedings (Lecture Notes in Computer Science, Vol. 11990), Dirk Beyer and Damien Zufferey (Eds.). Springer, 1–22. https://doi.org/10.1007/978-3-030-39322-9_1

[18] Zoe Paraskevopoulou and Andrew W. Appel. 2019. Closure conversion is safe for space. Proc. ACM Program. Lang. 3, ICFP (2019), 83:1–83:29. https://doi.org/10.1145/3341687

[19] Pascal Raymond, Claire Maiza, Catherine Parent-Vigouroux, Erwan Jahier, Nicolas Halbwachs, Fabienne Carrier, Mihail Asavoae, and Rémy Boutonnet. 2019. Improving WCET Evaluation using Linear Relation Analysis. Leibniz Trans. Embed. Syst. 6, 1 (2019), 02:1–02:28. https://doi.org/10.4230/LITES-v006-i001-a002

[20] Laurent Simon, David Chisnall, and Ross J. Anderson. 2018. What You Get is What You C: Controlling Side Effects in Mainstream C Compilers. In 2018 IEEE European Symposium on Security and Privacy, EuroS&P 2018, London, United Kingdom, April 24-26, 2018. IEEE, 1–15. https://doi.org/10.1109/EuroSP.2018.00009

[21] Robert Sison and Toby Murray. 2019. Verifying that a compiler preserves concurrent value-dependent information-flow security. In International Conference on Interactive Theorem Proving (Lecture Notes in Computer Science). Springer-Verlag.

[22] Marco Vassena, Craig Disselkoen, Klaus von Gleissenthall, Sunjay Cauligi, Rami Gökhan Kici, Ranjit Jhala, Dean M. Tullsen, and Deian Stefan. 2021. Automatically eliminating speculative leaks from cryptographic code with Blade. Proc. ACM Program. Lang. 5, POPL (2021), 1–30. https://doi.org/10.1145/3434330

### Appendix: Details on Stack Allocation
This appendix complements Section 5.5 by presenting the leakage transformer produced by the stack-allocation pass applied to the example program (Figure 16). It also briefly describes the (Coq) implementation of the stack-allocation pass.

The stack-allocation pass consists of two phases: an analysis phase that computes the layout of the stack frame, and a transformation phase that introduces memory operations. For leakage transformers, only the transformation phase is relevant. The transformation phase is structured into three main parts: transforming expressions, left values, and instructions. The transformations of expressions and left-values are similar, replacing reads from (or writes to) variables and arrays with loads from (or stores to) memory. The final transformation of instructions recursively applies these sub-transformations and composes their results straightforwardly. For brevity, this exposition focuses on the transformation of expressions, implemented by the function `alloc e` (Figure 15).

The `alloc e` function compiles an expression `e` based on a "map" `m` from the analysis phase. It returns an expression and the corresponding leakage transformer, or fails; hence the monadic return type `cexec` and the `ret` notation for successful results. The function is recursively defined, following the structure of the expression to compile. Constant expressions (line 3) are returned as is, with the identity leakage transformer `id`. Unary operators (Papp1) applied to a sub-expression produce the same leakage as the sub-expression, so the leakage transformer `r` for the sub-expression (line 5) directly applies to the whole expression (line 6). For a memory load, the leakage is a pair: the first component represents the evaluation of the address, and the second component reveals the accessed address. The compilation of a load expression recursively transforms the address expression but preserves its value (line 10).

For a read from a variable `x` (line 12), there are two cases: if `x` is bound in the map `m` to some offset `ofs`, it is transformed into a memory load, and the corresponding leakage is introduced; otherwise, the expression and its leakage are preserved. Finally, the compilation of a read of size `ws` from array `x` at index `e` first recursively transforms the sub-expression `e`; if the array is laid out at offset `ofs`, the relevant element is at offset `e × ws + ofs`. The expression representing this offset is built by the smart constructor `mk ofs` (not shown in the figure), which simplifies constant expressions and returns the corresponding leakage transformer. The complete leakage transformer (line 22) is the parallel composition of the transformations of the offset and the array leakage into a memory leakage.

**Figure 15: Pseudo-code of the stack-allocation of expressions**

```coq
Fixpoint alloc e (m: map) (e: pexpr) : cexec (pexpr × leak e tr) :=
  match e with
  | Pconst _ ⇒ ret e id
  | Papp1 o e' ⇒
      Let: (e', r) := alloc e m e' in
      ret (Papp1 o e') r
  | Pload ws x e' ⇒
      Let: (e', r) := alloc e m e' in
      ret (Pload ws x e') [ r, id ]
  | Pvar x ⇒
      if ... (* x has size ws and is allocated at offset ofs *) then
        ret (Pload ws stk ofs) [ id; C (sp + cst ofs) ]
      else ... (* x is a register *)
        ret e id
  | Pget ws x e' ⇒
      Let: (e', r) := alloc e m e' in
      if ... (* x is allocated at offset ofs *) then
        ret (Pget ws x e') [ r, id ]
      else ...
  | ... ⇒ ...
  end.
```

**Figure 16: Leakage transformer**

```coq
:=
:=
:=
{ ; }
( ,
)
id
( ,
)
id
id
•
𝐼(𝑥 ↦→ sp+ cst 𝑥 × cst 8)
•
𝐼(𝑥 ↦→ sp+ cst 𝑥 × cst 8)
id
id
( ,
)
:=
( ;
)
id
◦
id
•
( ,
)
( ;
)
id
𝐼(𝑥 ↦→ sp+ cst 𝑥 × cst 8)
•
```

### Session 2B: Formal Analysis and Verification
CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea