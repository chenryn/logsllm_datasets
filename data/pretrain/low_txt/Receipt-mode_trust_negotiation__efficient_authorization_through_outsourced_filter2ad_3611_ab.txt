### Subsystem for Control Transfer
This subsystem facilitates the transfer of control from the RMTN handler application back to the application-level protocol running on the original remote server. In essence, the information contained in an RMTN-RDR message enables the client to contact an appropriate helper (or helpers) for authorization via trust negotiation. It also allows the remote helper to determine which resource protection policy to use in the resulting trust negotiation session. The RMTN-RCP message encapsulates the state of the trust negotiation, allowing the server to validate how and why the client became authorized to access its service.

### 4.2 Basic RMTN
The basic form of our proposed RMTN protocol is illustrated in Figure 1. The protocol begins when a client requests a policy-protected resource from a server (message A). Recognizing that the request is for a policy-protected resource, the server issues an RMTN-RDR message to the client, designating at least one remote helper to offload the work from the server (message B). Based on the parameters in the RMTN-RDR message, the client and helper enter into a trust negotiation session to find a set of the client’s credentials that satisfy the resource access policy (messages C). If a satisfying set of credentials is found, the helper generates an RMTN-RCP message for the client, encapsulating a digitally-signed, minimal representation of the protocol state (message D).

The client can then present this receipt to the server (message E). After verifying that the signature on the receipt was created by an authorized helper and that the credentials presented by the client match those identified in the receipt, the server can verify that the credentials satisfy the policy implied by the client’s resource request and serve the resource (message F). This is accomplished by invoking a policy compliance checker on the policy protecting the resource and the set of credentials provided by the client. This step allows the server to "check the work" of the helper for correctness without requiring the server to execute the entire protocol.

#### Client/Server Delay Trade-Offs
Response time gains should be immediately realized in RMTN if the time to perform trust negotiation (TN) is much greater than the time to serve the resource originally requested. The time on the server to process a resource request is \(O(Stn + Sr)\), where \(O(Stn)\) is the time to negotiate trust with the client and \(O(Sr)\) is the time to serve the resource. The addition of a helper changes the response time to \(O(Srdr + Htn + Crcp + Sr)\), where \(O(Srdr)\) is the time to send the client the RMTN-RDR message, \(O(Htn)\) is the time to negotiate trust on the helper, and \(O(Crcp)\) is the time the client takes to transmit the receipt to the server. However, \(O(Htn)\) occurs on the helper, so local processing resources on the server are only \(O(Srdr + Crcp + Sr)\). Assuming the delivery time of messages is negligible compared to TN or serving resources, the server's processing time is characterized by \(O(Sr)\).

The response time the client sees is still limited by \(O(Htn + Sr)\), but if the server has sufficient work and the time to serve a resource is much less than the time to negotiate trust, i.e., \(O(Sr) \ll O(Stn)\), then the significant amount of time not spent in TN on the server can be used to process more requests. This load-balancing advantage is validated in Section 5.

### 6. RELATED WORK
Trust negotiation has been an active area of research within the security community over the last several years. Research has focused on foundational issues such as languages for expressing resource access policies and logics for reasoning about the outcomes of negotiations. Several groups have developed trust negotiation implementations for experimentation, and others have looked at optimizations related to the amount of information revealed during a single trust negotiation session. In contrast, we focus on optimizing the way a server handles many concurrent trust negotiation sessions.

In many ways, receipt-mode trust negotiation can be classified as a load balancing mechanism. Techniques for load balancing in networking, such as assigning packets or network flows to a pool of resources, increase reliability and throughput. To the best of our knowledge, load balancing has not been previously applied within the realm of trust negotiation. Naive replication of server-side credentials increases the likelihood of compromising the server’s long-term secrets; our RMTN protocols avoid this problem by replicating short-lived proxy certificates that allow helper nodes to operate on the server’s behalf without risking the safety of long-term secrets.

### 7. CONCLUSIONS AND FUTURE WORK
Trust negotiation has been proposed as an expressive means of access control for open environments where users and resources may not have a priori established relationships. Despite its advantages, the state management overheads associated with conducting many trust negotiation sessions can be significant. In this paper, we proposed remote-mode trust negotiation (RMTN) to mitigate these costs. RMTN safely delegates the interactive portions of the trust negotiation process to helper nodes that carry out the trust negotiation and generate third-party verifiable receipts attesting to the outcomes. As a result, resource servers need only to verify this receipt before serving content, a lightweight process.

We experimentally verified that RMTN greatly decreases server response time and showed that the use of the protocol compromises neither the correctness of the trust negotiation process nor the long-term credentials held by the resource server. In the future, we hope to extend this work by testing the utility of inexpensive platforms for RMTN and researching protocols that enable the resource server to synchronize policies and proxy certificates with its helpers efficiently.

### 8. REFERENCES
[1] Information technology - open systems interconnection - the directory: Public-key and attribute certificate frameworks, March 2000.
[2] Link aggregation (IEEE 802.1ax), 2008. http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=4668665
[3] Y. Amir, R. Caudy, A. Munjal, T. Schlossnagle, and C. Tutu. N-way fail-over infrastructure for reliable servers and routers. In DSN, pages 403–, 2003.
[4] T. Aura, P. Nikander, and J. Leiwo. DoS-resistant authentication with client puzzles. Cambridge Security Protocols Workshop 2000, Apr. 2000.
[5] M. Y. Becker and P. Sewell. Cassandra: Distributed access control policies with tunable expressiveness. In 5th IEEE International Workshop on Policies for Distributed Systems and Networks, 2004.
[6] E. Bertino, E. Ferrari, and A. C. Squicciarini. X-TNL: An XML-based language for trust negotiations. In Proceedings of the 4th IEEE International Workshop on Policies for Distributed Systems and Networks (POLICY ’03), 2003.
[7] E. Bertino, E. Ferrari, and A. C. Squicciarini. Trust-X: A peer-to-peer framework for trust establishment. IEEE Transactions on Knowledge and Data Engineering, 16(7):827–842, 2004.
[8] P. Bonatti and P. Samarati. Regulating service access and information release on the web. In 7th ACM Conference on Computer and Communications Security, pages 134–143, 2000.
[9] T. Dierks and E. Rescorla. The Transport Layer Security (TLS) Protocol Version 1.2, Aug. 2008.
[10] C. C. Fan. The Raincore distributed session service for networking elements.
[11] A. Juels and J. Brainard. Client puzzles: A cryptographic countermeasure against connection depletion attacks. Proceedings of NDSS '99 (Networks and Distributed Security Systems), pages 151–165, 1999.
[12] A. J. Lee and M. Winslett. Towards an efficient and language-agnostic compliance checker for trust negotiation systems. In 3rd ACM Symposium on Information, Computer, and Communication Security (ASIACCS '08), Mar. 2008.
[13] A. J. Lee, M. Winslett, and K. J. Perano. TrustBuilder2: A reconfigurable framework for trust negotiation. In Third IFIP WG 11.11 International Conference on Trust Management (IFITM 2009), June 2009.