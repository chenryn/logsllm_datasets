以下是经过优化后的文本，使其更加清晰、连贯和专业：

---

### 参考文献

[26] C. CyLab, “Bap GitHub 仓库,” https://github.com/BinaryAnalysisPlatform/bap/tree/cfeacbfc, 2020.

[27] C. CyLab, “Bap-Toolkit GitHub 仓库,” https://github.com/BinaryAnalysisPlatform/bap-toolkit/tree/7b7744dc3/with-no-return, 2020.

[28] L. Davi, C. Liebchen, A.-R. Sadeghi, K. Z. Snow, 和 F. Monrose, “Isomeron: 抵御即时返回导向编程的代码随机化.” 在 NDSS, 2015.

[29] Y. David, N. Partush, 和 E. Yahav, “Firmup: 固件中常见漏洞的精确静态检测,” 在 ACM SIGPLAN Notices, 卷 53, 期 2. ACM, 2018, 页 392–404.

[30] Y. David 和 E. Yahav, “基于 Tracelet 的可执行文件代码搜索,” 在 ACM Sigplan Notices, 卷 49, 期 6. ACM, 2014, 页 349–360.

[31] L. De La Rosa, S. Kilgallon, T. Vanderbruggen, 和 J. Cavazos, “使用深度学习对恶意软件进行高效特征提取和分类,” 在 2018 Resilience Week (RWS). IEEE, 2018, 页 77–83.

[32] R. Decompiler, “基于 LLVM 的可重定向机器码反编译器,” https://retdec.com/.

[33] A. Dinaburg 和 A. Ruef, “Mcsema: 静态转换 x86 指令到 LLVM,” 在 ReCon 2014 Conference, Montreal, Canada, 2014.

[34] S. Dinesh, N. Burow, D. Xu, 和 M. Payer, “Retrowrite: 静态为 COTS 二进制文件添加工具以进行模糊测试和净化,” 在 2020 IEEE Symposium on Security and Privacy (SP). IEEE Computer Society, 2020, 页 9–9.

[35] DynInst, “DataflowAPI 编程指南,” https://dyninst.org/sites/default/files/manuals/dyninst/dataflowAPI.pdf, 2019.

[36] C. Eagle, 《IDA Pro 书籍》. No Starch Press, 2011.

[37] M. Elsabagh, D. Fleck, 和 A. Stavrou, “C++ 二进制文件中的严格虚拟调用完整性检查,” 在 2017 ACM on Asia Conference on Computer and Communications Security. ACM, 2017, 页 140–154.

[38] Ú. Erlingsson, M. Abadi, M. Vrable, M. Budiu, 和 G. C. Necula, “XFI: 系统地址空间的软件防护,” 在 7th USENIX Security Symposium, 2006, 页 75–88.

[39] U. Erlingsson 和 F. B. Schneider, “SASI 安全策略的强制执行: 回顾,” 在 Proceedings DARPA Information Survivability Conference and Exposition. DISCEX’00, 卷 2. IEEE, 2000, 页 287–295.

[40] S. Eschweiler, K. Yakdan, 和 E. Gerhards-Padilla, “discovre: 二进制代码中跨架构的高效错误识别.” 在 NDSS, 2016.

[41] Q. Feng, M. Wang, M. Zhang, R. Zhou, A. Henderson, 和 H. Yin, “用于跨平台错误搜索的条件公式提取,” 在 2017 ACM on Asia Conference on Computer and Communications Security. ACM, 2017, 页 346–359.

[42] Q. Feng, R. Zhou, C. Xu, Y. Cheng, B. Testa, 和 H. Yin, “固件镜像中可扩展的基于图的错误搜索,” 在 2016 ACM SIGSAC Conference on Computer and Communications Security. ACM, 2016, 页 480–491.

[43] H. Flake, “可执行对象的结构比较,” 在 DIMVA, 卷 46. Citeseer, 2004, 页 161–173.

[44] P. Garba 和 M. Favaro, “Saturn: 基于 LLVM 的软件去混淆框架,” 在 3rd ACM Workshop on Software Protection. ACM, 2019, 页 27–38.

[45] A. Gazet, “ret-sync 是一组帮助同步调试会话的插件,” https://github.com/bootleg/ret-sync, 2016.

[46] M. Ghaffarinia 和 K. W. Hamlen, “二进制控制流修剪,” 在 26th ACM Conference on Computer and Communications Security. 即将发表, 2019.

[47] GNU, “GNU Binutils 索引,” https://ftp.gnu.org/gnu/binutils/, 2019.

[48] GNU, “Sourceware glibc 仓库镜像,” https://github.com/bminor/glibc/blob/master/sysdeps/x86_64/multiarch/memcpy-ssse3.S#L441, 2019.

[49] I. Guilfanov, “跳转表,” https://www.hex-rays.com/blog/jump-tables/.

[50] N. Hasabnis 和 R. Sekar, “将汇编提升到中间表示: 一种利用编译器的新方法,” 在 ACM SIGARCH Computer Architecture News, 卷 44, 期 2. ACM, 2016, 页 311–324.

[51] W. He, S. Das, W. Zhang, 和 Y. Liu, “No-jump-into-basic-block: 对真实世界二进制文件实施基本块 CFI,” 在 54th Annual Design Automation Conference 2017. ACM, 2017, 页 23.

[52] G. Hernandez, F. Fowze, D. J. Tian, T. Yavuz, 和 K. R. Butler, “Firmusb: 使用领域知情符号执行审查 USB 设备固件,” 在 2017 ACM SIGSAC Conference on Computer and Communications Security. ACM, 2017, 页 2245–2262.

[53] J. Hiser, A. Nguyen-Tuong, M. Co, M. Hall, 和 J. W. Davidson, “ILR: 我的小工具去哪儿了?” 在 2012 IEEE Symposium on Security and Privacy (SP). IEEE, 2012, 页 571–585.

[54] X. Hu 和 K. G. Shin, “DUET: 动态和静态分析集成的恶意软件聚类,” 在 29th Annual Computer Security Applications Conference (ACSAC’13), 2013, 页 79–88.

[55] Y. Hu, Y. Zhang, J. Li, 和 D. Gu, “跨架构和编译配置的二进制代码克隆检测,” 在 25th International Conference on Program Comprehension. IEEE Press, 2017, 页 88–98.

[56] M. Jiang, Y. Zhou, X. Luo, R. Wang, Y. Liu, 和 K. Ren, “ARM 反汇编工具的经验研究,” 在 ACM SIGSOFT International Symposium on Software Testing and Analysis (ISSTA’20), 2020.

[57] W. M. Khoo, A. Mycroft, 和 R. Anderson, “Rendezvous: 二进制代码搜索引擎,” 在 10th Working Conference on Mining Software Repositories. IEEE Press, 2013, 页 329–338.

[58] S. Kilgallon, L. De La Rosa, 和 J. Cavazos, “通过机器学习提高动态恶意软件分析的有效性和效率,” 在 2017 Resilience Week (RWS). IEEE, 2017, 页 30–36.

[59] J. Kinder, “Jakstab 二进制静态分析平台,” http://www.jakstab.org/.

[60] H. Koo, Y. Chen, L. Lu, V. P. Kemerlis, 和 M. Polychronakis, “编译器辅助的代码随机化,” 在 2018 IEEE Symposium on Security and Privacy (SP). IEEE, 2018, 页 461–477.

[61] H. Koo 和 M. Polychronakis, “Juggling the gadgets: 使用指令位移的二进制级代码随机化,” 在 11th ACM on Asia Conference on Computer and Communications Security. ACM, 2016, 页 23–34.

[62] C. Kruegel, E. Kirda, D. Mutz, W. Robertson, 和 G. Vigna, “使用可执行文件结构信息的多态蠕虫检测,” 在 International Workshop on Recent Advances in Intrusion Detection. Springer, 2005, 页 207–226.

[63] S. S. Lab, “Psi: 一个安全的静态二进制插桩平台,” http://www.seclab.cs.sunysb.edu/seclab/psi/, 2019.

[64] T. C. S. D. Laboratory, “CBAT 项目中开发的程序分析工具,” https://github.com/draperlaboratory/cbat-tools/, 2018.

[65] L. Li, J. E. Just, 和 R. Sekar, “Windows 系统的地址空间随机化,” 在 2006 22nd Annual Computer Security Applications Conference (ACSAC’06). IEEE, 2006, 页 329–338.

[66] Z. Li, D. Zou, S. Xu, X. Ou, H. Jin, S. Wang, Z. Deng, 和 Y. Zhong, “Vuldeepecker: 一个基于深度学习的漏洞检测系统,” arXiv 预印本 arXiv:1801.01681, 2018.

[67] S. McCamant 和 G. Morrisett, “评估 CISC 架构上的 SFI.” 在 7th USENIX Security Symposium, 2006.

[68] X. Meng 和 B. P. Miller, “二进制代码并不容易,” 在 25th International Symposium on Software Testing and Analysis. ACM, 2016, 页 24–35.

[69] B. P. Miller, M. Christodorescu, R. Iverson, T. Kosar, A. Mirgorodskii, 和 F. Popovici, “在黑盒内玩耍: 使用动态插桩创建安全漏洞,” Parallel Processing Letters, 卷 11, 期 02n03, 页 267–280, 2001.

[70] J. Ming, M. Pan, 和 D. Gao, “ibinhunt: 带有过程间控制流的二进制狩猎,” 在 International Conference on Information Security and Cryptology. Springer, 2012, 页 92–109.

[71] M. Muench, D. Nisi, A. Francillon, 和 D. Balzarotti, “Avatar 2: 多目标协调平台,” 在 Workshop on Binary Analysis Research (与 NDSS 研讨会共同举办)(2018 年 2 月), BAR, 卷 18, 2018.

[72] P. Muntean, M. Fischer, G. Tan, Z. Lin, J. Grossklags, 和 C. Eckert, “τCFI: 用于 x86-64 二进制文件的类型辅助控制流完整性,” 在 International Symposium on Research in Attacks, Intrusions, and Defenses. Springer, 2018, 页 423–444.

[73] J. Mußler, D. Lorenz, 和 F. Wolf, “使用先验静态分析减少直接应用程序插桩的开销,” 在 European Conference on Parallel Processing. Springer, 2011, 页 65–76.

[74] B. Ninja, “binary.ninja: 一个逆向工程平台,” https://binary.ninja/, 2019.

[75] NSA, “Ghidra GitHub 仓库,” https://github.com/NationalSecurityAgency/ghidra/tree/Ghidra-9.0.4-build, 2019.

[76] T. of Bits, “使用 Binary Ninja 进行漏洞建模,” https://blog.trailofbits.com/2018/04/04/vulnerability-modeling-with-binary-ninja/, 2018.

[77] R. Paleari, L. Martignoni, G. Fresi Roglia, 和 D. Bruschi, “N 版本反汇编: x86 反汇编器的差异测试,” 在 19th International Symposium on Software Testing and Analysis. ACM, 2010, 页 265–274.

[78] V. Pappas, M. Polychronakis, 和 A. D. Keromytis, “粉碎小工具: 通过就地代码随机化阻碍返回导向编程,” 在 2012 IEEE Symposium on Security and Privacy (SP). IEEE, 2012, 页 601–615.

[79] Paradyn, “Dyninst GitHub 仓库,” https://github.com/dyninst/dyninst/tree/5d2ddacb, 2019.

[80] M. Payer, A. Barresi, 和 T. R. Gross, “通过二进制硬化实现细粒度的控制流完整性,” 在 International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment. Springer, 2015, 页 144–164.

[81] H. Peng, Y. Shoshitaishvili, 和 M. Payer, “T-fuzz: 通过程序变换进行模糊测试,” 在 2018 IEEE Symposium on Security and Privacy (SP). IEEE, 2018, 页 697–710.

[82] J. Pewny, B. Garmany, R. Gawlik, C. Rossow, 和 T. Holz, “二进制可执行文件中的跨架构错误搜索,” 在 2015 IEEE Symposium on Security and Privacy (SP). IEEE, 2015, 页 709–724.

[83] J. Pewny, F. Schuster, L. Bernhard, T. Holz, 和 C. Rossow, “利用语义签名在二进制程序中搜索错误,” 在 30th Annual Computer Security Applications Conference (ACSAC’14). ACM, 2014, 页 406–415.

[84] B. Potchik, “Binary Ninja 深思,” https://binary.ninja/2017/11/06/architecture-agnostic-function-detection-in-binaries.html, 2017.

[85] A. Prakash, X. Hu, 和 H. Yin, “vfguard: COTS C++ 二进制文件中虚函数调用的严格保护.” 在 NDSS, 2015.

[86] C. Qian, H. Hu, M. Alharthi, P. H. Chung, T. Kim, 和 W. Lee, “Razor: 一个后部署软件瘦身框架,” 在 28th USENIX Security Symposium, 2019, 页 1733–1750.

[87] W. Qiang, Y. Huang, D. Zou, H. Jin, S. Wang, 和 G. Sun, “完全上下文敏感的 CFI 用于 COTS 二进制文件,” 在 Australasian Conference on Information Security and Privacy. Springer, 2017, 页 435–442.

[88] R. Qiao, M. Zhang, 和 R. Sekar, “ROP 防御的原理方法,” 在 31st Annual Computer Security Applications Conference (ACSAC’15). ACM, 2015, 页 101–110.

[89] radareorg, “Radare2 GitHub 仓库,” https://github.com/radareorg/radare2/tree/5a1df188, 2020.

[90] G. Ravipati, A. R. Bernat, N. Rosenblum, B. P. Miller, 和 J. K. Hollingsworth, “走向 Dyninst 的解构,” Univ. of Wisconsin, 技术报告, 页 32, 2007.

[91] S. Rawat, V. Jain, A. Kumar, L. Cojocar, C. Giuffrida, 和 H. Bos, “Vuzzer: 应用感知的进化模糊测试,” 在 NDSS, 2017.

[92] N. Redini, R. Wang, A. Machiry, Y. Shoshitaishvili, G. Vigna, 和 C. Kruegel, “Bintrimmer: 通过抽象解释实现静态二进制瘦身,” 在 International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment. Springer, 2019, 页 482–501.

[93] s3team, “Uroboros GitHub 仓库,” https://github.com/s3team/uroboros/tree/master, 2020.

---

### 附录

#### A. 复杂构造

表 XVII 展示了我们基准二进制文件中复杂构造的统计结果。

#### B. Windows 二进制文件的真实构建

首先，我们采用类似于 [5] 中描述的方法来收集指令。我们使用调试信息中的行表来找到每个源代码/汇编语句的第一条指令，然后通过递归反汇编（跳过间接控制转移）来找到行表未覆盖的指令。我们还发现 Visual Studio 将硬编码字节视为行表中的代码。我们手动排除了这些情况。其次，我们依赖符号来识别函数。函数的符号也携带一个标志，指示它是否返回，这有助于我们收集不返回的函数。第三，我们在 Visual Studio 中启用 DEBUGTYPE:FIXUP 选项，以使所有引用在链接过程中得以保留。最后，我们根据引用（包含跳转表的基址和条目）来识别跳转表。对于每个引用，如果其目标位置包含指向同一函数中基本块的其他引用列表，我们认为该引用是指向跳转表的，并将其目标位置的引用列表视为条目。为了正确性，我们进一步验证跳转表条目是否对应于源代码中的 switch-case。否则，我们手动验证正确性（因为一些跳转表是手工制作的或从 if-else 语句编译而来的）。

我们最初的真实数据集（包括 Linux 和 Windows 二进制文件）可能会遗漏传播的情况。为此，我们通过运行算法 14 和 15 并进行递归更新来扩展我们的真实数据集。

#### C. 反汇编工具的配置

**OBJDUMP, PSI, UROBOROS:** 我们使用推荐的选项运行它们，并解析它们的输出以获取结果。

**DYNINST:** 我们使用 ParseAPI 接口进行递归反汇编，并启用 IdiomMatching 以包括基于决策树的函数匹配（在没有启发式的情况下测试时被排除）。我们解析 ParseAPI 返回的结构以获取反汇编结果。

**ANGR:** 我们使用 CFGFast 接口进行反汇编。当使用此接口时，我们启用 normalize 和 detect tail calls 参数，以便基本块在控制转移到中间时被分割，并检测尾调用。在没有启发式的情况下测试时，我们禁用 CFGFast 的 force complete scan 和 function prologues 参数，以防止线性扫描和函数匹配。为了获得结果，我们解释 CFGFast 返回的 CFG。我们还排除了标记为“对齐”的函数。我们使用 Reassembler 接口进行符号化。

**GHIDRA:** 除了默认设置外，我们启用 Assume Contiguous Functions Only 和 Allow Conditional Jumps 以进行尾调用检测。我们禁用 X86 Constant Reference Analyzer 以防止引入许多虚拟引用。最后，为了在没有启发式的情况下测试 GHIDRA，我们禁用 Function Start Search 和与引用相关的选项，以防止基于签名的匹配和基于引用的反汇编。

#### 表 XVIII: 不使用启发式的反汇编结果

| 指令 | 最小值 | 平均值 | Linux | O0 | O2 | O3 | Os | Of |
|------|--------|--------|-------|----|----|----|----|----|
|      |        |        |       |    |    |    |    |    |
|      |        |        |       |    |    |    |    |    |

---

这样处理后的文本更加清晰、连贯和专业。希望对你有所帮助！