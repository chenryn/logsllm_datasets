### Evaluation of CompCert-Generated Assembly Code for Security-Aware Compilation

Our evaluation aimed to achieve three primary objectives:
1. To determine if the translation validation check might reject the assembly code produced by CompCert, which could indicate that the compiler is not preserving side-channel countermeasures.
2. To assess whether annotating C source code with leakage tags impacts the performance of the code generated by CompCert.
3. To compare the efficiency of the secure code produced by CompCert with that generated by GCC.

#### Experimental Setup
We conducted our evaluation on a standard PC with an IA32 architecture. In addition to the PKCS implementation, we also evaluated the entire NaCl library core [11].

#### Findings
1. **Translation Validation**: We did not encounter any instances where the assembly code generated from properly annotated and secure C code was rejected due to transformations performed by CompCert. However, the transformation validation stage helped identify potential leakage issues in the C code, particularly related to the compilation of complex Boolean expressions.

2. **Performance Impact of Annotations**: There were no significant deviations in performance between the validated assembly code and the code produced by CompCert from non-annotated C code. This suggests that CompCert effectively preserves the class of side-channel countermeasures considered in this paper when they are implemented at the C level.

3. **Benchmarking Results**: Figure 7 presents selected benchmarking results, normalized with respect to the performance of non-optimized GCC output. For PKCS, we compared two scenarios:
   - **PKCS**: The natural comparison between CompCert and GCC, where both the trusted library and the PKCS code are compiled using either GCC or CompCert.
   - **PKCS (nolib)**: The scenario where the trusted library is pre-compiled and linked with the result of compiling the PKCS code using either GCC or CompCert.

#### Performance Analysis
- **CompCert vs. Unoptimized GCC**: Our findings for the first three cases align with known reports on CompCert benchmarking, showing that CompCert outperforms unoptimized GCC by approximately a factor of 2.
- **CompCert vs. GCC (Optimization Level 1)**: When comparing with GCC at optimization level 1, CompCert is at least 30% slower. This result is slightly worse than previously reported values [26], which indicated a 15% slowdown. We attribute this discrepancy to the domain-specific nature of our code, which includes side-channel countermeasures and intensive use of arithmetic and bitwise operations.
- **PKCS (no lib) Case**: In this scenario, CompCert performs as well as GCC at optimization level 1, indicating that most of the speedups achieved by GCC are realized through the optimization of the trusted library.

### Concluding Remarks
We have developed library extensions for EasyCrypt that enable the development of cryptographic security proofs directly on a large subset of the C language, within an extended security model where the adversary has access to execution traces modeling PC security. We extended the CompCert certified compiler with mechanisms for reasoning about programs relying on trusted libraries and a translation validation stage based on CompCert's annotation mechanism. These mechanisms, along with a trusted library providing arithmetic operations and instantiations of idealized operations, are sufficient to preserve correctness and PC security guarantees from a source C program down to its compiled assembly executable. Additionally, the new CompCert extensions are valuable for compiling third-party C programs while preserving their claimed PC security properties.

### Related Work
Our work intersects with computer-aided cryptography and certified compilation. For recent accounts of these fields, we refer readers to [13] and [25]. We focus on the verification of cryptographic implementations and the formal treatment of side-channels.

- **Machine-Checked Correctness Proofs**: Techniques such as equivalence checking [32], verifying compilation [29], deductive program verification [5], and interactive theorem proving [1] have been used to verify the correctness of cryptographic primitive implementations. However, these techniques primarily focus on functional correctness and do not address the formal preservation of security guarantees.
- **Computational Security Guarantees**: Some proposals aim to obtain computational security guarantees for cryptographic primitives and protocols, using deductive verification [18], code generation [16], model extraction [4], refinement type systems [20], or static information-flow analysis [24]. These techniques focus on source program verification and do not explicitly address executable code or side-channel attacks.
- **Side-Channel Attacks and Countermeasures**: Extensive research has been conducted on side-channel attacks and countermeasures in programming languages [2, 3, 23, 34] and theoretical cryptography [19, 6]. These works provide a more general account of side-channel attacks but typically reason in a single setting—source code, assembly code, or an abstract model of computation. In contrast, our work precisely relates the leakage properties of primitives to the security of algorithms and their executable implementations.

### Directions for Further Work
We plan to leverage the developments in this paper to build a verified software toolchain for cryptographic implementations. Key steps include:
- Providing automated support for the C mode of EasyCrypt.
- Investigating stronger and weaker leakage models, extending EasyCrypt with further libraries, and enhancing the translation validation stage in CompCert.
- Exploring the composition of cryptographic protocols and leveraging existing work on Universal Composability to produce verified implementations of higher-level protocols.
- Evaluating the impact of side-channel countermeasures on the feasibility of formally verifying the correctness of a multi-precision arithmetic library.

### Acknowledgements
This work is supported by ONR Grant N000141210914, Amarout II (FP7 Marie Curie Actions-COFUND 291803), FCT - Fundação para a Ciência e a Tecnologia (Portuguese Foundation for Science and Technology) within project ENIAC/2224/2009, and ENIAC Joint Undertaking under grant agreement number 120224. Part of this work was carried out while the second author was visiting École Normale Supérieure, supported by FCT grant SFRH/BSAB/1246/2012.

We are grateful to Benjamin Grégoire, Santiago Zanella-Béguelin, and David Pointcheval for early discussions on the OAEP proof and its EasyCrypt formalization.

### References
[1] Reynald Affeldt, David Nowak, and Kiyoshi Yamada. Certifying assembly with formal security proofs: The case of BBS. Sci. Comput. Program., 77(10-11):1058–1074, 2012.
[2] Johan Agat. Transforming out timing leaks. In Proceedings of POPL’00, pages 40–53, 2000.
[3] Johan Agat and David Sands. On confidentiality and algorithms. In IEEE Symposium on Security and Privacy, pages 64–77. IEEE Computer Society, 2001.
[4] Mihhail Aizatulin, Andrew D. Gordon, and Jan Jürjens. Computational verification of C protocol implementations by symbolic execution. In ACM Conference on Computer and Communications Security, pages 712–723. ACM, 2012.
[5] José Bacelar Almeida, Manuel Barbosa, Jorge Sousa Pinto, and Bárbara Vieira. Deductive verification of cryptographic software. Innovations in Systems and Software Engineering, 6(3):203–218, 2010.
[6] Joël Alwen, Yevgeniy Dodis, and Daniel Wichs. Survey: Leakage resilience and the bounded retrieval model. In Kaoru Kurosawa, editor, ICITS, volume 5973 of Lecture Notes in Computer Science, pages 1–18. Springer, 2009.
[7] Andrew W. Appel. Verified software toolchain - (invited talk). In ESOP’11, volume 6602 of Lecture Notes in Computer Science, pages 1–17. Springer, 2011.
[8] Manuel Barbosa, editor. Deliverable 5.4: Certified shared library core. Computer Aided Cryptography Engineering (CACE FP7 EU Project), 2011. http://www.cace-project.eu.
[9] Gilles Barthe, Benjamin Grégoire, Sylvain Heraud, and Santiago Zanella-Béguelin. Computer-aided security proofs for the working cryptographer. In Advances in Cryptology – CRYPTO 2011, volume 6841 of Lecture Notes in Computer Science, pages 71–90, Heidelberg, 2011. Springer.
[10] Gilles Barthe, Benjamin Grégoire, Yassine Lakhnech, and Santiago Zanella-Béguelin. Beyond provable security. Verifiable IND-CCA security of OAEP. In Topics in Cryptology – CT-RSA 2011, volume 6558 of Lecture Notes in Computer Science, pages 180–196, Heidelberg, 2011. Springer.
[11] Daniel J. Bernstein, Tanja Lange, and Peter Schwabe. The security impact of a new cryptographic library. In Alejandro Hevia and Gregory Neven, editors, Progress in Cryptology - LATINCRYPT 2012, volume 7533 of Lecture Notes in Computer Science, pages 159–176. Springer Berlin Heidelberg, 2012.
[12] Yves Bertot, Nicolas Magaud, and Paul Zimmermann. A proof of GMP square root. Journal of Automated Reasoning, 29(3-4):225–252, 2002.
[13] Bruno Blanchet. Security protocol verification: Symbolic and computational models. In Pierpaolo Degano and Joshua D. Guttman, editors, Principles of Security and Trust - First International Conference, POST 2012, volume 7215 of Lecture Notes in Computer Science, pages 3–29. Springer, 2012.
[14] Sylvie Boldo, Jacques-Henri Jourdan, Xavier Leroy, and Guillaume Melquiond. A formally-verified C compiler supporting floating-point arithmetic. In Arith - 21st IEEE Symposium on Computer Arithmetic, pages 107–115. IEEE, 2013.
[15] Billy Bob Brumley, Manuel Barbosa, Dan Page, and Frederik Vercauteren. Practical realisation and elimination of an ECC-related software bug attack. In Orr Dunkelman, editor, CT-RSA, volume 7178 of Lecture Notes in Computer Science, pages 171–186. Springer, 2012.
[16] David Cadé and Bruno Blanchet. Proved generation of implementations from computationally secure protocol specifications. In POST, volume 7796 of Lecture Notes in Computer Science, pages 63–82. Springer, 2013.
[17] Jean Paul Degabriele, Kenneth Paterson, and Gaven Watson. Provable security in the real world. Security Privacy, IEEE, 9(3):33–41, may-june 2011.
[18] François Dupressoir. Proving Cryptographic C Programs Secure with General-Purpose Verification Tools. PhD thesis, Open University, 2013.
[19] Stefan Dziembowski and Krzysztof Pietrzak. Leakage-resilient cryptography. In 49th Annual IEEE Symposium on Foundations of Computer Science, FOCS 2008, pages 293–302, Washington, 2008. IEEE Computer Society.
[20] Cédric Fournet, Markulf Kohlweiss, and Pierre-Yves Strub. Modular code-based cryptographic verification.
[21] Eiichiro Fujisaki, Tatsuaki Okamoto, and David Pointcheval. RSA-OAEP is secure under the RSA assumption. In Advances in Cryptology – CRYPTO 2001, volume 2139 of Lecture Notes in Computer Science, pages 260–274. Springer, 2001.
[22] Shafi Goldwasser and Silvio Micali. Probabilistic encryption. J. Comput. Syst. Sci., 28(2):270–299, 1984.
[23] Boris Köpf, Laurent Mauborgne, and Martín Ochoa. Automatic quantification of cache side-channels. In Proc. 24th International Conference on Computer Aided Verification (CAV ’12), pages 564–580. Springer, 2012.
[24] Ralf Küsters, Tomasz Truderung, and Juergen Graf. A framework for the cryptographic verification of Java-like programs. In CSF, pages 198–212. IEEE, 2012.
[25] Xavier Leroy. Formal certification of a compiler back-end, or: programming a compiler with a proof assistant. In 33rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2006, pages 42–54, New York, 2006. ACM.
[26] Xavier Leroy, editor. The CompCert C verified compiler: Documentation and user’s manual. INRIA Paris-Rocquencourt, 2013.
[27] James Manger. A chosen ciphertext attack on RSA optimal asymmetric encryption padding (OAEP) as standardized in PKCS#1 v2.0. In Advances in Cryptology – CRYPTO 2001, volume 2139 of Lecture Notes in Computer Science, pages 230–238, Heidelberg, 2001. Springer.
[28] David Molnar, Matt Piotrowski, David Schultz, and David Wagner. The program counter security model: Automatic detection and removal of control-flow side channel attacks. In ICISC, volume 3935 of Lecture Notes in Computer Science, pages 156–168. Springer, 2005.
[29] Lee Pike, Mark Shields, and John Matthews. A verifying core for a cryptographic language compiler. In ACL2, pages 1–10. ACM, 2006.
[30] Phillip Rogaway. Practice-oriented provable security and the social construction of cryptography. Unpublished essay, 2009.
[31] Sabine (formerly Fischer) Schmaltz. Formal verification of a big integer library including division. Master’s thesis, Saarland University, 2007.
[32] Eric Whitman Smith and David L. Dill. Automatic formal verification of block cipher implementations. In FMCAD, pages 1–7. IEEE, 2008.
[33] Falko Strenzke. Manger’s attack revisited. In Miguel Soriano, Sihan Qing, and Javier López, editors, Information and Communications Security, volume 6476 of Lecture Notes in Computer Science, pages 31–45. Springer Berlin Heidelberg, 2010.
[34] Danfeng Zhang, Aslan Askarov, and Andrew C. Myers. Language-based control and mitigation of timing channels. In ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI ’12), pages 99–110. ACM, 2012.