### Bootstrapping and Middleware Independence
The bootstrapping process ensures that the calling processes communicate directly with the kernel module through our generic API. This allows the kernel module to operate independently of middleware services.

### Life-Cycle Management
Each module must implement functions for life-cycle management, such as initialization and shutdown. This enables the framework to inform the module when the system has reached a state during the boot cycle where the module will be called or when the system is shutting down. Modules should use these functions to initiate their policy engines or save internal states to persistent storage before the device powers off.

### Event Notifications
Event notification interfaces are used to propagate important system events to the module. For example, modules should be immediately informed when an app is successfully installed, replaced, or removed. Although this information is typically propagated via broadcast Intents, the time gap between package change and broadcast delivery can cause inconsistencies in module states. Therefore, these events must be delivered synchronously.

### Framework Callbacks
The framework provides a callback interface for modules to communicate more directly with system services, such as the PackageManagerService, without going through the Android API. This is particularly useful for policy authors who want to leverage internal middleware information. Our current callback interface includes functions that allow modules to efficiently resolve PIDs to application package names.

### Proprietary Protocols
We introduced a `callModule()` function in our framework API that allows modules to implement proprietary communication protocols with other apps that are aware of the specific module, such as frontend apps (cf. Section 5.1). When using `callModule()`, these protocols are based on Bundles and enable a protocol similar to the Parcel-based Binder IPC: apps serialize function arguments to a Bundle and add an identifier for the proprietary function the module should execute with the deserialized arguments. It is the module's responsibility to verify that the sender has sufficient privileges to send commands.

### IRM Instrumentation
The framework provides an instrumentation API that enables security modules to hook any Java function within selected app processes. To the best of our knowledge, ASF is the first solution for Android to provide a generic instrumentation API. Hooks injected via the instrumentation API are local to the app process from which the API is called. Therefore, all calls to the instrumentation API must be performed from within the target app’s process. We achieve this by placing an instrumentation hook in the ActivityManagerService that is triggered when a new app process is about to be launched. A module that implements this hook must return a Java class for the instrumentation logic that will be executed within the app’s process. To ensure this code is executed before control flow is passed to the app itself, we modify the arguments passed to Zygote to start the new app process via a special wrapper class that loads and executes the instrumentation code first.

### Middleware Security Modules
We elaborate on the structure of security modules, focusing on the Middleware Sub-Module. A middleware module is a Jar file created with an Android SDK that includes our new security API. It is deployed to a protected location on the file system and loaded during boot. The Jar file contains all the module’s code, resources, and manifest file (cf. Figure 3):

- **Module Manifest**: The manifest (formatted in XML) declares properties such as the module author or code version, and, more importantly, the name of the main Java class that forms the entry point for the module.
- **Classes.dex**: The classes.dex file contains the Java code compiled to Dalvik executable bytecode (DEX). It includes all Java classes that implement the security module’s logic. During the load process of the Middleware Sub-Module, the middleware framework uses the Java reflection API to load the module’s main class (as specified in the manifest) from classes.dex. To ensure error-free reflection, the main class must implement the API as described in Section 5.3. Since the API defines over a hundred methods, but a security module may only require a subset, our SDK provides an abstract class that implements the API. The abstract class can be subclassed by the module’s main class, which then only needs to override the required functions. The abstract class returns an "allow" decision for each non-overridden enforcement function.
- **LSM Interface**: The proprietary interface between user-space processes and the Linux security module in the kernel is implemented through a native library (`liblsm.so`) and a corresponding Java class (`LSM.java`), which exposes the native library via the Java Native Interface. `LSM.java` must implement the generic interface for communication with the kernel, as explained in the previous section. The generic kernel module interface of ASF loads `LSM.java` through the Java reflection API into Android’s application framework, allowing apps and services to communicate with the kernel module and avoiding a policy-specific interface. We exemplified this mechanism by integrating SELinux through the API into Zygote (cf. Section 6.2).
- **Resources**: Each module can include proprietary resources, such as initial configuration files or required binaries. During module instantiation, the framework informs the module about the filesystem location of its Jar file, enabling the module to extract these resources on-demand.

### Stackable and Dynamic Loadable Modules
Two desirable properties for an extensible security framework like ASF are dynamically loadable policies and policy composition (i.e., stacking modules). We explain why we chose, in contrast to related work [20], to permit these features by design but not consider them a requirement for our solution.

- **Dynamically Loadable Modules**: Being able to dynamically load and unload modules is desirable for speeding up development and testing cycles. However, there are technical and security considerations. First, dynamic loading is not always technically possible, especially for static policy models that require extensive labeling operations at runtime. Second, there are security risks; loading and unloading must be strictly controlled to ensure only trusted modules are loaded. In our design, we agree with the conclusions of various Linux security module authors [11] and consider the drawbacks of dynamically loadable modules to outweigh their benefits. Therefore, we load the module once during system boot and permit users to activate dynamic unloading and loading, but we do not consider this feature a requirement.
- **Stackable Modules**: Composing the overall policy from multiple, simultaneously loaded, and independent policies is desirable since no "one-size-fits-all" policy exists. Android, for instance, implements a quadruple-policy approach consisting of Permissions, SE Android type enforcement, AppOps, and Linux capabilities. Multiple policies naturally conflict, requiring the security framework to support different policy composition and reconciliation strategies (e.g., consensus or priority-based) [32, 27]. Supporting fully generic policy composition is challenging and has been shown to be intractable [18]. Thus, despite its benefits, we decided to follow the lessons learned by LSM developers [40] and only permit module developers to implement stackable modules, without providing explicit interfaces for stacked modules in our framework infrastructure. In module combinations where policy consolidation is feasible, the approach would be to provide a "composition module" that implements policy reconciliation and composition logic and can load other modules and multiplex API calls between them.

### Example Security Modules
We demonstrate the efficiency and effectiveness of our Android Security Framework by instantiating different security models from related work. To illustrate the versatility of ASF, we chose models from the areas of inlined reference monitoring, Android’s default security architecture, and type enforcement. We present further instantiations of other security models in our long version [2].

#### 6.1 AppOps and IntentFirewall
Google introduced (unofficially) with Android v4.3 the AppOps infrastructure for dynamic, more fine-grained permissions. It added hooks in different system services and apps, which query a central AppOpsService whether an application is allowed to perform an operation (e.g., retrieving the device location or querying a ContentProvider). The AppOps rules define a mapping from UID/package name to allowed operations. AppOps offers an interface to apps to retrieve the current configuration. Additionally, Google introduced (again unofficially) an IntentFirewall, which acts as a reference monitor for certain Intent-based operations, such as starting an Activity. The IntentFirewall rules describe which caller is allowed to receive which kind of Intent object, using the Intent’s attributes such as destination component.

**Implementation as a Module**: We ported AppOps and IntentFirewall (from Android v4.3) to a security module for ASF (cf. Figure 4) by moving the AppOpsService and the IntentFirewall classes into a module. Our module comprises 2290 lines of code and differs in 33.71% of all LoC from the original implementation. The bulk of the changes (520 LoC) were required to move the hook logic of both services from the system apps and services of Android into the module using our enforcement functions. For the IntentFirewall, this was straightforward, and we only had to substitute a direct callback from IntentFirewall to the ActivityManagerService by our framework callback mechanism. For the AppOpsService, we had to add a mapping from caller PID to package name. By default, the hooks of AppOps determine the caller’s package name and pass this information to the AppOpsService for policy check. Since this is a policy-specific logic of the hooks, our framework hooks do not (by default) provide the caller’s package name, and we re-implemented this logic in our module using our callback interface, which allows us to retrieve the package name for app PIDs. Moreover, we adapted the AppOpsService interface to retrieve/configure the current policies via a Bundle-based communication. AppOps is, furthermore, partially integrated into the Settings application to allow users to disable notifications from selected apps. We replaced this policy-specific channel between Settings and AppOps with our policy-agnostic Bundle-based communication. Modules that support this Settings option can return a value indicating whether notifications are disabled or not. If the module does not support this feature, the Settings app by default allows notifications.

#### 6.2 Type Enforcement [36, 8]
SE Android [36] brought SELinux type enforcement to the Android kernel and established the required user space support, e.g., it extended Zygote to label new app processes with a security type. FlaskDroid [8], developed for Android v4.0.3, extends SE Android’s type enforcement to Android’s middleware. Building on SEAndroid’s kernel and low-level patches, it adds policy-specific hooks as policy enforcement points to various system services and apps in Android’s middleware. The policy decisions at the kernel level are made by the SELinux kernel module, while the decisions at the middleware level are made centrally in a policy server service. Both policy decision points decide based on subject type, object type, and object class reported by the hooks at their respective layer whether control flows should be truncated or not.

**Implementation as a Module**: We realized type enforcement with our ASF by porting FlaskDroid [8] as a module (cf. Figure 5), in this context porting the currently hardcoded SELinux support of Android’s middleware into an ASF module. At the kernel level, we use the SE Android kernel and provide an SELinux-specific interface implementation for the kernel module. Further, we moved the middleware policy server and its dependencies into the middleware module. Using the enforcement functions of our API, we moved the policy-specific hook logic of FlaskDroid into the module as well. Additionally, we used SE Android’s build system to label the file system with security types.

Our port of FlaskDroid’s middleware component as a security module consists of 4968 LoC (cf. Table 1) and differs in only 16.53% of all LoC from the original code. The bulk of these changes (550 LoC) is attributed to additions for implementing a mapping from the enforcement functions of our framework API to FlaskDroid’s type checks. To confirm the correct enforcement of policies, we used the policies for middleware and kernel level that are provided with the FlaskDroid source code. Additionally, we noticed during our tests that the original implementation contains an error in assigning middleware security types to processes. Additional changes were necessary to fix this error in our module.

#### 6.3 Inlined Reference Monitoring [3]
We use AppGuard [3] as the use-case to illustrate the applicability of our IRM instrumentation API, but similar application rewriting approaches [21] are also feasible. AppGuard is a privacy app for Android that enables end-users to enforce fine-grained access control policies on 3rd party apps by restricting their ability to access critical system resources. By injecting an IRM into apps, this approach supports security policies not easily enforceable by traditional external reference monitors in the Android middleware or kernel, e.g., to enforce the use of HTTPS over HTTP.

**Implementation as a Module**: We ported AppGuard [3] as a module for ASF by separating its privacy app into three components: We adapted the (1) AppGuard reference monitor with its dynamic hook placement and policy enforcement logic to use our IRM instrumentation API.