### QuackyDucky and Tooling
QuackyDucky supports the automatic extraction of message format descriptions from RFCs. This capability has been applied to network message formats, such as IMAP, a widely used mail protocol. While the input language of QuackyDucky is more expressive than that of EverParse, the latter produces parsers that are provably safe, secure, and functionally correct. In contrast, Jim and Mandelbaum's work does not address message formatting.

### Limitations and Future Work

#### Trusted Computing Base (TCB)
We ensure memory safety, functional correctness, and non-malleability for all code generated by QuackyDucky at the F* source level. To maintain non-malleability down to machine code, it is sufficient to preserve functional correctness, as non-malleability is a specification-level guarantee. Our verification results, including the preservation of memory safety and functional correctness down to machine code, rely on a trusted computing base (TCB) that includes:
- The F* proof assistant and the Z3 theorem prover, though work by Swamy et al. [48] provides a model of a subset of F* and proves its soundness.
- The KReMLin compiler from Low* to C, with Protzenko et al. [38] providing a model of a subset of Low*, its compilation to CompCert Clight, and proofs (on paper) that compilation to C preserves memory safety and functional correctness.
- The C compiler, where one can use the CompCert [28] verified C compiler to ensure the preservation of memory safety and functional correctness, albeit with some performance trade-offs.

This TCB is comparable to Coq-based verified implementations, which trust Coq, the Coq extraction to OCaml, and the OCaml compiler and runtime. Ongoing research aims to reduce this TCB by verifying Coq extraction; similar efforts could, in principle, be applied to F* and KReMLin.

#### Security and Liveness
LowParse and QuackyDucky are not part of the TCB. LowParse is fully verified, while the input format specification of QuackyDucky is trusted for liveness but not for security. If there is a mistake in the format specification, the worst that can happen is that the generated messages are incompatible with implementations of the correct format. We rely on interoperability testing to detect such mistakes. Conversely, EverParse can be used during the standardization of a new message format, as it can prove that the specification is secure regardless of the generated implementation.

#### Expressiveness
QuackyDucky currently focuses on supporting tag-length-value encodings of non-malleable data formats. We have shown that the message formats of several important protocols and standards, including TLS, PKCS #1 signature payloads, and Bitcoin, fall into this class. LowParse, being the target language of QuackyDucky’s translation, is also currently restricted to supporting non-malleable data formats. However, it would be straightforward to make non-malleability conditional on a flag set in the parser metadata to define combinators for zero-copy malleable formats, such as MessagePack, CBOR, Apache Arrow, Cap'n proto, and Protocol Buffers, which are malleable by default (some have canonical representation rules). Generalized to support malleable formats, LowParse, as a library of verified monadic parser combinators, would support parsing with arbitrary data dependence and lookahead, beyond the class of context-free languages. However, developing efficient verified implementations of parsers for such language classes remains an open question. In the future, we will consider generalizing QuackyDucky to target the class of languages supported by LowParse.

#### Side-Channel Attacks
The implementation produced by EverParse branches on values read from the input buffer, which may leak information through timing side-channels when used on confidential data. In principle, we can verify properties such as constant-time execution for the processing of simple message formats, reusing F* and KReMLin techniques and libraries for side-channel protection of cryptographic algorithms. For example, we may provide constant-time combinators for fixed-length secret bytestrings. Such extensions are left for future work.

#### Fuzzing
Since we expect our extracted C code to be compiled by unverified toolchains (such as GCC and LLVM, with optimizations), fuzz testing can provide additional assurance that the compilation from F* to binary does not break our verified safety properties. We have started using fuzzers optimized for parsers, such as SAGE [19], to fuzz the generated Bitcoin block validator. We plan to extend their use to fuzz application code that uses generated validators and accessors.

#### Integration
We have integrated the high-level implementation of EverParse TLS parsers into MITLS, but our goal is to transition to the low-level implementation, thus avoiding many unnecessary heap allocations and copies. This is a major step towards making MITLS practical in performance-sensitive deployments.

### Conclusion
Developers should prefer the convenience and robustness of writing high-level format specifications compiled by parser generation tools over programming tedious and error-prone custom parsers, although the latter is sometimes required for performance reasons. EverParse offers a unique combination of high performance, zero-copy implementations, and high-assurance formal verification of the generated parsers.

### Acknowledgments
We thank the anonymous reviewers and Prateek Saxena for their helpful comments, which improved the writing of this paper. We also thank Barry Bond, Christoph Wintersteiger, and the Everest team for their help in testing EverParse. Special thanks to Clément Pit-Claudel and Benjamin Delaware for insightful discussions on the goals of verified parsing. Tej Chajed and Nadim Kobeissi completed their work during internships at Microsoft Research.

### References
[1] The Coq proof assistant. http://coq.inria.fr, 1984–2019.
[2] A. Barenghi, N. Mainardi, and G. Pelosi. Systematic parsing of X.509: eradicating security issues with a parse tree. CoRR, abs/1812.04959, 2018.
[3] A. Barthwal and M. Norrish. Verified, executable parsing. In European Symposium on Programming, pages 160–174. Springer, 2009.
[4] D. Benjamin. Applying GREASE to TLS extensibility. IETF Draft, 2016.
[5] B. Beurdouche, A. Delignat-Lavaud, N. Kobeissi, A. Pironti, and K. Bhargavan. FLEXTLS: A tool for testing TLS implementations. In Usenix Workshop on Offensive Technologies (WOOT15), 2015.
[6] K. Bhargavan, B. Bond, A. Delignat-Lavaud, C. Fournet, C. Hawblitzel, C. Hritcu, S. Ishtiaq, M. Kohlweiss, R. Leino, J. R. Lorch, K. Maillard, J. Pan, B. Parno, J. Protzenko, T. Ramananandro, A. Rane, A. Rastogi, N. Swamy, L. Thompson, P. Wang, S. Z. Béguelin, and J. K. Zinzindohoue. Everest: Towards a verified, drop-in replacement of HTTPS. In 2nd Summit on Advances in Programming Languages, SNAPL 2017, May 7-10, 2017, Asilomar, CA, USA, pages 1:1–1:12, 2017. https://project-everest.github.io.
[7] K. Bhargavan, C. Fournet, and M. Kohlweiss. miTLS: Verifying protocol implementations against real-world attacks. IEEE Security & Privacy, 14(6):18–25, Nov 2016. https://github.com/project-everest/mitls-fstar.
[8] D. Bleichenbacher, T. Duong, E. Kasper, and Q. Nguyen. Project Wycheproof: Scaling crypto testing. In Real World Crypto Symposium, New York, USA, 2017.
[9] S. Y. Chau. The OID parser in the ASN.1 code in GMP allows any number of random bytes after a valid OID. Available from MITRE CVE-2018-16151, 2018.
[10] P. Cousot and R. Cousot. Grammar Analysis and Parsing by Abstract Interpretation, pages 175–200. Springer Berlin Heidelberg, Berlin, Heidelberg, 2007.
[11] P. Cuoq, F. Kirchner, N. Kosmatov, V. Prevosto, J. Signoles, and B. Yakobowski. Frama-C. In International Conference on Software Engineering and Formal Methods, pages 233–247. Springer, 2012.
[12] C. Decker and R. Wattenhofer. Bitcoin transaction malleability and MtGox. In European Symposium on Research in Computer Security, pages 313–326. Springer, 2014.
[13] A. Delignat-Lavaud. RSA signature forgery attack in NSS due to incorrect parsing of ASN.1 encoded DigestInfo. MITRE CVE-2014-1569, 2014.
[14] T. Dierks and C. Allen. The TLS 1.0 protocol. IETF RFC 2246, 1999.
[15] T. Dierks and E. Rescorla. The transport layer security (TLS) protocol version 1.2. IETF RFC 5246, 2008.
[16] K.-G. Doh, H. Kim, and D. A. Schmidt. Abstract LR-Parsing, pages 90–109. Springer Berlin Heidelberg, Berlin, Heidelberg, 2011.
[17] Z. Durumeric, F. Li, J. Kasten, J. Amann, et al. The Matter of Heartbleed. In Proceedings of the 2014 Internet Measurement Conference, pages 475–488. ACM, 2014.
[18] H. Finney. Bleichenbacher’s RSA signature forgery based on implementation error, 2006.
[19] P. Godefroid, M. Y. Levin, and D. Molnar. SAGE: whitebox fuzzing for security testing. Queue, 10(1):20, 2012.
[20] Google. Protocol buffers. github.com/protocolbuffers.
[21] R. D. Graham and P. C. Johnson. Finite state machine parsing for internet protocols: Faster than you think. In Security and Privacy Workshops (SPW), 2014 IEEE, pages 185–190. IEEE, 2014.
[22] G. Hutton. Higher-order functions for parsing. Journal of functional programming, 2(3):323–343, 1992.
[23] T. Jim and Y. Mandelbaum. Efficient Earley parsing with regular right-hand sides. Electr. Notes Theor. Comput. Sci., 253(7):135–148, 2010.
[24] T. Jim and Y. Mandelbaum. A new method for dependent parsing. In Programming Languages and Systems - 20th European Symposium on Programming (ESOP), pages 378–397, 2011.
[25] J.-H. Jourdan, F. Pottier, and X. Leroy. Validating LR(1) parsers. In Proceedings of the 21st European Conference on Programming Languages and Systems, ESOP’12, pages 397–416, Berlin, Heidelberg, 2012. Springer-Verlag.
[26] A. Koprowski and H. Binsztok. TRX: A formally verified parser interpreter. In European Symposium on Programming, pages 345–365. Springer, 2010.
[27] D. Leijen and E. Meijer. Parsec: Direct style monadic parser combinators for the real world. 2001.
[28] X. Leroy. Formal certification of a compiler back-end, or: programming a compiler with a proof assistant. In 33rd ACM symposium on Principles of Programming Languages, pages 42–54. ACM Press, 2006.
[29] O. Levillain. Parsifal: A pragmatic solution to the binary parsing problems. In 2014 IEEE Security and Privacy Workshops, pages 191–197, May 2014.
[30] A. Madhavapeddy and D. J. Scott. Unikernels: the rise of the virtual library operating system. Communications of the ACM, 57(1):61–69, 2014.
[31] G. Martínez, D. Ahman, V. Dumitrescu, N. Giannarakis, C. Hawblitzel, C. Hritcu, M. Narasimhamurthy, Z. Paraskevopoulou, C. Pit-Claudel, J. Protzenko, T. Ramananandro, A. Rastogi, and N. Swamy. Meta-F*: Proof automation with SMT, tactics, and metaprograms. In 28th European Symposium on Programming, 2019.
[32] N. Mavrogiannopoulos, F. Vercauteren, V. Velichkov, and B. Preneel. A cross-protocol attack on the TLS protocol. In Proceedings of the ACM Conference on Computer and Communications Security, pages 62–72, 10 2012.
[33] MongoDB. BSON. http://bsonspec.org/.
[34] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system. 2008.
[35] N. Nethercote and J. Seward. Valgrind: a framework for heavyweight dynamic binary instrumentation. In ACM Sigplan notices, volume 42, pages 89–100. ACM, 2007.
[36] G. Neufeld and S. Vuong. An overview of ASN.1. Computer Networks and ISDN Systems, 23(5):393–415, 1992.
[37] Y. Oiwa, K. Kobara, and H. Watanabe. A new variant for an attack against RSA signature verification using parameter field. In J. Lopez, P. Samarati, and J. L. Ferrer, editors, Public Key Infrastructure, pages 143–153, Berlin, Heidelberg, 2007. Springer Berlin Heidelberg.
[38] J. Protzenko, J.-K. Zinzindohoué, A. Rastogi, T. Ramananandro, P. Wang, S. Zanella-Béguelin, A. Delignat-Lavaud, C. Hriţcu, K. Bhargavan, C. Fournet, and N. Swamy. Verified low-level programming embedded in F*. PACMPL, 1(ICFP):17:1–17:29, Sept. 2017.
[39] A. Razaghpanah, A. Akhavan Niaki, N. Vallina-Rodriguez, S. Sundaresan, J. Amann, and P. Gill. TLS handshake data collected by Lumen, Sept. 2017. https://haystack.mobi/datasets.
[40] E. Rescorla. The transport layer security (TLS) protocol version 1.3. IETF RFC 8446, 2018.
[41] J. Salowey, H. Zhou, P. Eronen, and H. Tschofenig. Transport layer security (TLS) session resumption without server-side state. IETF RFC 5077, 2008.
[42] N. Schirmer. Verification of sequential imperative programs in Isabelle/HOL. PhD thesis, Technische Universität München, 2006.
[43] K. Serebryany. OSS-Fuzz: Google’s continuous fuzzing service for open source software. 2017.
[44] K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov. AddressSanitizer: A fast address sanity checker. In Usenix Annual Technical Conference (ATC12), pages 309–318, 2012.
[45] J. Somorovsky. Systematic fuzzing and testing of TLS libraries. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, pages 1492–1504. ACM, 2016.
[46] R. Srinivasan. XDR: External data representation. IETF RFC 1832, 1995.
[47] S. Suriyakarn, B. Delaware, A. Chlipala, et al. Narcissus: Deriving correct-by-construction decoders and encoders from binary formats. arXiv preprint arXiv:1803.04870, 2018.
[48] N. Swamy, C. Hriţcu, C. Keller, A. Rastogi, A. Delignat-Lavaud, S. Forest, K. Bhargavan, C. Fournet, P.-Y. Strub, M. Kohlweiss, J.-K. Zinzindohoué, and S. Zanella-Béguelin. Dependent types and multi-monadic effects in F*. In ACM Symposium on Principles of Programming Languages, pages 256–270, 2016. https://www.fstar-lang.org.
[49] F. Valsorda. Bleichenbacher’06 signature forgery in Python-RSA, 2016.
[50] P. Wuille et al. BIP62: Dealing with malleability, 2014.
[51] Q. Ye and B. Delaware. A verified protocol buffer compiler. In Proceedings of the 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, CPP 2019, pages 222–233, 2019.