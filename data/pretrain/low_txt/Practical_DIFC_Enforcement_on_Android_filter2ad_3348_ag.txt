### References

[10] **DEVELOPERS, S.**  
*SELinux Kernel ToDo.*  
https://github.com/SELinuxProject/selinux/wiki/Kernel-Todo, 2015.

[11] **DEVRIESE, D., AND PIESSENS, F.**  
*Noninterference through Secure Multi-Execution.*  
In *31st IEEE Symposium on Security and Privacy*, May 2010.

[12] **DIETZ, M., SHEKHAR, S., PISETSKY, Y., SHU, A., AND WALLACH, D. S.**  
*Quire: Lightweight Provenance for Smart Phone Operating Systems.*  
In *Proceedings of the USENIX Security Symposium*, 2011.

[28] **NADKARNI, A., AND ENCK, W.**  
*Preventing Accidental Data Disclosure in Modern Operating Systems.*  
In *Proceedings of the ACM Conference on Computer and Communications Security (CCS)*, 2013.

[13] **ENCK, W., GILBERT, P., CHUN, B.-G., COX, L. P., JUNG, J., MCDANIEL, P., AND SHETH, A. N.**  
*TaintDroid: An Information-Flow Tracking System for Realtime Privacy Monitoring on Smartphones.*  
In *Proceedings of the 9th USENIX Symposium on Operating Systems Design and Implementation (OSDI)*, 2010.

[14] **FELT, A. P., WANG, H. J., MOSHCHUK, A., HANNA, S., AND CHIN, E.**  
*Permission Re-Delegation: Attacks and Defenses.*  
In *Proceedings of the USENIX Security Symposium*, 2011.

[15] **GIFFIN, D. B., LEVY, A., STEFAN, D., TEREI, D., MAZIÈRES, D., MITCHELL, J. C., AND RUSSO, A. H.**  
*Hails: Protecting Data Privacy in Untrusted Web Applications.*  
In *Presented as part of the 10th USENIX Symposium on Operating Systems Design and Implementation (OSDI 12)*, 2012.

[16] **GRACE, M., ZHOU, Y., WANG, Z., AND JIANG, X.**  
*Systematic Detection of Capability Leaks in Stock Android Smartphones.*  
In *Proceedings of the ISCO Network and Distributed System Security Symposium*, 2012.

[17] **HORNYACK, P., HAN, S., JUNG, J., SCHECHTER, S., AND WETHERALL, D.**  
*These Aren’t the Droids You’re Looking For: Retrofitting Android to Protect Data from Imperious Applications.*  
In *Proceedings of the ACM Conference on Computer and Communications Security (CCS)*, 2011.

[18] **JEREMY EDER.**  
*Comprehensive Overview of Storage Scalability in Docker.*  
https://developerblog.redhat.com/2014/09/30/overview-storage-scalability-docker/, 2014.

[19] **JIA, L., ALJURAIDAN, J., FRAGKAKI, E., BAUER, L., STROUCKEN, M., FUKUSHIMA, K., KIYOMOTO, S., AND MIYAKE, Y.**  
*Run-Time Enforcement of Information-Flow Properties on Android (Extended Abstract).*  
In *Proceedings of the European Symposium on Research in Computer Security (ESORICS)*, 2013.

[20] **KROHN, M., AND TROMER, E.**  
*Noninterference for a Practical DIFC-Based Operating System.*  
In *Proceedings of the IEEE Symposium on Security and Privacy*, 2009.

[21] **KROHN, M., YIP, A., BRODSKY, M., CLIFFER, N., KAASHOEK, M. F., KOHLER, E., AND MORRIS, R.**  
*Information Flow Control for Standard OS Abstractions.*  
In *Proceedings of the ACM Symposium on Operating Systems Principles (SOSP)*, 2007.

[22] **LAGEMAN, M., AND SOLUTIONS, S. C.**  
*Solaris Containers: What They Are and How to Use Them.*

[23] **MCILROY, M. D., AND REEDS, J. A.**  
*Multilevel Security in the UNIX Tradition.*  
*Software: Practice and Experience*, 1992.

[24] **MERKEL, D.**  
*Docker: Lightweight Linux Containers for Consistent Development and Deployment.*  
*Linux Journal*, 2014.

[25] **MYERS, A. C.**  
*JFlow: Practical Mostly-Static Information Flow Control.*  
In *Proceedings of the ACM Symposium on Principles of Programming Languages (POPL)*, 1999.

[26] **MYERS, A. C., AND LISKOV, B.**  
*A Decentralized Model for Information Flow Control.*  
In *Proceedings of the ACM Symposium on Operating Systems Principles (SOSP)*, 1997.

[27] **MYERS, A. C., AND LISKOV, B.**  
*Protecting Privacy Using the Decentralized Label Model.*  
*ACM Transactions on Software Engineering and Methodology*, 2000.

[29] **NEIL BROWN.**  
*Overlay Filesystem.*  
https://www.kernel.org/doc/Documentation/filesystems/overlayfs.txt, 2013.

[30] **PORTER, D. E., BOND, M. D., ROY, I., MCKINLEY, K. S., AND WITCHEL, E.**  
*Practical Fine-Grained Information Flow Control Using Laminar.*  
*ACM Trans. Program. Lang. Syst.*, November 2014.

[31] **REPS, T. W.**  
*Program Analysis via Graph Reachability.*  
*Information & Software Technology*, 40(11-12), 1998.

[32] **RODEH, O., BACIK, J., AND MASON, C.**  
*BTRFS: The Linux B-Tree Filesystem.*  
*ACM Transactions on Storage (TOS)*, August 2013.

[33] **ROY, I., PORTER, D. E., BOND, M. D., MCKINLEY, K. S., AND WITCHEL, E.**  
*Laminar: Practical Fine-Grained Decentralized Information Flow Control.*  
In *Proceedings of the Conference on Programming Language Design and Implementation (PLDI)*, 2009.

[34] **SAMSUNG ELECTRONICS.**  
*An Overview of Samsung Knox.*  
http://www.samsung.com/global/business/business-images/resource/white-paper/2014/02/Samsung_KNOX_whitepaper_June-0-0.pdf, 2013.

[35] **SCHAUFLER, C.**  
*LSM: Multiple Concurrent LSMs.*  
https://lkml.org/lkml/2013/7/25/482, 2013.

[36] **SHARIR, M., AND PNUELI, A.**  
*Two Approaches to Interprocedural Data Flow Analysis.*  
In *Program Flow Analysis: Theory and Applications*, 1981.

[37] **SHIVERS, O.**  
*Control-Flow Analysis of Higher-Order Languages.*  
PhD thesis, Carnegie Mellon University, Pittsburgh, PA, 1991.

[38] **SPAHN, R., BELL, J., LEE, M., BHAMIDIPATI, S., GEAMBASU, R., AND KAISER, G.**  
*Pebbles: Fine-Grained Data Management Abstractions for Modern Operating Systems.*  
In *Proceedings of the USENIX Operating Systems Design and Implementation (OSDI)*, 2014.

[39] **STATISTA.**  
*Number of Applications Available in the Google Play Store from December 2009 to February 2016.*  
http://www.statista.com/statistics/266210/number-of-available-applications-in-the-google-play-store/.

[40] **STEFAN, D., RUSSO, A., MITCHELL, J. C., AND MAZIÈRES, D.**  
*Flexible Dynamic Information Flow Control in Haskell.*  
In *Proceedings of the 4th ACM Symposium on Haskell (Haskell '11)*, 2011.

[41] **STEFAN, D., YANG, E. Z., MARCHENKO, P., RUSSO, A., HERMAN, D., KARP, B., AND MAZIÈRES, D.**  
*Protecting Users by Confining JavaScript with COWL.*  
In *11th USENIX Symposium on Operating Systems Design and Implementation (OSDI 14)*, October 2014.

[42] **STEFAN, H., STEFAN, D., YANG, E. Z., RUSSO, A., AND MITCHELL, J. C.**  
*IFC Inside: Retrofitting Languages with Dynamic Information Flow Control.*  
In *Proceedings of the 4th Conference on Principles of Security and Trust (POST 2015)*, 2015.

[43] **TANG, Y., AMES, P., BHAMIDIPATI, S., BIJLANI, A., GEAMBASU, R., AND SARDA, N.**  
*CleanOS: Limiting Mobile Data Exposure with Idle Eviction.*  
In *Proceedings of the USENIX Symposium on Operating Systems Design and Implementation (OSDI)*, 2012.

[44] **VANDEBOGART, S., EFSTATHOPOULOS, P., KOHLER, E., KROHN, M., FREY, C., ZIEGLER, D., KAASHOEK, F., MORRIS, R., AND MAZIÈRES, D.**  
*Labels and Event Processes in the Asbestos Operating System.*  
*ACM Transactions on Computer Systems (TOCS)*, 2007.

[45] **WALSH, D.**  
*SELinux/OverlayFS Integration.*  
https://twitter.com/rhatdan/status/588338475084029953, 2015.

[46] **XU, Y., AND WITCHEL, E.**  
*Maxoid: Transparently Confining Mobile Applications with Custom Views of State.*  
In *Proceedings of the Tenth European Conference on Computer Systems (EuroSys)*, 2015, ACM.

[47] **YANG, J., HANCE, T., AUSTIN, T. H., SOLAR-LEZAMA, A., FLANAGAN, C., AND CHONG, S.**  
*End-To-End Policy-Agnostic Security for Database-Backed Applications.*  
*arXiv preprint arXiv:1507.03513*, 2015.

[48] **YANG, J., YESSENOV, K., AND SOLAR-LEZAMA, A.**  
*A Language for Automatically Enforcing Privacy Policies.*  
In *Proceedings of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL)*, 2012.

[49] **ZELDOVICH, N., BOYD-WICKIZER, S., KOHLER, E., AND MAZIÈRES, D.**  
*Making Information Flow Explicit in HiStar.*  
In *Proceedings of the 7th Symposium on Operating Systems Design and Implementation (OSDI)*, 2006.

[50] **ZELDOVICH, N., BOYD-WICKIZER, S., AND MAZIÈRES, D.**  
*Securing Distributed Systems with Information Flow Control.*  
In *Proceedings of the USENIX Symposium on Networked Systems Design and Implementation (NSDI)*, 2008.

### Component Polyinstantiation Logic

In this section, we describe Weir's modifications to the Activity Manager service's component and process assignment logic. Figure 8 illustrates the workflow inside the Activity Manager when a component \( C \) is called. The shaded blocks represent Weir's label checks and polyinstantiation logic. The figure outlines the high-level steps followed by the Activity Manager, which are common to all components.

When a call arrives, Weir first retrieves the label for the caller's process from the kernel and stores it in `callerLabel`. The Activity Manager then resolves the target component \( C \) using the information in the call. At this point, the Activity Manager only knows the name and type of the target component (e.g., a content provider \( C \)).

The Activity Manager then checks if there is a running instance of \( C \) in its records. If a runtime instance exists and is executing in a process with a matching label, the call is delivered to the running instance. Otherwise, Weir forces the Activity Manager to create a new runtime instance for the `callerLabel`.

Without Weir, the Activity Manager would always deliver the call to the existing instance.5 Weir modifies the Activity Manager's internal bookkeeping structures to be consistent with its polyinstantiation; i.e., it enables the Activity Manager to manage multiple runtime records for the same component. For example, the Activity Manager uses a direct mapping between a service's name and its runtime instance to store records of running services. Weir modifies this mapping to one between the name and a set of services.

At this stage, the system has a new component instance that needs to be executed in a process. The Activity Manager selects the process based on the `processName` extracted from the `android:process` manifest attribute. A runtime record of the resolved process \( P \) is then sent to Weir for process matching (i.e., the `Match Weir Proc (P, callerLabel)` subroutine). Weir first checks the label of the existing process \( P \), and if it matches, returns \( P \) itself. If not, Weir retrieves its internal list of processes associated with \( P \). This list includes the processes that were created in the past to be assigned instead of \( P \) for specific caller labels. Weir checks if the list contains a process with a label matching the current `callerLabel`; this step ensures that components with the same `processName` and `callerLabel` are executed in the same process. If Weir fails to find a matching process in the list, it allocates a new process for the `callerLabel` and adds it to the list of existing processes mapped to the specific `processName`. This process is then returned as \( P \) to the Activity Manager. The Activity Manager then starts \( P \), if it is not already started, and Weir sets its label in the kernel. Note that if the process is already started (i.e., the original \( P \) was matching, or a matching process was found in Weir's `pList (P.processName)`), the Activity Manager does not restart it. Finally, the component instance is executed in the assigned process, and the call is delivered to it.

5 Except in the case of standard and multi-process activities.

---

This version of the text is more structured and coherent, with clearer references and a more professional tone.