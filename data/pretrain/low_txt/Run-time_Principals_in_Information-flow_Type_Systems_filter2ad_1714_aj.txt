### Acknowledgments

We would like to express our gratitude to Geoffrey Washburn, Stephanie Weirich, and the anonymous reviewers for their valuable suggestions and comments on earlier drafts of this work. This research was partially supported by NSF grants CCR-0311204 (Dynamic Security Policies) and CNS-0346939 (CAREER: Language-based Distributed System Security).

### References

1. Abadi, M. 1998. On SDSI’s linked local name spaces. *Journal of Computer Security* 6(1-2): 3–21.
   
2. Abadi, M., Banerjee, A., Heintze, N., and Riecke, J. 1999. A core calculus of dependency. In *Proc. 26th ACM Symp. on Principles of Programming Languages (POPL)*, San Antonio, TX, 147–160.

3. Abadi, M., Burrows, M., Lampson, B. W., and Plotkin, G. D. 1993. A calculus for access control in distributed systems. *Transactions on Programming Languages and Systems* 15(4): 706–734.

4. Agat, J. 2000. Transforming out timing leaks. In *Proc. 27th ACM Symp. on Principles of Programming Languages (POPL)*, Boston, MA, 40–53.

5. Aspinall, D. 1994. Subtyping with Singleton Types. In *Computer Science Logic*, 1–15.

6. Banerjee, A. and Naumann, D. A. 2002. Secure information flow and pointer confinement in a Java-like language. In *Proc. of the 15th IEEE Computer Security Foundations Workshop*, 253–267.

7. Banerjee, A. and Naumann, D. A. 2003. Using access control for secure information flow in a Java-like language. In *Proc. of the 16th IEEE Computer Security Foundations Workshop*. IEEE Computer Society Press, 155–169.

8. Chothia, T., Duggan, D., and Vitek, J. 2003. Type-Based Distributed Access Control. In *Proc. of the IEEE Computer Security Foundations Workshop*, 170.

9. Crary, K., Kliger, A., and Pfenning, F. 2004. A monadic analysis of information flow security with mutable state. *Journal of Functional Programming* 15(2): 249–291.

10. Crary, K., Walker, D., and Morrisett, G. 1999. Typed memory management in a calculus of capabilities. In *Proc. 26th ACM Symp. on Principles of Programming Languages (POPL)*, San Antonio, Texas, 262–275.

11. Crary, K., Weirich, S., and Morrisett, G. 2002. Intensional polymorphism in type erasure semantics. *Journal of Functional Programming* 12(6): 567–600.

12. Fournet, C. and Gordon, A. 2002. Stack inspection: Theory and variants. In *Proc. 29th ACM Symp. on Principles of Programming Languages (POPL)*, 307–318.

13. Gasser, M. and McDermott, E. 1990. An architecture for practical delegation in a distributed system. In *Proc. IEEE Symposium on Security and Privacy*. IEEE Computer Society Press, 20–30.

14. Goguen, J. A. and Meseguer, J. 1982. Security policies and security models. In *Proc. IEEE Symposium on Security and Privacy*. IEEE Computer Society Press, 11–20.

15. Gunter, C. A. and Jim, T. 2000. Generalized certificate revocation. In *Proc. 27th ACM Symp. on Principles of Programming Languages (POPL)*. ACM Press, Boston, Massachusetts, 316–329.

16. Heintze, N. and Riecke, J. G. 1998. The SLam calculus: Programming with secrecy and integrity. In *Proc. 25th ACM Symp. on Principles of Programming Languages (POPL)*, San Diego, California, 365–377.

17. Howell, J. and Kotz, D. 2000. End-to-end authorization. In *Proc. USENIX Symp. on Operating Systems Design and Implementation (OSDI)*, 151–164.

18. Jim, T. 2001. SD3: a trust management system with certificate revocation. In *IEEE Symposium on Security and Privacy*, 106–115.

19. Jouvelot, P. and Gifford, D. K. 1991. Algebraic reconstruction of types and effects. In *ACM Symposium on Principles of Programming Languages*, 303–310.

20. Li, P., Mao, Y., and Zdancewic, S. 2003. Information integrity policies. In *Proceedings of the Workshop on Formal Aspects in Security & Trust (FAST)*, 53–70.

21. Mitchell, J. C. 1996. *Foundations for Programming Languages*. Foundations of Computing Series. The MIT Press.

22. Myers, A. C., Chong, S., Nystrom, N., Zheng, L., and Zdancewic, S. 1999. Jif: Java information flow.

23. Myers, A. C. and Liskov, B. 1998. Complete, safe information flow with decentralized labels. In *Proc. IEEE Symposium on Security and Privacy*, Oakland, CA, USA, 186–197.

24. Myers, A. C. and Liskov, B. 2000. Protecting privacy using the decentralized label model. *ACM Transactions on Software Engineering and Methodology* 9(4): 410–442.

25. Myers, A. C., Sabelfeld, A., and Zdancewic, S. 2004. Enforcing Robust Declassification. In *Proc. of the IEEE Computer Security Foundations Workshop*, 172–186.

26. Myers, A. C., Sabelfeld, A., and Zdancewic, S. 2006. Enforcing robust declassification and qualified robustness. *ACM Transactions on Software Engineering and Methodology* 14(2): 157–196.

27. Pierce, B. C. 2002. *Types and Programming Languages*. MIT Press.

28. Pitts, A. 1998. Existential Types: Logical Relations and Operational Equivalence. In *International Colloquium on Automata, Languages and Programming*, 309–326.

29. Pottier, F. and Conchon, S. 2000. Information flow inference for free. In *Proc. 5th ACM SIGPLAN International Conference on Functional Programming (ICFP)*, 46–57.

30. Pottier, F. and Simonet, V. 2002. Information flow inference for ML. In *Proc. 29th ACM Symp. on Principles of Programming Languages (POPL)*, Portland, Oregon, 319–330.

31. Pottier, F., Skalka, C., and Smith, S. F. 2001. A Systematic Approach to Static Access Control. In *European Symposium on Programming*, 344–382.

32. Sabelfeld, A. and Myers, A. C. 2003. Language-based information-flow security. *IEEE Journal on Selected Areas in Communications* 21(1): 5–19.

33. Sabelfeld, A. and Sands, D. 2001. A PER model of secure information flow in sequential programs. *Higher-Order and Symbolic Computation* 14(1): 59–91.

34. Simonet, V. 2003. Flow Caml in a nutshell. In *Proceedings of the first APPSEM-II workshop*, edited by G. Hutton, 152–165.

35. Simonet, V. and Pottier, F. 2004. Constraint-Based Type Inference with Guarded Algebraic Data Types. Submitted to *ACM Transactions on Programming Languages and Systems*.

36. Tse, S. and Zdancewic, S. 2004. Run-time Principals in Information-flow Type Systems. In *IEEE Symposium on Security and Privacy*.

37. Tse, S. and Zdancewic, S. 2005. Designing a Security-typed Language with Certificate-based Declassification. In *European Symposium on Programming*.

38. Volpano, D., Smith, G., and Irvine, C. 1996. A sound type system for secure flow analysis. *Journal of Computer Security* 4(3): 167–187.

39. Wadler, P. 1989. Theorems for Free! In *ACM Functional Programming Languages and Computer Architecture*, 347–359.

40. Wallach, D. S., Appel, A. W., and Felten, E. W. 2000. The security architecture formerly known as stack inspection: A security mechanism for language-based systems. *ACM Transactions on Software Engineering and Methodology* 9(4): 341–378.

41. Wallach, D. S. and Felten, E. W. 1998. Understanding Java stack inspection. In *Proc. IEEE Symposium on Security and Privacy*, Oakland, California, USA, 52–63.

42. Zdancewic, S. 2003. A type system for robust declassification. In *Proceedings of the Nineteenth Conference on the Mathematical Foundations of Programming Semantics*. *Electronic Notes in Theoretical Computer Science*.

43. Zdancewic, S. and Myers, A. C. 2001. Secure information flow and CPS. In *Proc. of the 10th European Symposium on Programming*. Lecture Notes in Computer Science, vol. 2028, 46–61.

44. Zdancewic, S. and Myers, A. C. 2002. Secure information flow via linear continuations. *Higher Order and Symbolic Computation* 15(2/3): 209–234.

45. Zheng, L. and Myers, A. C. 2004. Dynamic Security Labels and Noninterference. In *Formal Aspects in Security and Trust*.

### Full Syntax of λRP

**Principals**
- \( p ::= \alpha \)
- \( X ::= \cdot \mid p, s \)
- \( s ::= \cdot \mid p : s \)
- \( c ::= \cdot \mid c; d \)
- \( d ::= \{d!s\} \)
- \( l ::= \cdot \mid p \)
- \( \Delta ::= \cdot \mid \Delta, p \sqsubseteq p \)
- \( A ::= \cdot \mid A, X \sqsubseteq X \)
- \( \Gamma ::= \cdot \mid \Gamma, x : t \)
- \( \pi ::= \cdot \mid \delta, \alpha \mapsto X \)
- \( \delta ::= \cdot \mid \gamma, x \mapsto v \)
- \( \gamma ::= \cdot \mid \gamma, x \mapsto v \)

**Security Types**
- \( t ::= u^l \)
- \( u ::= 1 \mid t + t \mid [π] t → t \mid ∀α \sqsubseteq p. t \mid ∃α \sqsubseteq p. t \mid Pp \mid C \)

**Values**
- \( v ::= * \mid \text{inl } v \mid \text{inr } v \mid \lambda x: t. e \mid \Lambda \alpha \sqsubseteq p. e \mid \text{pack}(p \sqsubseteq q, e) \mid X \mid \text{let}(X_1 \sqsubseteq X_2) \text{ in } v \mid X\{i\} \)

**Terms**
- \( e ::= v \mid x \mid \text{inl } e \mid \text{inr } e \mid \text{case } e \mid v \mid v \mid e \, e \mid e [p] \mid \text{open}(\alpha, x) = e \text{ in } e \mid \text{if } (e \sqsubseteq e) \, e \, e \mid \text{let } (e \sqsubseteq e) \text{ in } e \mid \text{if } (e \Rightarrow e . i) \, e \, e \mid \text{declassify } e \, t \mid \text{endorse } e \, p \mid \text{acquire } e . i \)

**Privileges**
- \( i ::= \text{declassify} \mid \text{endorse} \mid \text{delegate}_{p \sqsubseteq p} \)

This syntax provides a comprehensive framework for understanding and implementing run-time principals in information-flow type systems.