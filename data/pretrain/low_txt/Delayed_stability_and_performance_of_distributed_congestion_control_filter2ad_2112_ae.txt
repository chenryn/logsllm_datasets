### Optimized Text

For each packet arriving within the current interval \(\Delta\), the router inserts feedback information, computed during the previous interval \(\Delta\), into the packet header. Consequently, the feedback is delayed by \(\Delta\) time units inside the router, in addition to any backward directional delays \(D_{\leftarrow}\). Since MKC (Max-Min Kelly Control) is robust to feedback delay, this extra \(\Delta\) time units does not affect the stability of the system. Further implementation details are provided below.

During the interval \(\Delta\), the router maintains a local variable \(S\), which tracks the total amount of data that has arrived into the queue (including dropped packets) since the beginning of the interval. Specifically, for each incoming packet \(k\) from flow \(i\), the router increments \(S\) by the size of the packet: \(S = S + s_i(k)\). Additionally, the router checks whether its locally recorded estimate \(\tilde{p}\) of packet loss (computed in the previous interval \(\Delta\)) is greater than the one carried in the packet. If so, the router overrides the corresponding entries in the packet and places its own router ID, packet loss, and sequence number into the header. This ensures that, after traversing the entire path, each packet records information from the most congested link.

At the end of the interval \(\Delta\), the router approximates the combined arriving rate \(X(n)\) by averaging \(S\) over the interval \(\Delta\):

\[
\tilde{X} = \frac{S}{\Delta}.
\]

Based on this information, the router computes an estimate of packet loss \(\tilde{p}\) as follows:

\[
\tilde{p} = \frac{\tilde{X} - C}{\tilde{X}},
\]

where \(C\) is the capacity of the outgoing link known to the router (these functions are performed on a per-queue basis).

After computing \(\tilde{p}\), the router increments its packet-loss sequence number (i.e., \(seq = seq + 1\)) and resets variable \(S\) to zero. The newly computed values \(seq\) and \(\tilde{p}\) are then inserted into qualified packets arriving during the next interval \(\Delta\) and are subsequently fed back by the receiver to the sender. The sender adjusts its sending rate based on this feedback, as discussed in the next section.

### User-Side Implementation of MKC

MKC employs the primal algorithm (12)-(13) at the end-users, who adjust their sending rates based on the packet loss generated by the most congested resources along their paths. However, to properly implement MKC, the following issues need to be addressed.

First, note that ACKs carrying feedback information continuously arrive at the end-user and often contain duplicate feedback (assuming \(\Delta\) is sufficiently large). To prevent the user from responding to redundant or obsolete feedback caused by reordering, each packet carries a sequence number \(seq\), which is modified by the bottleneck router and echoed by the receiver to the sender. Each end-user \(i\) maintains a local variable \(seq_i\), which records the largest value of \(seq\) observed by the user so far. Thus, for each incoming ACK with sequence \(seq\), the user responds if and only if \(seq > seq_i\). This allows MKC senders to pace their control actions such that their rate adjustments and the router's feedback occur on the same timescale.

Second, recall from (12)-(13) that MKC requires both the delayed feedback \(\eta_i(n)\) and the delayed reference rate \(x_i(n - D_i)\) when deciding the next sending rate. The next problem to address is how to correctly implement the control equation (12). We develop two strategies for this problem below.

#### Naive Implementation

One straightforward option is to directly follow (12) based on the rate that was in effect exactly \(D_i\) time units earlier. Since round-trip delays fluctuate, the most reliable way to determine \(x_i(n - D_i)\) is to carry this information in the user field of each packet (see Figure 9). When the receiver echoes the router field to the sender, it also copies the user field into the acknowledgment. We show the performance of this strategy via ns2 simulations in Figure 10(a), where a single MKC flow passes through a bottleneck link of capacity 10 mb/s. We set \(\alpha\) to 100 kb/s, \(\beta\) to 0.9, packet size to 200 bytes, and router sampling interval \(\Delta\) to 50 ms. As seen in Figure 10(a), the sending rate converges to its stationary point in less than 2 seconds and does not exhibit oscillations in the steady state; however, the flow exhibits transient oscillations and overshoots \(C\) by over 200% in the first quarter of a second. Although this transient behavior does not affect the stability of the system, it is highly undesirable from a practical standpoint.

#### Proper Implementation

To remove the transient oscillations, we first need to understand how they are created. Notice from (57)-(58) that since the router calculates the packet loss based on the average incoming rate over interval \(\Delta\), it is possible that packets of different sending rates \(x_i(n_1)\) and \(x_i(n_2)\) arrive at the router during the same interval \(\Delta\). Denote by \(T_i(n)\) the time when user \(i\) receives the \(n\)-th non-duplicate feedback \(p(n)\). Since the user responds to each feedback only once, it computes new sending rates \(x_i(n)\) at time instances \(T_i(n)\).

To better understand the dynamics of a typical AQM control loop, consider the illustration in Figure 10(b). In the figure, the router generates feedback \(p(n - 1)\) and \(p(n)\) exactly \(\Delta\) units apart. This feedback is randomly delayed by \(D_{\leftarrow}\) time units and arrives at the user at instances \(T_i(n - 1)\) and \(T_i(n)\), respectively. In response to the first feedback, the user changes its rate from \(x_i(n - 2)\) to \(x_i(n - 1)\); however, the router observes the second rate only at time \(T_i(n - 1) + D_{\rightarrow}\). At the end of the \(n\)-th interval \(\Delta\), the router averages both rates \(x_i(n - 2)\) and \(x_i(n - 1)\) to produce its feedback \(p(n)\) as shown in the figure.

When the control loop is completed, the user is misled to believe that feedback \(p(n)\) refers to a single rate \(x(n - 1)\) and is forced to incorrectly compute \(x(n)\). This inconsistency is especially pronounced in the first few control steps, during which the flows increase their rates exponentially, and the error between the actual rate and the reference rate is large.

Instead of changing the router, we modify the end-users to become more sophisticated in their processing of network feedback. The key is to allow end-users to accurately estimate their own contribution to \(\tilde{X}\) and determine their average rates seen by the router during interval \(\Delta\). For each outgoing packet \(k\), MKC sender \(i\) places the packet’s sequence number \(k\) in the user field and records in local memory the size of the packet \(s_i(k)\) and its sequence number \(k\). Upon arrival of the \(n\)-th non-duplicate feedback at time \(T_i(n)\), the end-flow extracts the user field from the acknowledgment and records its value in variable \(z_i(n)\), which is the sequence number of the packet that generated feedback \(p(n)\). To compute the new rate \(x_i(n)\), the user calculates the amount of data that it has transmitted between packets \(z_i(n - 1)\) and \(z_i(n) - 1\) and normalizes the sum by \(\Delta\), which is exactly the average rate used by the router in generating \(p(n)\).

To visualize this description, consider Figure 11(a), where the end-flow is about to decide its sending rate \(x_i(n)\) at time \(T_i(n)\). Notice in the figure that feedback \(p(n)\) is based on all packets of flow \(i\) with sequence numbers between \(z_i(n - 1)\) and \(z_i(n) - 1\). Through the use of \(z_i(n)\), we obtain a projection of the time-interval used by the router in its computation of \(p(n)\) onto the sequence-number axis of the end user. Given the above discussion, the user computes its average rate as:

\[
\bar{x}_i(n) = \frac{1}{\Delta} \sum_{k=z_i(n-1)}^{z_i(n)-1} s_i(k),
\]

and utilizes it in its control equation:

\[
x_i(n) = \bar{x}_i(n) + \alpha - \beta \eta_i(n) \bar{x}_i(n).
\]

Next, we examine the performance of this strategy with a single flow in the ns2 simulation in Figure 11(b). The figure shows that (59)-(60) successfully eliminates transient oscillations and offers fast, monotonic convergence to the steady state. Our next example shows the performance of the new method (59)-(60) with multiple flows. The simulation topology of this example is illustrated in Figure 12(a): four EMKC flows identical to those in Figure 10(a) share the same bottleneck link of capacity 10 mb/s. The round trip delays of the four flows are 50 ms, 60 ms, 70 ms, and 80 ms, respectively, and the sampling intervals \(\Delta\) of routers C1-C5 are 120 ms, 140 ms, 160 ms, 180 ms, and 100 ms, respectively. At time 0, the first flow starts at 125 kb/s and monotonically converges to bottleneck capacity in less than 0.4 seconds, as seen in Figure 12(b). Five seconds later, the second flow joins at an initial rate of 150 kb/s. The figure shows that the system is immediately re-stabilized in the new stationary point, and the individual flows quickly converge to fairness without oscillations. This behavior is repeated when the other two flows join the network, and the system regains stability and fairness with ideal performance (i.e., monotonically).

### Conclusion

This paper investigates the properties of Internet congestion controls under non-negligible directional feedback delays. We focus on the class of control methods with symmetric Jacobians and show that all such systems are stable under heterogeneous delays. To construct a practical congestion control system with a symmetric Jacobian, we made two changes to the classic discrete Kelly control and created a max-min version called MKC. Combining MKC with a negative packet-loss feedback, we developed a new controller, EMKC, and showed in theory and simulations that it offers smooth sending rates and fast convergence to efficiency. Furthermore, we demonstrated that EMKC’s convergence rate to fairness is exponential when the network provider scales the number of flows \(N\) as \(\Theta(C)\) and linear otherwise. From an implementation standpoint, EMKC places very little burden on routers, requiring only two local variables per queue and one addition per arriving packet, and allows for easy implementation in both end-to-end environments and under AQM support. Future work involves improving the convergence speed to fairness and designing pricing schemes for EMKC to achieve loss-free performance regardless of the number of flows \(N\).

### References

[1] R. Bronson. Schaum’s Outline of Theory and Problems of Matrix Operations. McGraw-Hill, 1988.
[2] D.-M. Chiu and R. Jain, “Analysis of the Increase and Decrease Algorithms for Congestion Avoidance in Computer Networks,” Computer Networks and ISDN Systems, 17(1):1–14, June 1989.
[3] M. Dai and D. Loguinov, “Analysis of Rate-Distortion Functions and Congestion Control in Scalable Internet Video Streaming,” ACM NOSSDAV, June 2003.
[10] K. Kar, S. Sarkar, and L. Tassiulas, “A Simple Rate Control Algorithm for Maximizing Total User Utility,” IEEE INFOCOM, April 2001.
[11] D. Katabi, M. Handley, and C. Rohrs, “Congestion Control for High Bandwidth Delay Product Networks,” ACM SIGCOMM, August 2002.
[12] W. G. Kelley and A. C. Peterson. Difference Equations. Harcourt / Academic Press, 2001.
[13] F. P. Kelly, “Charging and Rate Control for Elastic Traffic,” European Transactions on Telecommunications, 8(1):33–37, January 1997.
[14] F. P. Kelly, A. K. Maulloo, and D. K. H. Tan, “Rate Control for Communication Networks: Shadow Prices, Proportional Fairness and Stability,” Journal of the Operational Research Society, 49(3):237–252, March 1998.
[15] T. Kelly, “Scalable TCP: Improving Performance in High-speed Wide Area Networks,” First International Workshop on Protocols for Fast Long-Distance Networks, February 2003.
[16] S. Kunniyur and R. Srikant, “Analysis and Design of an Adaptive Virtual Queue (AVQ) Algorithm for Active Queue Management,” ACM SIGCOMM, August 2001.
[17] S. Kunniyur and R. Srikant, “A Time-Scale Decomposition Approach to Adaptive Explicit Congestion Notification (ECN) Marking,” IEEE Transactions on Automatic Control, 47(6):882 – 894, June 2002.
[18] S. Kunniyur and R. Srikant, “End-to-End Congestion Control Schemes: Utility Functions, Random Losses and ECN Marks,” IEEE/ACM Transactions on Networking, 11(5):689 – 702, October 2003.
[19] S. Kunniyur and R. Srikant, “Stable, Scalable, Fair Congestion Control and AQM Schemes that Achieve High Utilization in the Internet,” IEEE Transactions on Automatic Control, 48(11):2024–2029, November 2003.
[20] C.-K. Li and R. Mathias, “The Determinant of the Sum of Two Matrices,” Bull. Australian Math. Soc., 52(3):425–429, 1995.
[21] D. Loguinov and H. Radha, “End-to-End Rate-Based Congestion Control: Convergence Properties and Scalability Analysis,” IEEE/ACM Transactions on Networking, 11(5):564–577, August 2003.
[22] S. H. Low, “A Duality Model of TCP and Queue Management Algorithms,” IEEE/ACM Transactions on Networking, 11(4):525–536, August 2003.
[23] S. H. Low and D. E. Lapsley, “Optimization Flow Control I: Basic Algorithm and Convergence,” IEEE/ACM Transactions on Networking, 7(6):861–874, December 1999.
[24] L. Massoulié, “Stability of Distributed Congestion Control with Heterogeneous Feedback Delays,” IEEE/ACM Transactions on Networking, 47(6):895–902, June 2002.
[25] F. Paganini, J. Doyle, and S. H. Low, “A Control Theoretical Look at Internet Congestion Control,” The Mohammed Dahleh Symposium, 2002.
[4] S. Deb and R. Srikant, “Global Stability of Congestion Control with Heterogeneous Feedback Delays,” IEEE/ACM Transactions on Networking, 11(5):689 – 702, October 2003.
[26] G. Vinnicombe, “On the Stability of End-to-End Controllers for the Internet,” IEEE Transactions on Automatic Control, 48(6):1055 – 1060, June 2003.
[5] S. Floyd, “High-speed TCP for Large Congestion Windows,” RFC 3649, December 2003.
[6] S. Floyd, M. Handley, J. Padhye, and J. Widmer, “Equation-Based Congestion Control for Unicast Applications,” ACM SIGCOMM, August 2000.
[7] S. Floyd and V. Jacobson, “Random Early Detection Gateways for Congestion Avoidance,” IEEE/ACM Transactions on Networking, 1(4):397–413, January 1993.
[8] C. Jin, D. Wei, and S. H. Low, “FAST TCP: Motivation, Architecture, Algorithms, Performance,” IEEE INFOCOM, March 2004.
[9] R. Johari and D. K. H. Tan, “End-to-End Congestion Control for the Internet: Delays and Stability,” Technical Report CUED/F-INFENG/TR.398, University of Cambridge, December 2000.
[27] G. Vinnicombe, “Robust Congestion Control for the Internet,” Technical report, University of Cambridge, 2002.
[28] L. Xu, K. Harfoush, and I. Rhee, “Binary Increase Congestion Control for Fast, Long Distance Networks,” IEEE INFOCOM, March 2004.
[29] Y. R. Yang and S. S. Lam, “General AIMD Congestion Control,” IEEE ICNP, November 2000.
[30] L. Ying, G. E. Dullerud, and R. Srikant, “Global Stability of Internet Congestion Control with Heterogeneous Delays,” American Control Conference, June 2004.
[31] Y. Zhang, S.-R. Kang, and D. Loguinov, “Delayed Stability and Performance of Distributed Congestion Control (extended version),” Texas A&M Technical Report, August 2004.