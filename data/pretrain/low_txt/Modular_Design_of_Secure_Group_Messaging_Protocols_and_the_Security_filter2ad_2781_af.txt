### Store Key Bundle of a Contact
- **Function**: `Get-KB(ID', kb)`
- **Process**:
  - Extract the key bundle: `(wpk, spk, sig) â† kb`
  - Verify the static public key: `req spk âˆˆ CL-S[ID']`
  - Verify the signature: `req S-Ver(spk, wpk, sig)`
  - Enqueue the key pair in the contact list: `CL-KB[ID'].enq((wpk, spk))`

### Set Callerâ€™s ID
- **Assignment**: `ME â† ID`

### Stored Signature Keys
- **Initialization**: `SK-sk[.] â† ğœ€`

### Stored Welcome Keys
- **Initialization**: `WK-wk[.] â† ğœ€`

### Contact List
- **Initialization**: `CL-KB[.] â† ğœ€`

### Group Specific State
- **Buffered Proposals**: `s.Props[.] â† ğœ€`
- **Roster**: `s.G â† [.]`
- **CGKA State**: `s.ğ›¾ â† ğœ€`
- **PRF-PRG State**: `s.ğœ â† ğœ€`
- **FS-GAEAD States**: `s.ğ‘£[.] â† ğœ€`
- **Current Epoch ID**: `s.C-epid â† ğœ€`
- **My Signature Key**: `s.C-ssk â† ğœ€`
- **Verification Keys**: `s.Ep-SPK[., .] â† ğœ€`
- **MAC Key**: `s.km â† ğœ€`

### Figure 6: The SGM Construction: Initialization and PKI Algorithms

### Function to Determine if Authenticity of Epoch is Compromised
- **Function**: `*auth-compr(vid)`
- **Return**: `return Â¬*PP-secure(vid, *Proj-PP(SGM-Data))`

### Function to Determine if IDâ€™s Signature Key is Compromised in Epoch
- **Function**: `*SK-compr(vid, ID)`
- **Check**: `chk HG.getSKIDs(vid, ID) âˆ© SK-Lk = âˆ…`

### Privacy Predicate
- **Function**: `*AM-sec (vid, S, ğ‘–)`
- **Condition**:
  - If the privacy predicate is secure: 
    - `if *PP-secure(vid, *Proj-PP(SGM-Data))`
    - `return *FS-sec((S, ğ‘–), *Proj-FS(SGM-Data, vid))`
  - Otherwise: `return false`

### Project History Graph to PRF-PRNG Game
- **Function**: `*Proj-PP (SGM-Data = (V, P, V-Lk, AM-Lk, BR, WK-Lk))`
- **Process**:
  - Initialize `Vâ€²` and `BI`
  - For each vertex in `V`:
    - Add `vid` to `Vâ€²`
    - Update `BI` with the result of `*CGKA-priv(vid', *Proj-CGKA(SGM-Data))`
  - Return `(Vâ€², V-Lk, BI)`

### Project History Graph to CGKA Game
- **Function**: `*Proj-CGKA (SGM-Data = (V, P, V-Lk, AM-Lk, BR, WK-Lk))`
- **Process**:
  - Initialize `Vâ€²` and `Pâ€²`
  - For each vertex in `V`:
    - Add `(vid, orig, pid)` to `Vâ€²`
    - For each operation in `V`:
      - If the operation is `add`, update `dataâ€²` and `ğ‘â€²`
      - If the operation is `rem`, set `ğ‘â€²` to `ğ‘`
      - If the operation is `upd`, set `ğ‘â€²` to `âŠ¥`
      - Add `ğ‘â€²` to `Pâ€²`
  - Return `(Vâ€², Pâ€², V-Lk, BR, WK-Lk)`

### Project History Graph to FS-GAEAD Game
- **Function**: `*Proj-FS (SGM-Data = (V, P, V-Lk, AM-Lk, BR, WK-Lk), vid)`
- **Process**:
  - Initialize `AM-Lkâ€²`
  - For each entry in `AM-Lk`:
    - Add `(ID, AM-Rcvd[ID], AM-Tr[ID])` to `AM-Lkâ€²`
  - Return `AM-Lkâ€²`

### Figure 8: Safety Oracles and Safety Predicate of the Security Game for SGM Schemes

### Process a Proposal
- **Function**: `Proc-PM(P)`
- **Process**:
  - Extract proposal: `(Pâ€², ğ‘¡, sig) â† P`
  - Extract epoch and ID: `(., epid, ID, ., .) â† Pâ€²`
  - Check current epoch: `req epid = s.C-epid`
  - Retrieve static public key: `spk â† s.Ep-SPK[epid, ID]`
  - Verify message tag: `req M-Ver(s.km, Pâ€², ğ‘¡)`
  - Verify signature: `req S-Ver(spk, (Pâ€², ğ‘¡), sig)`
  - Add proposal to buffer: `s.Props +â† Pâ€²`
  - Return proposal information: `return *get-propInfo(Pâ€²)`

### Send a Message
- **Function**: `Send(ğ‘, ğ‘š)`
- **Process**:
  - Get current epoch: `ğ¸ â† s.C-epid`
  - Send message: `(s.ğ‘£[ğ¸], Â¯ğ‘’) â† F-Send(s.ğ‘£[ğ¸], (ğ¸, ğ‘), ğ‘š)`
  - Prepare message: `ğ‘’â€² â† (ğ¸, ğ‘, Â¯ğ‘’)`
  - Sign message: `sig â† S-Sign(s.C-ssk, ğ‘’â€²)`
  - Return message and signature: `return (ğ‘’â€², sig)`

### Process Commit Message
- **Function**: `Proc-CM(T)`
- **Process**:
  - Extract commit message: `(Tâ€², ğ‘¡, sig) â† T`
  - Extract epoch and ID: `(., epid, ID, h, Â¯T) â† Tâ€²`
  - Check current epoch: `req epid = s.C-epid`
  - Retrieve static public key: `spk â† s.Ep-SPK[epid, ID]`
  - Verify message tag: `req M-Ver(s.km, Tâ€², ğ‘¡)`
  - Verify signature: `req S-Ver(spk, (Tâ€², ğ‘¡), sig)`
  - Get proposal: `P â† s.Props[h]`
  - Call CGKA: `(s.ğ›¾, GI, ğ¼) â† K-Proc-Com(s.ğ›¾, Â¯T)`
  - Update PRF-PRG state: `(s.ğœ, ğ‘˜ğ‘’ , s.km, s.C-epid) â† PP(s.ğœ, ğ¼ , H(Tâ€²))`
  - Update roster: `s.G â† GI.G`
  - Get position: `ğ‘ğ‘œğ‘  â† *roster-pos(ME, s.G)`
  - Initialize FS-GAEAD: `s.ğ‘£[s.C-epid] â† F-Init(ğ‘˜ğ‘’ , |s.G| , ğ‘ğ‘œğ‘ )`
  - Update verification keys: `s.Ep-SPK[s.C-epid, .] â† *new-spks(s.Ep-SPK[epid, Â·], P)`
  - Retrieve and set signature key: `spk â† s.Ep-SPK[s.C-epid, ME]` and `s.C-ssk â† SK-sk[spk]`
  - Return group information: `return GI`

### Join a Group
- **Function**: `Proc-WM(W)`
- **Process**:
  - Extract welcome message: `(Wâ€², ğ‘¡, sig) â† W`
  - Extract sender ID and other data: `(., IDğ‘  , ., v,ğ‘Špub,ğ‘Špriv, ğ‘’, wpk, spk) â† Wâ€²`
  - Retrieve static public key: `spk â† spk[IDğ‘  ]`
  - Verify key and signature: `req spk âˆˆ CL-S[IDğ‘  ] âˆ§ S-Ver(spk, Wâ€², sig)`
  - Retrieve welcome keys: `(esk, isk) â† WK-wk[wpk]`
  - Decrypt session key: `s.ğœ â† E-Dec(esk, ğ‘’)`
  - Join group: `(s.ğ›¾, GI, ğ¼) â† K-Join(ME, IDğ‘  ,ğ‘Špub,ğ‘Špriv, isk)`
  - Update PRF-PRG state: `(s.ğœ, ğ‘˜ğ‘’ , s.km, s.C-epid) â† PP(s.ğœ, ğ¼ , v)`
  - Verify message tag: `req M-Ver(s.km, (Wâ€², s.C-epid), ğ‘¡)`
  - Update roster: `s.G â† GI.G`
  - Get position: `ğ‘ğ‘œğ‘  â† *roster-pos(ME, s.G)`
  - Initialize FS-GAEAD: `s.ğ‘£[s.C-epid] â† F-Init(ğ‘˜ğ‘’ , |s.G| , ğ‘ğ‘œğ‘ )`
  - Update verification keys: `s.Ep-SPK[s.C-epid, .] â† spk`
  - Retrieve and set signature key: `spk â† s.Ep-SPK[s.C-epid, ME]` and `s.C-ssk â† SK-sk[spk]`
  - Clear proposals: `s.Props â† ğœ€`

### Create a Group
- **Function**: `Create(spk, wpk; ğ‘Ÿ)`
- **Process**:
  - Initialize roster: `s.G â† [ME]`
  - Retrieve welcome keys: `wsk â† WK-wk[wpk]` and `(Â·, isk) â† wsk`
  - Create group: `(s.ğ›¾, ğ¼) â† K-Create(ME, isk; ğ‘Ÿ)`
  - Update PRF-PRG state: `(s.ğœ, ğ‘˜ğ‘’ , s.km, s.C-epid) â† PP(0, ğ¼ , 0)`
  - Update verification keys: `s.Ep-SPK[s.C-epid, ME] â† spk`
  - Initialize FS-GAEAD: `s.ğ‘£[s.C-epid] â† F-Init(ğ‘˜ğ‘’ , 1, ME)`

### Add Proposal
- **Function**: `Add(IDğ‘)`
- **Process**:
  - Retrieve key bundle: `kbâ€² â† CL-KB[IDğ‘]`
  - Extract keys: `((epk, ipk), spk) â† kbâ€²`
  - Generate add proposal: `(s.ğ›¾, Â¯P) â† K-Add(s.ğ›¾, IDğ‘, ipk)`
  - Prepare proposal: `Pâ€² â† ("add", s.C-epid, ME, (IDğ‘, kbâ€²), Â¯P)`
  - Tag message: `ğ‘¡ â† M-Tag(s.km, Pâ€²)`
  - Sign proposal: `sig â† S-Sign(s.C-ssk, (Pâ€², ğ‘¡))`
  - Return proposal: `return (Pâ€², ğ‘¡, sig)`

### Remove Proposal
- **Function**: `Remove(IDğ‘Ÿ )`
- **Process**:
  - Generate remove proposal: `(s.ğ›¾, Â¯P) â† K-Remove(s.ğ›¾, IDğ‘Ÿ )`
  - Prepare proposal: `Pâ€² â† ("rem", s.C-epid, ME, IDğ‘Ÿ , Â¯P)`
  - Tag message: `ğ‘¡ â† M-Tag(s.km, Pâ€²)`
  - Sign proposal: `sig â† S-Sign(s.C-ssk, (Pâ€², ğ‘¡))`
  - Return proposal: `return (Pâ€², ğ‘¡, sig)`

### Update Proposal
- **Function**: `Update(spk; ğ‘Ÿ)`
- **Process**:
  - Check signature key: `req SK-sk[spk] Ì¸= ğœ€`
  - Generate update proposal: `(s.ğ›¾, Â¯P) â† K-Update(s.ğ›¾; ğ‘Ÿ)`
  - Prepare proposal: `Pâ€² â† ("upd", s.C-epid, ME, spk, Â¯P)`
  - Tag message: `ğ‘¡ â† M-Tag(s.km, Pâ€²)`
  - Sign proposal: `sig â† S-Sign(s.C-ssk, (Pâ€², ğ‘¡))`
  - Return proposal: `return (Pâ€², ğ‘¡, sig)`

### Receive a Message
- **Function**: `Rcv(ğ‘, ğ‘’)`
- **Process**:
  - Extract message and signature: `(ğ‘’â€², sig) â† ğ‘’`
  - Extract epoch and sender: `(epid, ğ‘, Â¯ğ‘’) â† ğ‘’â€²`
  - Receive message: `(s.ğ‘£[epid], IDğ‘  , ğ‘–, ğ‘š) â† F-Rcv(s.ğ‘£[epid], (epid, ğ‘), Â¯ğ‘’)`
  - Check sender: `req IDğ‘  Ì¸= âŠ¥`
  - Retrieve static public key: `spk â† s.Ep-SPK[epid, IDğ‘  ]`
  - Verify signature: `req S-Ver(spk, ğ‘’â€², sig)`
  - Return message details: `return (epid, IDğ‘  , ğ‘–, ğ‘š)`

### Commit
- **Function**: `Commit(P; ğ‘Ÿ)`
- **Process**:
  - Check proposals: `req P âŠ† s.Props`
  - Extract proposals: `Â¯P â† P.Â¯P`
  - Commit changes: `(s.ğ›¾,ğ‘Špub, WPrv, Â¯T, ğ¼) â† K-Commit(s.ğ›¾, Â¯P; ğ‘Ÿ)`
  - Prepare commit message: `Tâ€² â† ("com", s.C-epid, ME, H(P), Â¯T)`
  - Compute hash: `v â† H(Tâ€²)`
  - Update PRF-PRG state: `(., ., ğ‘˜ğ‘š, epid) â† PP(s.ğœ, ğ¼ , v)`
  - Tag message: `ğ‘¡ â† M-Tag(ğ‘˜ğ‘š, Tâ€²)`
  - Sign commit message: `sig â† S-Sign(s.C-ssk, (Tâ€², ğ‘¡))`
  - Finalize commit message: `T â† (Tâ€², ğ‘¡, sig)`
  - Get added IDs and keys: `(ID, wpk) â† *added(P)` and `spk â† *new-spks(s.Ep-SPK[s.C-epid, Â·], P)`
  - For each ID, prepare welcome messages:
    - Encrypt session key: `ğ‘’ â† E-Enc(wpk[ğ‘–].epk, s.ğœ)`
    - Prepare welcome message: `Wâ€² â† ("wel", ME, ID[ğ‘–], v,ğ‘Špub, . . . , WPrv[ğ‘–], ğ‘’, wpk[ğ‘–], spk)`
    - Tag message: `ğ‘¡ â† M-Tag(ğ‘˜ğ‘š, (Wâ€², epid))`
    - Sign welcome message: `sig â† S-Sign(spk[ME], (Wâ€², ğ‘¡))`
    - Finalize welcome message: `W[ğ‘–] â† (Wâ€², ğ‘¡, sig)`
  - Return commit and welcome messages: `return (epid, W, T)`

### Figure 7: The SGM Construction: Main Algorithms

### References
1. J. Alwen, M. Capretto, M. Cueto, C. Kamath, K. Klein, G. Pascual-Perez, K. Pietrzak, and M. Walter. Keep the dirt: Tainted treeKEM, an efficient and provably secure continuous group key agreement protocol. IACR Cryptol. ePrint Arch., 2019:1489, 2019.
2. J. Alwen, S. Coretti, and Y. Dodis. The double ratchet: Security notions, proofs, and modularization for the Signal protocol. In Y. Ishai and V. Rijmen, editors, EUROCRYPT 2019, Part I, volume 11476 of LNCS, pages 129â€“158. Springer, Heidelberg, May 2019.
3. J. Alwen, S. Coretti, Y. Dodis, and Y. Tselekounis. Security analysis and improvements for the IETF MLS standard for group messaging. In D. Micciancio and T. Ristenpart, editors, CRYPTO 2020, Part I, volume 12170 of LNCS, pages 248â€“277. Springer, Heidelberg, Aug. 2020.
4. J. Alwen, S. Coretti, Y. Dodis, and Y. Tselekounis. Modular design of secure group messaging protocols and the security of MLS. Cryptology ePrint Archive, Report 2021/1083, 2021. https://ia.cr/2021/1083.
5. J. Alwen, S. Coretti, D. Jost, and M. Mularczyk. Continuous group key agreement. Cryptology ePrint Archive, Report 2020/1327, 2020. https://eprint.iacr.org/2020/1327.
6. J. Alwen, D. Jost, and M. Mularczyk. On the insider security of MLS. IACR Cryptol. ePrint Arch., 2020:1327, 2020.
7. R. Barnes. Subject: [MLS] Remove without double-join (in TreeKEM), 2018. https://mailarchive.ietf.org/arch/msg/mls/Zzw2tqZC1FCbVZA9LKERsMIQXik.
8. R. Barnes, B. Beurdouche, J. Millican, E. Omara, K. Cohn-Gordon, and R. Robert. Internet-Draft draft-ietf-mls-protocol-11, Internet Engineering Task Force, Dec. 2020. Work in Progress.
9. K. Bhargavan, B. Beurdouche, and P. Naldurg. Formal Models and Verified Protocols for Group Messaging: Attacks and Proofs for IETF MLS. Research report, Inria Paris, Dec. 2019.
10. A. Bienstock, Y. Dodis, and P. RÃ¶sler. On the price of concurrency in group ratcheting. Cryptology ePrint Archive, Report 2020/1593, 2020. https://eprint.iacr.org/2020/1593.
11. C. Brzuska, E. Cornelissen, and K. Kohbrok. Cryptographic security of the MLS ratcheting protocols. In R. Pass and K. Pietrzak, editors, TCC, 2020. Cryptology ePrint Archive, Report 2021/137, 2021. https://eprint.iacr.org/2021/137.
12. R. Canetti, J. A. Garay, G. Itkis, D. Micciancio, M. Naor, and B. Pinkas. Multicast security: A taxonomy and some efficient constructions. In IEEE INFOCOMâ€™99, pages 708â€“716, New York, NY, USA, Mar. 21â€“25, 1999.
13. K. Cohn-Gordon, C. Cremers, L. Garratt, J. Millican, and K. Milner. On end-to-end encryption: Asynchronous group messaging with strong security guarantees. In D. Lie, M. Mannan, M. Backes, and X. Wang, editors, ACM CCS 2018, pages 1802â€“1819. ACM Press, Oct. 2018.
14. K. Cohn-Gordon, C. J. F. Cremers, B. Dowling, L. Garratt, and D. Stebila. A formal security analysis of the Signal messaging protocol. In 2017 IEEE European Symposium on Security and Privacy, EuroS&P 2017, pages 451â€“466, 2017.
15. C. Cremers, B. Hale, and K. Kohbrok. Revisiting post-compromise security guarantees in group messaging. IACR Cryptol. ePrint Arch., 2019:477, 2019.
16. Y. Dodis and N. Fazio. Public key broadcast encryption for stateless receivers. In J. Feigenbaum, editor, Digital Rights Management, pages 61â€“80, Berlin, Heidelberg, 2002. Springer Berlin Heidelberg.
17. E. Eaton, D. Jao, and C. Komlo. Towards post-quantum updatable public-key encryption via supersingular isogenies. Cryptology ePrint Archive, Report 2020/1593, 2020. https://eprint.iacr.org/2020/1593.
18. A. Fiat and M. Naor. Broadcast encryption. In D. R. Stinson, editor, CRYPTOâ€™93, volume 773 of LNCS, pages 480â€“491. Springer, Heidelberg, Aug. 1994.
19. Z. Jafargholi, C. Kamath, K. Klein, I. Komargodski, K. Pietrzak, and D. Wichs. Be adaptive, avoid overcommitting. In J. Katz and H. Shacham, editors, CRYPTO 2017, Part I, volume 10401 of LNCS, pages 133â€“163. Springer, Heidelberg, Aug. 2017.
20. D. Jost, U. Maurer, and M. Mularczyk. Efficient ratcheting: Almost-optimal guarantees for secure messaging. In Y. Ishai and V. Rijmen, editors, EUROCRYPT 2019, Part I, volume 11476 of LNCS, pages 159â€“188. Springer, Heidelberg, May 2019.
21. Y. Kim, A. Perrig, and G. Tsudik. Group key agreement efficient in communication. IEEE Trans. Computers, 53(7):905â€“921, 2004.
22. H. Krawczyk. Cryptographic extraction and key derivation: The HKDF scheme. In T. Rabin, editor, CRYPTO 2010, volume 6223 of LNCS, pages 631â€“648. Springer, Heidelberg, Aug. 2010.
23. Matthew A. Weidner. Group Messaging for Secure Asynchronous Collaboration. Dissertation, 2019. https://mattweidner.com/acs-dissertation.pdf.
24. S. Mittra. Iolus: A framework for scalable secure multicasting. In Proceedings of ACM SIGCOMM, pages 277â€“288, Cannes, France, Sept. 14â€“18, 1997.
25. S. Panjwani. Tackling adaptive corruptions in multicast encryption protocols. In S. P. Vadhan, editor, TCC 2007, volume 4392 of LNCS, pages 21â€“40. Springer, 2007.
26. C. K. Wong, M. Gouda, and S. S. Lam. Secure group communications using key graphs. IEEE/ACM Transactions on Networking, 8(1):16â€“30, Feb. 2000.
27. Masterâ€™s thesis, University of Cambridge, June 2019.