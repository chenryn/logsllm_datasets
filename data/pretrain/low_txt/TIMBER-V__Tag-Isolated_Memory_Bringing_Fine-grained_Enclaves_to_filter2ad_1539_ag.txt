# Performance and Overhead Analysis

## Overlap Checks in Enclave Initialization
Overlap checks, performed during the `add-region` operation, exhibit variability. This is acceptable because overlap checks are relatively inexpensive. These checks are only conducted at enclave initialization and not during runtime. For `add-data` and `add-entries`, the runtime increases with the size of the added data blob or the number of entries, respectively. This is due to the need to update memory tags and compute hash measurements, which depend on the amount of data. Additionally, performance slightly depends on the position of the associated enclave region in the ECB (Enclave Control Block). The base costs for adding one data word or one entry to the first enclave region are shown in Table VI. The `init-enclave` operation has a constant overhead. In contrast, `destroy-enclave` unclaims all enclave memory with a linear sweep over the enclave, and we show the runtime for destroying an empty enclave. `load-enclave` validates the MPU (Memory Protection Unit) configuration against the loaded enclave’s ECB, resulting in moderate overhead. Once an enclave is loaded, horizontal transitions between U-mode (user mode) and TU-mode (trusted user mode) experience no significant overhead.

## Trusted Enclave Services
Trusted enclave services are implemented as TSyscalls, which have slight overhead due to M-mode (machine mode) trap delegation. TSyscall dispatching includes validation of the MPU configuration for vertical stack interleaving and jumping to the correct service routine. A return from a TSyscall unwinds the dispatcher context, clears all caller-saved registers, and returns to TU-mode using the RISC-V `sret` instruction. We exclude TSyscall, dispatch, and return overhead in the following analysis. The `get-key` function computes an HMAC using two SHA256 computations, contributing to the overhead. `shm-offer` needs to check the validity of the arguments, including their memory tags and whether they belong to the calling enclave. Apart from this, the performance is constant and independent of other enclaves. `shm-accept` traverses the linked list of ECBs to find a matching SHM offer. In our benchmarks, the first enclave in the linked list has a corresponding SHM offer. `shm-release` only erases the accepted SHM region from the enclave’s ECB, in our case, the fifth enclave region. Interruption and resumption of enclaves (and TagRoot) are fast, mainly consisting of saving and restoring the execution context in the interrupt frame. As before, the performance numbers for `interrupt-enclave` and `resume` exclude TSyscall latency due to trap delegation, and TSyscall dispatch and return overhead do not apply here.

### TUenter and TUleave
As shown in the last rows of Table VI, `TUenter` has no overhead, showing only one jump instruction into the enclave. `TUleave` takes longer due to an assumed pipeline stall of the `ret` instruction. When enclaves call untrusted functions on the outside, these ocalls need to securely store and verify the stack pointer, as discussed in Section VI-B. Moreover, an enclave must clear sensitive CPU registers on `TUleave` as well as ocalls, which can be automated, e.g., via so-called edge routines in the SGX SDK [30].

## Memory Overhead
TIMBER-V adds two tag bits to each 32-bit memory word, introducing a 6.25% hardware memory overhead. Our TIMBER-V architecture directly runs unmodified code, thus not introducing software memory overhead. Similarly, our code hardening transformation does not introduce memory overhead, as memory instructions are replaced 1:1 with checked instructions. Slight overhead only occurs if additional instructions are inserted for fixing offset overflows, as discussed in Section IX-B. Heap interleaving requires small, constant-sized code memory for allocation hooks but eliminates the need for secure heap implementations, reducing overall code size. We do not provide actual numbers since this strongly depends on the heap implementation. Stack interleaving needs additional code for stack frame allocation and deallocation. Currently, we insert checked store instructions for each allocated word, showing a 43% overhead in assembler code lines for the expensive `minver` benchmark. However, optimizing for code size, one could achieve constant overhead per stack (de)allocation by embedding checked stores in a loop. We manually optimized stack interleaving for `minver` and reduced the code overhead to 1%.

### TagRoot Code Size
We used `sloccount` to count the number of source code lines as an estimate of TagRoot’s complexity. TagRoot consists of 369 lines of assembler code and 1686 lines of C-code, with 313 lines used by HMAC and SHA256. This code base is relatively small, which is desirable for a trusted computing base as it reduces the risk of programming bugs. The small size is also beneficial for formal verification techniques that could help certify our TagRoot implementation [33]. For comparison, the FreeRTOS operating system has approximately 12,500 lines of code.

## Related Work
In this section, we compare TIMBER-V against related work on isolated execution and tagged memory architectures.

### Isolated Execution
Hardware-based isolated execution can be classified into virtual and physical address-based systems, as detailed by Maene et al. [36]. Many schemes target mid and upper-class processors with virtual memory support, such as AEGIS [47], Intel TXT [28], ARM TrustZone [2], Bastion [10], IBM SecureBlue++ [7], Intel SGX [37], and ISO-X [22]. Sanctum [13] implements the SGX enclave model on RISC-V with virtual memory, adding additional side-channel protection. In contrast, we bring enclaves to smaller RISC-V processors featuring only limited physical memory.

#### Physical Address-based Systems
SMART [21], Sancus [40], Soteria [25], TyTAN [9], and TrustLite [34] implement program counter-based memory access control for isolating secure tasks. Secure task’s memory regions are only accessible when the program counter is in its code region. Sancus has a hardware-only TCB and isolates a fixed number of small, uninterruptible secure tasks stored in predefined memory locations. TyTAN and TrustLite use an execution-aware MPU (EA-MPU) with multiple code and/or data regions per secure task. TrustLite loads all secure tasks at boot time, while TyTAN allows dynamic loading and unloading of secure tasks at runtime. The EA-MPU makes context switches faster but limits the number of concurrently loaded secure tasks. In contrast, TIMBER-V supports an arbitrary number of enclaves with fine-grained, dynamic isolation and multiple entry points.

Secure communication in TrustLite is done via a simple handshake protocol, where two secure tasks first attest each other and then use cryptographic session tokens to authenticate messages. In TIMBER-V, local enclave attestation and communication are done implicitly via shared memory, without using any cryptographic secrets. TyTAN uses a dedicated IPC proxy task to forward messages between secure tasks, introducing copying overhead (1324 CPU cycles). In contrast, our secure shared memory is a fast alternative for exchanging bulk data between enclaves.

TrustZone-M [3] supports four security domains like TIMBER-V. Horizontal and vertical domain transitions require special instructions, while in TIMBER-V, domain switches are direct, imposing zero runtime overhead. TrustZone-M only supports secure and non-secure tasks, while our architecture supports mixed processes, where enclaves are directly embedded in untrusted processes via tagged memory, achieving fine-grained isolation. TrustZone-M optionally supports two separate MPUs, one for the secure and one for the non-secure world. We reuse the same MPU across security domains, thus saving hardware costs. Additionally, our dynamic memory interleaving allows for stack (and heap) reuse, while TrustZone-M requires separate stacks for each domain.

### Tagged Memory Architectures
The availability of metadata is the foundation for various run-time monitoring techniques like sanitizers [44, 46] and dynamic information flow tracking (DIFT) [43]. Many hardware-based tagged memory architectures have been developed, ranging from single tag bit schemes with fixed policy (e.g., Minos [14] and CHERI [52]) to multi-bit schemes with partially configurable policy (e.g., Raksha [15], DIFT [48], DIFT with coprocessor [32]), to schemes with configurable bit width and fully programmable policy and enforcement (e.g., FlexiTaint [49], instruction-grain lifeguards [11], Harmoni [17], PUMP [19]).

Compared to DIFT architectures, TIMBER-V has notably different characteristics. Firstly, DIFT schemes focus on performing tag/taint propagation during ALU operations, whereas TIMBER-V does not perform any tag propagation but utilizes tags for isolation purposes. Abusing a DIFT architecture solely for isolation, while possible in some schemes like Raksha [15] and PUMP [19], is needlessly wasteful. Secondly, TIMBER-V introduces a new trusted security domain, and the isolation and update policies depend on the currently active domain. Partially configurable DIFT architectures typically do not support such a domain switch. Finally, even fully programmable DIFT architectures are not necessarily suited for implementing TIMBER-V. Architectures that perform tag operations asynchronously to the main processor [11, 17, 32] introduce a TOCTOU gap that can potentially be used to exfiltrate data from the trusted domain.

Besides DIFT-based architectures, other architectures use tagged memory for enforcing various kinds of memory protection. HardBound [18] implements fat pointers to prevent spatial memory safety violations. HDFI [45] uses a single tag bit to protect sensitive data words. However, in HDFI, tag checks are only performed when reading the data, meaning that destructive write operations on sensitive data cannot be prevented but only detected. This property corresponds to the weak low-watermark policy for objects of the Biba integrity model [6]. In contrast, TIMBER-V follows the stronger strict integrity policy of the Biba model by refusing untrusted modifications of trusted data. Compared to that, Mondrian Memory Protection [53], which uses two tag bits, and Loki [54], using up to 32 tag bits per word, are more similar to TIMBER-V. However, both concepts solely use tagged memory to implement word-wise access permissions, which is not sufficient to implement efficient isolated execution. Additionally, when different permissions are tightly interleaved, Loki’s tag size is too large for low-end devices that we target.

## Possible Extensions
The concept of TIMBER-V can be directly applied to other system components, enabling flexible safety-critical systems with secure interrupts.

### Secure Components and Peripherals
One can easily extend CPU caches with our two tag bits and propagate them to main memory on cache eviction. Memory-mapped I/O peripherals can benefit from TIMBER-V’s tag isolation policy by pinning their tag bits in a tag cache. This facilitates secure I/O, allowing secure interaction with end users, sensors, actuators, or other networked devices.

### Secure Interrupts
Most embedded systems react to regular timer or irregular I/O interrupts. TIMBER-V supports secure interrupts by modifying the M-mode trap delegation mechanism to route interrupts directly to the trusted trap handler, which is not callable to prevent fake interrupts from S-mode.

### Safety-critical Systems
TagRoot is a compact implementation of isolated execution on top of TIMBER-V. Extending TagRoot for safety-critical systems with availability guarantees is an interesting field of research and should be straightforward. We denote safety-critical enclaves as safeclaves. To guarantee real-time behavior, safeclaves must be protected against denial-of-service attacks (DoS). Safeclaves are not triggered by untrusted code but by external I/O events or recurring timer periods. TagRoot can intercept safeclave interrupts to assuredly trigger safeclave execution. Dynamic memory interleaving cannot be used for safeclaves, but normal enclaves can still benefit from interleaving. By slightly adapting our shared MPU design, one can exclude safeclave MPU slots from being shared, making safeclaves safe against DoS from the OS.

## Conclusion
We presented TIMBER-V, the first efficient tagged memory architecture for isolated execution of enclaves. TIMBER-V minimizes memory overhead of tagged memory by augmenting tag isolation with MPU isolation. The flexibility of TIMBER-V enables fine-grained and dynamic management of trusted memory, enabling novel schemes like stack interleaving. This reduces memory fragmentation, particularly relevant for low-end devices. A small trust manager provides trusted services, including secure shared memory. We implemented and evaluated TIMBER-V to demonstrate its practicality.

## Acknowledgments
This work was partially supported by the TU Graz LEAD project “Dependable Internet of Things in Adverse Environments” and by the Austrian Research Promotion Agency (FFG) via the K-project DeSSnet, which is funded in the context of COMET – Competence Centers for Excellent Technologies by BMVIT, BMWFW, Styria, and Carinthia. Furthermore, this research was co-funded by the German Science Foundation, as part of project S2 and P3 within CRC 1119 CROSSING, and Intel Collaborative Research Institute for Collaborative Autonomous & Resilient Systems (ICRI-CARS).

## References
[1] I. Anati, S. Gueron, S. Johnson, and V. Scarlata. Innovative technology for CPU based attestation and sealing, 2013. White Paper.
[2] ARM Security Technology: Building a Secure System using TrustZone Technology, 2009. Ref. no. PRD29-GENC-009492C.
[3] TrustZone technology for ARMv8-M Architecture, 2017. Ref. no. 100690 0200 00 en.
[4] J. Bennett, A. Burgess, S. Cook, K. Eder, S. Hollis, and J. Pallister. Bristol/embecosm embedded benchmark suite. http://beebs.eu/ (Accessed 2018/06/18).
[5] D. J. Bernstein. Cache-Timing Attacks on AES, 2005. https://cr.yp.to/antiforgery/cachetiming-20050414.pdf. (Accessed 2018/05/29).
[6] K. J. Biba. Integrity Considerations for Secure Computer Systems, 1977. The MITRE Corporation. Tech. Report ESD-TR-76-372.
[7] R. Boivie and P. Williams. SecureBlue++: CPU Support for Secure Executables, 2012. IBM research report no. RC25369.
[8] A. Bradbury, G. Ferris, and R. Mullins. Tagged memory and minion cores in the lowRISC SoC, 2014. lowRISC-MEMO 2014-001.
[9] F. F. Brasser, B. E. Mahjoub, A. Sadeghi, C. Wachsmann, and P. Koeberl. TyTAN: tiny trust anchor for tiny devices. In Design Automation Conference – DAC’15, pages 34:1–34:6. ACM, 2015.
[10] D. Champagne and R. B. Lee. Scalable architectural support for trusted software. In High Performance Computer Architecture – HPCA’10, pages 1–12. IEEE Computer Society, 2010.
[11] S. Chen, M. Kozuch, P. B. Gibbons, M. P. Ryan, T. Strigkos, T. C. Mowry, O. Ruwase, E. Vlachos, B. Falsafi, and V. Ramachandran. Flexible Hardware Acceleration for Instruction-Grain Lifeguards. IEEE Micro, 29:62–72, 2009.
[12] B. Coppens, I. Verbauwhede, K. D. Bosschere, and B. D. Sutter. Practical Mitigations for Timing-Based Side-Channel Attacks on Modern x86 Processors. In Security and Privacy – S&P’09, pages 45–60. IEEE Computer Society, 2009.
[13] V. Costan, I. A. Lebedev, and S. Devadas. Sanctum: Minimal Hardware Extensions for Strong Software Isolation. In USENIX Security’16, pages 857–874. USENIX Association, 2016.
[14] J. R. Crandall, S. F. Wu, and F. T. Chong. Minos: Architectural support for protecting control data. TACO, 3:359–389, 2006.
[15] M. Dalton, H. Kannan, and C. Kozyrakis. Raksha: a flexible information flow architecture for software security. In International Symposium on Computer Architecture – ISCA’07, pages 482–493. ACM, 2007.
[16] A. A. de Amorim, C. Hritcu, and B. C. Pierce. The Meaning of Memory Safety. In Principles of Security and Trust – POST’18, volume 10804 of LNCS, pages 79–105. Springer, 2018.
[17] D. Y. Deng and G. E. Suh. High-performance parallel accelerator for flexible and efficient run-time monitoring. In Dependable Systems and Networks – DSN’12, pages 1–12. IEEE Computer Society, 2012.
[18] J. Devietti, C. Blundell, M. M. K. Martin, and S. Zdancewic. Hardbound: architectural support for spatial safety of the C programming language. In Architectural Support for Programming Languages and Operating Systems – ASPLOS’08, pages 103–114. ACM, 2008.
[19] U. Dhawan, C. Hritcu, R. Rubin, N. Vasilakis, S. Chiricescu, J. M. Smith, T. F. K. Jr., B. C. Pierce, and A. DeHon. Architectural Support for Software-Defined Metadata Processing. In Architectural Support for Programming Languages and Operating Systems – ASPLOS’15, pages 487–502. ACM, 2015.
[20] EEMBC. CoreMark. https://www.eembc.org/coremark/ (Accessed 2018/06/18).
[21] K. Eldefrawy, G. Tsudik, A. Francillon, and D. Perito. SMART: Secure and Minimal Architecture for (Establishing Dynamic) Root of Trust. In Network and Distributed System Security Symposium – NDSS’12. The Internet Society, 2012.
[22] D. Evtyushkin, J. Elwell, M. Ozsoy, D. V. Ponomarev, N. B. Abu-Ghazaleh, and R. Riley. Iso-X: A Flexible Architecture for Hardware-Managed Isolated Execution. In Symposium on Microarchitecture – MICRO’14, pages 190–202. IEEE Computer Society, 2014.
[23] E. A. Feustel. The Rice research computer: a tagged architecture. In American Federation of Information Processing Societies – AFIPS, volume 40 of AFIPS Conference Proceedings, pages 369–377. AFIPS, 1972.
[24] The GNU Awk User’s Guide. Edition 4.2. https://www.gnu.org/software/gawk/manual/gawk.html, (Accessed 2018/08/06).
[25] J. Götzfried, T. Müller, R. de Clercq, P. Maene, F. C. Freiling, and I. Verbauwhede. Soteria: Offline Software Protection within Low-cost Embedded Devices. In Annual Computer Security Applications Conference – ACSAC’15, pages 241–250. ACM, 2015.
[26] Helpnetsecurity. The cost of IoT hacks: Up to 13% of revenue for smaller firms, 2017. https://www.helpnetsecurity.com/2017/06/05/iot-hacks-cost/ (Accessed 2018/07/27).
[27] B. Igal. Bits, please! exploring Qualcomm’s TrustZone implementation, 2015. http://bits-please.blogspot.com/2015/08/exploring-qualcomms-trustzone.html (Accessed 2018/08/01).
[28] Intel Trusted Execution Technology (Intel TXT), Software Development Guide. Reference no. 315168-012.
[29] Intel 64 and IA-32 Architectures Software Developer’s Manual, 2016. Reference no. 325462-061US.
[30] Intel Software Guard Extensions SDK for Linux OS. Developer Reference, 2016. Rev. 1.5.
[31] A. Joannou, J. Woodruff, R. Kovacsics, S. W. Moore, A. Bradbury, H. Xia, R. N. M. Watson, D. Chisnall, M. Roe, B. Davis, E. Napierala, J. Baldwin, K. Gudka, P. G. Neumann, A. Mazzinghi, A. Richardson, S. D. Son, and A. T. Markettos. Efficient Tagged Memory. In International Conference on Computer Design – ICCD’17, pages 641–648. IEEE Computer Society, 2017.
[32] H. Kannan, M. Dalton, and C. Kozyrakis. Decoupling Dynamic Information Flow Tracking with a dedicated coprocessor. In Dependable Systems and Networks – DSN’09, pages 105–114. IEEE Computer Society, 2009.
[33] G. Klein, J. Andronick, K. Elphinstone, G. Heiser, D. Cock, P. Derrin, D. Elkaduwe, K. Engelhardt, R. Kolanski, M. Norrish, T. Sewell, H. Tuch, and S. Winwood. seL4: formal verification of an operating-system kernel. Commun. ACM, 53:107–115, 2010.
[34] P. Koeberl, S. Schulz, A. Sadeghi, and V. Varadharajan. TrustLite: a security architecture for tiny embedded devices. In European Conference on Computer Systems – EUROSYS’14, pages 10:1–10:14. ACM, 2014.
[35] S. Larson. FDA confirms that St. Jude’s cardiac devices can be hacked. https://money.cnn.com/2017/01/09/technology/fda-st-jude-cardiac-hack/ (Accessed 2018/07/18).
[36] P. Maene, J. Götzfried, R. de Clercq, T. Müller, F. C. Freiling, and I. Verbauwhede. Hardware-Based Trusted Computing Architectures for Isolation and Attestation. IEEE Trans. Computers, 67:361–374, 2018.
[37] F. McKeen, I. Alexandrovich, A. Berenzon, C. V. Rozas, H. Shafi, V. Shanbhogue, and U. R. Savagaonkar. Innovative instructions and software model for isolated execution. In Hardware and Architectural Support for Security and Privacy – HASP, page 10. ACM, 2013.
[38] C. Miller and C. Valasek. Remote exploitation of an unaltered passenger vehicle, 2015. http://illmatics.com/Remote%20Car%20Hacking.pdf (Accessed 2018/07/18).
[39] NJCCIC. Mirai Botnet. https://www.cyber.nj.gov/threat-profiles/botnet-variants/mirai-botnet (Accessed 2018/07/18).
[40] J. Noorman, J. V. Bulck, J. T. Mühlberg, F. Piessens, P. Maene, B. Preneel, I. Verbauwhede, J. Götzfried, T. Müller, and F. C. Freiling. Sancus 2.0: A Low-Cost Security Architecture for IoT Devices. ACM Trans. Priv. Secur., 20:7:1–7:33, 2017.
[41] E. Ronen, A. Shamir, A. Weingarten, and C. O’Flynn. IoT Goes Nuclear: Creating a ZigBee Chain Reaction. In Security and Privacy – S&P’17, pages 195–212. IEEE Computer Society, 2017.
[42] X. Ruan. Boot with Integrity, or Don’t Boot, pages 143–163. Apress, Berkeley, CA, 2014.
[43] E. J. Schwartz, T. Avgerinos, and D. Brumley. All You Ever Wanted to Know about Dynamic Taint Analysis and Forward Symbolic Execution (but Might Have Been Afraid to Ask). In Security and Privacy – S&P’10, pages 317–331. IEEE Computer Society, 2010.
[44] K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov. AddressSanitizer: A Fast Address Sanity Checker. In USENIX Annual Technical Conference – USENIX ATC’12, pages 309–318. USENIX Association, 2012.
[45] C. Song, H. Moon, M. Alam, I. Yun, B. Lee, T. Kim, W. Lee, and Y. Paek. HDFI: Hardware-Assisted Data-Flow Isolation. In Security and Privacy – S&P’16, pages 1–17. IEEE Computer Society, 2016.
[46] E. Stepanov and K. Serebryany. MemorySanitizer: fast detector of uninitialized memory use in C++. In Symposium on Code Generation and Optimization – CGO’15, pages 46–55. IEEE Computer Society, 2015.
[47] G. E. Suh, D. E. Clarke, B. Gassend, M. van Dijk, and S. Devadas. AEGIS: architecture for tamper-evident and tamper-resistant processing. In International Conference on Supercomputing – ICS’03, pages 160–171. ACM, 2003.
[48] G. E. Suh, J. W. Lee, D. Zhang, and S. Devadas. Secure program execution via dynamic information flow tracking. In Architectural Support for Programming Languages and Operating Systems – ASPLOS’04, pages 85–96. ACM, 2004.
[49] G. Venkataramani, I. Doudalis, Y. Solihin, and M. Prvulovic. FlexiTaint: A programmable accelerator for dynamic taint propagation. In High Performance Computer Architecture – HPCA’08, pages 173–184. IEEE Computer Society, 2008.
[50] A. Waterman and K. Asanović. The RISC-V Instruction Set Manual, Volume I: User-Level ISA, Version 2.2. Technical report, SiFive Inc., EECS Department, University of California, Berkeley, 2017.
[51] A. Waterman and K. Asanović. The RISC-V Instruction Set Manual, Volume II: Privileged Architecture, Version 1.10. Technical report, SiFive Inc., EECS Department, University of California, Berkeley, 2017.
[52] R. N. M. Watson, J. Woodruff, P. G. Neumann, S. W. Moore, J. Anderson, D. Chisnall, N. H. Dave, B. Davis, K. Gudka, B. Laurie, S. J. Murdoch, R. Norton, M. Roe, S. D. Son, and M. Vadera. CHERI: A Hybrid Capability-System Architecture for Scalable Software Compartmentalization. In Security and Privacy – S&P’15, pages 20–37. IEEE Computer Society, 2015.
[53] E. Witchel, J. Cates, and K. Asanovic. Mondrian memory protection. In Architectural Support for Programming Languages and Operating Systems – ASPLOS’02, pages 304–316. ACM Press, 2002.
[54] N. Zeldovich, H. Kannan, M. Dalton, and C. Kozyrakis. Hardware Enforcement of Application Security Policies Using Tagged Memory. In Operating Systems Design and Implementation – OSDI’08, pages 225–240. USENIX Association, 2008.