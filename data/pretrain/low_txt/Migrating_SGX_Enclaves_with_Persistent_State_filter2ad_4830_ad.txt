### Vulnerability to Side-Channel Attacks
Our solution is less vulnerable to side-channel attacks compared to the standard function. Therefore, we conclude that our solution meets Security Requirement R1.

### Controlled Migration
The identity of the Migration Enclave is verified during the local attestation process before migration. Subsequently, the identity of the Migration Enclave on the destination machine is verified and authenticated by the Migration Enclave on the source machine. This ensures that the destination Migration Enclave has a valid identity and is running on an authorized machine. Finally, the Migration Enclave on the destination machine only transfers the data to a destination enclave that has the same identity as the source enclave. Thus, our solution meets Security Requirement R2.

### Fork Prevention
Using our scheme, it is impossible for an enclave to be active on two different machines with inconsistent data. The Migration Enclave ensures this by sending the data to only one destination machine and from there to one destination enclave. Our scheme prevents the type of fork attack described in Section III-B because the Migration Library deletes the SGX monotonic counters on the source machine before sending the migration data to the Migration Enclave. This is feasible because we also store the counters’ UUIDs in the persistent data of the Migration Library. If the Migration Enclave is given obsolete persistent data, the monotonic counters become unusable, as they would have been deleted by the SDK, even if the Migration Library does not detect the data as obsolete. Attempting to access a counter initialized from the wrong offset value will result in an error, regardless of the offset value. Assuming the enclave code is not malicious, it can detect this situation through a monotonic counter error, thus maintaining security. Therefore, our approach fulfills Security Requirement R3.

### Roll-Back Prevention
On any given machine, roll-back attacks are prevented using SGX counters (as usual). Roll-back attacks that could arise from migration (as described in Section III-C) are prevented by migrating the counter values to the destination enclave. This ensures that an enclave’s persistent state cannot be rolled back to an earlier version, and thus our scheme fulfills Security Requirement R4.

### Software TCB Size
As a software-only solution, our Migration Enclave and Library increase the size of the software Trusted Computing Base (TCB). However, our Migration Enclave and Library consist of 217 and 940 lines of code, respectively (excluding the SGX trusted libraries), which is feasible to audit.

### Performance Evaluation
We measured the performance of the migratable alternatives of sealing and monotonic counters, as well as the initialization operations performed when our Migration Library is started for the first time or subsequently restarted. All measurements were obtained by measuring the time of an ECALL for each operation. We started the enclave, measured the initialization of a new library buffer, restarted the enclave, and measured the other ECALLs. After this, we shut down the enclave. We repeated this process 1000 times and compared the results with the baseline performance when standard SGX primitives were used for the counter and sealing operations. There is no baseline for the initialization of the library, as this step is not required without the Migration Library. We plotted the average of all our results together with error bars showing a 99% mean confidence interval, indicating that the true mean value is within the confidence interval bar with 99% probability. We also used a 1-tailed t-test to check if the differences are statistically significant.

#### Monotonic Counter Operations
Figure 3 shows the results of the monotonic counter operations. The migratable versions of the counters introduce a small overhead of at most 12.3%. This is due to the additional array operations performed by the library to properly wrap the monotonic counter for the enclave. For creating and destroying a counter, this means an additional sealing of the internal data buffer that stores the counter data, and for incrementing a counter, this means performing additional checks to prevent integer overflow due to the offset. The increment operation incurs an average overhead of 12.3% (statistically significant, p < 0.05) for migratable counters, whereas the read operation has no statistically significant overhead (p > 0.12). Since reading and incrementing counters are the most frequent operations, the overhead introduced by our library is minimal for normal enclave operations.

#### Sealing and Unsealing Operations
Figure 4 shows the measurements for the sealing and unsealing operations, as well as for the initialization of the library. The migratable sealing operations are slightly faster than their standard SGX counterparts because the MSK is already available from the library buffer. In contrast, the standard SGX sealing operations have to perform an SGX EGETKEY operation. The initialization of the Migration Library is very fast, as it only generates a key and initializes the arrays when creating a new buffer, and only has to unseal the data when it is reloaded. Since this is only done once during the lifetime of the enclave, the initialization time is negligible.

Additionally, we measured the overhead that migrating an enclave introduces on top of VM migration. We migrated an enclave 1000 times and calculated the average time of one migration. The extra time for local attestation, communicating with ME, and sending over the sealed data is 0.47 ± 0.035 seconds. Since migrating the VM usually takes several seconds [10], the overhead of migrating an enclave is relatively small.

### Usability Evaluation
We argue qualitatively that the Migration Library is easy to use for enclave developers. Initializing the Migration Library requires only one function call after the enclave has been started. Similarly, initiating the migration process also only requires a single function call. Minimal effort is required to switch from the non-migratable versions to the migratable versions provided by the Migration Library. For sealing, only the function name changes, as the other function parameters are identical to the standard SGX Library functions. For the monotonic counter operations, the developer only needs to change the function name and switch from using the SGX UUIDs to the counter ID assigned by the Migration Library. We argue that this is a reasonable low effort to make an enclave migratable and conclude that our migration system meets the defined usability goal.

### Related Work
#### Hardware Security in the Cloud
Although the use of hardware security technologies in the cloud is a relatively new field, there have already been several examples of their benefits in this setting. For example, Amazon’s CloudHSM provides the functionality of a traditional hardware security module to VMs in the cloud. In terms of trusted execution environments, Intel has published a list of recent research efforts using SGX, many of which target cloud environments. Ohrimenko et al. [15] provide a framework for privacy-preserving machine learning in a multi-party setting. Using SGX, a machine learning algorithm hosted in the cloud could be provided with privacy-sensitive data from multiple parties. Tamrakar et al. [16] use both SGX and ARM TrustZone in a cloud setting to provide a scalable private membership test system (e.g., for cloud-based malware checking). They investigated how to avoid leaking data through memory access patterns. The Signal messaging service recently announced that they are using a similar SGX-based approach on their servers to support private contact discovery. Zheng et al. [17] described Opaque, a distributed data analytics platform, which uses SGX enclaves to support a wide range of data queries while ensuring strong security guarantees. In the VC3 system [18], SGX enclaves are used to execute a MapReduce protocol securely on untrusted infrastructure. To authenticate the machines that belong to the cloud provider, VC3 introduces the idea of a Cloud quoting enclave. We propose a similar solution for authenticating servers owned by the cloud provider. Matetic et al. [19] specifically address the issue of rollback protection in TEEs. They argue that the hardware-based monotonic counters available in SGX suffer several disadvantages, including rate-limiting and wear-out. They propose ROTE, a system for maintaining virtual counters using consensus among a group of SGX enclaves running on different physical machines. A migratable enclave that uses ROTE would not need to migrate monotonic counters but would still require a mechanism to securely migrate the keys it uses to identify itself to the ROTE system.

#### SGX Migration
The first attempt to address the problem of migrating an SGX-enabled VM was presented by Park et al. [1]. They identified the central challenge of copying the enclave’s memory to the destination machine, which naively appears to violate the SGX security guarantees (i.e., the source enclave’s data become accessible outside the source enclave). They proposed a conceptual solution that requires a new SGX hardware instruction to agree on a live migration key (LMK) between two SGX-enabled machines, and then securely transfer the enclave’s contents from the source to the destination, encrypted using the LMK. One advantage of this hardware-based approach is that the migration occurs transparently to the migrating enclave, and no software changes to the enclave are required. However, the significant disadvantage is that this would require extensive hardware changes. This proposal has therefore not been evaluated.

Gu et al. [2] presented the current state-of-the-art software-only framework to enable migration of VMs containing SGX enclaves. They focus on the challenge of migrating the data memory of an enclave, and their approach is to add a library to the enclave to support this. Their library performs remote attestation and key agreement with the destination enclave. It then re-encrypts the memory pages of the source enclave and writes out the resulting encrypted data outside the enclave’s memory. This can then be migrated with the VM and input to the equivalent library in the destination enclave. Apart from successfully migrating the enclave’s memory, they also considered issues of multithreading, since the enclave may be busy executing an ECALL when the migration takes place. They add a control thread to the enclave that, when notified of a migration, pauses the execution of the enclave by spin-locking all worker threads. Although this software-only solution cannot support transparent migration, there are various ways in which the enclave can be notified about the migration. One constraint of migrating an enclave’s data memory via a software-only solution is that all data memory on the source enclave must be made readable by the migration functionality within the enclave. The authors have presented an extensive performance evaluation, but have not released the source code.

Our solution builds upon some of the ideas presented in previous work (e.g., the migration enclave concept from Park et al. [1] and the migration library idea from Gu et al. [2]). However, neither solution considers enclaves with persistent state, leading to the potential attacks described in Section III.

### Conclusion and Future Work
To use SGX in a cloud environment, it must be possible to migrate enclaves between physical machines. While previous work showed how to migrate the data memory of enclaves, it did not consider migration of enclaves with persistent state (i.e., sealed data or monotonic counters). In this paper, we propose, design, and implement a framework to enable migration of such enclaves while maintaining the same functionality and security guarantees of non-migratable SGX enclaves. Our framework, which can be integrated with previous solutions, consists of a Migration Library that is integrated into each migratable enclave and a Migration Enclave running in the management VM on each physical machine. Our proof-of-concept implementation overcomes several practical challenges, such as accessing architectural enclaves from VMs and limiting the migration of enclaves to authorized machines, while incurring low performance overhead (less than 12.3%) and minimal additional effort for enclave developers.

As future work, we plan to investigate how enclave providers can provision customized migration policies with their enclaves. For example, a migration policy could specify minimum computational requirements of a destination machine or ensure that a particular enclave is not migrated outside a specified geographic region. These policies would be enforced by the Migration Enclave, and the mutual local attestation between the enclave and the Migration Enclave provides assurance that they will be enforced correctly.

As discussed in Section I, fully transparent migration of enclaves is not possible with current Intel SGX hardware. In our framework, each application that uses enclaves must be notified of the migration and must call the `migrate()` function provided by our Migration Library. However, it may be possible to perform the migration semi-transparently by having the hypervisor or management VM locate and call the `migrate()` function of all enclaves associated with a particular VM. The migration process will then take place as described in this paper, but will essentially be transparent to the applications and OS of the guest VM.

### Acknowledgements
This work was supported in part by ICRI-CARS at Aalto University and the Cloud Security Services (CloSer) project (3881/31/2016), funded by Business Finland.

### References
[1] J. Park, S. Park, J. Oh, and J. J. Won, “Toward Live Migration of SGX-Enabled Virtual Machines,” in 2016 IEEE World Congress on Services (SERVICES), June 2016, pp. 111–112.
[9] K. Huang, “SGX Virtualization,” https://01.org/intel-software-guard-extensions/sgx-virtualization.
[10] M. Nelson, B.-H. Lim, and G. Hutchins, “Fast Transparent Migration for Virtual Machines,” in Proceedings of the Annual Conference on USENIX Annual Technical Conference, ser. ATEC ’05, 2005, pp. 25–25. [Online]. Available: http://dl.acm.org/citation.cfm?id=1247360.1247385
[11] F. McKeen, I. Alexandrovich, A. Berenzon, C. V. Rozas, H. Shaﬁ, V. Shanbhogue, and U. R. Savagaonkar, “Innovative instructions and software model for isolated execution.” in HASP@ ISCA, vol. 10, 2013.
[12] Y. Xu, W. Cui, and M. Peinado, “Controlled-channel attacks: Deterministic side channels for untrusted operating systems,” in Security and Privacy (SP), 2015 IEEE Symposium on, 2015, pp. 640–656.
[2] J. Gu, Z. Hua, Y. Xia, H. Chen, B. Zang, H. Guan, and J. Li, “Secure Live Migration of SGX Enclaves on Untrusted Cloud,” in 2017 47th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN), 2017, pp. 225–236.
[3] J. Lind, I. Eyal, P. Pietzuch, and E. G. Sirer, “Teechan: Payment Channels Using Trusted Execution Environments,” in 4th Workshop on Bitcoin and Blockchain Research, 2017.
[4] J. Behl, T. Distler, and R. Kapitza, “Hybrids on Steroids: SGX-Based High Performance BFT,” in Proceedings of the Twelfth European Conference on Computer Systems, ser. EuroSys ’17, 2017.
[5] Intel, “Software Guard Extensions Developer Guide,” https://software.intel.com/en-us/documentation/sgx-developer-guide, 2017.
[6] I. Anati, S. Gueron, S. P. Johnson, and V. R. Scarlata, “Innovative Technology for CPU Based Attestation and Sealing,” 2013.
[7] Intel, “Software Guard Extensions SDK Developer Reference,” https://software.intel.com/en-us/sgx-sdk/documentation.
[8] E. Brickell and J. Li, “Enhanced Privacy ID from Bilinear Pairing for Hardware Authentication and Attestation,” in 2010 IEEE Second International Conference on Social Computing, Aug 2010, pp. 768–775.
[13] M. Hähnel, W. Cui, and M. Peinado, “High-resolution side channels for untrusted operating systems,” in 2017 USENIX Annual Technical Conference (USENIX ATC 17), 2017, pp. 299–312. [Online]. Available: https://www.usenix.org/conference/atc17/technical-sessions/presentation/hahnel
[14] S. Lee, M.-W. Shih, P. Gera, T. Kim, H. Kim, and M. Peinado, “Inferring fine-grained control flow inside SGX enclaves with branch shadowing,” in USENIX Security Symposium, 2017.
[15] O. Ohrimenko, F. Schuster, C. Fournet, A. Mehta, S. Nowozin, K. Vaswani, and M. Costa, “Oblivious multi-party machine learning on trusted processors.” in USENIX Security Symposium, 2016, pp. 619–636.
[16] S. Tamrakar, J. Liu, A. Paverd, J.-E. Ekberg, B. Pinkas, and N. Asokan, “The Circle Game: Scalable Private Membership Test Using Trusted Hardware,” in Proceedings of the 2017 ACM on Asia Conference on Computer and Communications Security, 2017, pp. 31–44.
[17] W. Zheng, A. Dave, J. G. Beekman, R. A. Popa, J. E. Gonzalez, and I. Stoica, “Opaque: An oblivious and encrypted distributed analytics platform.” in NSDI, 2017, pp. 283–298.
[18] F. Schuster et al., “VC3: Trustworthy Data Analytics in the Cloud,” MSR, Tech. Rep. MSR-TR-2014-39, February 2014. [Online]. Available: https://www.microsoft.com/en-us/research/publication/vc3-trustworthy-data-analytics-in-the-cloud/
[19] S. Matetic, M. Ahmed, K. Kostiainen, A. Dhar, D. Sommer, A. Gervais, A. Juels, and S. Capkun, “ROTE: Rollback Protection for Trusted Execution,” 2017.