### 4.1 Fault Emulation Using G-SWFIT

G-SWFIT is based on two key principles: 
1. The existence of a set of simple, high-level programming errors that occur frequently.
2. Knowledge of how high-level languages are translated into low-level code.

This approach allows us to identify patterns in the low-level code that correspond to locations suitable for fault injection and to determine the specific mutations needed to emulate the intended faults. The executable code mutation process is guided by a library of mutation operators previously defined for the target platform. The target code is scanned for specific low-level instruction patterns, and mutations are applied to these patterns to emulate high-level faults. Each mutation generates a different version of the original target. To cover more faults, one can simply expand the library with additional operators.

As discussed in Section 3, many of the defects that remain in software after deployment are simple programming errors. Therefore, techniques like G-SWFIT, which recreate programmer errors, provide an effective tool for fault emulation.

When defining mutation operators, the following issues are relevant:
- **Representative Faults:** The faults addressed in the library must be representative of the faults that actually appear in defective software.
- **Injection Locations:** The locations eligible for fault injection should reflect the high-level constructs where faults are likely to appear.
- **Mutation Accuracy:** The mutations applied must recreate the code that would have been generated by the compiler if the intended fault were present in the source code.

We addressed these issues in the following manner:
- **Operator Basis:** The operators proposed in this paper are based on the data on real software faults discussed in Section 3.
- **Location Selection:** The locations for fault injection are selected using appropriate search patterns, based on the high-level code locations where we observed that faults are more frequent.
- **Mutation Design:** The proposed mutations were based on the analysis of the effects of each fault and the observation of how the source code is translated into low-level code.

The resulting set of low-level mutation operators is presented in Section 4.2. Currently, G-SWFIT does not address all the faults listed in Section 3. Since this technique is oriented towards small and localized code mutations, faults that relate to large portions of code are still outside its scope.

### 4.2 Low-Level Mutation Operators

In our previous work [9], we demonstrated that the construction of the low-level mutation library is primarily dependent on the target processor architecture. While the programming language, compiler, and compiler optimization settings also influence the library, they account for some additional fault operators. Different processor architectures, however, require completely different libraries. The operators presented here are designed for the IA32 architecture, and the target applications are assumed to be 32-bit code. The search patterns and related mutations were derived from observing compiler code generation under different optimization settings. Both patterns and mutations are presented in assembly mnemonics according to Intel notation [16].

The G-SWFIT mutation operators are defined around two concepts:
- **Search Pattern:** A sequence of machine code instructions that relates to the high-level constructs where faults can be emulated. Search patterns are designed to identify locations where it is pertinent to emulate a given fault and exclude other locations where such a fault would not be meaningful.
- **Low-Level Mutation:** The mutation to apply to a location to emulate the intended fault.

It is worth noting that most of the operators cover more than one fault type described in Section 3.4, which simplifies the task of building the operator library. Due to space restrictions, we cannot present a comprehensive list of mutation operators here (see [11] for a more complete list). The operators listed in Table 12 cover the following types:

#### Missing Function Call
- **Operator (OFC):** This operator locates function calls in contexts where the return value is not used. Removing a function call where its value is needed would not represent a real software fault. This restriction is implemented by ensuring that the `CALL` instruction is not followed by instructions that use the return value.

#### Missing/Wrong Initialization
- **Operators (OIV, OIE):** These operators address different ways a variable can be initialized, either through the assignment of a value (OIV) or another variable or expression (OIE). Search patterns locate the first occurrence of an assignment to a stack-resident variable.

#### Missing/Wrong Variable Assignment
- **Operators (OAE, OAV, OAA, OAVW):** These operators address various ways a variable can be assigned, such as through the assignment of a value (OAV), another variable, or an expression (OAE). Operator OAA covers both cases. To avoid emulating missing variable initialization faults, the first occurrence of assignment to each offset inside the function stack space is excluded from mutation. Operator OAVW addresses the emulation of a wrong value used in a variable assignment.

#### Wrong Variable in Parameter of Function Call
- **Operator (OWPV):** This operator emulates the use of a wrong variable as a parameter in a function call. It locates `CALL` instructions that are preceded by the fetching and pushing of a stack-resident variable.

#### Missing "if (cond)"
- **Operators (OIA, OIS):** Operator OIA recreates a missing `if` condition, causing some instructions to always execute instead of only when the condition is met. Operator OIS emulates a missing `if` construct and the statements it affects.

#### Missing "AND expr" in Logical Expression Used in Branch Condition
- **Operator (OLAC):** This operator emulates the omission of part of a logical expression used in a branch condition. The logical expression is composed of a sequence of at least two sub-expressions linked together with the logical operator `AND`. The effect of omitting one of the sub-expressions can be obtained by removing its related jump instruction.

### 5. Conclusions

The analysis of field data on more than five hundred real software faults shows a clear trend in fault distribution across ODC classes. Other research works using field data have also obtained similar fault distributions, despite using different sources. This suggests that this fault distribution is a characteristic of software faults in general and should be reflected in faultload definition for representative emulation of software faults. One important conclusion is that a smaller subset of specific fault types is clearly dominant regarding fault occurrence. These specific fault types are the obvious candidates for the emulation of software faults.

The emulation of software faults can be performed using a technique that mutates the low-level code in a way that recreates the code that would have been produced by the compiler if the fault had occurred at the high-level source code. This method is simple and can be used even when the original source code is not available. Our field data analysis led us to define a set of mutation operators that emulate the majority of fault types expected to be found in real software.

To assist in the definition of mutation operators, faults were classified as missing, wrong, or extraneous constructs. This classification proved useful as it is well adapted to common mistakes made by programmers and leads to a considerable simplification in the definition of mutation operators. In fact, the same operator can generally emulate more than one fault type.

### References

[1] J. Aidemark, J. Vinter, P. Folkesson, J. Karlsson, “GOOFI: Generic Object-Oriented Fault Injection Tool,” Proceedings of International Conference on Dependable Systems and Networks, DSN-2001, Göteborg, Sweden, 2001, pp. 71-76.

[2] J. Arlat et al., “Fault Injection and Dependability Evaluation of Fault Tolerant Systems,” IEEE Transactions on Computers, vol. 42, no. 8, pp. 919-923, August 1993.

[3] A. Brown, D. Patterson, “Towards Availability Benchmark: A Case Study of Software RAID Systems,” Proceedings of 2000 USENIX Annual Technical Conference, San Diego, California, USA, June 18-23, 2000, pp. 263-276.

[4] J. Carreira, H. Madeira, J. G. Silva, “Xception: Software Fault Injection and Monitoring in Processor Functional Units,” IEEE Transactions on Software Engineering, vol. 24, no. 2, Feb. 1998.

[5] R. Chillarege, “Orthogonal Defect Classification,” Ch. 9 of “Handbook of Software Reliability Engineering,” M. Lyu Ed., IEEE Computer Society Press, McGraw-Hill, 1995.

[6] J. Christmansson and R. Chillarege, “Generation of an Error Set that Emulates Software Faults,” Proceedings of the 26th IEEE Fault Tolerant Computing Symposium, FTCS-26, Sendai, Japan, pp. 304-313, June 1996.

[7] D. Costa, T. Rilho, M. Vieira, H. Madeira, “ESFFI–A Novel Technique for the Emulation of Software Faults in COTS Components,” Conference on the Engineering of Computer-Based Systems, ECBS 2001, Washington, DC, USA, April 2001.

[8] M. Daran, P. Thévenod-Fosse, “Software Error Analysis: A Real Case Study Involving Real Faults and Mutations,” Proc. of 3rd Symposium on Software Testing and Analysis, ISSTA-3, San Diego, USA, pp. 158-171, January 1996.

[9] J. Durães, H. Madeira, “Emulation of Software Faults by Educated Mutations at Machine-Code Level,” Proceedings of the Thirteenth IEEE International Symposium on Software Reliability Engineering, ISSRE’02, November 2002, Annapolis MD, USA.

[10] J. Durães, H. Madeira, “Characterization of Operating Systems Behavior in the Presence of Faulty Drivers through Software Fault Emulation,” Proceedings of the Ninth IEEE Pacific Rim International Symposium on Dependable Computing, PRDC’02, December 2002, Tsukuba, Japan.

[11] J. Durães, H. Madeira, “Definition of Complete Set of Software Fault Emulation Operators Based on a Field Data Study,” Technical Report DEI-005-2002, ISSN 0873-9293, Departamento de Engenharia Informática – FCTUC, 2002, http://www.dei.uc.pt/~henrique/G-SWFIT.htm.

[12] R. DeMillo, D. Guindi, W. McCracken, A. Offut, K. King, “An Extended Overview of the Mothra Software Testing Environment,” Proc. of ACM SIGSOFT/IEEE 2nd Workshop on Software Testing, Verification, and Analysis, pp. 142-151, July 1988.

[13] J.-C. Fabre, F. Salles, M. R. Moreno, J. Arlat, “Assessment of COTS Microkernels by Fault Injection,” in Dependable Computing for Critical Applications (Proceedings of the 7th IFIP Working Conference on Dependable Computing for Critical Applications: DCCA-7, San Jose, CA, USA, Jan. 1999).

[14] J. Gray, “A Census of Tandem Systems Availability Between 1985 and 1990,” IEEE Transactions on Reliability, vol. 39, no. 4, pp. 409-418, October 1990.

[15] J. P. Hudepohl et al., “EMERALD: A Case Study in Enhancing Software Reliability,” Proceedings of 8th International Symposium on Software Reliability Engineering, ISSRE’98, Nov. 1998.

[16] Intel Architecture Software Developer’s Manual, Volume 2: Instruction Set Reference, Intel Corporation, 1997.

[17] R. K. Iyer, “Experimental Evaluation,” Special Issue FTCS-25 Silver Jubilee, 25th IEEE Symposium on Fault Tolerant Computing, FTCS-25, pp. 115-132, June 1995.

[18] G. Kanawati, N. Kanawati, J. Abraham, “FERRARI: A Tool for the Validation of System Dependability Properties,” Proceedings of the 22nd IEEE Fault Tolerant Computing Symposium, FTCS-22, pp. 336-344, June 1992.

[19] K. Kanoun, J. Arlat, D. Costa, M. Dal Cin, P. Gil, J-C. Laprie, H. Madeira, N. Suri, “DBench: Dependability Benchmarking,” Supplement of International Conference on Dependable Systems and Networks, DSN-2001, Göteborg, Sweden, 2001.

[20] T. Khoshgoftaar et al., “Process Measures for Predicting Software Quality,” High Assurance Systems Engineering Workshop, HASE’97, Washington D.C., USA, 1997.

[21] P. Koopman, J. Sung, C. Dingman, D. Siewiorek, T. Marz, “Comparing Operating Systems Using Robustness Benchmarks,” in Proceedings of the 16th International Symposium on Reliable Distributed Systems, SRDS-16, Durham, NC, USA, 1997.

[22] I. Lee, R. K. Iyer, “Software Dependability in the Tandem GUARDIAN System,” IEEE Transactions on Software Engineering, vol. 21, no. 5, pp. 455-467, May 1995.

[23] M. Lyu, “Handbook of Software Reliability Engineering,” IEEE Computer Society Press, McGraw-Hill, 1996.

[24] H. Madeira, M. Vieira, D. Costa, “On the Emulation of Software Faults by Software Fault Injection,” International Conference on Dependable Systems and Networks, NY, USA, June 2000.

[25] J. Musa, “Software Reliability Engineering,” McGraw-Hill, 1996.

[26] W. T. Ng, C. M. Aycock, P. M. Chen, “Comparing Disk and Memory’s Resistance to Operating System Crashes,” Proc. of the 7th IEEE Int. Symp. on Software Reliability Engineering, ISSRE’96, Oct. 1996, New York, USA.

[27] Wee. T. Ng and Peter M. Chen, “Systematic Improvement of Fault Tolerance in the RIO File Cache,” Proc. of the 30th IEEE Fault Tolerant Computing Symposium, FTCS-29, Madison, WI, USA, June 1999.

[28] M. Sullivan, R. Chillarege, “Software Defects and Their Impact on Systems Availability – A Study of Field Failures on Operating Systems,” Proc. of the 21st IEEE Fault Tolerant Computing Symposium, FTCS-21, pp. 2-9, June 1991.

[29] T. Tsai and R. K. Iyer, “An Approach to Benchmarking of Fault-Tolerant Commercial Systems,” Proceedings of the 26th IEEE Fault Tolerant Computing Symposium, FTCS-26, Sendai, Japan, pp. 314-323, June 1996.

[30] J. Voas, G. McGraw, L. Kassab, L. Voas, “A ‘Crystal Ball’ for Software Liability,” 1996.

[31] J. Voas, F. Charron, G. McGraw, K. Miller, and M. Friedman, “Predicting How Badly ‘Good’ Software Can Behave,” IEEE Software, 1997.

### Acknowledgements

Funding for this paper was provided, in part, by the Portuguese Government/European Union through R&D Unit 326/94 (CISUC) and by the DBench project, IST 2000 - 25425 DBENCH, funded by the European Union. We also thank Kerstin Buchacker and Roland Karch for showing us the bugs database of open-source programs.