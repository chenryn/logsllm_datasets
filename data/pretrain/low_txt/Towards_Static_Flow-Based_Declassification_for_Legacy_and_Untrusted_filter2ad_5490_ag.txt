### Optimized Text

To ensure that a sufficient number of values are averaged, the resulting value must be carefully managed. We propose that the problem of determining how many times a loop should run can be effectively addressed through a combination of static analysis and runtime enforcement mechanisms. Static analysis would define the necessary constraints, while runtime mechanisms would enforce them.

Secondly, this paper does not address the challenge of matching program graphs against policy graphs up to algebraic equivalence of the denoted expressions [42]. This capability would allow for the verification of programs that compute expressions different from those specified by the declassification policy but equivalent under algebraic laws such as associativity, commutativity, and idempotence. One possible approach is to transform both program and policy graphs into a normal form before applying the matching algorithm. However, this can lead to a combinatorial explosion, necessitating conservative approximations to maintain tractability.

Our flow analysis is termination-insensitive [43]. To make it termination-sensitive, we could either disallow while loops under high conditionals or introduce a flow between the conditional and all output channels in the program. However, both approaches are overly restrictive. Disallowing while loops under high conditionals would make the program dependent on the policy, which we aim to avoid. Balancing correct termination behavior with practical analysis is challenging and beyond the scope of this paper. Therefore, we do not address termination and timing channels in this work.

The policies used in our framework specify the expressions over inputs that can be declassified, addressing the "what" dimension of declassification. Extending our analysis to the "who" dimension is straightforward, as the system operator can control which policy graphs are used based on the program's author and the intended observers of the output. However, extensively using the "where" dimension would contradict our goal of making the policy independent of the program. For legacy code, which typically lacks explicitly defined information-flow policies, and untrusted code, where assurance is needed without trusting the programmer, it is feasible to specify program points where a particular policy applies. The "when" dimension, which may require different parts of the program to be verified with different policies based on runtime conditions, is more challenging and may only be realistic for newly written, trusted code.

A key assumption in our work is that declassifications are not invertible. This is reasonable given well-formed policies. If a declassification policy allows \( f(\alpha) \) and an inverse function \( f^{-1} \) exists, the policy effectively discloses \( \alpha \). Even if a mechanism checks for the absence of inversion in the code, nothing prevents the inverse function from being applied externally. Thus, we assume that well-formed policies do not permit the declassification of invertible expressions.

Sections V and VI assume that all output channels in the program are observable and all input channels are controlled by the target system. To relax these assumptions, we can associate security levels with inputs and outputs and use standard lattice models to specify allowed flows. Policy graph nodes would be labeled accordingly, and the analysis algorithm would respect these labels, with minimal changes to our approach or the PCR theorem and its proof.

If the input channels used in the program are interactive, their values can change outside the program's control, potentially influencing other input channels. Such interactions are not considered in our current threat model but can be addressed by including additional assumptions about channel interactions. For example, if a set of input channels is under an attacker's control, they can be treated as equivalent, requiring shared control dependencies. If any of these channels is read in a non-declassifiable context, no value from any of these channels may be declassified. Similar reasoning applies if reads themselves are observable events. These issues will be addressed in future work.

Our approach can be extended to support a broader range of language constructs. Since we rely on φ-functions from SSA translation to recognize control-flow branches, commands like `case`, `continue`, `break`, and others can be included if there is a valid SSA translation. For constructs such as procedures, methods, classes, and inheritance, our approach can be adapted to work modularly [44]. Individual blocks of code, such as user-defined functions, can be analyzed by generating separate graphs, with calls to these blocks using "procedure call edges" to reference "argument nodes." Global variables and class parameters, however, would require special treatment. Extending our approach to handle concurrency and constructs that enable unpredictable control flow (e.g., computed goto, exceptions) presents significant challenges.

### Acknowledgements

Part of this research was supported by the STW Sentinels Project “S-Mobile,” the NSF under awards CNS 08-31212, CNS-0716210, and CNS-0716750, and the Texas Higher Education Coordinating Board NHARP Award 010115-0037-2007. We would like to thank all the reviewers for their helpful comments and suggestions.

### References

[1] A. Sabelfeld and A. C. Myers, “Language-based information-flow security,” IEEE Journal on Selected Areas in Communications, vol. 21, 2003.
[2] J. A. Goguen and J. Meseguer, “Security policies and security models,” in SP ’82: Proceedings of the 3rd IEEE Symposium on Security and Privacy, 1982, pp. 11–20.
[3] A. C. Myers, “JFlow: practical mostly-static information flow control,” in POPL ’99: Proceedings of the 26th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. New York, NY, USA: ACM, 1999, pp. 228–241.
[4] F. Pottier and V. Simonet, “Information flow inference for ML,” ACM Transactions on Programming Languages and Systems, vol. 25, no. 1, pp. 117–158, 2003.
[5] D. M. Volpano, C. E. Irvine, and G. Smith, “A Sound Type System for Secure Flow Analysis,” Journal of Computer Security, vol. 4, pp. 167–188, 1996.
[6] T. Amtoft and A. Banerjee, “Information Flow Analysis in Logical Form,” in SAS ’04: 11th International Static Analysis Symposium, 2004, pp. 100–115.
[7] T. Amtoft, S. Bandhakavi, and A. Banerjee, “A logic for information flow in object-oriented programs,” in POPL ’06: Proceedings of the 33rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, 2006, pp. 91–102.
[8] J.-P. Banâtre, C. Bryce, and D. L. Métayer, “Compile-Time Detection of Information Flow in Sequential Programs,” in ESORICS ’94: Proceedings of the 3rd European Symposium on Research in Computer Security. London, UK: Springer-Verlag, 1994, pp. 55–73.
[9] D. E. Denning, “A Lattice Model of Secure Information Flow,” Communications of the ACM, vol. 19, no. 5, pp. 236–243, 1976.
[10] A. Sabelfeld and D. Sands, “Dimensions and Principles of Declassification,” in CSFW ’05: Proceedings of the 18th IEEE Workshop on Computer Security Foundations, 2005, pp. 255–269.
[11] S. Zdancewic, “Challenges in Information-Flow Security,” in PLID ’04: Proceedings of the First International Workshop on Programming Language Interference and Dependence, Verona, Italy, August 2004.
[12] A. Banerjee, D. A. Naumann, and S. Rosenberg, “Expressive Declassification Policies and Modular Static Enforcement,” in SP ’08: Proceedings of the 29th IEEE Symposium on Security and Privacy, 2008, pp. 339–353.
[13] B. Hicks, D. King, P. McDaniel, and M. Hicks, “Trusted declassification: high-level policy for a security-typed language,” in PLAS ’06: Proceedings of the 2006 Workshop on Programming Languages and Analysis for Security. New York, NY, USA: ACM, 2006, pp. 65–74.
[14] R. Cytron, J. Ferrante, B. K. Rosen, M. N. Wegman, and F. K. Zadeck, “Efficiently computing static single assignment form and the control dependence graph,” ACM Transactions on Programming Languages and Systems, vol. 13, no. 4, pp. 451–490, 1991.
[15] G. Bilardi and K. Pingali, “Algorithms for computing the static single assignment form,” Journal of the ACM, vol. 50, no. 3, pp. 375–425, 2003.
[16] M. M. Brandis and H. Mössenböck, “Single-pass generation of static single-assignment form for structured languages,” ACM Transactions on Programming Languages and Systems, vol. 16, no. 6, pp. 1684–1698, 1994.
[17] R. Milner, Communication and concurrency. Upper Saddle River, NJ, USA: Prentice-Hall, Inc., 1989.
[18] B. P. S. Rocha, S. Bandhakavi, J. den Hartog, W. H. Winsborough, and S. Etalle, “Towards Static Flow-based Declassification for Legacy and Untrusted Programs,” Tech. Rep., to appear.
[19] A. Askarov and A. Sabelfeld, “Gradual Release: Unifying Declassification, Encryption and Key Release Policies,” in SP ’07: Proceedings of the 28th IEEE Symposium on Security and Privacy. Washington, DC, USA: IEEE Computer Society, 2007, pp. 207–221.
[20] A. Banerjee and D. A. Naumann, “Secure Information Flow and Pointer Confinement in a Java-like Language,” in CSFW ’02: Proceedings of the 15th IEEE Workshop on Computer Security Foundations. Washington, DC, USA: IEEE Computer Society, 2002, p. 253.
[21] J.-F. Bergeretti and B. A. Carré, “Information-Flow and Data-Flow Analysis of While-Programs,” ACM Transactions on Programming Languages and Systems, vol. 7, no. 1, pp. 37–61, 1985.
[22] D. Clark, C. Hankin, and S. Hunt, “Information flow for Algol-like languages,” Computer Languages, vol. 28, no. 1, pp. 3–28, 2002.
[23] C. Hammer, J. Krinke, and G. Snelting, “Information flow control for Java based on path conditions in dependence graphs,” in ISSSE ’06: Proceedings of the IEEE International Symposium on Secure Software Engineering. IEEE, 2006.
[24] C. Hammer and G. Snelting, “Flow-sensitive, context-sensitive, and object-sensitive information flow control based on program dependence graphs,” International Journal of Information Security, vol. 8, no. 6, pp. 399–422, December 2009, supersedes ISSSE and ISoLA 2006.
[25] N. Swamy and M. Hicks, “Verified enforcement of stateful information release policies,” in PLAS ’08: Proceedings of the 3rd ACM SIGPLAN Workshop on Programming Languages and Analysis for Security. New York, NY, USA: ACM, 2008, pp. 21–32.
[26] P. Li and S. Zdancewic, “Downgrading policies and relaxed noninterference,” SIGPLAN Notices, vol. 40, no. 1, pp. 158–170, 2005.
[27] S. Chong and A. C. Myers, “Security policies for downgrading,” in CCS ’04: Proceedings of the 11th ACM Conference on Computer and Communications Security, New York, NY, USA, 2004, pp. 198–209.
[28] S. Tse and S. Zdancewic, “A Design for a Security-Typed Language with Certificate-Based Declassification,” in ESOP ’05: 14th European Symposium on Programming, 2005, pp. 279–294.
[29] S. Chong and A. C. Myers, “End-to-End Enforcement of Erasure and Declassification,” in CSF ’08: Proceedings of the 21st IEEE Computer Security Foundations Symposium, 2008, pp. 98–111.
[30] A. Sabelfeld and A. C. Myers, “A Model for Delimited Information Release,” in ISSS ’03: International Symposium on Software Security, 2003, pp. 174–191.
[31] N. Swamy, M. Hicks, S. Tse, and S. Zdancewic, “Managing policy updates in security-typed languages,” in CSFW ’06: Proceedings of the 19th IEEE Workshop on Computer Security Foundations, 2006, pp. 202–216.
[32] S. Bandhakavi, W. H. Winsborough, and M. Winslett, “A Trust Management Approach for Flexible Policy Management in Security-Typed Languages,” in CSF ’08: Proceedings of the 21st IEEE Computer Security Foundations Symposium, 2008, pp. 33–47.
[33] B. Hicks, D. King, and P. McDaniel, “Declassification with Cryptographic Functions in a Security-Typed Language,” Network and Security Center, Department of Computer Science, Pennsylvania State University, Tech. Rep. NAS-TR-0004-2005, January 2005, (updated May 2005).
[34] A. Askarov and A. Sabelfeld, “Localized delimited release: combining the what and where dimensions of information release,” in PLAS ’07: Proceedings of the 2nd Workshop on Programming Languages and Analysis for Security. New York, NY, USA: ACM, 2007, pp. 53–60.
[35] S. Chong, A. C. Myers, K. Vikram, and L. Zheng, Jif Reference Manual, June 2006. [Online]. Available: http://www.truststc.org/pubs/548.html
[36] A. Askarov and A. Sabelfeld, “Security-Typed Languages for Implementation of Cryptographic Protocols: A Case Study,” in ESORICS ’05: Proceedings of the 10th European Symposium on Research in Computer Security, 2005, pp. 197–221.
[37] ——, “Tight enforcement of information-release policies for dynamic languages,” in CSF ’09: Proceedings of the 22nd IEEE Computer Security Foundations Symposium. Washington, DC, USA: IEEE Computer Society, 2009, pp. 43–59.
[38] P. Giambiagi and M. Dam, “On the secure implementation of security protocols,” Science of Computer Programming, vol. 50, no. 1-3, pp. 73–99, 2004.
[39] V. B. Livshits and M. S. Lam, “Finding security vulnerabilities in Java applications with static analysis,” in SSYM ’05: Proceedings of the 14th Conference on USENIX Security Symposium. Berkeley, CA, USA: USENIX Association, 2005, pp. 18–18.
[40] O. Tripp, M. Pistoia, S. J. Fink, M. Sridharan, and O. Weisman, “TAJ: effective taint analysis of web applications,” in PLDI ’09: Proceedings of the 2009 ACM SIGPLAN Conference on Programming Language Design and Implementation, New York, NY, USA, 2009, pp. 87–97.
[41] R. Giacobazzi and I. Mastroeni, “Abstract non-interference: parameterizing non-interference by abstract interpretation,” in POPL ’04: Proceedings of the 31st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. New York, NY, USA: ACM, 2004, pp. 186–197.
[42] J. Hendrix and H. Ohsaki, “Combining equational tree automata over AC and ACI theories,” in RTA ’08: Proceedings of the 19th International Conference on Rewriting Techniques and Applications. Springer-Verlag, 2008, pp. 142–156.
[43] A. Askarov, S. Hunt, A. Sabelfeld, and D. Sands, “Termination-insensitive noninterference leaks more than just a bit,” in ESORICS ’08: Proceedings of the 13th European Symposium on Research in Computer Security. Springer, 2008, pp. 333 – 348.
[44] T. Reps, S. Horwitz, and M. Sagiv, “Precise Interprocedural Dataflow Analysis via Graph Reachability,” in POPL ’95: Proceedings of the 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. New York, NY, USA: ACM, 1995, pp. 49–61.