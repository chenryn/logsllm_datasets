### C. Comparison with Other Detection Solutions

We have conducted experiments using two publicly available PHP vulnerability scanners: RIPS [22], [23] and WAP [24]. Both tools offer options to detect unrestricted file upload vulnerabilities. Specifically, RIPS identifies sensitive sinks as potential vulnerable functions if they are tainted by untrusted inputs. While taint analysis considers the source of the uploaded file, it does not model the file's name or extension, leading to a higher likelihood of false positives. WAP combines taint analysis with machine learning for detection but does not specifically model the uploaded file.

In our tests, we scanned 28 vulnerability-free samples, 13 known vulnerable scripts, and 3 newly detected vulnerable plugins. RIPS detected 15 out of 16 vulnerable samples (missing "the WooCommerce Custom Profile") with a high false positive rate of 27/28. WAP, on the other hand, achieved a detection rate of 4/16 with a false positive rate of 1/28. We acknowledge that UChecker currently focuses only on unrestricted file upload vulnerabilities, while RIPS and WAP cover a broader range of vulnerabilities. However, these systems can complement each other in practical usage.

### V. Related Work

Static program analysis has been widely adopted to detect various types of vulnerabilities [25], [26], [27], [9], [28], [29], [30], [31], [23]. For instance, Zheng et al. [25], [26] and Xie et al. [27] use static program analysis to detect PHP web applications vulnerable to SQL injection and cross-site scripting (XSS) attacks. Son et al. [9] proposed a method to identify semantic vulnerabilities such as infinite loops and missing authorization checks in PHP web applications. Dahse et al. [28] designed a system to detect SQL injections and XSS using data flow analysis. Barth et al. [29] developed a system to detect XSS attacks by analyzing the structure of content submitted to the server.

Compared to these methods, UChecker focuses on a different vulnerability: unrestricted file upload. Staicu et al. [31] studied Node.js applications vulnerable to injection attacks that exploit `exec` or `eval` APIs. Similar to UChecker, this method also interprets the abstract syntax tree (AST) of a web application for analysis. However, it uses template matching rather than symbolic execution to detect vulnerabilities and targets different types of vulnerabilities. Dahse et al. [23] proposed novel block and function summaries to detect taint-style vulnerabilities. Unfortunately, taint analysis alone is insufficient to model unrestricted file upload vulnerabilities, often leading to false positives. Samimi et al. [32] designed a system to automatically repair HTML generation errors in PHP applications using string constraint solving techniques, but this system addresses a different problem. Nunes et al. [33] conducted benchmark-based assessments to compare the capabilities of publicly available static vulnerability detection tools.

Many methods detect vulnerable PHP applications [34], [35], [36] and JavaScript applications [37] using dynamic program analysis, which fundamentally differs from the static analysis methodology employed by UChecker. Although dynamic analysis is generally more efficient, it often suffers from low coverage of program paths and high uncertainties introduced by the runtime environment. In UChecker, we mitigate the performance bottleneck inherent in static analysis by designing a vulnerability-oriented locality analysis.

Several existing projects [38], [39], [5], [28], [40] have studied unrestricted file upload vulnerabilities. For example, Canali et al. [40] built a honeypot to study actual malicious upload attempts. Despite the insights gained from these studies, a systematic solution capable of detecting vulnerable web applications before deployment is still lacking. UChecker aims to fill this gap.

### VI. Discussion

The current implementation of UChecker has several limitations. First, UChecker currently focuses on vulnerabilities that allow the uploading of PHP files (i.e., those with ".php" and ".php5" extensions). However, variant vulnerabilities may permit files with other potentially harmful extensions such as ".asa" and ".swf". UChecker can be extended to cover these variants by verifying additional extensions.

Second, as demonstrated in Section IV-A, false positives are mainly attributed to the fact that UChecker does not model WordPress's built-in function `add_action('admin_menu', func_name)`. This does not represent a design flaw, as modeling platform-dependent functions is constrained by awareness of these functions. Nevertheless, this can be a practical challenge if the variety and dynamics of built-in functions are high.

Third, UChecker’s interpreter does not cover all language features of PHP. For example, UChecker does not precisely model loops, which may lead to false negatives and false positives. Performing effective symbolic execution for loops is an intrinsic challenge in static program analysis and is not a specific flaw of our design. Additionally, PHP is a dynamic language. Although UChecker’s translation rules partially address challenges introduced by PHP’s dynamic types, it does not handle executable content generated by a PHP script at runtime. Consequently, scripts analyzed by UChecker might be incomplete, leading to detection inaccuracies. A potential solution is to integrate dynamic analysis to access all executables produced at runtime.

Finally, UChecker does not model PHP regular expression matching operations due to their high complexity. A potential solution is to leverage Z3’s built-in regular-expression-enabled solver. However, such a solver may not sufficiently cover all cases expressible by PHP regular expressions. Another potential solution is to integrate dynamic analysis into the interpretation process, assigning concrete values to certain symbols.

### VII. Conclusion

We have developed UChecker to automatically detect PHP-based web programs with unrestricted file upload vulnerabilities. UChecker interprets the abstract syntax trees of PHP source code for symbolic execution, with performance enhanced by a novel vulnerability-oriented locality analysis algorithm. We model vulnerabilities using constraints and verify them using an SMT solver. Experiments have shown that UChecker successfully detected three vulnerable web applications that had not been publicly reported.