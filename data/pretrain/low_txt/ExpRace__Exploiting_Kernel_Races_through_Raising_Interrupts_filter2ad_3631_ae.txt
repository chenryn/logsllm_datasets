### Success Number and Cycles

The success number was not maintained before reaching 2,250 cycles of \( T_x \). It is important to note that both membarrier and TLB shootdown also failed to maintain the success number. This implies that even if these methods were applied to da1b9564 (regardless of the process/thread issue), they would have failed to exploit the vulnerability.

In the probability model (Figure 9-a-2), hardware interrupts only succeeded when \( T_x \) was approximately 2,250 cycles. The other sub-figures (from Figure 9-b-1 to 9-d-1) showed consistent results with Figure 9-a-1. Specifically, when \( T_y \) was {41, 130, 1135} cycles, the vulnerabilities {CVE-2017-15265, CVE-2019-1999, CVE-2019-2025, 11eb85ec, 1a6084f8, 20f2e4c2, 4842e98f, e20a2e9c} could be exploited by all EXPRACE methods, respectively. However, the baseline method failed for all eight vulnerabilities, which is consistent with real-world exploitation results. For CVE-2019-1999, only TLB shootdown and hardware interrupt methods were successful, aligning with real-world exploitation outcomes.

### Event Analysis During Exploitation

Figure 10 illustrates the number of related events—Syscallx, Syscally, and the number of interrupts (including both hardware interrupts and IPIs)—during the exploitation. Over one minute, the number of Syscallx events was similar for all exploitation methods (approximately 250M) because the handling mechanism of Syscallx is not affected by the varying exploitation methods.

In contrast, the number of Syscally events varied. The baseline method had the highest number because Syscally handling was not interrupted. All other methods had fewer Syscally events because their execution stalled upon receiving an interrupt.

Regarding the number of interrupts, there were no interrupts during the baseline method. Membarrier had the highest number of interrupts, likely due to its lighter IPI, allowing it to be delivered quickly. Hardware interrupts had the fewest among EXPRACE's methods, suggesting that their interrupt issue logic is the slowest.

### Accuracy of the Probability Model

Overall, both synthetic evaluation results and probability model results showed a sharp decrease at a specific x-axis value. As depicted in Figure 9-d-1, the number of successes sharply decreased after \( T_x \) exceeded 16,000 cycles. Similarly, in Figure 9-d-2, the number of successes sharply decreased after \( T_x \) exceeded 15,000 cycles. The slight difference between these two results is attributed to measurement errors. While the probability model uses fixed cycle values, synthetic experiments can have measurement errors due to noise.

### Length of Enlarged Race Windows

To determine the extent of race window enlargement, we measured the cycles of \( T_y' \) when exploiting the synthetic race. Specifically, we fixed \( T_x \) and \( T_y \) at 539 and 25 cycles, respectively. We then instrumented rdtsc at two points: (i) right before line 23 in Figure A.4 (point A in Figure 8) and (ii) right after line 27 in Figure A.4 (point D in Figure 8).

Figure 11 shows the average \( T_y' \) for each exploitation method. A filled circle denotes the average cycles when the exploitation was successful, and a cross mark indicates failure. The cycle difference between success and failure for each method indicates \( T_E \), as success means the race window is extended (\( T_y' = T_y + T_E \)). Overall, all methods showed higher \( T_y' \) when successful, with different levels of enlargement. The hardware interrupt method had the largest \( T_E \) (14,103 cycles), explaining why it maintained the number of successes while varying \( T_x \) in Figure 9. Conversely, Reschedule had the smallest \( T_E \) (734 cycles), leading to earlier drops in success numbers compared to other EXPRACE methods.

### Exploiting Other Operating Systems

To evaluate the effectiveness of EXPRACE on other operating systems, we tested the synthetic race vulnerability developed as a kernel driver for Windows and macOS. Figure 12 shows the results, where \( T_y \) was fixed at 17 cycles, and the exploitation ran for one minute. Reschedule and TLB shootdown showed significantly more successes than the baseline, demonstrating EXPRACE's effectiveness. In Linux, the success number dropped quickly when \( T_x > 1,400 \), but in Windows and macOS, this drop occurred when \( T_x > 2,000 \). This suggests that TLB flushing in Linux is faster than in Windows and macOS.

Unfortunately, we could not include real-world exploitation cases for Windows and macOS due to the lack of public descriptions of non-inclusive race vulnerabilities on these platforms. This limitation is further discussed in Section 8.1.

### Mitigation Approaches

To mitigate new exploitation threats introduced by EXPRACE, two potential approaches are:

1. **Identifying Abnormal Interrupt Frequency**: EXPRACE imposes frequent interrupts, so attempts can be detected by a kernel-level monitor that checks for an unusually high number of interrupts within a short period. This approach is simple to implement but may produce false positives, requiring further investigation.

2. **Avoiding Preemption by Userspace-Originated Interrupts**: By avoiding preemption of kernel execution context if an interrupt is raised by a user, EXPRACE's exploitation technique can be mitigated. This approach requires significant kernel modifications to track the origins of all interrupt events, potentially hindering practical adoption and imposing runtime overheads.

Adopting these approaches requires careful consideration to avoid breaking the original semantics and backward compatibility of existing kernel services. We hope this paper provokes discussions on the fundamental design of interrupt handling in operating systems from a security perspective, questioning whether unprivileged users should be allowed to control interrupt timing.

### Related Work

**Detecting Races**: Many works use static or dynamic analysis to detect race conditions. Static analysis methods often employ lockset analysis, while dynamic analysis techniques selectively monitor memory accesses. EXPRACE focuses on exploiting real-world race conditions rather than automating detection.

**Avoiding Races**: Previous works use deterministic execution to avoid concurrency bugs. Grace, DThread, PEREGRINE, and Parrot propose various mechanisms to ensure deterministic behavior in multi-threaded programs.

**Automating Exploitation of Memory Corruptions**: Tools like APEG, AEG, mayhem, FUZE, Revery, and KOOBE automate the generation of exploits for memory corruption vulnerabilities. These tools differ from EXPRACE, which targets race conditions.

**Performance Degradation**: Researchers have used performance degradation factors like interrupts and cache evictions to launch side-channel attacks. EXPRACE differs by focusing on race issues and assuming user-level privileges, unlike previous works that assume full kernel control.

### Conclusion

This paper studies the exploitability of kernel data races, analyzing real-world kernel races and developing EXPRACE, a generic race exploitation technique for Linux, Windows, and macOS. Evaluations with real-world race vulnerabilities demonstrate that EXPRACE effectively enhances the exploitability of kernel races.

### Acknowledgment

We thank anonymous reviewers and our shepherd, Vasileios P. Kemerlis, for their valuable feedback. We also acknowledge Dae R. Jeong for providing the initial idea and insights. This work was supported by the National Research Foundation (NRF) of Korea, Institute for Information & Communications Technology Promotion (IITP), and US Office of Naval Research. Research facilities were provided by the Institute of Engineering Research (IOER) and Automation and Systems Research Institute (ASRI) at Seoul National University.

### References

[1] T. Allan, B. B. Brumley, K. Falkner, J. Van de Pol, and Y. Yarom. Amplifying side channels through performance degradation. In Proceedings of the Annual Computer Security Applications Conference (ACSAC), 2016.
[2] N. Amit. Optimizing the TLB Shootdown Algorithm with Page Access Tracking. In Proceedings of the 2017 USENIX Annual Technical Conference (ATC), Santa Clara, CA, July 2017.
[3] Z. Anderson, D. Gay, R. Ennals, and E. Brewer. Sharc: Checking data sharing strategies for multithreaded C. In Proceedings of the 2008 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), Tucson, Arizona, June 2008.
[4] A. Aviram, S.-C. Weng, S. Hu, and B. Ford. Efficient system-enforced deterministic parallelism. Communications of the ACM, 55(5):111–119, 2012.
[5] J.-J. Bai, J. Lawall, Q.-L. Chen, and S.-M. Hu. Effective static analysis of concurrency use-after-free bugs in Linux device drivers. In Proceedings of the 2019 USENIX Annual Technical Conference (ATC), RENTON, WA, July 2019.
[6] E. D. Berger, T. Yang, T. Liu, and G. Novark. Grace: safe multithreaded programming for C/C++. In Proceedings of the 24th Annual ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), Orlando Florida, Oct. 2009.
[7] M. D. Bond, K. E. Coons, and K. S. McKinley. Pacer: proportional detection of data races. In Proceedings of the 2010 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), Toronto, Canada, June 2010.
[8] D. Brumley, P. Poosankam, D. Song, and J. Zheng. Automatic patch-based exploit generation is possible: Techniques and implications. In Proceedings of the 29th IEEE Symposium on Security and Privacy (Oakland), Oakland, CA, May 2008.
[9] Y. Cai, J. Zhang, L. Cao, and J. Liu. A deployable sampling strategy for data race detection. In Proceedings of the 24th ACM SIGSOFT Symposium on the Foundations of Software Engineering (FSE), Seattle, WA, Nov. 2016.
[10] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley. Unleashing mayhem on binary code. In Proceedings of the 33rd IEEE Symposium on Security and Privacy (Oakland), San Francisco, CA, May 2012.
[11] W. Chen, X. Zou, G. Li, and Z. Qian. Koobe: Towards facilitating exploit generation of kernel out-of-bounds write vulnerabilities. In Proceedings of the 28th USENIX Security Symposium (Security), BOSTON, MA, Aug. 2020.
[12] H. Cui, J. Wu, J. Gallagher, H. Guo, and J. Yang. Efficient deterministic multithreading through schedule relaxation. In Proceedings of the 23rd ACM Symposium on Operating Systems Principles (SOSP), Cascais, Portugal, Oct. 2011.
[13] H. Cui, J. Simsa, Y.-H. Lin, H. Li, B. Blum, X. Xu, J. Yang, G. A. Gibson, and R. E. Bryant. Parrot: a practical runtime for deterministic, stable, and reliable threads. In Proceedings of the 24th ACM Symposium on Operating Systems Principles (SOSP), Farmington, PA, Nov. 2013.
[14] M. Daniel, J. Honoroff, and C. Miller. Engineering heap overflow exploits with JavaScript. In Proceedings of the 2nd USENIX Workshop on Offensive Technologies (WOOT), SAN JOSE, CA, July 2008.
[15] P. Deligiannis, A. F. Donaldson, and Z. Rakamaric. Fast and precise symbolic analysis of concurrency bugs in device drivers (t). In Proceedings of the 30rd IEEE/ACM International Conference on Automated Software Engineering (ASE), Lincoln, Nebraska, Sept. 2015.
[16] F. Electrons. Realtime in embedded Linux systems. 2004.
[17] D. Engler and K. Ashcraft. RacerX: effective, static detection of race conditions and deadlocks. In Proceedings of the 19th ACM Symposium on Operating Systems Principles (SOSP), Kiawah Island, SC, Dec. 2003.