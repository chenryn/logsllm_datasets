### Optimized Text

#### Measuring Input-Output Pairs
Evaluating all possible input-output pairs would require enumerating 21,320 potential inputs, which is impractical. In this context, our technique, which performs interference analysis on real codebases within a timeframe of minutes to hours (and even faster with parallelization), represents a significant improvement. Additionally, these results are likely to improve further with advancements in symbolic execution and model counting. Despite our extensive experimentation with various optimizations for postcondition generation and model counting, the computational costs remain high for real-world codebases, making interactive analysis by human programmers unfeasible. Instead, we envision our analysis being used as an overnight diagnostic tool.

#### Discussion and Limitations
Our methodology builds upon two recognized, challenging tasks in computer science: constructing a logical postcondition \(\Pi_{\text{proc}}\) for a procedure \(\text{proc}\) using symbolic execution, and performing model counting, which is #P-complete. Our approach inherits the limitations of existing symbolic execution tools, such as difficulties in scaling to certain procedures and challenges involving symbolic pointers and unbounded loops. For instance, in our TCP case study (Section VI-C), we encountered these issues and had to implement workarounds. We are optimistic that future improvements in these areas will enhance our methodology.

One of the strengths of our approach is its applicability to scenarios where the distributions of inputs—whether controlled by attackers or otherwise—are unknown, which is often the case in practice. In some cases, these input distributions may be unknowable, especially for \(VarsC\). In others, they may be knowable but require substantial empirical data to estimate (e.g., the distribution of user-input search terms, as in Section VI-A). Although our method is insensitive to these distributions, it does not immediately accommodate them if they are known. However, our methodology allows for these inputs to be accounted for in a principled manner, unlike other methods that either disallow them or assign them heuristically.

#### Conclusion
In this paper, we have introduced a new method for assessing interference and mitigating it. Noninterference is achieved when the output produced by a procedure in response to an adversary's input is unaffected by secret values that the adversary is not authorized to observe. We developed a method to estimate the number of pairs of attacker-controlled inputs and attacker-observable outputs, conditioned on the secret being limited to a particular sample. The discovery of such pairs that are possible for one sample but not another reveals interference.

We demonstrated the effectiveness of our strategy through both artificial examples (Section V) and real-world codebases (Section VI). Specifically, we evaluated leakage in the Sphinx auto-complete feature of its search interface due to response sizes and the effectiveness of various mitigations (Section VI-A); the CRIME vulnerabilities of adaptive compression in Gzip and fixed-dictionary compression in Smaz (Section VI-B); and leakage of TCP sequence numbers in Linux and the effectiveness of two mitigations of our own design (Section VI-C). Within these contexts, we also explored leakage over a single procedure execution and over multiple executions, showing that our framework allows for a useful comparison of how procedures leak data as the number of executions increases.

A key aspect of our methodology's scalability to real codebases is our use of approximate model counting, particularly hash-based model counting. While the resulting tool is not yet fast enough for interactive use, it is well-positioned to benefit from ongoing research in symbolic execution and approximate model counting.

#### Acknowledgements
This work was supported in part by NSF grants 1330599, 1619450, 1652954, and 1718084.

#### References
[1] B. W. Lampson, “A note on the confinement problem,” Communications of the ACM, vol. 16, no. 10, pp. 613–615, 1973.
[2] D. King, B. Hicks, M. Hicks, and T. Jaeger, “Implicit flows: Can’t live with 'em, can’t live without 'em,” in 4th International Conference on Information Systems Security, 2008, pp. 56–70.
[3] J. A. Goguen and J. Meseguer, “Security policies and security models,” in 3rd IEEE Symposium on Security and Privacy, 1982, pp. 11–20.
[4] S. Chakraborty, K. S. Meel, and M. Y. Vardi, “A scalable approximate model counter,” in Principles and Practice of Constraint Programming, ser. LNCS, vol. 8124, 2013.
[5] S. Chen, R. Wang, X. Wang, and K. Zhang, “Side-channel leaks in web applications: A reality today, a challenge tomorrow,” in 31st IEEE Symposium on Security and Privacy, 2010, pp. 191–206.
[6] J. Kelsey, “Compression and information leakage of plaintext,” in 9th International Workshop on Fast Software Encryption, 2002, pp. 263–276.
[7] R. T. Morris, “A weakness in the 4.2BSD Unix TCP/IP software,” 1985.
[8] Z. Qian, Z. M. Mao, and T. Xie, “Collaborative TCP sequence number inference attack – how to crack sequence number under a second,” in 19th ACM Conference on Computer and Communications Security, 2012, pp. 593–604.
[9] A. C. Myers, “JFlow: Practical mostly-static information flow control,” in 26th ACM Symposium on Principles of Programming Languages, 1999, pp. 228–241.
[10] A. Sabelfeld and A. C. Myers, “Language-based information-flow security,” IEEE Journal on Selected Areas in Communications, vol. 21, no. 1, Jan. 2003.
[11] N. Javanovic, C. Kruegel, and E. Kirda, “Pixy: A static analysis tool for detecting web application vulnerabilities,” in 27th IEEE Symposium on Security and Privacy, 2006.
[12] Q. A. Chen, Z. Qian, Y. J. Jia, Y. Shao, and Z. M. Mao, “Static detection of packet injection vulnerabilities: A case for identifying attacker-controlled implicit information leaks,” in 22nd ACM Conference on Computer and Communications Security, 2015.
[13] F. Nentwich, N. Jovanovic, E. Kirda, C. Kruegel, and G. Vigna, “Cross-site scripting prevention with dynamic data tainting and static analysis,” in 14th Network and Distributed System Security Symposium, 2007.
[14] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein, Y. L. Traon, D. Octeau, and P. McDaniel, “FlowDroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint analysis for Android apps,” in 35th ACM Conference on Programming Language Design and Implementation, 2014, pp. 259–269.
[15] D. E. R. Denning, Cryptography and Data Security. Addison-Wesley, 1982.
[16] J. W. Gray, “Toward a mathematical foundation for information flow security,” in 12th IEEE Symposium on Research in Security and Privacy, 1991, pp. 21–34.
[17] D. Clark, S. Hunt, and P. Malacaria, “Quantitative analysis of the leakage of confidential data,” Electronic Notes in Theoretical Computer Science, vol. 59, no. 3, 2002.
[18] G. Lowe, “Quantifying information flow,” in 15th IEEE Workshop on Computer Security Foundations, 2002.
[19] D. Clark, S. Hunt, and P. Malacaria, “Quantitative information flow, relations and polymorphic types,” Journal of Logic and Computation, vol. 15, no. 2, 2005.
[20] M. R. Clarkson, A. C. Myers, and F. B. Schneider, “Belief in information flow,” in 18th IEEE Workshop on Computer Security Foundations, 2005, pp. 31–45.
[21] D. Clark, S. Hunt, and P. Malacaria, “A static analysis for quantifying information flow in a simple imperative language,” Journal of Computer Security, vol. 15, no. 3, pp. 321–371, 2007.
[22] P. Malacaria, “Assessing security threats of looping constructs,” in 34th ACM Symposium on Principles of Programming Languages, 2007, pp. 225–235.
[23] B. K¨opf, L. Mauborgne, and M. Ochoa, “Automatic quantification of cache side-channels,” in 24th International Conference on Computer Aided Verification, 2012, pp. 564–580.
[24] G. Doychev, B. K ¨opf, L. Mauborgne, and J. Reineke, “CacheAudit: A tool for the static analysis of cache side channels,” in 22nd USENIX Security Symposium, 2013, pp. 431–446.
[25] K. Zhang, Z. Li, R. Wang, X. Wang, and S. Chen, “Sidebuster: Automated detection and quantification of side-channel leaks in web application development,” in 17th ACM Conference on Computer and Communications Security, 2010, pp. 595–606.
[26] P. Chapman and D. Evans, “Automated black-box detection of side-channel vulnerabilities in web applications,” in 18th ACM Conference on Computer and Communications Security, 2011, pp. 263–274.
[27] Q.-S. Phan and P. Malacaria, “Abstract model counting: A novel approach for quantification of information leaks,” in 9th ACM Symposium on Information, Computer and Communications Security, 2014, pp. 283–292.
[28] P. Mardziel, M. S. Alvim, M. Hicks, and M. R. Clarkson, “Quantifying information flow for dynamic secrets,” in 35th IEEE Symposium on Security and Privacy, 2014, pp. 540–555.
[29] B. K¨opf and D. Basin, “An information-theoretic model for adaptive side-channel attacks,” in 14th ACM Conference on Computer and Communications Security, 2007, pp. 286–296.
[30] C. S. P˘as˘areanu, Q.-S. Phan, and P. Malacaria, “Multi-run side-channel analysis using symbolic execution and max-SMT,” in 29th IEEE Computer Security Foundations Symposium, 2016, pp. 387–400.
[31] Q.-S. Phan, L. Bang, C. S. P˘as˘areanu, P. Malacaria, and T. Bultan, “Synthesis of adaptive side-channel attacks,” in 30th IEEE Computer Security Foundations Symposium, 2017.
[32] B. K¨opf and A. Rybalchenko, “Approximation and randomization for quantitative information-flow analysis,” in 23rd IEEE Computer Security Foundations Symposium, Jul. 2010, pp. 3–14.
[33] A. Biere, M. Heule, and H. van Maaren, Handbook of Satisfiability. IOS press, 2009, vol. 185.
[34] M. Backes, B. K ¨opf, and A. Rybalchenko, “Automatic discovery and quantification of information leaks,” in 30th IEEE Symposium on Security and Privacy, 2009, pp. 141–153.
[35] A. D. Pierro, C. Hankin, and H. Wiklicky, “Approximate non-interference,” Journal of Computer Security, vol. 12, no. 1, pp. 37–81, Jan. 2004.
[36] R. Ensaﬁ, J. C. Park, D. Kapur, and J. R. Crandall, “Idle port scanning and non-interference analysis of network protocol stacks using model checking,” in 19th USENIX Security Symposium, 2010.
[37] T. Murray, D. Matichuk, M. Brassil, P. Gammie, T. Bourke, S. Seefried, C. Lewis, X. Gao, and G. Klein, “seL4: From general purpose to a proof of information flow enforcement,” in 34th IEEE Symposium on Security and Privacy, 2013, pp. 415–429.
[38] C. Hritcu, J. Hughes, B. C. Pierce, A. Spector-Zabusky, D. Vytiniotis, A. A. de Amorim, and L. Lampropoulos, “Testing noninterference, quickly,” in 18th ACM International Conference on Functional Programming, 2013, pp. 455–468.
[39] F. D ¨orre and V. Klebanov, “Practical detection of entropy loss in pseudo-random number generators,” in 23rd ACM Conference on Computer and Communications Security, 2016, pp. 678–689.
[40] T. Antonopoulos, P. Gazzillo, M. Hicks, E. Koskinen, T. Terauchi, and S. Wei, “Decomposition instead of self-composition for proving the absence of timing channels,” in 38th ACM Conference on Programming Language Design and Implementation, 2017, pp. 362–375.
[41] J. Chen, Y. Feng, and I. Dillig, “Precise detection of side-channel vulnerabilities using quantitative cartesian Hoare logic,” in 24th ACM Conference on Computer and Communications Security, 2017, pp. 875–890.
[42] G. Smith, “Quantifying information flow using min-entropy,” in 8th International Conference on Quantitative Evaluation of Systems, Sep. 2011, pp. 159–167.
[43] Y. Dodis, R. Ostrovsky, L. Reyzin, and A. Smith, “Fuzzy extractors: How to generate strong keys from biometrics and other noisy data,” SIAM Journal on Computing, vol. 38, no. 1, pp. 97–139, 2008.
[44] C. Cadar, D. Dunbar, and D. Engler, “KLEE: Unassisted and automatic generation of high-coverage tests for complex systems programs,” in 8th USENIX Symposium on Operating Systems Design and Implementation, Dec. 2008.
[45] V. Chipounov, V. Kuznetsov, and G. Candea, “S2E: a platform for in-vivo multi-path analysis of software systems,” in 16th International Conference on Architectural Support for Programming Languages and Operating Systems, 2011, pp. 265–278.
[46] M. Soos, “The CryptoMiniSAT 5 set of solvers at SAT Competition 2016,” SAT COMPETITION 2016, p. 28, 2016.
[47] A. Ivrii, S. Malik, K. S. Meel, and M. Y. Vardi, “On computing minimal independent support and its applications to sampling and counting,” Constraints, vol. 21, no. 1, pp. 41–58, Jan. 2016.
[48] G. Kellaris, G. Kollios, K. Nissim, and A. O’Neill, “Generic attacks on secure outsourced databases,” in 23rd ACM Conference on Computer and Communications Security, 2016, pp. 1329–1340.
[49] K. P. Dyer, S. E. Coull, T. Ristenpart, and T. Shrimpton, “Peek-a-boo, I still see you: Why efficient traffic analysis countermeasures fail,” in 33rd IEEE Symposium on Security and Privacy, 2012, pp. 332–346.
[50] J. Alawatugoda, D. Stebila, and C. Boyd, “Protecting encrypted cookies from compression side-channel attacks,” in Financial Cryptography and Data Security, 2015, pp. 86–106.
[51] S. Sanfilippo, “Small strings compression library,” https://github.com/antirez/smaz, 2009.
[52] Y. Cao, Z. Qian, Z. Wang, T. Dao, S. V. Krishnamurthy, and L. M. Marvel, “Off-path TCP exploits: Global rate limit considered dangerous,” in 25th USENIX Security Symposium, 2016, pp. 209–225.
[53] “Linux blind TCP spoofing vulnerability,” http://www.securityfocus.com/bid/580/info, 1999.
[54] J. Dike, “User-mode Linux,” in Annual Linux Showcase & Conference, 2001.
[55] V. Kuznetsov, J. Kinder, S. Bucur, and G. Candea, “Efficient state merging in symbolic execution,” in 33rd ACM Conference on Programming Language Design and Implementation, 2012, pp. 193–204.

#### Appendix: From Procedure to Logical Postcondition
As mentioned in Section III, the logical postcondition \(\Pi_{\text{proc}}\) represents the relationship between inputs and outputs induced by the procedure \(\text{proc}\). To extract \(\Pi_{\text{proc}}\) from \(\text{proc}\), we apply symbolic execution. Each input variable (i.e., each parameter in \(VarsC\), \(VarsI\), and \(VarsS\)) is marked as symbolic before the user-defined entry point. We then use KLEE [44] or S2E [45] to explore all feasible execution paths through \(\text{proc}\) that reach a return. On each path, the symbolic execution engine accumulates a set of constraints among symbolic variables implied by the branches taken and assignments computed along that path. These constraints, combined with the assignments for \(VarsO\) defined by our API `make_observable`, form the postcondition for the path. The overall postcondition \(\Pi_{\text{proc}}\) is the disjunction of the path conditions generated for each execution path.

Symbolic execution can suffer from state explosion, so we implemented an optimization to manage this. Specifically, we created a searcher to perform state merging [55], where the constraints accumulated along two or more execution prefixes ending at the same instruction are disjoined and simplified (using an SMT solver). Execution is then continued from their last instruction, accumulating more constraints into their now-combined constraints. This optimization dramatically reduced the number of symbolic states managed in one of our case studies (Section VI-C), improving the speed of extracting \(\Pi_{\text{proc}}\) by more than 600×. For this case study, we forced state merging to occur whenever a symbolic state was forked at a symbolic branch. To reduce the complexity of the merged path constraint, we avoided merging two path constraints when their expressions for the outputs in \(O\) differed or when two path constraints (in conjunctive normal form) had less than half of their conjuncts in common.

A well-known limitation of symbolic execution is managing unbounded loops, as they can prevent termination. In the case studies of Section VI, we bounded all inputs, ensuring that symbolic execution terminated. Provided that the input parameters are sufficiently loosely bounded to encompass all practical values, this bounding does not impact the assessment provided by our measures in practice.

Postcondition generation costs are summarized in Figure 13. These computations were performed on a DELL PowerEdge R710 server equipped with two 2.67GHz Intel Xeon 5550 processors and 128GB memory. Each processor includes 4 physical cores and had hyperthreading enabled. As indicated in Figure 13, we experimented with both KLEE and S2E to generate postconditions, depending on the procedure. The column headings indicate the number of processes across which the computation was divided. To enable multi-process support in KLEE, we made a small modification in KLEE’s execution engine, causing it to explore only execution paths starting from a predefined branching prefix. The designation ‘merging’ indicates the use of the KLEE optimization summarized above; as shown in Figure 13, this optimization was remarkably effective on the Linux TCP implementations discussed in Section VI-C. S2E was configured to utilize its concolic execution capabilities.