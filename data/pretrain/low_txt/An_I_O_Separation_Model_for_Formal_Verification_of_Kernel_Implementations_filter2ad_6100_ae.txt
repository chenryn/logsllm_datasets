### Wimpy Kernel Design Vulnerability 2

**Vulnerability Description:**

1. **Time (1):** A malicious driver, `i`, writes to an external Transfer Descriptor (TD) with a value that defines a write transfer to the TD itself.
2. **Time (2):** The same driver, `i`, writes to its device's (USB HC `i`'s) transfer descriptor (TDi), enabling it to read the external TD. The Wimpy Kernel (WK) allows driver `i` to perform both operations because all direct transfers defined in the modified TDs reference objects in the local green partition 1, and their new values enable only local-partition transfers.
3. **Time (3):** The USB HC device `i` reads the value of the external TD. Since driver `i` modified the TD and defined a write transfer to the TD itself at time (1), device `i` can then write new configuration values to this TD under the control of the malicious driver `i`. Next, device `i` overwrites the external TD, thereby enabling transfers to driver `j` and device USB HC `j`. The WK allows USB HC device `i` to write the configuration values to the external TD since this operation is direct and local to the green partition 1. Note that the WK does not ensure that the values written by the device prevent indirect transfers.
4. **Time (4):** The USB HC `i` issues an indirect transfer to device USB HC `j` and/or driver `j` of partition 2 via the external TD, violating the green-green partition separation. This transfer is similar to the Indirect Transfer 2 in Figure 2(b).

**Mitigation:**
To remove this vulnerability, the sound WK design specifications prevent all direct TD write transfers by devices in their local green partition. Computing the TD state transitive closure would have removed this vulnerability. For performance concerns, the sound WK enforces a stronger and more conservative policy: preventing all direct TD write transfers by devices in their local green partition. This type of check is not included in the original WK design [21].

### Generation of Formally Verified Wimpy Kernel Code

We use Vale/Dafny [22] to specify and verify a new, sound Wimpy kernel (WK) implementation, following the general approach used in prior work [15]. Comparing the new implementation with the original, we identify additional implementation errors in the original code.

#### A. WK API Specifications and Verification

- **API Specification:** All WK APIs are specified in Vale using the specifications of 15 CPU instructions. To generate assembly code, we implement an assembly printer to convert the abstract-syntax-tree (AST) of APIs generated by Vale into GNU assembly format. The new WK implementation is achieved by replacing the APIs with the newly generated ones in the original WK code.
- **Verification:** Vale specifications are converted into Dafny, and proof obligations are discharged in Dafny through a simulation (refinement) proof that connects the implementation to the design.

**System State:**
- **Identifiers:** The implementation uses device, driver, and object identifiers established on x86 platforms instead of abstract identifiers from the design specifications. For example, USB peripheral device identifiers use USB hierarchy addresses, and I/O objects in memory use physical memory addresses.
- **Ephemeral USB Host Controller Objects:** The implementation uses designated registers of ephemeral USB HCs to instantiate the abstract objects in the design.
- **USB Interface Data Structures (IDSes):** The implementation uses the designated fields of USB IDSes, which map to abstract objects in the design.

**Mappings:**
- We define mappings between the concrete implementation on the x8://platform and their abstract definitions in the design specifications.

**Operations:**
- The WK implementation code defines 21 APIs and 23 direct I/O accesses, each of which maps to exactly one operation of the design specifications (Table III of Appendix B). Direct I/O accesses of drivers and devices to physical memory and device registers of x86 platforms are specified in Dafny to provide a complete list of read and write accesses that hardware can perform (Section IV-A).

**Axioms:**
- The WK APIs and direct I/O accesses rely on 107 axioms, 105 of which are independent of I/O hardware authorization and are used to reduce proof effort. Only two axioms define I/O hardware authorizations:
  - **Ax1I:** If OS devices can only reference I/O objects outside the untrusted OS partition by memory addresses, then IOMMUs prevent these devices from accessing any objects outside that partition.
  - **Ax2I:** Only USB IDS queue headers may define transfers to USB peripheral devices.

**State Invariants:**
- The implementation maintains 88 state invariants, 36 of which are refinements of the state invariants of WK design. Among the rest, 52 new invariants are introduced, 34 of which refer to CPU registers, stack, and global variables used by the WK APIs. These invariants define valid values that can be set in these registers and memory. 13 invariants define valid mappings between identifiers used in code and abstract identifiers used by design specifications. Another invariant ensures that the I/O objects of OS drivers and devices have valid memory regions. Only 4 invariants are related to the I/O hardware used by WK.

**Transition Constraints:**
- In addition to the refinements of the WK-design transition constraints, the implementation enforces the following constraint:
  - **TC1I:** All mappings between identifiers used in WK code and identifiers used in design specifications are not modified by APIs or direct I/O accesses.

The Vale/Dafny specifications of the WK implementation support I/O separation since their correspondence to the sound WK design specifications is already proven.

#### B. Vulnerabilities of the Original WK Code

We re-examined the original WK code [21] and found that it fails to satisfy the Vale/Dafny specifications of the verified WK implementation in four areas. This shows that careful but informal implementation of the original kernel code can still lead to exploitable vulnerabilities without formal verification. The first three vulnerabilities arise from violations of implementation-specific state invariants and transition constraints, whereas the fourth arises from incomplete kernel mediation of IDS modifications by drivers. These are low-level implementation errors, unrelated to the design vulnerabilities of Section VI-B.

- **Vulnerability 1:** Isolated application drivers can modify their devices' USB addresses. In the original WK implementation, a rogue isolated driver could configure its device to overlap its address with another isolated driver’s USB device, allowing it to access the latter device and break I/O separation between isolated application drivers. This vulnerability violates TC1I.
- **Vulnerability 2:** Physical and ephemeral USB HCs can have PIO addresses, enabling untrusted OS applications to access both the ephemeral USB HCs owned by isolated application drivers and their mapped physical USB HCs, despite selective authorization of all memory accesses. This vulnerability violates state invariant SI2I.
- **Vulnerability 3:** The WK fails to clear a physical USB HC’s I/O objects when releasing it to untrusted OS/applications. The original kernel code fails to prevent unauthorized object reuse. Isolated drivers cannot clear these objects since they do not have direct I/O access to them, as these USB HCs are shared. Hence, I/O separation between untrusted OS/Apps and isolated drivers does not hold. This vulnerability violates the refinement of the concrete model’s TC1c in the implementation.
- **Vulnerability 4:** Isolated drivers can modify USB IDSes after verification by WK, enabling time-of-check-to-time-of-use attacks and violating I/O separation between isolated drivers and between untrusted OS/applications and isolated drivers.

#### C. Current Limitations

- The current WK implementation is unoptimized: only one USB IDS can be used in one API invocation by green applications, whereas the original implementation takes multiple USB IDSes. Additionally, this implementation does not support USB device interrupts and assumes that WK disables them.

### Discussion

#### A. Future Use for Other I/O Kernel Designs

Our I/O model can be instantiated to other I/O kernels. We informally discuss those shown by dashed lines in Figure 5.

- **GPU Separation Kernel (GSK):** GSK [38] is a special I/O kernel that separates ephemeral GPUs to create separate screen areas for trusted and untrusted applications to coexist on the same display. Informally, GSK design can be generated from the same concrete model used for the Wimpy kernel (WK). In contrast to WK, GSK’s ephemeral GPUs can be active in green and red partitions simultaneously, even though they map to the same physical GPU. GSK ensures the separation of ephemeral GPUs. More concretely, the state of GSK design needs one additional variable: the ID of the ephemeral GPU used by the untrusted OS. Ephemeral GPUs in isolated applications can be active at the same time, and thus concurrent I/O operations are allowed on the same physical GPUs. To satisfy the ephemeral device policy of the concrete model, GSK needs to maintain additional state invariants and transition constraints for ephemeral GPUs; e.g., ephemeral GPUs must be inactive when their mapped physical GPU is active. The informal analysis shows that the original GSK design fails to enforce I/O separation when the physical GPU shares the same PCI bus with a red device; i.e., it has the vulnerability 1 of the WK design. The solution is to enforce GSK use of only PCIe GPUs. GSK does not have vulnerability 2 of the WK design because isolated applications only need to provide display contents (data object values) and window geometry configurations (function descriptor values) without accessing any TDs.
- **Traditional Separation Kernels:** Traditional separation kernels [17], [16] can also be formalized in our framework. However, they would have a different I/O separation policy from the concrete model for WK and GSK, and thus require a new concrete model. First, I/O partitions are separation-kernel partitions, and there is no distinction between red and green I/O partitions. Second, the new concrete model leverages the unidirectional communication channels provided by separation kernels to authorize transfers issued by drivers. Isolated applications use these channels to communicate with I/O kernels in different partitions. Third, the allocation of devices to these I/O kernels is static and cannot be modified on demand, because devices cannot move between partitions. I/O kernels instantiating such a concrete model can enforce all policies as traditional separation kernels; in addition, they can support DMA accesses that were excluded by traditional separation kernels [44], [17].
- **Low-Assurance OS Kernels:** Low-assurance OS kernels, such as the Linux kernel, can also fit into our framework. However, another concrete model is necessary to capture the intra-OS I/O separation policies that prevent devices from accessing non-DMA memory. This new model would have two I/O partitions, one comprising all active subjects and objects, and the other the NULL I/O partition for inactive ones. The kernel would ensure that non-DMA memory areas contain only inactive I/O objects (i.e., unmapped in DMA memory), and thus active devices cannot access them. Unlike previous I/O separation designs [11], the new concrete-model instantiation in OS kernels could support device P2P communications, with early authorization.

#### B. Lessons Learned

Several practical lessons arise from the process of designing and applying the models to the verification of I/O kernels. Three of these lessons are summarized below:

1. **Inadequate I/O Hardware:** The application of our models to systems with inadequate I/O hardware clearly shows the significant extra verification cost and limited scalability of these systems. This suggests that inadequate I/O hardware should be deprecated for use in large commodity systems.
2. **Formal Design and Implementation:** Formal design and implementation force rigorous reasoning beyond careful but informal development. Without formal specifications and verification, security assurance is difficult to obtain even for small I/O kernels (e.g., fewer than 4K SLoC) that use the best I/O hardware. Subtle I/O kernel design and implementation vulnerabilities can be easily missed by informal development. Also, simply using the best I/O authorization hardware to separate address spaces is insufficient; e.g., separation of ephemeral devices, which are multiplexed on the same physical device, must be formally verified.
3. **Performance of Formally Verified I/O Separation:** The performance of formally verified I/O separation need not incur any penalty beyond that of secure IOMMU context switches in existing OS kernels [11]. In fact, the use of non-shared, de-privileged drivers and buffers in isolated applications, which don’t rely on shared buffer pools in OS kernels, and of small and simple, dedicated I/O kernels naturally offer added performance benefits [21]. In contrast, substantial performance improvements that preserve intra-OS kernel I/O separation by selective authorization can still incur up to 25% throughput overhead and 20% increased CPU utilization by using shared buffer pools [11].

### Related Work

- **Low Assurance and Limited I/O Functions:** Device virtualization [3], [45] can support separate I/O transfers to different virtual machines. However, this yields a much larger trusted code base, hence lowering assurance significantly. To minimize trusted code bases, some isolation kernels [46] and micro-hypervisors [47], [19], [48] support I/O separation for only a limited set of I/O devices and functions. Other micro-kernels (e.g., Nexus RVM [2]) are incompatible with commodity OSes. They fail to authorize P2P device transfers (vulnerability 2 in Section VI-B) and support multiple-device broadcasts on a bus controller. Finally, since no commodity I/O devices can encrypt/decrypt traffic with secret keys of crypto enclaves, they cannot transfer to/from encrypted memory; i.e., SGX [41]. Instead, they separate I/O transfers to isolated drivers, which establish crypto channels with enclaves [49].
- **Verified Kernels:** The SELinux security kernel [50] enforces MAC policies but assumes that unverified kernel mechanisms support I/O separation. The seL4 micro-kernel can ensure static I/O separation when it implements a separation kernel [51], as described in Section VIII-A. The ExpressOS [52] micro-kernel provides formally verified application security properties without trusting system services. However, it does not enforce I/O separation for isolated applications; e.g., an application can read I/O buffers of other applications, and I/O separation for general devices is not enforced.

### Acknowledgment

We thank the reviewers for their thoughtful comments and suggestions. The research reported herein was supported in part by the Department of the Navy, Office of Naval Research, under Grant No. N00014-17-1-2892.

### References

[1] D. R. Engler, M. F. Kaashoek, and J. O’Toole, Jr., “Exokernel: An operating system architecture for application-level resource management,” in ACM SOSP, 1995.
[2] D. Williams, P. Reynolds, K. Walsh, E. G. Sirer, and F. B. Schneider, “Device driver safety through a reference validation mechanism,” in USENIX OSDI, 2008.
[3] L. Xia, J. Lange, P. Dinda, and C. Bae, “Investigating virtual pass-through I/O on commodity devices,” SIGOPS Oper. Syst. Rev., vol. 43, no. 3, pp. 83–94, Jul. 2009.
[4] S. Boyd-Wickizer and N. Zeldovich, “Tolerating malicious device drivers in Linux,” in USENIX ATC, 2010.
[5] PCI-SIG, “Multicast, https://pcisig.com/specifications,” May 2008.
[6] NXP Semiconductors, “I2C-bus Specification and User Manual, https://www.nxpcom/docs/en/user-guide/UM10204.pdf,” April 2014.
[7] “The Linux Documentation Project,” http://www.tldp.org/HOWTO/Plug-and-Play-HOWTO-7.html [Accessed on Jun. 20, 2019], 2007.
[8] Intel, “Enhanced Host Controller Interface Specification for Universal Serial Bus,” 2002.
[9] Intel, “Intel Virtualization Technology for Directed I/O Architecture Specification,” Intel Pub. no. D51397-006 rev. 2.2, 2013.
[10] F. L. Sang, É. Lacombe, V. Nicomette, and Y. Deswarte, “Exploiting an