### Verified Protocol Core

In **RefTLS-CORE**, we develop, implement, and verify (for the first time) a composite state machine for TLS 1.2 and 1.3 (detailed in Appendix B). Each state transition is managed by a ProScript function that processes a flight of incoming messages, updates the session state, and generates a flight of outgoing messages. For TLS 1.3 clients, these functions include `get_client_hello`, `put_server_hello`, and `put_server_finished`. For servers, the corresponding functions are `put_client_hello`, `get_server_finished`, and `put_client_finished`.

We then use the ProScript compiler to translate this module into a ProVerif script, which closely mirrors the protocol models described in earlier sections of this paper (see [48] for translation details). Each pure function in ProScript is translated into a ProVerif function, while functions that modify mutable state are translated into ProVerif processes that read and write from tables. The module's interface is compiled into a top-level process, exposing a subset of the protocol functions to the adversary over a public channel. The adversary can call these functions in any order and any number of times, to initiate parallel connections, provide incoming flights of messages, and obtain outgoing flights of messages. The ProVerif model uses internal tables, inaccessible to the attacker, to manage state updates between flights and maintain state invariants throughout the protocol execution.

Our approach allows us to quickly generate verifiable ProVerif models from running RefTLS code. For example, we were able to rapidly prototype changes to the TLS 1.3 specification between Draft-13 and Draft-18, while simultaneously testing for interoperability and analyzing the core protocol. Specifically, we extracted a model from our Draft-18 implementation and verified our security goals from §III and §V using ProVerif.

We designed the ProScript compiler to produce readable ProVerif models that can be modified by protocol analysts to experiment with different threat models. We are also working towards applying the same automated translation approach to CryptoVerif models. Although CryptoVerif syntax slightly differs from ProVerif, there is ongoing work in the CryptoVerif team to accept the same source syntax as ProVerif. However, the types of models that are easily verifiable using CryptoVerif differ from those that ProVerif can automatically verify, and the assumptions on cryptographic primitives will always remain distinct. Therefore, even if the source syntax is the same, we may need to adapt our compiler to generate different models for ProVerif and CryptoVerif.

### Evaluation: Verification, Interoperability, Performance

The full RefTLS codebase consists of approximately 6500 lines of Flow code, including 3000 lines of trusted libraries (mostly message parsing), 2500 lines of untrusted application code, and 1000 lines of verified protocol core. From the core, we extracted an 800-line protocol model in ProVerif and composed it with our generic library from §II. Verifying this model took several hours on a powerful workstation.

RefTLS implements TLS 1.0-1.3 and interoperates with all major TLS libraries for TLS 1.0-1.2. Fewer libraries currently support TLS 1.3, but RefTLS participated in the IETF Hackathon and achieved interoperability with other implementations of Draft-14. It now interoperates with NSS (Firefox) and BoringSSL (Chrome) for Draft-18.

To demonstrate the utility of this approach, we integrated RefTLS into the Brave web browser, which is written in Electron. We are able to intercept all of Brave’s HTTPS requests and reliably fulfill them through RefTLS. We benchmarked RefTLS against Node.js’s default OpenSSL-based HTTPS stack when run against an OpenSSL peer over TLS 1.2. In terms of computational overhead, RefTLS is two times slower than Node’s native library, which is not surprising since RefTLS is written in JavaScript, whereas OpenSSL is written in C. In exchange for speed, RefTLS offers an early implementation of TLS 1.3 and a verified protocol core. Furthermore, in many application scenarios, network latency dominates over cryptographic operations, so the performance penalty of RefTLS may not be noticeable.

### Discussion and Related Work

#### Symbolic Analysis of TLS 1.3

We symbolically analyzed a composite model of TLS 1.3 Draft-18 with optional client authentication, PSK-based resumption, and PSK-based 0-RTT, alongside TLS 1.2, against a rich threat model, and established a series of security goals. In summary, 1-RTT provides forward secrecy, authentication, and unique channel identifiers, 0.5-RTT offers weaker authentication, and 0-RTT lacks forward secrecy and replay protection. We discovered potential vulnerabilities in 0-RTT client authentication in earlier draft versions. These attacks were presented at the TLS Ready-Or-Not (TRON) workshop and contributed to the removal of certificate-based 0-RTT client authentication from TLS 1.3. The current design of PSK binders in Draft-18 is partly inspired by these authentication attacks.

TLS 1.3 has been symbolically analyzed before using the Tamarin prover [35]. ProVerif and Tamarin are both state-of-the-art protocol analyzers with different strengths. Tamarin can verify arbitrary compositions of protocols by relying on user-provided lemmas, whereas ProVerif is less expressive but offers more automation. In terms of protocol features, the Tamarin analysis covered PSK and ECDHE handshakes for 0-RTT and 1-RTT in Draft-10, but did not consider 0-RTT client certificate authentication or 0.5-RTT data. On the other hand, they do consider delayed (post-handshake) authentication, which we did not cover here.

The main qualitative improvement in our verification results over theirs is that we consider a richer threat model that allows for downgrade attacks, and we analyze TLS 1.3 in composition with previous versions of the protocol, whereas they verify TLS 1.3 in isolation. Our full ProVerif development consists of 1030 lines of ProVerif; including a generic library incorporating our threat model (400 lines), processes for TLS 1.2 (200 lines) and TLS 1.3 (250 lines), and security queries for TLS 1.2 (50 lines) and TLS 1.3 (180 lines). All proofs complete in about 70 minutes on a powerful workstation. In terms of manual effort, these models took about 3 person-weeks for a ProVerif expert.

#### Computational Proofs for TLS 1.3

We presented the first mechanically-checked cryptographic proof for TLS 1.3, developed using the CryptoVerif prover. We prove secrecy, forward secrecy with respect to the compromise of long-term keys, authentication, replay prevention (except for 0-RTT data), and the existence of a unique channel identifier for TLS 1.3 Draft-18. Our analysis considers PSK modes with and without DHE key exchange, with and without client authentication. It includes 0-RTT and 0.5-RTT data, as well as key updates, but not post-handshake authentication.

Unlike the ProVerif analysis, our CryptoVerif model does not consider compositions of client certificates and pre-shared keys in the same handshake. It also does not account for version or ciphersuite negotiation; instead, we assume that the client and server only support TLS 1.3 with strong cryptographic algorithms. The reason we limit the model in this way is to make the proofs more tractable, as CryptoVerif is not fully automated and requires significant input from the user. With future improvements in the tool, we may be able to remove some of these restrictions.

CryptoVerif is better suited to proofs than finding attacks. Sometimes, proof failures in CryptoVerif might lead us towards computational attacks that do not appear at the symbolic level, but we did not find such attacks in our model of TLS 1.3. We failed to prove forward secrecy for handshakes that use both pre-shared keys and Diffie-Hellman, but this failure is due to limitations in our tool, not due to an attack. Our proofs required some unusual assumptions on public values in Diffie-Hellman groups to avoid confusions between different key exchange modes; these ambiguities are inherent in Draft-18 but have been fixed in Draft-19, making some of our assumptions unnecessary.

In comparison with previous cryptographic proofs of draft versions of TLS 1.3 [40], [52], [55], our cryptographic assumptions and proof structure are similar. The main difference in this work is that our proof is mechanized, so we can easily adapt and recheck our proofs as the protocol evolves.

Our full CryptoVerif development consists of 1895 lines, including new definitions and lemmas for the key schedule (570 lines), a model of the initial handshake (550 lines), a model of PSK-based handshakes (625 lines), and a model of the record protocol (150 lines). For different proofs, we sometimes wrote small variations of these files, and we do not count all those variations here. All proofs completed in about 6 minutes. The total verification effort took about 5 person-weeks for a CryptoVerif expert.

#### Verifying TLS Implementations

Specifications for protocols like TLS are primarily focused on interoperability; the RFC standard precisely defines message formats, cryptographic computations, and expected message sequences. However, it says little about the state machines these protocol implementations should use or the APIs they should offer to their applications. This specification ambiguity is arguably the culprit for many implementation bugs [12] and protocol flaws [15] in TLS.

In the absence of a more explicit specification, we advocate the need for verified reference implementations of TLS that can provide exemplary code and design patterns for secure deployment. We proposed one such implementation, RefTLS, for use in JavaScript applications. The core protocol code in RefTLS implements both TLS 1.2 and 1.3 and has been verified using ProVerif. However, RefTLS is a work-in-progress, and many of its trusted components remain to be verified. For example, we did not verify our message parsing code or cryptographic libraries, and our verification results rely on the correctness of the unverified ProScript-to-ProVerif compiler [48].

The symbolic security guarantees of RefTLS are weaker than those of computationally-verified implementations like miTLS [21]. However, unlike miTLS, our analysis is fully automated and can quickly find attacks. The type-based technique of miTLS requires significant user intervention and is better suited to building proofs than finding attacks.

#### Other Verification Approaches

In addition to ProVerif and CryptoVerif, there are many symbolic and computational analysis tools that have been used to verify cryptographic protocols like TLS. As discussed above, Tamarin [68] was used to symbolically analyze TLS 1.3 Draft-10 [35]. EasyCrypt [8] has been used to develop cryptographic proofs for various components used in TLS, including the MAC-Encode-Encrypt construction used in the record layer [5]. Our ProScript-to-ProVerif compiler is inspired by previous works on deriving ProVerif models from F# [20], Java [6], and JavaScript [16]. Such translations have been used to symbolically and computationally analyze TLS implementations [18]. An alternative to model extraction is to synthesize a verified implementation from a verified model; [30] shows how to compile CryptoVerif models to OCaml and uses it to derive a verified SSH implementation.

The most advanced case studies for verified protocol implementations use dependent type systems because they scale well to large codebases. Refinement types for F# have been used to prove both symbolic [19] and cryptographic security properties, with applications to TLS [21]. The F* programming language [70] has been used to verify small protocols and cryptographic libraries [73]. Similar techniques have been applied to the cryptographic verification of Java programs [53].

### Conclusion and Future Work

TLS 1.3 is a social and technical experiment in the collaborative design of a practical protocol with regular input and review from the academic research community. It seeks to reverse the traditional pattern where security analyses are performed several years after standardization, when it may be too late to change how implementations work. This paper describes our contribution to this standardization effort.

We present verification results for symbolic models in ProVerif, computational models in CryptoVerif, and a reference implementation in JavaScript of TLS 1.3 Draft-18. There are still many features and aspects of the emerging protocol standard that remain to be analyzed. Furthermore, the formal connections between our ProVerif models, CryptoVerif proofs, and JavaScript code are not as strong as could be desired. We have focused on proof automation and readable models as a pragmatic first step, but we are working on formal proofs of correctness for our translations from Flow to ProVerif and CryptoVerif, so that we can obtain strong guarantees for our protocol source code.