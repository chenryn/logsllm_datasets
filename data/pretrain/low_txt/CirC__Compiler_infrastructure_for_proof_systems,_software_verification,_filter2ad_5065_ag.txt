以下是经过优化的参考文献列表，以提高其清晰度、连贯性和专业性：

1. M. Walfish, “Verifying computations with state,” in SOSP, Nov. 2013. Extended version: http://eprint.iacr.org/2013/356.
2. B. Parno, J. Howell, C. Gentry, and M. Raykova, “Pinocchio: Nearly practical verifiable computation,” in IEEE S&P, May 2013.
3. C. Costello, C. Fournet, J. Howell, M. Kohlweiss, B. Kreuter, M. Naehrig, B. Parno, and S. Zahur, “Geppetto: Versatile verifiable computation,” in IEEE S&P, May 2015.
4. A. E. Kosba, C. Papamanthou, and E. Shi, “xJsnark: A framework for efficient verifiable computation,” in IEEE S&P, May 2018.
5. R. S. Wahby, S. Setty, Z. Ren, A. J. Blumberg, and M. Walfish, “Efficient RAM and control flow in verifiable outsourced computation,” in NDSS, Feb. 2015.
6. J. Eberhardt and S. Tai, “ZoKrates—scalable privacy-preserving off-chain computations,” in IEEE Blockchain, July 2018.
7. “ZoKrates.” https://zokrates.github.io/.
8. “Zinc.” https://zinc.matterlabs.dev/.
9. J. Baylina, “Circom.” https://github.com/iden3/circom.
10. “Noir.” https://noir-lang.github.io/book/index.html.
11. “Leo.” https://developer.aleo.org/aleo/getting-started/overview/.
12. C. Chin, H. Wu, R. Chu, A. Coglio, E. McCarthy, and E. Smith, “Leo: A programming language for formally verified, zero-knowledge applications,” 2021. https://ia.cr/2021/651.
13. Y. Lindell, “Secure multiparty computation (MPC).” https://eprint.iacr.org/2020/300. To appear in CACM.
14. V. Vaikuntanathan, “Computing blindfolded: New developments in fully homomorphic encryption,” in FOCS, Oct. 2011.
15. C. Barrett, A. Stump, and C. Tinelli, “The SMT-LIB standard: Version 2.0,” in SMT, 2010.
16. M. Barnett, B.-Y. E. Chang, R. DeLine, B. Jacobs, and K. R. M. Leino, “Boogie: A modular reusable verifier for object-oriented programs,” in FMCO, 2005.
17. K. R. M. Leino, “Dafny: An automatic program verifier for functional correctness,” in LPAR, 2010.
18. N. Bjørner and L. de Moura, “Applications of SMT solvers to program verification,” in Notes for the Summer School on Formal Techniques, 2014.
19. Z. Rakamarić and M. Emmi, “Smack: Decoupling source language details from verifier implementations,” in CAV, 2014.
20. E. Torlak and R. Bodik, “A lightweight symbolic virtual machine for solver-aided host languages,” in PLDI, 2014.
21. E. Clarke, D. Kroening, and F. Lerda, “A tool for checking ANSI-C programs,” in TACAS, 2004.
22. A. Solar-Lezama, L. Tancau, R. Bodik, S. Seshia, and V. Saraswat, “Combinatorial sketching for finite programs,” in ASPLOS, 2006.
23. E. Kneuss, I. Kuraj, V. Kuncak, and P. Suter, “Synthesis modulo recursive functions,” in OOPSLA, 2013.
24. S. Srivastava, S. Gulwani, and J. S. Foster, “From program verification to program synthesis,” in POPL, 2010.
25. R. Fourer, D. M. Gay, and B. W. Kernighan, *AMPL: A Modeling Language for Mathematical Programming*. Boston, MA, USA: Cengage Learning, 2nd ed., 2002.
26. W. E. Hart, C. D. Laird, J.-P. Watson, D. L. Woodruff, G. A. Hackebeil, B. L. Nicholson, and J. D. Siirola, *Pyomo-optimization modeling in Python*, vol. 67. Springer, 2017.
27. D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella, “Fairplay–A secure two-party computation system,” in USENIX Security, Aug. 2004.
28. S. T. V. Setty, V. Vu, N. Panpalia, B. Braun, A. J. Blumberg, and M. Walfish, “Taking proof-based verified computation a few steps closer to practicality,” in USENIX Security, Aug. 2012. Extended version: https://ia.cr/2012/598.
29. A. Gurfinkel and J. A. Navas, “A context-sensitive memory model for verification of C/C++ programs,” in SAS, 2017.
30. C. Sinz, S. Falke, and F. Merz, “A precise memory model for low-level bounded model checking,” in SSV, 2010.
31. C. Cadar, D. Dunbar, and D. R. Engler, “KLEE: Unassisted and automatic generation of high-coverage tests for complex systems programs,” in OSDI, 2008.
32. K. R. M. Leino, “This is Boogie 2.” https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/krml178.pdf, 2008.
33. E. Cohen, M. Moskal, S. Tobies, and W. Schulte, “A precise yet efficient memory model for C,” in SSV, Oct. 2009.
34. I. Yun, S. Lee, M. Xu, Y. Jang, and T. Kim, “QSYM: A practical concolic execution engine tailored for hybrid fuzzing,” in USENIX Security, 2018.
35. E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza, “SNARKs for C: Verifying program executions succinctly and in zero knowledge,” in CRYPTO, Aug. 2013.
36. E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza, “Succinct non-interactive zero knowledge for a von Neumann architecture,” in USENIX Security, Aug. 2014.
37. C. Lattner and V. Adve, “LLVM: A compilation framework for lifelong program analysis and transformation,” in CGO, 2004.
38. S. Arora and B. Barak, *Computational Complexity: A Modern Approach*. Cambridge, UK: Cambridge University Press, 2009.
39. Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou, “vSQL: Verifying arbitrary SQL queries over dynamic outsourced databases,” in IEEE S&P, 2017.
40. G. Danezis, C. Fournet, M. Kohlweiss, and B. Parno, “Pinocchio coin: Building Zerocoin from a succinct pairing-based proof system,” in PETShop, 2013.
41. R. S. Wahby, M. Howald, S. Garg, A. Shelat, and M. Walfish, “Verifiable ASICs,” in IEEE S&P, 2016.
42. R. S. Wahby, Y. Ji, A. J. Blumberg, A. Shelat, J. Thaler, M. Walfish, and T. Wies, “Full accounting for verifiable outsourcing,” in CCS, 2017.
43. M. Walfish and A. J. Blumberg, “Verifying computations without reexecuting them: From theoretical possibility to near practicality,” *CACM*, vol. 58, pp. 74–84, Feb. 2015.
44. J. Thaler, “Proofs, arguments, and zero-knowledge.” http://people.cs.georgetown.edu/jthaler/ProofsArgsAndZK.pdf.
45. E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza, “Scalable zero knowledge via cycles of elliptic curves,” in CRYPTO, Aug. 2014.
46. M. Fredrikson and B. Livshits, “Zø: An optimizing distributing zero-knowledge compiler,” in USENIX Security, Aug. 2014.
47. Y. Xie and A. Aiken, “Saturn: A scalable framework for error detection using boolean satisfiability,” in *TOPLAS*, 2007.
48. M. W. Hall, J. M. Anderson, S. P. Amarasinghe, B. R. Murphy, S.-W. Liao, E. Bugnion, and M. S. Lam, “Maximizing multiprocessor performance with the SUIF compiler,” *IEEE Computer*, 1996.
49. C. Lattner, J. A. Pienaar, M. Amini, U. Bondhugula, R. Riddle, A. Cohen, T. Shpeisman, A. Davis, N. Vasilache, and O. Zinenko, “MLIR: A compiler infrastructure for the end of Moore’s law.” https://arxiv.org/abs/2002.11054.
50. L. Daoud, D. Zydek, and H. Selvaraj, “A survey of high level synthesis languages, tools, and compilers for reconfigurable high performance computing,” in ICSS, Apr. 2013.
51. S. Setty, B. Braun, V. Vu, A. J. Blumberg, B. Parno, and M. Walfish, “Resolving the conflict between generality and plausibility in verified computation,” in EuroSys, Apr. 2013.
52. “libsnark.” https://github.com/scipr-lab/libsnark.
53. “bellman.” https://github.com/zkcrypto/bellman.
54. A. Ben-David, N. Nisan, and B. Pinkas, “FairplayMP: A system for secure multi-party computation,” in CCS, Oct. 2008.
55. W. Henecka, S. Kögl, A.-R. Sadeghi, T. Schneider, and I. Wehrenberg, “TASTY: Tool for automating secure two-party computations,” in CCS, Oct. 2010.
56. N. Büscher, D. Demmler, S. Katzenbeisser, D. Kretzmer, and T. Schneider, “HyCC: Compilation of hybrid protocols for practical secure computation,” in CCS, Oct. 2018.
57. C. Acay, R. Recto, J. Gancher, A. C. Myers, and E. Shi, “Viaduct: An extensible, optimizing compiler for secure distributed programs,” in PLDI, 2021.
58. A. Holzer, M. Franz, S. Katzenbeisser, and H. Veith, “Secure two-party computations in ANSI C,” in CCS, Oct. 2012.
59. L. Cordeiro, B. Fischer, and J. Marques-Silva, “SMT-based bounded model checking for embedded ANSI-C software,” in ASE, 2009.
60. D. Kroening and M. Tautschnig, “CBMC–C bounded model checker,” in TACAS, 2014.
61. P. Cuoq, F. Kirchner, N. Kosmatov, V. Prevosto, J. Signoles, and B. Yakobowski, “Frama-C,” in SEFM, 2012.
62. F. Kirchner, N. Kosmatov, V. Prevosto, J. Signoles, and B. Yakobowski, “Frama-C: A software analysis perspective,” in *FAC*, 2015.
63. T. Ball, V. Levin, and S. K. Rajamani, “A decade of software model checking with SLAM,” *CACM*, vol. 54, pp. 68–76, July 2011.
64. T. Ball, E. Bounimova, V. Levin, R. Kumar, and J. Lichtenberg, “The Static Driver Verifier research platform,” in CAV, 2010.
65. K. R. M. Leino, P. Müller, and J. Smans, “Verification of concurrent programs with Chalice,” in FOSAD, 2009.
66. B. Jacobs, J. Smans, P. Philippaerts, F. Vogels, W. Penninckx, and F. Piessens, “VeriFast: A powerful, sound, predictable, fast verifier for C and Java,” in NASA Formal Methods Symposium, 2011.
67. N. Vazou, *Liquid Haskell: Haskell as a theorem prover*. PhD thesis, UC San Diego, 2016.
68. N. Vazou, E. L. Seidel, R. Jhala, D. Vytiniotis, and S. Peyton-Jones, “Refinement types for Haskell,” in ICFP, 2014.
69. N. Swamy, C. Hritcu, C. Keller, A. Rastogi, A. Delignat-Lavaud, S. Forest, K. Bhargavan, C. Fournet, P.-Y. Strub, M. Kohlweiss, J.-K. Zinzindohoue, and S. Zanella-Béguelin, “Dependent types and multi-monadic effects in F*,” in POPL, 2016.
70. L. Cordeiro, P. Kesseli, D. Kroening, P. Schrammel, and M. Trtik, “JBMC: A bounded model checking tool for verifying Java bytecode,” in CAV, 2018.
71. N. P. Lopes, D. Menendez, S. Nagarakatte, and J. Regehr, “Provably correct peephole optimizations with Alive,” in PLDI, 2015.
72. D. Menendez, S. Nagarakatte, and A. Gupta, “Alive-FP: Automated verification of floating point based peephole optimizations in LLVM,” in SAS, 2016.
73. A. Nötzli and F. Brown, “Lifejacket: Verifying precise floating-point optimizations in LLVM,” in SOAP, 2016.
74. K. v. Gleissenthall, R. G. Kıcı, A. Bakst, D. Stefan, and R. Jhala, “Pretend synchrony: Synchronous verification of asynchronous distributed programs,” in POPL, 2019.
75. R. Uhler and N. Dave, “Smten with satisfiability-based search,” in OOPSLA, 2014.
76. A. Köksal, V. Kuncak, and P. Suter, “Constraints as control,” in POPL, 2012.
77. L. Moura, “Z3Py guide: Z3 API in Python.” https://ericpony.github.io/z3py-tutorial/guide-examples.htm.
78. L. Erkök, “SBV: SMT based verification in Haskell.” https://hackage.haskell.org/package/sbv.
79. E. Torlak and R. Bodik, “Growing solver-aided languages with Rosette,” in Onward!, 2013.
80. J.-C. Filliâtre and A. Paskevich, “Why3—where programs meet provers,” in ESOP, 2013.
81. P. Müller, M. Schwerhoff, and A. J. Summers, “Viper: A verification infrastructure for permission-based reasoning,” in VMCAI, 2016.
82. J. Bootle, A. Cerulli, J. Groth, S. Jakobsen, and M. Maller, “Arya: Nearly linear-time zero-knowledge proofs for correct program execution,” in ASIACRYPT, 2018.
83. B. Braun, “Compiling computations to constraints for verified computation.” UT Austin Honors Thesis HR-12-10, Dec. 2012.
84. R. Brinkmann and R. Drechsler, “RTL-datapath verification using integer linear programming,” in ASP-DAC/VLSI, 2002.
85. Z. Zeng, P. Kalla, and M. Ciesielski, “LPSAT: A unified approach to RTL satisfiability,” in DATE, 2001.
86. D. Beyer, “Automatic verification of C and Java programs: SV-COMP 2019,” in TACAS, 2019.
87. “Zcash Sapling circuit library.” https://github.com/zcash-hackworks/sapling-crypto, 2018.
88. “pedersen hash.rs.” https://github.com/zcash-hackworks/sapling-crypto/blob/49017b4e055ba4322dad1f03fe7d80dc0ed449cc/src/circuit/pedersen_hash.rs, 2018.
89. A. Ozdemir, F. Brown, and R. S. Wahby, “CirC: Compiler infrastructure for proof systems, software verification, and more.” https://eprint.iacr.org/2020/1586. Extended version.
90. M. Chang, “Performance issue on QF NIRA formula. CVC4 Issue 5354.” https://github.com/CVC4/CVC4/issues/5354.
91. N. Becker, P. Müller, and A. J. Summers, “The Axiom Profiler: Understanding and debugging SMT quantifier instantiations,” in TACAS, 2019.
92. F. Baader and T. Nipkow, *Term rewriting and all that*. Cambridge, UK: Cambridge University Press, 1999.
93. L. Nelson, J. Bornholt, R. Gu, A. Baumann, E. Torlak, and X. Wang, “Scaling symbolic evaluation for automated verification of systems code with Serval,” in SOSP, 2019.
94. C. Barrett, C. L. Conway, M. Deters, L. Hadarean, D. Jovanović, T. King, A. Reynolds, and C. Tinelli, “CVC4,” in CAV, 2011.
95. Z. Nehai and F. Bobot, “Deductive proof of Ethereum smart contracts using Why3.” arXiv:1904.11281, 2019.
96. M. Baranowski, S. He, and Z. Rakamarić, “Verifying Rust programs using SMACK,” in ATVA, 2018.
97. Á. Hajdu and D. Jovanović, “solc-verify: A modular verifier for Solidity smart contracts,” in VSTTE, 2019.
98. N. Swamy, J. Weinberger, C. Schlesinger, J. Chen, and B. Livshits, “Verifying higher-order programs with the Dijkstra monad,” in PLDI, 2013.
99. R. Baldoni, E. Coppa, D. C. D’elia, C. Demetrescu, and I. Finocchi, “A survey of symbolic execution techniques,” *ACM Computing Surveys*, vol. 51, no. 3, pp. 1–39, 2018.
100. C. Cadar and K. Sen, “Symbolic execution for software testing: Three decades later,” *CACM*, vol. 56, no. 2, pp. 82–90, 2013.
101. D. A. Ramos and D. Engler, “Under-constrained symbolic execution: Correctness checking for real code,” in USENIX Security, 2015.
102. P. Godefroid, M. Y. Levin, and D. Molnar, “SAGE: Whitebox fuzzing for security testing,” *CACM*, vol. 55, no. 3, pp. 40–44, 2012.
103. P. Godefroid, N. Klarlund, and K. Sen, “DART: Directed automated random testing,” in PLDI, 2005.
104. K. Sen, D. Marinov, and G. Agha, “CUTE: A concolic unit testing engine for C,” in ESEC-FSE, 2005.
105. V. Chipounov, V. Kuznetsov, and G. Candea, “S2E: A platform for in-vivo multi-path analysis of software systems,” in ASPLOS, 2011.
106. N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta, Y. Shoshitaishvili, C. Kruegel, and G. Vigna, “Driller: Augmenting fuzzing through selective symbolic execution,” in NDSS, 2016.
107. F. Brown, D. Stefan, and D. Engler, “SymCC: Symbolic execution with SymCC: Don’t interpret, compile!,” in USENIX Security, 2020.
108. “Gurobi.” https://www.gurobi.com/.
109. J. Forrest and R. Lougee-Heimer, “CBC user guide,” in Emerging theory, methods, and applications, pp. 257–277, 2005.
110. A. V. Aho, R. Sethi, and J. D. Ullman, *Compilers, principles, techniques*. Addison Wesley, 1986.
111. M. Blum, W. S. Evans, P. Gemmell, S. Kannan, and M. Naor, “Checking the correctness of memories,” in FOCS, 1991.
112. E. Mullen, D. Zuniga, Z. Tatlock, and D. Grossman, “Verified peephole optimizations for CompCert,” in PLDI, 2016.
113. “Pequin: A system for verifying outsourced computations and applying SNARKs.” https://github.com/pepper-project/pequin.
114. Y. Zhang, A. Steele, and M. Blanton, “PICCO: A general-purpose compiler for private distributed computation,” in CCS, Nov. 2013.
115. I. Abal, “Haskell Z3 bindings.” https://github.com/PLSysSec/haskell-z3.
116. J. Bootle, A. Cerulli, J. Groth, S. Jakobsen, and M. Maller, “Arya: Nearly linear-time zero-knowledge proofs for correct program execution,” in ASIACRYPT, 2018.
117. B. Braun, “Compiling computations to constraints for verified computation.” UT Austin Honors Thesis HR-12-10, Dec. 2012.
118. R. Brinkmann and R. Drechsler, “RTL-datapath verification using integer linear programming,” in ASP-DAC/VLSI, 2002.
119. Z. Zeng, P. Kalla, and M. Ciesielski, “LPSAT: A unified approach to RTL satisfiability,” in DATE, 2001.
120. D. Beyer, “Automatic verification of C and Java programs: SV-COMP 2019,” in TACAS, 2019.
121. “Zcash Sapling circuit library.” https://github.com/zcash-hackworks/sapling-crypto, 2018.
122. “pedersen hash.rs.” https://github.com/zcash-hackworks/sapling-crypto/blob/49017b4e055ba4322dad1f03fe7d80dc0ed449cc/src/circuit/pedersen_hash.rs, 2018.
123. A. Ozdemir, F. Brown, and R. S. Wahby, “CirC: Compiler infrastructure for proof systems, software verification, and more.” https://eprint.iacr.org/2020/1586. Extended version.
124. M. Chang, “Performance issue on QF NIRA formula. CVC4 Issue 5354.” https://github.com/CVC4/CVC4/issues/5354.
125. N. Becker, P. Müller, and A. J. Summers, “The Axiom Profiler: Understanding and debugging SMT quantifier instantiations,” in TACAS, 2019.
126. F. Baader and T. Nipkow, *Term rewriting and all that*. Cambridge, UK: Cambridge University Press, 1999.
127. L. Nelson, J. Bornholt, R. Gu, A. Baumann, E. Torlak, and X. Wang, “Scaling symbolic evaluation for automated verification of systems code with Serval,” in SOSP, 2019.
128. C. Barrett, C. L. Conway, M. Deters, L. Hadarean, D. Jovanović, T. King, A. Reynolds, and C. Tinelli, “CVC4,” in CAV, 2011.
129. Z. Nehai and F. Bobot, “Deductive proof of Ethereum smart contracts using Why3.” arXiv:1904.11281, 2019.
130. M. Baranowski, S. He, and Z. Rakamarić, “Verifying Rust programs using SMACK,” in ATVA, 2018.
131. Á. Hajdu and D. Jovanović, “solc-verify: A modular verifier for Solidity smart contracts,” in VSTTE, 2019.
132. N. Swamy, J. Weinberger, C. Schlesinger, J. Chen, and B. Livshits, “Verifying higher-order programs with the Dijkstra monad,” in PLDI, 2013.
133. R. Baldoni, E. Coppa, D. C. D’elia, C. Demetrescu, and I. Finocchi, “A survey of symbolic execution techniques,” *ACM Computing Surveys*, vol. 51, no. 3, pp. 1–39, 2018.
134. C. Cadar and K. Sen, “Symbolic execution for software testing: Three decades later,” *CACM*, vol. 56, no. 2, pp. 82–90, 2013.
135. D. A. Ramos and D. Engler, “Under-constrained symbolic execution: Correctness checking for real code,” in USENIX Security, 2015.
136. P. Godefroid, M. Y. Levin, and D. Molnar, “SAGE: Whitebox fuzzing for security testing,” *CACM*, vol. 55, no. 3, pp. 40–44, 2012.
137. P. Godefroid, N. Klarlund, and K. Sen, “DART: Directed automated random testing,” in PLDI, 2005.
138. K. Sen, D. Marinov, and G. Agha, “CUTE: A concolic unit testing engine for C,” in ESEC-FSE, 2005.
139. V. Chipounov, V. Kuznetsov, and G. Candea, “S2E: A platform for in-vivo multi-path analysis of software systems,” in ASPLOS, 2011.
140. N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta, Y. Shoshitaishvili, C. Kruegel, and G. Vigna, “Driller: Augmenting fuzzing through selective symbolic execution,” in NDSS, 2016.
141. F. Brown, D. Stefan, and D. Engler, “SymCC: Symbolic execution with SymCC: Don’t interpret, compile!,” in USENIX Security, 2020.
142. “Gurobi.” https://www.gurobi.com/.
143. J. Forrest and R. Lougee-Heimer, “CBC user guide,” in Emerging theory, methods, and applications, pp. 257–277, 2005.
144. A. V. Aho, R. Sethi, and J. D. Ullman, *Compilers, principles, techniques*. Addison Wesley, 1986.
145. M. Blum, W. S. Evans, P. Gemmell, S. Kannan, and M. Naor, “Checking the correctness of memories,” in FOCS, 1991.
146. E. Mullen, D. Zuniga, Z. Tatlock, and D. Grossman, “Verified peephole optimizations for CompCert,” in PLDI, 2016.
147. “Pequin: A system for verifying outsourced computations and applying SNARKs.” https://github.com/pepper-project/pequin.
148. Y. Zhang, A. Steele, and M. Blanton, “PICCO: A general-purpose compiler for private distributed computation,” in CCS, Nov. 2013.
149. I. Abal, “Haskell Z3 bindings.” https://github.com/PLSysSec/haskell-z3.
150. J. Bootle, A. Cerulli, J. Groth, S. Jakobsen, and M. Maller, “Arya: Nearly linear-time zero-knowledge proofs for correct program execution,” in ASIACRYPT, 2018.
151. B. Braun, “Compiling computations to constraints for verified computation.” UT Austin Honors Thesis HR-12-10, Dec. 2012.
152. R. Brinkmann and R. Drechsler, “RTL-datapath verification using integer linear programming,” in ASP-DAC/VLSI, 2002.
153. Z. Zeng, P. Kalla, and M. Ciesielski, “LPSAT: A unified approach to RTL satisfiability,” in DATE, 2001.
154. D. Beyer, “Automatic verification of C and Java programs: SV-COMP 2019,” in TACAS, 2019.
155. “Zcash Sapling circuit library.” https://github.com/zcash-hackworks/sapling-crypto, 2018.
156. “pedersen hash.rs.” https://github.com/zcash-hackworks/sapling-crypto/blob/49017b4e055ba4322dad1f03fe7d80dc0ed449cc/src/circuit/pedersen_hash.rs, 2018.
157. A. Ozdemir, F. Brown, and R. S. Wahby, “CirC: Compiler infrastructure for proof systems, software verification, and more.” https://eprint.iacr.org/2020/1586. Extended version.
158. M. Chang, “Performance issue on QF NIRA formula. CVC4 Issue 5354.” https://github.com/CVC4/CVC4/issues/5354.
159. N. Becker, P. Müller, and A. J. Summers, “The Axiom Profiler: Understanding and debugging SMT quantifier instantiations,” in TACAS, 2019.
160. F. Baader and T. Nipkow, *Term rewriting and all that*. Cambridge, UK: Cambridge University Press, 1999.
161. L. Nelson, J. Bornholt, R. Gu, A. Baumann, E. Torlak, and X. Wang, “Scaling symbolic evaluation for automated verification of systems code with Serval,” in SOSP, 2019.
162. C. Barrett, C. L. Conway, M. Deters, L. Hadarean, D. Jovanović, T. King, A. Reynolds, and C. Tinelli, “CVC4,” in CAV, 2011.
163. Z. Nehai and F. Bobot, “Deductive proof of Ethereum smart contracts using Why3.” arXiv:1904.11281, 2019.
164. M. Baranowski, S. He, and Z. Rakamarić, “Verifying Rust programs using SMACK,” in ATVA, 2018.
165. Á. Hajdu and D. Jovanović, “solc-verify: A modular verifier for Solidity smart contracts,” in VSTTE, 2019.
166. N. Swamy, J. Weinberger, C. Schlesinger, J. Chen, and B. Livshits, “Verifying higher-order programs with the Dijkstra monad,” in PLDI, 2013.
167. R. Baldoni, E. Coppa, D. C. D’elia, C. Demetrescu, and I. Finocchi, “A survey of symbolic execution techniques,” *ACM Computing Surveys*, vol. 51, no. 3, pp. 1–39, 2018.
168. C. Cadar and K. Sen, “Symbolic execution for software testing: Three decades later,” *CACM*, vol. 56, no. 2, pp. 82–90, 2013.
169. D. A. Ramos and D. Engler, “Under-constrained symbolic execution: Correctness checking for real code,” in USENIX Security, 2015.
170. P. Godefroid, M. Y. Levin, and D. Molnar, “SAGE: Whitebox fuzzing for security testing,” *CACM*, vol. 55, no. 3, pp. 40–44, 2012.
