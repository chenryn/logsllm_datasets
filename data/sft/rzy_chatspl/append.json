{"input": "String监控", "instruction": "Redis数据，编写查询语句实现如下分析场景", "output": "tag:rds_cmd (rds_cmd.cmd:\"mget\" OR rds_cmd.cmd:\"append\") | stats max(rds_cmd.summ.calls) as calls by rds_cmd.cmd"}
{"input": "", "instruction": "查找最近一月内出现 SQL 注入攻击或 XSS 攻击的日志，并显示攻击类型和来源 IP 地址", "output": " starttime=\"now-1M\" _index:web| parse field=uri \"(?i)\\b(union|select|drop|delete|update|insert)\\b\" | eval attack_type=\"SQL Injection\" | append [[ starttime=\"now-1M\" _index:web | parse field=uri \"(?i)<script>.*</script>\" | eval attack_type=\"XSS\"]] | table timestamp, attack_type, src_ip"}
{"input": "", "instruction": "linux_当天重启主机列表", "output": "starttime=\"now/d\" tag:linux_boot linux.boot_time:* | eval day=formatdate(now(),\"yyyy-MM-dd\") | eval day1=parsedate(day,\"yyyy-MM-dd\") | eval t_dura=now()-day1 | eval dura=now()-linux.boot_time | eval boot_time=formatdate(linux.boot_time,\"yyyy-MM-dd HH:mm\") | dedup 1 ip | append [[ tag:linux_boot NOT linux.boot_time:*  | parse \".*boot\\s+(?<boot_time>\\w{3}\\s+\\d+\\s+\\d+\\:\\d+)\"  | eval year=formatdate(now(),\"yyyy\") | eval boot_time=year+\" \"+boot_time | eval boot_time=parsedate(boot_time,\"yyyy MMM dd HH:mm\") | eval dura=now()-tolong(boot_time) | eval dura=if(dura>0,dura,dura+365*24*60*60*1000) | eval day=formatdate(now(),\"yyyy-MM-dd\") | eval day1=parsedate(day,\"yyyy-MM-dd\") | eval t_dura=now()-day1 | eval dura=now()-linux.boot_time | eval boot_time=formatdate(boot_time,\"yyyy-MM-dd HH:mm\") | dedup 1 ip ]] | where t_dura>dura | table boot_time,ip"}
{"input": "", "instruction": "linux_系统启动详情", "output": "tag:linux_boot linux.boot_time:* | eval hour=(now()-linux.boot_time)/(60*60*1000) | eval boot_time=formatdate(linux.boot_time,\"yyyy-MM-dd HH:mm\") | dedup 1 ip | append [[ tag:linux_boot NOT linux.boot_time:*  | parse field=raw_message \".*boot\\s+(?<boot_time>\\w{3}\\s+\\d+\\s+\\d+\\:\\d+)\"  | eval year=formatdate(now(),\"yyyy\") | eval boot_time=year+\" \"+boot_time | eval boot_time=parsedate(boot_time,\"yyyy MMM dd HH:mm\") | eval hour=(now()-tolong(boot_time))/(60*60*1000) | eval hour=if(hour>1,hour,hour+365*24) | eval boot_time=formatdate(boot_time,\"yyyy-MM-dd HH:mm\") | dedup 1 ip ]] | table ip,boot_time,hour | sort by +hour"}
{"input": "", "instruction": "linux_系统稳定运行TOP10", "output": "tag:linux_boot linux.boot_time:* | eval hour=(now()-linux.boot_time)/(60*60*1000) | eval boot_time=formatdate(linux.boot_time,\"yyyy-MM-dd HH:mm\") | dedup 1 ip | append [[ tag:linux_boot NOT linux.boot_time:*  | parse field=raw_message \".*boot\\s+(?<boot_time>\\w{3}\\s+\\d+\\s+\\d+\\:\\d+)\"  | eval year=formatdate(now(),\"yyyy\") | eval boot_time=year+\" \"+boot_time | eval boot_time=parsedate(boot_time,\"yyyy MMM dd HH:mm\") | eval hour=(now()-tolong(boot_time))/(60*60*1000) | eval hour=if(hour>0,hour,hour+365*24) | eval boot_time=formatdate(boot_time,\"yyyy-MM-dd HH:mm\") | dedup 1 ip ]] | table ip,hostname,boot_time,hour | sort by -hour | limit 10"}
{"input": "从定时任务索引里统计来帐最大耗时与平均耗时", "instruction": "查询农信银支付前置(mfe)系统数据，进行如下统计", "output": "_index:schedule schedule_name:农信银支付前置来账耗时 | stats max(cost) as _cost by msgcd | eval type=\"最大耗时\" | append [[ _index:schedule schedule_name:农信银支付前置来账耗时 | stats avg(cost) as _cost by msgcd | eval type=\"平均耗时\" ]] | sort by msgcd"}
{"input": "从定时任务索引里统计往账最大耗时与平均耗时", "instruction": "查询农信银支付前置(mfe)系统数据，进行如下统计", "output": "_index:schedule schedule_name:农信银支付前置往账耗时 | stats max(cost) as _cost by msgcd | eval type=\"最大耗时\" | append [[ _index:schedule schedule_name:农信银支付前置往账耗时 | stats avg(cost) as _cost by msgcd | eval type=\"平均耗时\" ]] | sort by msgcd"}
{"input": "", "instruction": "linux_当天重启主机数量", "output": "starttime=\"now/d\" tag:linux_boot linux.boot_time:* | eval day=formatdate(now(),\"yyyy-MM-dd\") | eval day1=parsedate(day,\"yyyy-MM-dd\") | eval t_dura=now()-day1 | eval dura=now()-linux.boot_time | dedup 1 ip | append [[ tag:linux_boot NOT linux.boot_time:*  | parse field=raw_message \".*boot\\s+(?<boot_time>\\w{3}\\s+\\d+\\s+\\d+\\:\\d+)\"  | eval year=formatdate(now(),\"yyyy\") | eval boot_time=year+\" \"+boot_time | eval boot_time=parsedate(boot_time,\"yyyy MMM dd HH:mm\") | eval dura=now()-tolong(boot_time) | eval dura=if(dura>0,dura,dura+365*24*60*60*1000) | eval day=formatdate(now(),\"yyyy-MM-dd\") | eval day1=parsedate(day,\"yyyy-MM-dd\") | eval t_dura=now()-day1 | dedup 1 ip ]] | where t_dura>dura | stats count() as ct"}
{"input": "搜索 state 为 ESTABLISHED 的日志，排除掉外部地址和本机地址相同的数据，将外部地址和外部端口用冒号拼接成 from 字段。本机地址重命名为 to 字段，并做日志量统计。类似的，再统计本地地址为 from、本地端口为 to的日志量，本地端口为 from、进程号和进程名拼在一起为 to 的日志量。三组数据 append 到一起", "instruction": "10.10.96.98这台 linux 服务器的进程连接关系", "output": "tag:process process.local_addr:* proto:tcp state:ESTABLISHED  ip:10.10.96.98 |where foreign_addr!=local_addr |eval from=foreign_addr+\":\"+foreign_port |stats count() as cnt by from,local_addr |rename  local_addr as to  |append [[ tag:process local_addr:* proto:tcp state:ESTABLISHED   ip:10.10.96.98 |where foreign_addr!=local_addr |stats count() as cnt by local_addr,local_port |rename local_addr as from,local_port as to]] |append [[ tag:process local_addr:* proto:tcp state:ESTABLISHED   ip:10.10.96.98 |where foreign_addr!=local_addr |eval t=pid+\":\"+program_name |stats count() as cnt by local_port,t |rename local_port as from,t as to]]"}
{"input": "交易质量分布", "instruction": "支付聚合_epay数据，编写查询语句实现如下分析场景", "output": "tag:epay epay.action:请求|eval requesttime=timestamp|eval id=epay.request.externalRefNumber|table epay.action,id,epay.request.cardHolderName,epay.trans_code,requesttime|join type=left id[[tag:epay epay.action:应答|eval id=epay.response.externalRefNumber|eval responsetime=timestamp|eval result=case( epay.response.responseTextMessage==\"交易成功\",\"成功\",default,\"异常\" ) |table id,responsetime,result]]|eval duration_ms=responsetime-requesttime|eval ydtype=case(duration_ms<2000,\"快交易\",default,\"慢交易\")|stats count() by epay.trans_code,ydtype|rename epay.trans_code as from,ydtype as to |append[[tag:epay epay.action:请求|eval requesttime=timestamp|eval id=epay.request.externalRefNumber|table epay.action,id,epay.request.cardHolderName,epay.trans_code,requesttime|join type=left id[[tag:epay epay.action:应答|eval id=epay.response.externalRefNumber|eval responsetime=timestamp|eval result=case( epay.response.responseTextMessage==\"交易成功\",\"成功\",default,\"异常\" ) |table id,responsetime,result]]|eval duration_ms=responsetime-requesttime|eval ydtype=case(duration_ms<2000,\"快交易\",default,\"慢交易\")|stats count() by ydtype,result|rename ydtype as from ,result as to]]"}
{"input": "", "instruction": "我想问的是linux系统启动的时间和时间段内的登录情况", "output": "tag:linux_boot linux.boot_time:* | eval hour=(now()-linux.boot_time)/(60*60*1000) | eval boot_time=formatdate(linux.boot_time,\"yyyy-MM-dd HH:mm\") | dedup 1 ip | append [[ tag:linux_boot NOT linux.boot_time:*  | parse field=raw_message \".*boot\\s+(?<boot_time>\\w{3}\\s+\\d+\\s+\\d+\\:\\d+)\"  | eval year=formatdate(now(),\"yyyy\") | eval boot_time=year+\" \"+boot_time | eval boot_time=parsedate(boot_time,\"yyyy MMM dd HH:mm\") | eval hour=(now()-tolong(boot_time))/(60*60*1000) | eval hour=if(hour>1,hour,hour+365*24) | eval boot_time=formatdate(boot_time,\"yyyy-MM-dd HH:mm\") | dedup 1 ip ]] | table ip,boot_time,hour | sort by +hour"}
{"input": "", "instruction": "我想寻找一些关于网站被黑客入侵的信息，所以我在询问有关某一特定时间段内发生的 SQL 注入和跨站脚本攻击事件数量。", "output": " starttime=\"now-1M\" _index:web| parse field=uri \"(?i)\\b(union|select|drop|delete|update|insert)\\b\" | eval attack_type=\"SQL Injection\" | append [[ starttime=\"now-1M\" _index:web | parse field=uri \"(?i)<script>.*</script>\" | eval attack_type=\"XSS\"]] | table timestamp, attack_type, src_ip"}
{"input": "按每5分钟分桶统计，6个维度(内存、CPU、磁盘、入口流量、出口流量、磁盘IO)的问题ip数量。具体方案如下：1. 首先查询top_info_win_system_stats的指标,计算每个ip的平均内存使用百分比,过滤大于80%的ip,统计这些ip的数量,并将group字段置为“内存”。2. 然后查询top_info_win_system_stats的指标,计算每个ip的平均CPU空闲百分比,过滤小于20%的ip,统计这些ip的数量,并将group字段置为“CPU”。3. 然后查询top_info_win_disk_stats的指标,过滤磁盘使用百分比大于80%的ip,统计这些ip的数量,并将group字段置为“磁盘”。4. 然后查询top_info_win_system_stats的指标,计算每个ip的平均入口流量,过滤大于50MB/s的ip,统计这些ip的数量,并将group字段置为“入口流量”。5. 然后对top_info_win_system_stats的指标进行5分钟的bucket,计算每个时间段每个ip的平均出口流量,过滤大于50MB/s的ip,统计这些ip的数量,并将group字段置为“出口流量”。6. 然后对top_info_win_disk_io_stats的指标进行5分钟的bucket,计算每个时间段每个ip的平均磁盘IO空闲百分比,过滤小于20%的ip,统计这些ip的数量,并将group字段置为“磁盘IO”。7. 最后将6个查询的结果进行append,合并为一份结果。", "instruction": "Windows主机运维监控指标数据，编写查询语句实现如下分析场景", "output": "appname:top_info_win_system_stats \n\t| stats avg(json.Mem.used_percent) as _avg by ip \n\t| where _avg >=80 \n\t| stats dc(ip) as _dc \n | rename _dc as \"数量\"\n\t| eval group=\"内存\"\n| append\n[[ appname:top_info_win_system_stats \n\t| stats avg(json.cpu.idle_percent) as _avg by ip\n\t| where _avg <=20\n\t| stats dc(ip) as _dc \n\t| rename _dc as \"数量\"\n        | eval group=\"CPU\"\n]]\n| append\n[[ appname:top_info_win_disk_stats \n\t| where json.disk.used_percent >=80 \n\t| stats dc(ip) as _dc \n\t| rename _dc as \"数量\"\n | eval group=\"磁盘\"\n]]\n| append\n[[ appname:top_info_win_system_stats \n\t| stats avg('json.nets.本地连接.bytes_recv') as _avg by ip\n\t| where _avg / (1024 * 1024) > 50 \n\t| sort by ts \n\t| stats dc(ip) as _dc \n| rename _dc as \"数量\"\n| eval group=\"入口流量\"\n]]\n| append\n[[ appname:top_info_win_system_stats \n\t| bucket timestamp span=5m as ts \n\t| stats avg('json.nets.本地连接.bytes_sent') as _avg by ts,ip\n\t| where _avg / (1024 * 1024) > 50 \n\t| sort by ts \n\t| stats dc(ip) as _dc\n| rename _dc as \"数量\"\n| eval group=\"出口流量\"\n]]\n| append\n[[ appname:top_info_win_disk_io_stats\n| bucket timestamp span=5m as ts\n| stats avg(json.percent_idle_time) as _avg by ts,ip\n| where _avg <= 20 \n| stats dc(ip) as _dc\n| rename _dc as \"数量\"\n| eval group=\"磁盘IO\"\n]]\n\t"}
{"input": "运维异常概览。每15分钟统计独立 CPU 指标、内存指标、出口流量、入口流量、磁盘和进程指标的独立 ip 数", "instruction": "Linux主机运维监控指标数据，编写查询语句实现如下分析场景", "output": "appname:top_info_system_stats AND json.cpu.idle_percent:<=0 \n\t| stats dc(ip) as _dc \n\t| rename _dc as \"数量\" \n\t| eval group = \"CPU\" \n\t| append \n\t[[ appname:top_info_system_stats \n\t| bucket timestamp span=15m as ts \n\t| stats avg(json.Mem.used_percent) as _avg by ip,ts \n\t| where _avg >=20 |stats dc(ip) as _dc \n\t| rename _dc as \"数量\" | eval group = \"内存\"\n\t]] \n\t| append \n\t[[ appname:top_info_system_stats \n\t| bucket timestamp span=15m as ts \n\t| stats avg(json.net.bytes_sent) as _avg by ip,ts \n\t| where _avg/(1024*1024) >= 50 | stats dc(ip) as _dc  \n\t| rename _dc as \"数量\"  | eval group = \"出口流量\" \n\t]] \n\t| append \n\t[[ appname:top_info_system_stats \n\t| bucket timestamp span=15m as ts \n\t| stats avg(json.net.bytes_recv) as _avg by ip,ts \n\t| where _avg/(1024*1024) >= 50 | stats dc(ip) as _dc  \n\t| rename _dc as \"数量\" | eval group = \"入口流量\" \n\t]] \n\t| append \n\t[[ appname:top_info_disk_stats AND NOT json.disk.path:\\/boot \n\t| where json.disk.used_percent >=80 \n\t| stats dc(ip) as _dc \n\t| rename _dc as \"数量\" \n\t| eval group = \"磁盘\" \n\t]] \n\t| append\n\t[[ appname:top_info_proc_stats AND json.cpu_percent:>80\n\t| stats dc(ip) as _dc\n\t| rename _dc as \"数量\"\n\t| eval group=\"进程\"\n\t]]"}
{"input": "按每5分钟分桶统计主机内存健康度", "instruction": "Linux主机运维监控指标数据，编写查询语句实现如下分析场景", "output": "appname:top_info_system_stats  |stats count() as ct by ip |stats count(ip) as _ct |appendcols [[appname:top_info_system_stats \n\t| bucket timestamp span=5m as ts \n\t| stats avg(json.Mem.used_percent) as _avg by ip,hostname \n\t| where _avg >= 80 \n\t| stats dc(ip) as _dc ]]| eval health=abs(_ct-_dc)/_ct"}
{"input": "按每5分钟分桶统计主机CPU健康度", "instruction": "Linux主机运维监控指标数据，编写查询语句实现如下分析场景", "output": "appname:top_info_system_stats  |stats count() as ct by ip |stats count(ip) as _ct |appendcols [[appname:top_info_system_stats  \n\t| bucket timestamp span=5m as ts \n\t| stats avg(json.cpu.idle_percent) as _avg by ts,ip,hostname \n\t| where _avg <=30 \n\t\n\t| stats dc(ip) as _dc ]]|eval health=abs(_ct-_dc)/_ct"}
{"input": "192.168.41.1主机，磁盘IO、CPU、网络接口出入丢包、内存使用率等各项指标在一天内的趋势，按每 30 分钟统计一次", "instruction": "docker性能数据，编写查询语句实现如下分析场景", "output": "starttime=\"-1d\" appname:docker_metric tag:docker_metric_diskio AND (hostname:* AND ip:\"192.168.41.1\") |bucket timestamp span=30m as ts| stats count() as cnt by json.total,ts |rename json.total as total|eval line=\"diskio\"|append[[appname:docker_metric tag:docker_metric_cpu AND (hostname:* AND ip:*) |bucket timestamp span=30m as ts| stats count() as cnt by json.total.pct,ts|rename json.total.pct as total|eval line=\"cpu\"]]|append[[appname:docker_metric tag:docker_metric_network AND (hostname:* AND ip:*) |bucket timestamp span=30m as ts| stats count() as cnt by json.outbound.dropped,json.in.dropped,json.out.dropped,json.inbound.dropped,ts |eval drop=json.outbound.dropped+json.in.dropped+json.out.dropped+json.inbound.dropped|rename drop as total | eval line=\"drop_pct\"]]|append[[appname:docker_metric tag:docker_metric_memory AND (hostname:* AND ip:*) |bucket timestamp span=30m as ts| stats count() as cnt by json.usage.pct,ts|rename json.usage.pct as total | eval line=\"memory_pct\" ]]"}
{"input": "操作系统服务运行状态", "instruction": "安全合规数据，编写查询语句实现如下分析场景", "output": "appname:linux tag:services \n| stats count() as cnt by ip,appname,linux.service_name,linux.status \n| rename linux.service_name as service_name,linux.status as status\n|append[[\n\tappname:windows tag:services \n\t| stats count() as cnt by ip,appname,json.service_name,json.status,json.description \n\t| rename  json.service_name as service_name,json.status as status,json.description as desc]]\n|eval a=if(empty(desc),\"null\",desc)"}
{"input": "数据库各用户详情", "instruction": "安全合规数据，编写查询语句实现如下分析场景", "output": "appname:oracle tag:user_detail \n|rename mysql.user as user,mysql.password_expired as password_expired,json.ACCOUNT_STATUS as status,json.EXPIRY_DATE as password_expired,json.USERNAME as user \n| stats count() as cnt by ip,appname,user,status,password_expired\n|append [[\n\tappname:mysql tag:user_detail \n\t|rename mysql.user as user,mysql.password_expired as password_expired,json.ACCOUNT_STATUS as status,json.EXPIRY_DATE as password_expired,json.USERNAME as user \n\t| stats count() as cnt by ip,appname,user,password_expired]] \n|eval status=if(empty(status),\"OPEN\",status) \n| fields ip,appname,user,status,password_expired \n| rename appname as \"数据库类型\",user as \"用户名\" ,password_expired as \"密码有效期至\",status as \"账号状态\""}
{"input": "服务器密码策略详情", "instruction": "安全合规仪表盘数据，编写查询语句实现如下分析场景", "output": "appname:linux tag:policy_info\n|rename linux.PASS_MAX_DAYS as passwd_maxage ,linux.PASS_MIN_LEN as passwd_min_length\n|stats count() as cnt by ip,appname,passwd_maxage,passwd_min_length \n|append[[\n\tappname:windows tag:policy_info \n\t| rename json.MaximumPasswordAge as passwd_maxage, json.MinimumPasswordLength as passwd_min_length ,json.PasswordComplexity as passwd_complexity ,json.LockoutBadCount as lockout_count ,json.ResetLockoutCount as reset_lockout_count , json.LockoutDuration as lockout_time ,json.EnableGuestAccount  as enable_guest \n\t| stats count() as cnt by ip,appname,passwd_maxage,passwd_min_length,passwd_complexity,lockout_count,lockout_time,reset_lockout_count,enable_guest]] \n|eval a=if(empty(passwd_complexity),\"0\",passwd_complexity)|eval b=if(empty(lockout_count),\"0\",lockout_count)|eval c=if(empty(lockout_time),\"0\",lockout_time) | eval d=if(empty(enable_guest),\"0\",enable_guest) | fields ip,appname,passwd_maxage,passwd_min_length,a,b,c,d\n|rename appname as \"操作系统\",passwd_maxage as \"密码最长使用时间\",passwd_min_length as \"密码长度最小值\",a as \"密码复杂性是否启用\",b as \"账号锁定阀值\", c as \"账户锁定时间\" ,d as \"是否启用guest账号\""}
{"input": "", "instruction": "我想问的是，你有没有和 Oracle 用户的详细信息相关的日志吗？如果有的话，请告诉我这些日志中包含哪些字段，以及它们的数据类型。", "output": "appname:oracle tag:user_detail |rename mysql.user as user,mysql.password_expired as password_expired,json.ACCOUNT_STATUS as status,json.EXPIRY_DATE as password_expired,json.USERNAME as user | stats count() as cnt by ip,appname,user,status,password_expired|append [[ appname:mysql tag:user_detail  |rename mysql.user as user,mysql.password_expired as password_expired,json.ACCOUNT_STATUS as status,json.EXPIRY_DATE as password_expired,json.USERNAME as user  | stats count() as cnt by ip,appname,user,password_expired]] |eval status=if(empty(status),\"OPEN\",status) | fields ip,appname,user,status,password_expired | rename appname as \"数据库类型\",user as \"用户名\",password_expired as \"密码有效期至\",status as \"账号状态\""}
{"input": "", "instruction": "我想要知道有多少台 Linux 服务器上正在运行哪些服务，以及这些服务的状态和 IP 地址。请告诉我如何实现这个功能。", "output": "appname:linux tag:services | stats count() as cnt by ip,appname,linux.service_name,linux.status | rename linux.service_name as service_name,linux.status as status|append[[ appname:windows tag:services  | stats count() as cnt by ip,appname,json.service_name,json.status,json.description  | rename  json.service_name as service_name,json.status as status,json.description as desc]]|eval a=if(empty(desc),\"null\",desc)"}
{"input": "首先过滤出app名称为linux,并且tag为policy_info的事件,同时重命名字段linux.PASS_MAX_DAYS为passwd_maxage,linux.PASS_MIN_LEN为passwd_min_length；然后基于ip,appname,passwd_maxage,passwd_min_length这些字段做统计；然后追加一段查询，过滤appname为windows,tag为policy_info的事件,并重命名相关字段和 Linux 字段保持一致；如果passwd_complexity,lockout_count,lockout_time,enable_guest为空,则将其值设为0；保留需要的字段并改为中文名称。", "instruction": "列出 Linux 和 Windows 的最大密码有效期、最小密码长度以及是否开启了密码强度要求、是否允许 guest 用户等相关策略配置内容", "output": "appname:linux tag:policy_info|rename linux.PASS_MAX_DAYS as passwd_maxage,linux.PASS_MIN_LEN as passwd_min_length|stats count() as cnt by ip,appname,passwd_maxage,passwd_min_length |append[[ appname:windows tag:policy_info  | rename json.MaximumPasswordAge as passwd_maxage, json.MinimumPasswordLength as passwd_min_length,json.PasswordComplexity as passwd_complexity,json.LockoutBadCount as lockout_count,json.ResetLockoutCount as reset_lockout_count, json.LockoutDuration as lockout_time,json.EnableGuestAccount  as enable_guest  | stats count() as cnt by ip,appname,passwd_maxage,passwd_min_length,passwd_complexity,lockout_count,lockout_time,reset_lockout_count,enable_guest]] |eval a=if(empty(passwd_complexity),\"0\",passwd_complexity)|eval b=if(empty(lockout_count),\"0\",lockout_count)|eval c=if(empty(lockout_time),\"0\",lockout_time) | eval d=if(empty(enable_guest),\"0\",enable_guest) | fields ip,appname,passwd_maxage,passwd_min_length,a,b,c,d|rename appname as \"操作系统\",passwd_maxage as \"密码最长使用时间\",passwd_min_length as \"密码长度最小值\",a as \"密码复杂性是否启用\",b as \"账号锁定阀值\", c as \"账户锁定时间\",d as \"是否启用guest账号\""}
{"input": "", "instruction": "我想问的是，在过去一天内，我的容器有哪些磁盘 I/O 消耗比较高？请列出每个容器的总和以及平均值。", "output": "starttime=\"-1d\" appname:docker_metric tag:docker_metric_diskio AND (hostname:* AND ip:\"192.168.41.1\") |bucket timestamp span=30m as ts| stats count() as cnt by json.total,ts |rename json.total as total|eval line=\"diskio\"|append[[appname:docker_metric tag:docker_metric_cpu AND (hostname:* AND ip:*) |bucket timestamp span=30m as ts| stats count() as cnt by json.total.pct,ts|rename json.total.pct as total|eval line=\"cpu\"]]|append[[appname:docker_metric tag:docker_metric_network AND (hostname:* AND ip:*) |bucket timestamp span=30m as ts| stats count() as cnt by json.outbound.dropped,json.in.dropped,json.out.dropped,json.inbound.dropped,ts |eval drop=json.outbound.dropped+json.in.dropped+json.out.dropped+json.inbound.dropped|rename drop as total | eval line=\"drop_pct\"]]|append[[appname:docker_metric tag:docker_metric_memory AND (hostname:* AND ip:*) |bucket timestamp span=30m as ts| stats count() as cnt by json.usage.pct,ts|rename json.usage.pct as total | eval line=\"memory_pct\" ]]"}
{"input": "", "instruction": "我想问的是系统的平均内存使用率是否高于80%，并且按五分钟颗粒度统计的数据。", "output": "appname:top_info_system_stats  |stats count() as ct by ip |stats count(ip) as _ct |appendcols [[appname:top_info_system_stats  | bucket timestamp span=5m as ts  | stats avg(json.Mem.used_percent) as _avg by ip,hostname  | where _avg >= 80  | stats dc(ip) as _dc ]]| eval health=abs(_ct-_dc)/_ct"}
{"input": "", "instruction": "我想要知道系统的 CPU 使用率是否过高，并且只显示使用率低于 30% 的主机的信息。请告诉我这些主机的 IP 和主机名。", "output": "appname:top_info_system_stats  |stats count() as ct by ip |stats count(ip) as _ct |appendcols [[appname:top_info_system_stats   | bucket timestamp span=5m as ts  | stats avg(json.cpu.idle_percent) as _avg by ts,ip,hostname  | where _avg <=30  | stats dc(ip) as _dc ]]|eval health=abs(_ct-_dc)/_ct"}
{"input": "内网访问外网关系图，包括源ip、源端口、目的ip、国家、城市，展示最近 20 条。索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "firewall_神州数码数据，编写查询语句实现如下分析场景", "output": "appname:firewall tag:dc firewall.src.geo.city:private \n|stats count() as cnt by firewall.src_ip,firewall.src_port,firewall.dst_ip,firewall.dst.geo.country,firewall.dst.geo.city\n| eval dst=firewall.dst_ip+\"_\"+firewall.dst.geo.city\n|eval from=firewall.src_ip\n|eval to=firewall.src_port\n|sort by cnt\n|limit 20\n|fields from,to,cnt\n|append[[\n\tappname:firewall tag:dc firewall.src.geo.city:private \n\t|stats count() as cnt by firewall.src_ip,firewall.src_port,firewall.dst_ip,firewall.dst.geo.country,firewall.dst.geo.city\n\t| eval dst=firewall.dst_ip+\"_\"+firewall.dst.geo.country+\"_\"+firewall.dst.geo.city\n\t|eval from=firewall.src_port\n\t|eval to=dst\n\t|sort by cnt\n\t|limit 20\n\t|fields from,to,cnt]]"}
{"input": "非内网会话关系图，包括源ip、目的ip、目的端口，展示最近 20 条。索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "firewall_神州数码数据，编写查询语句实现如下分析场景", "output": "appname:firewall tag:dc   NOT firewall.src.geo.city:private \n|stats count() as cnt by firewall.src_ip,firewall.dst_port,firewall.dst_ip,firewall.src.geo.province,firewall.src.geo.city\n| eval src=firewall.src_ip+\"_\"+firewall.src.geo.province+\"_\"+firewall.src.geo.city\n|eval from=src\n|eval to=firewall.dst_ip\n|fields from,to,cnt\n\t|sort by cnt\n\t|limit 20\n\t|fields from,to,cnt\n|append[[\n\tappname:firewall tag:dc NOT firewall.src.geo.city:private \n\t|stats count() as cnt by firewall.src_ip,firewall.dst_port,firewall.dst_ip,firewall.src.geo.province,firewall.src.geo.city\n\t|eval from=firewall.dst_ip\n\t|eval to=firewall.dst_port\n\t|sort by cnt\n\t|limit 20\n\t|fields from,to,cnt]]"}
{"input": "被访问资源TOP10。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "深信服零信任VPN数据，编写查询语句实现如下分析场景", "output": "appname:vpn tag:sangfor_0trust  vpn.event_name:access_resource\n|stats count() as cnt by vpn.resource_name\n|rename vpn.resource_name as resource_name\n| append [[\n\tappname:vpn tag:sangfor_0trust  vpn.event_name:app\n\t|stats count() as cnt by vpn.target.displayName\n\t| rename vpn.target.displayName as resource_name\n]]|stats sum(cnt) as cnt by resource_name|sort by cnt|limit 10"}
{"input": "防火墙高频次失败访问IP和端口的关系图，按请求量取前 20 对。索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "cisco_asa防火墙数据，编写查询语句实现如下分析场景", "output": "appname:firewall tag:cisco_asa (firewall.action:failure OR firewall.action:teardown OR firewall.action:blocked) | stats count() as cnt by firewall.src.geo.ip,firewall.dst.geo.ip,firewall.dst_port|sort by cnt|limit 20|fields firewall.src.geo.ip,firewall.dst.geo.ip,cnt|rename  firewall.src.geo.ip as from,firewall.dst.geo.ip as to| append [[appname:firewall tag:cisco_asa (firewall.action:failure OR firewall.action:teardown OR firewall.action:blocked) | stats count() as cnt by firewall.src.geo.ip,firewall.dst.geo.ip,firewall.dst_port|sort by cnt|limit 20|fields firewall.dst.geo.ip,firewall.dst_port,cnt|rename firewall.dst.geo.ip as from,firewall.dst_port as to]]"}
{"input": "源IP到目标IP、目标端口的访问关系图，展示前 20 条。索引可用字段有：ips.action, ips.application, ips.attack_name, ips.attack_type, ips.block_reason, ips.cve, ips.dst.geo.city, ips.dst.geo.ip, ips.dst.geo.latitude, ips.dst.geo.longitude, ips.dst_ip, ips.dst_port, ips.event, ips.event_id, ips.event_level, ips.event_name, ips.inbound_interface, ips.inbound_zone, ips.level, ips.local, ips.msg.seclevel, ips.outbound_interface, ips.outbound_zone, ips.policy, ips.proto, ips.service, ips.severity, ips.src.geo.city, ips.src.geo.country, ips.src.geo.ip, ips.src.geo.latitude, ips.src.geo.longitude, ips.src.geo.province, ips.src_ip, ips.src_port, ips.url, ips.vendor_app, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "ips_mcafee数据，编写查询语句实现如下分析场景", "output": "appname:ips tag:mcafee NOT ips.level:Informational\n| stats count() as cnt by ips.src_ip,ips.dst_ip,ips.dst_port\n|sort by cnt\n|limit 20\n|rename ips.src_ip as from,ips.dst_ip as to\n|append [[\n\tappname:ips tag:mcafee NOT ips.level:Informational\n\t| stats count() as cnt by ips.src_ip,ips.dst_ip,ips.dst_port\n\t|sort by cnt\n\t|limit 20\n\t|rename ips.dst_ip as from,ips.dst_port as to\n]]|fields from,to,cnt"}
{"input": "非 info 级别的攻击事件关系图，保留前 20 条。索引可用字段有：ips.action, ips.application, ips.attack_name, ips.attack_type, ips.block_reason, ips.cve, ips.dst.geo.city, ips.dst.geo.ip, ips.dst.geo.latitude, ips.dst.geo.longitude, ips.dst_ip, ips.dst_port, ips.event, ips.event_id, ips.event_level, ips.event_name, ips.inbound_interface, ips.inbound_zone, ips.level, ips.local, ips.msg.seclevel, ips.outbound_interface, ips.outbound_zone, ips.policy, ips.proto, ips.service, ips.severity, ips.src.geo.city, ips.src.geo.country, ips.src.geo.ip, ips.src.geo.latitude, ips.src.geo.longitude, ips.src.geo.province, ips.src_ip, ips.src_port, ips.url, ips.vendor_app, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "ips_mcafee数据，编写查询语句实现如下分析场景", "output": "appname:ips tag:mcafee NOT ips.level:Informational\n| stats count() as cnt by ips.src_ip,ips.dst_ip,ips.event_name\n|sort by cnt\n|limit 20\n|rename ips.src_ip as from,ips.dst_ip as to\n|append [[\n\tappname:ips tag:mcafee NOT ips.level:Informational\n\t| stats count() as cnt by ips.src_ip,ips.dst_ip,ips.event_name\n\t|sort by cnt\n\t|limit 20\n\t|rename ips.dst_ip as from,ips.event_name as to\n]]|fields from,to,cnt"}
{"input": "非 info 级别威胁事件关系图，保留前 20 条。索引可用字段有：nta.Service_Name, nta.alert.action, nta.alert.category, nta.alert.metadata.former_category, nta.alert.severity, nta.alert.signature, nta.attack_name, nta.attack_type, nta.dest_ip, nta.dest_port, nta.dst.geo.city, nta.dst_ip, nta.dst_ip_city, nta.dst_port, nta.event_level, nta.event_name, nta.event_type, nta.flow.bytes_toclient, nta.flow.bytes_toserver, nta.kill_chain, nta.level, nta.login_user, nta.proto, nta.src.geo.city, nta.src.geo.country, nta.src.geo.province, nta.src_ip, nta.src_ip_city, nta.src_port, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "长亭NTA数据，编写查询语句实现如下分析场景", "output": "appname:nta tag:chaitin NOT nta.level:Informational\n| stats count() as cnt by nta.src_ip,nta.dst_ip,nta.attack_name\n|sort by cnt\n|limit 20\n|rename nta.src_ip as from,nta.dst_ip as to\n|append [[\n\tappname:nta tag:chaitin NOT nta.level:Informational\n\t| stats count() as cnt by nta.src_ip,nta.dst_ip,nta.attack_name\n\t|sort by cnt\n\t|limit 20\n\t|rename nta.dst_ip as from,nta.attack_name as to\n]]|fields from,to,cnt"}
{"input": "源IP到目标IP_目标端口的访问关系统计，展示前 20 条。索引可用字段有：nta.Service_Name, nta.alert.action, nta.alert.category, nta.alert.metadata.former_category, nta.alert.severity, nta.alert.signature, nta.attack_name, nta.attack_type, nta.dest_ip, nta.dest_port, nta.dst.geo.city, nta.dst_ip, nta.dst_ip_city, nta.dst_port, nta.event_level, nta.event_name, nta.event_type, nta.flow.bytes_toclient, nta.flow.bytes_toserver, nta.kill_chain, nta.level, nta.login_user, nta.proto, nta.src.geo.city, nta.src.geo.country, nta.src.geo.province, nta.src_ip, nta.src_ip_city, nta.src_port, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "长亭NTA数据，编写查询语句实现如下分析场景", "output": "appname:nta tag:chaitin \n| stats count() as cnt by nta.src_ip,nta.dst_ip,nta.dst_port\n|sort by cnt\n|limit 20\n|rename nta.src_ip as from,nta.dst_ip as to\n|append [[\n\tappname:nta tag:chaitin \n\t| stats count() as cnt by nta.src_ip,nta.dst_ip,nta.dst_port\n\t|sort by cnt\n\t|limit 20\n\t|rename nta.dst_ip as from,nta.dst_port as to\n]]|fields from,to,cnt"}
{"input": "威胁事件关系图，保留前 20 条。", "instruction": "fireeye_nx数据，编写查询语句实现如下分析场景", "output": "appname:fireeye tag:nx\n| stats count() as cnt by nx.src_ip,nx.dst_ip,nx.sname\n|sort by cnt\n|limit 20\n|rename nx.src_ip as from,nx.dst_ip as to\n|append [[\n\tappname:fireeye tag:nx \n\t| stats count() as cnt by nx.src_ip,nx.dst_ip,nx.sname\n\t|sort by cnt\n\t|limit 20\n\t|rename nx.dst_ip as from,nx.sname as to\n]]|fields from,to,cnt"}
{"input": "源IP到目标IP_目标端口访问关系图，展示前 20 条。", "instruction": "fireeye_nx数据，编写查询语句实现如下分析场景", "output": "appname:fireeye tag:nx \n| stats count() as cnt by nx.src_ip,nx.dst_ip,nx.dst_port\n|sort by cnt\n|limit 20\n|rename nx.src_ip as from,nx.dst_ip as to\n|append [[\n\tappname:fireeye tag:nx \n\t| stats count() as cnt by nx.src_ip,nx.dst_ip,nx.dst_port\n\t|sort by cnt\n\t|limit 20\n\t|rename nx.dst_ip as from,nx.dst_port as to\n]]|fields from,to,cnt"}
{"input": "dns_bind9_查询记录top30。索引可用字段有：dns.dhcp_ip, dns.dhcp_mac, dns.dhcp_req_type, dns.domain, dns.gateway, dns.level, dns.query, dns.rcode, dns.search_type, dns.src_ip, dns.type, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "dns_bind9数据，编写查询语句实现如下分析场景", "output": "appname:dns tag:bind9 |stats count() as cnt by dns.src_ip,dns.search_type|rename dns.src_ip as from,dns.search_type as to|sort by cnt |limit 30|append [[appname:dns tag:bind9 |stats count() as cnt by dns.search_type,dns.query\t|rename dns.search_type as from,dns.query as to|sort by cnt |limit 30]]"}
{"input": "安全设备检测到高危ipTop20。索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "安全态势仪表盘数据，编写查询语句实现如下分析场景", "output": "appname:firewall Deny|stats count() as cnt by firewall.src_ip|rename firewall.src_ip as src_ip|append [[appname:ips |stats count() as cnt by ips.src_ip|rename ips.src_ip as src_ip]]|append [[appname:waf|stats count() as cnt by waf.src_ip|rename waf.src_ip as src_ip]]|sort by cnt |limit 20"}
{"input": "安全设备检测到高危目的ipTop20。索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "安全态势仪表盘数据，编写查询语句实现如下分析场景", "output": "appname:firewall Deny|stats count() as cnt by firewall.dst_ip|rename firewall.dst_ip as dst_ip|append [[appname:ips |stats count() as cnt by ips.dst_ip|rename ips.dst_ip as dst_ip]]|append [[appname:waf|stats count() as cnt by waf.dst_ip|rename waf.dst_ip as dst_ip]]|sort by cnt |limit 20"}
{"input": "被攻击地址_端口TOP20。索引可用字段有：waf.action, waf.attack_name, waf.attack_type, waf.bytes_in, waf.cost, waf.cve_id, waf.dst_city, waf.dst_domain, waf.dst_ip, waf.dst_latitude, waf.dst_longitude, waf.dst_port, waf.error_msg, waf.event_level, waf.event_log_level, waf.event_name, waf.event_type, waf.http_method, waf.http_refer, waf.is_truncated, waf.kv.Evt_level, waf.kv.Evt_type, waf.kv.event_name, waf.kv.http_method, waf.kv.http_refer, waf.kv.http_url, waf.kv.msg, waf.kv.owasp_top, waf.kv.pri, waf.kv.severity_level, waf.kv.status, waf.kv.type, waf.level, waf.log_category, waf.message, waf.message.action, waf.message.event, waf.message.method, waf.message.policy, waf.message.src_ip.geo.ip, waf.message.src_ip.geo.province, waf.message.src_port, waf.message.status, waf.message.threaten, waf.method, waf.module, waf.msg.act, waf.msg.cs, waf.msg.policy_id, waf.msg.src.geo.country, waf.policy_name, waf.proto, waf.referer, waf.risk_level, waf.severity, waf.src.geo.city, waf.src.geo.country, waf.src.geo.ip, waf.src.geo.isp, waf.src.geo.latitude, waf.src.geo.longitude, waf.src.geo.province, waf.src_ip, waf.src_port, waf.status, waf.status_code, waf.threat_level, waf.time, waf.ua_browser, waf.ua_device, waf.ua_os, waf.uri, waf.url, waf.user_agent.browser, waf.user_agent.os, waf.website_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "WAF_F5数据，编写查询语句实现如下分析场景", "output": "appname:waf tag:f5 NOT waf.is_truncated:truncated NOT waf.attack_type:\"\" \n|stats count() as cnt by waf.dst_ip,waf.dst_port\n|append[[\n\tappname:waf tag:f5  waf.is_truncated:truncated  \n\t|stats count() as cnt by waf.dst_ip,waf.dst_port ]]|sort by cnt |limit 20"}
{"input": "攻击地址TOP20。索引可用字段有：waf.action, waf.attack_name, waf.attack_type, waf.bytes_in, waf.cost, waf.cve_id, waf.dst_city, waf.dst_domain, waf.dst_ip, waf.dst_latitude, waf.dst_longitude, waf.dst_port, waf.error_msg, waf.event_level, waf.event_log_level, waf.event_name, waf.event_type, waf.http_method, waf.http_refer, waf.is_truncated, waf.kv.Evt_level, waf.kv.Evt_type, waf.kv.event_name, waf.kv.http_method, waf.kv.http_refer, waf.kv.http_url, waf.kv.msg, waf.kv.owasp_top, waf.kv.pri, waf.kv.severity_level, waf.kv.status, waf.kv.type, waf.level, waf.log_category, waf.message, waf.message.action, waf.message.event, waf.message.method, waf.message.policy, waf.message.src_ip.geo.ip, waf.message.src_ip.geo.province, waf.message.src_port, waf.message.status, waf.message.threaten, waf.method, waf.module, waf.msg.act, waf.msg.cs, waf.msg.policy_id, waf.msg.src.geo.country, waf.policy_name, waf.proto, waf.referer, waf.risk_level, waf.severity, waf.src.geo.city, waf.src.geo.country, waf.src.geo.ip, waf.src.geo.isp, waf.src.geo.latitude, waf.src.geo.longitude, waf.src.geo.province, waf.src_ip, waf.src_port, waf.status, waf.status_code, waf.threat_level, waf.time, waf.ua_browser, waf.ua_device, waf.ua_os, waf.uri, waf.url, waf.user_agent.browser, waf.user_agent.os, waf.website_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "WAF_F5数据，编写查询语句实现如下分析场景", "output": "appname:waf tag:f5 NOT waf.is_truncated:truncated NOT waf.attack_type:\"\" \n|stats count() as cnt by waf.src_ip\n|append[[\n\tappname:waf tag:f5  waf.is_truncated:truncated  \n\t|stats count() as cnt by waf.src_ip ]]|sort by cnt |limit 20"}
{"input": "游戏TOP20。索引可用字段有：ac.ac_ip, ac.action, ac.ap_ip, ac.ap_name, ac.app, ac.app_name, ac.band, ac.client, ac.command, ac.dst_ip, ac.dst_port, ac.event_id, ac.event_name, ac.event_type, ac.kv.app_cat_name, ac.kv.log_level, ac.kv.receive_addr, ac.kv.send_addr, ac.kv.subject, ac.kv.term_device, ac.log_type, ac.mac_addr, ac.mnemonic, ac.msg.app, ac.msg.serv, ac.msg.tm_type, ac.msg.user, ac.operation, ac.policy, ac.request_url, ac.resource, ac.resource_type, ac.result, ac.src_ip, ac.src_mac, ac.ssid, ac.status, ac.time, ac.user, ac.user_agent, ac.user_name, ac.web_app, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "奇安信AC数据，编写查询语句实现如下分析场景", "output": "appname:ac tag:qianxin ac.log_type:web ac.web_app:*游戏* \n| stats count() as cnt by ac.src_ip\n| sort by cnt \n| limit 20 \n|rename ac.src_ip as src \n|append[[\n\tappname:ac tag:qianxin ac.log_type:trc ac.action:阻塞 NOT ac.app:色情\n\t| stats count() as cnt by ac.dst_ip\n\t|sort by cnt \n\t| limit 20\n\t|rename ac.dst_ip as src ]] \n|sort by cnt \n|limit 20"}
{"input": "按每5分钟分桶统计整机流量速率曲线图。具体过程如下：\n1. 过滤 switchperf 日志,选取 ifInOctets 类型\n2. 每 5 分钟汇总一次,求和 switchperf.value 字段值,分组 by switchperf.devip(设备 IP)、switchperf.ifindex(接口索引)\n3. 按 switchperf.ifindex 升序排序\n4. 自动回归(_totalOctets 为上一步求和的值),上一条记录的 _totalOctets 字段值,p=1 表示只回归 1 条记录\n5. 同样回归 switchperf.ifindex 和 switchperf.type 字段\n6. 过滤,只选取 switchperf.ifindex 与上一条记录相同的记录\n7. 计算 Octets 字段值,根据 _totalOctets 与 last_totalOctets 的差值\n8. 再次求和 Octets 字段值,分组 by ts 和 switchperf.devip\n9. 设置 type 字段为 \"InBytes\"\n10. 结果与第二条查询语句的结果做 append 连接\n11. 第二条查询语句类似,区别在于过滤 ifOutOctets 类型,设置 type 字段为 \"OutBytes\"\n12. 第三条查询语句过滤 ifInOctets 和 ifOutOctets 任一类型,设置 type 字段为 \"TotalBytes\"\n13. 最终结果为3条查询语句连接后的结果。索引可用字段有：switchperf.devip, switchperf.ifindex, switchperf.type, switchperf.value, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "网络设备接口数据数据，编写查询语句实现如下分析场景", "output": "appname:switchperf AND switchperf.type:ifInOctets | bucket timestamp span=5m as ts | stats sum(switchperf.value) as _totalOctets by ts,switchperf.devip,switchperf.ifindex  | sort by switchperf.ifindex,+ts | autoregress _totalOctets as last_totalOctets p=1 | autoregress switchperf.ifindex as lastifindex p=1 | where\tswitchperf.ifindex==lastifindex | eval Octets=case(_totalOctets-last_totalOctets<0,_totalOctets-last_totalOctets+4294967296,default,_totalOctets-last_totalOctets) | stats sum(Octets) as Octets by ts,switchperf.devip | eval type=\"InBytes\"\n| append\n[[appname:switchperf AND switchperf.type:ifOutOctets | bucket timestamp span=5m as ts | stats sum(switchperf.value) as _totalOctets by ts,switchperf.devip,switchperf.ifindex  | sort by switchperf.ifindex,+ts | autoregress _totalOctets as last_totalOctets p=1 | autoregress switchperf.ifindex as lastifindex p=1 | where\tswitchperf.ifindex==lastifindex | eval Octets=case(_totalOctets-last_totalOctets<0,_totalOctets-last_totalOctets+4294967296,default,_totalOctets-last_totalOctets) | stats sum(Octets) as Octets by ts,switchperf.devip | eval type=\"OutBytes\"]]\n| append\n[[appname:switchperf AND (switchperf.type:ifOutOctets OR switchperf.type:ifInOctets)| bucket timestamp span=5m as ts | stats sum(switchperf.value) as _totalOctets by ts,switchperf.devip,switchperf.ifindex,switchperf.type | sort by switchperf.ifindex,switchperf.type,+ts | autoregress _totalOctets as last_totalOctets p=1 | autoregress switchperf.ifindex as lastifindex p=1 | autoregress switchperf.type as lasttype p=1 | where switchperf.ifindex==lastifindex| where switchperf.type==lasttype | eval Octets=case(_totalOctets-last_totalOctets<0,_totalOctets-last_totalOctets+4294967296,default,_totalOctets-last_totalOctets) | stats sum(Octets) as Octets by ts,switchperf.devip | eval type=\"TotalBytes\"]]"}
{"input": "按每5分钟分桶统计整机流量数据包率曲线图。分析思路如下：Filters for switch performance logs (appname:switchperf)。\nOnly looks at inbound and outbound unicast and non-unicast packet types。\nGroups the data by 5 minute buckets 。\nCalculates the sum of packet values for each 5 minute period 。\nGroups the results by device IP, interface index, and type。\nSorts the results by interface index and type。\nCalculates the change in packet count from the previous period (autoregress and eval Pkts calculations)。\nSums the packet change for each 5 minute period 。\nLabels the results as either \"InPkts\", \"OutPkts\", or \"TotalPkts\"。\nAppends the results for inbound, outbound, and total packets into a single result set。。", "instruction": "网络设备接口数据数据，编写查询语句实现如下分析场景", "output": "appname:switchperf AND (switchperf.type:ifInUcastPkts OR switchperf.type:ifInNUcastPkts) | bucket timestamp span=5m as ts | stats sum(switchperf.value) as _totalPkts by ts,switchperf.devip,switchperf.ifindex,switchperf.type  | sort by switchperf.ifindex,switchperf.type,+ts | autoregress _totalPkts as last_totalPkts p=1 | autoregress switchperf.ifindex as lastifindex p=1 | autoregress switchperf.type as lasttype p=1 | where\tswitchperf.ifindex==lastifindex| where\tswitchperf.type==lasttype | eval Pkts=case(_totalPkts-last_totalPkts<0,_totalPkts-last_totalPkts+4294967296,default,_totalPkts-last_totalPkts) | stats sum(Pkts) as Pkts by ts,switchperf.devip | eval type=\"InPkts\"\n| append\n[[appname:switchperf AND (switchperf.type:ifOutUcastPkts OR switchperf.type:ifOutNUcastPkts) | bucket timestamp span=5m as ts | stats sum(switchperf.value) as _totalPkts by ts,switchperf.devip,switchperf.ifindex,switchperf.type  | sort by switchperf.ifindex,switchperf.type,+ts | autoregress _totalPkts as last_totalPkts p=1 | autoregress switchperf.ifindex as lastifindex p=1 | autoregress switchperf.type as lasttype p=1 | where switchperf.ifindex==lastifindex | where\tswitchperf.type==lasttype  | eval Pkts=case(_totalPkts-last_totalPkts<0,_totalPkts-last_totalPkts+4294967296,default,_totalPkts-last_totalPkts) | stats sum(Pkts) as Pkts by ts,switchperf.devip | eval type=\"OutPkts\"]]\n| append\n[[appname:switchperf AND (switchperf.type:ifInUcastPkts OR switchperf.type:ifInNUcastPkts OR switchperf.type:ifOutUcastPkts OR switchperf.type:ifOutNUcastPkts)| bucket timestamp span=5m as ts | stats sum(switchperf.value) as _totalPkts by ts,switchperf.devip,switchperf.ifindex,switchperf.type | sort by switchperf.ifindex,switchperf.type,+ts | autoregress _totalPkts as last_totalPkts p=1 | autoregress switchperf.ifindex as lastifindex p=1 | autoregress switchperf.type as lasttype p=1 | where switchperf.ifindex==lastifindex | where\tswitchperf.type==lasttype  | eval Pkts=case(_totalPkts-last_totalPkts<0,_totalPkts-last_totalPkts+4294967296,default,_totalPkts-last_totalPkts) | stats sum(Pkts) as Pkts by ts,switchperf.devip | eval type=\"TotalPkts\"]]"}
{"input": "分别过滤 session opened for关键字和session closed for关键字，为命中这两个关键字的日志创建新的 action 字段并分别赋值为切换和退出。两类日志均只保留 action、audit.msg.user 和 timestamp 字段，然后 append 到一起，再按 timestamp 排序。最后把 timestamp 字段转换为人类可读格式。索引可用字段有：audit.MACHINE, audit.OSUSER, audit.PROGRAM, audit.SQL_ID, audit.SQL_TEXT, audit.USERNAME, audit.command, audit.msg.cmd, audit.msg.command, audit.msg.exec_time, audit.msg.info, audit.msg.path, audit.msg.pid, audit.msg.pwd, audit.msg.rhost, audit.msg.ruser, audit.msg.ser, audit.msg.src_ip, audit.msg.src_port, audit.msg.user, audit.up_time, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "在 audit 日志里查询用户su操作", "output": "appname:audit  AND audit.msg.ser:su-l AND \"session opened for\" | eval action=\"切换\" | table action,audit.msg.user,audit.msg.ruser,timestamp | append [[ appname:audit AND audit.msg.ser:su-l AND \"session closed for\" | eval action=\"退出\" | table action,audit.msg.user,timestamp ]] | sort by timestamp | eval time=formatdate(timestamp) "}
{"input": "最近一天发现病毒一览表。", "instruction": "防病毒_SEPM数据，编写查询语句实现如下分析场景", "output": "starttime=\"-1d\" appname:antivirus_gateway tag:symantec  \"发现病毒\" |table 'antivirus_gateway.src_ip','antivirus_gateway.msg.计算机名','antivirus_gateway.msg.风险名称','antivirus_gateway.msg.流行程度','antivirus_gateway.msg.应用类型'|append[[appname:antivirus_gateway AND ( tag:symantec OR tag:symantec_app_c OR tag:symantec_risk ) \"发现病毒\" | table antivirus_gateway.src_ip,antivirus_gateway.host_name,antivirus_gateway.risk_name]]"}
{"input": "天融信防火墙认证和修改配置详细日志记录。索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "天融信防火墙日志数据，编写查询语句实现如下分析场景", "output": "appname:firewall AND tag:topsec (AUTH OR firewall.recorder:config)\n| table firewall.time,firewall.msg.fw,firewall.msg.user,firewall.src_ip,firewall.msg.msg\n|rename firewall.msg.msg as msg  \n|append[[\n\tappname:firewall AND tag:topsec config \n\t|table  firewall.time,firewall.msg.fw,firewall.msg.user,firewall.src_ip,firewall.msg.command\n\t|rename firewall.msg.command as msg]]"}
{"input": "匹配日志类型为vpn、tag为sangfor、actype为login或者logout以及actype为allocate vip的日志,将timestamp格式化成日期时间,存储在tt字段。重命名vpn.src_ip为srcip和vpn.msg.virtual_ip为vip字段。取30条 login/logout日志与20条allocate vip日志,合并后取100条。根据result字段生成msg字段,result为success或者REMOTE,msg为成功,否则msg为vpn.msg原值。最后根据时间tt排序,表格展示相关字段,并重命名各个字段的名称。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "vpn用户登录明细", "output": "appname:vpn tag:sangfor (vpn.actype:login OR vpn.actype:logout)  |eval tt=formatdate(timestamp) |rename vpn.src_ip as srcip |limit 30 |append [[ appname:vpn tag:sangfor vpn.actype:\"allocate vip\"    |eval tt=formatdate(timestamp)| rename vpn.msg.virtual_ip as vip   |rename vpn.src_ip as srcip |limit 20 ]] |limit 100 |eval msg=if((vpn.result==\"success\"||vpn.result==\"REMOTE\"),\"成功\",vpn.msg) |sort by +tt|table tt,vpn.login_user,srcip,vip,vpn.dst_ip,vpn.dst_port,vpn.result,msg |rename tt as \"时间\",vpn.login_user as \"账号\",srcip as \"外网IP\",vip as \"内网VIP\",vpn.result as \"返回状态\",msg as \"返回结果\""}
{"input": "1. 查询logtype为vpn,tag为sangfor,且event_type为login或logout的前30条日志。 对结果重命名src_ip为srcip,并格式化时间戳为tt。\n2. 追加查询logtype为vpn,tag为sangfor,event_type为access resource的前20条日志。对结果重命名login_user为vpn.login_user,src_ip为vip,格式化时间戳为tt。\n3. 追加查询logtype为vpn,tag为sangfor,event_type为allocate vip的前20条日志。对结果重命名msg.virtual_ip为vip,src_ip为srcip,格式化时间戳为tt。\n4. 最后对结果取前100条,如果result为success或REMOTE,则msg为“成功”,否则msg为vpn.msg。\n5. 对最终结果按时间升序排序,并以表格形式显示,并重命名列名。\n。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "VPN各类事件详情", "output": "appname:vpn tag:sangfor (vpn.actype:login OR vpn.actype:logout)  |eval tt=formatdate(timestamp) |rename vpn.src_ip as srcip |limit 30 |append [[ appname:vpn tag:sangfor vpn.actype:\"access resource\"   |eval tt=formatdate(timestamp)| rename vpn.vpn.login_user as vpn.login_user |rename vpn.src_ip as vip |limit 20 ]] |append [[ appname:vpn tag:sangfor vpn.actype:\"allocate vip\"    |eval tt=formatdate(timestamp)| rename vpn.msg.virtual_ip as vip   |rename vpn.src_ip as srcip |limit 20 ]] |limit 100 |eval msg=if((vpn.result==\"success\"||vpn.result==\"REMOTE\"),\"成功\",vpn.msg) |sort by +tt|table tt,vpn.actype,vpn.login_user,srcip,vip,vpn.dst_ip,vpn.dst_port,vpn.result,msg |rename tt as \"时间\",vpn.login_user as \"账号\",vpn.actype as \"事件类型\",srcip as \"外网IP\",vip as \"内网VIP\",vpn.dst_ip as \"访问目标IP\",vpn.dst_port as \"访问目标端口\",vpn.result as \"返回状态\",msg as \"返回结果\""}
{"input": "各类事件详情，展示 100 条。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "深信服VPN日志数据，编写查询语句实现如下分析场景", "output": "appname:vpn tag:sangfor (vpn.actype:login OR vpn.actype:logout) \n|eval tt=formatdate(timestamp)\n|table tt,vpn.login_user,vpn.actype,vpn.src_ip,vpn.result,vpn.msg\n|rename vpn.src_ip as srcip\n|limit 30\n|append\n[[\nappname:vpn tag:sangfor vpn.actype:\"access resource\"   |eval tt=formatdate(timestamp)| table tt,vpn.vpn.login_user,vpn.actype,vpn.src_ip,vpn.dst_ip,vpn.dst_port,vpn.result\n|rename vpn.vpn.login_user as vpn.login_user\n|rename vpn.src_ip as vip\n|limit 20\n]]\n|append\n[[\nappname:vpn tag:sangfor vpn.actype:\"allocate vip\"  \n |eval tt=formatdate(timestamp)| table tt,vpn.login_user,vpn.actype,vpn.src_ip,vpn.msg.virtual_ip,vpn.result\n|rename vpn.msg.virtual_ip as vip  \n|rename vpn.src_ip as srcip\n|limit 20\n]]\n|limit 100\n|eval msg=if((vpn.result==\"success\"||vpn.result==\"REMOTE\"),\"成功\",vpn.msg)\n|sort by +tt|table tt,vpn.actype,vpn.login_user,srcip,vip,vpn.dst_ip,vpn.dst_port,vpn.result,msg\n|rename tt as \"时间\",vpn.login_user as \"账号\",vpn.actype as \"事件类型\",srcip as \"外网IP\",vip as \"内网VIP\",vpn.dst_ip as \"访问目标IP\",vpn.dst_port as \"访问目标端口\",vpn.result as \"返回状态\",msg as \"返回结果\"|limit 100"}
{"input": "vpn用户登录明细，展示登录登出和虚拟 IP分配的 20 条。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "深信服VPN日志数据，编写查询语句实现如下分析场景", "output": "appname:vpn tag:sangfor (vpn.actype:login OR vpn.actype:logout) \n|eval tt=formatdate(timestamp)\n|table tt,vpn.login_user,vpn.actype,vpn.src_ip,vpn.result,vpn.msg\n|rename vpn.src_ip as srcip\n|limit 20\n|append\n[[\nappname:vpn tag:sangfor vpn.actype:\"allocate vip\"  \n |eval tt=formatdate(timestamp)| table tt,vpn.login_user,vpn.actype,vpn.src_ip,vpn.msg.virtual_ip,vpn.result\n|rename vpn.msg.virtual_ip as vip  \n|rename vpn.src_ip as srcip\n|limit 20\n]]\n|limit 40\n|eval msg=if((vpn.result==\"success\"||vpn.result==\"REMOTE\"),\"成功\",vpn.msg)\n|sort by +tt|table tt,vpn.login_user,srcip,vip,vpn.dst_ip,vpn.dst_port,vpn.result,msg\n|rename tt as \"时间\",vpn.login_user as \"账号\",srcip as \"外网IP\",vip as \"内网VIP\",vpn.result as \"返回状态\",msg as \"返回结果\""}
{"input": "登录、登出、资源访问、分配 vip 等各类事件追加在一起，展示 100 条详情数据。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "Cisco_VPN日志数据，编写查询语句实现如下分析场景", "output": "appname:vpn tag:cisco (vpn.actype:login OR vpn.actype:logout) \n|eval tt=formatdate(timestamp)\n|table tt,vpn.login_user,vpn.actype,vpn.src_ip,vpn.result,vpn.msg\n|rename vpn.src_ip as srcip\n|limit 30\n|append\n[[\nappname:vpn tag:cisco vpn.actype:\"access resource\"   |eval tt=formatdate(timestamp)| table tt,vpn.vpn.login_user,vpn.actype,vpn.src_ip,vpn.dst_ip,vpn.dst_port,vpn.result\n|rename vpn.vpn.login_user as vpn.login_user\n|rename vpn.src_ip as vip\n|limit 20\n]]\n|append\n[[\nappname:vpn tag:cisco vpn.actype:\"allocate vip\"  \n |eval tt=formatdate(timestamp)| table tt,vpn.login_user,vpn.actype,vpn.src_ip,vpn.msg.virtual_ip,vpn.result\n|rename vpn.msg.virtual_ip as vip  \n|rename vpn.src_ip as srcip\n|limit 20\n]]\n|limit 100\n|eval msg=if((vpn.result==\"success\"||vpn.result==\"REMOTE\"),\"成功\",vpn.msg)\n|sort by +tt|table tt,vpn.actype,vpn.login_user,srcip,vip,vpn.dst_ip,vpn.dst_port,vpn.result,msg\n|rename tt as \"时间\",vpn.login_user as \"账号\",vpn.actype as \"事件类型\",srcip as \"外网IP\",vip as \"内网VIP\",vpn.dst_ip as \"访问目标IP\",vpn.dst_port as \"访问目标端口\",vpn.result as \"返回状态\",msg as \"返回结果\"|limit 100"}
{"input": "vpn用户登录明细30 条。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "Cisco_VPN日志数据，编写查询语句实现如下分析场景", "output": "appname:vpn tag:cisco (vpn.actype:login OR vpn.actype:logout) \n|eval tt=formatdate(timestamp)\n|table tt,vpn.login_user,vpn.actype,vpn.src_ip,vpn.result,vpn.msg\n|rename vpn.src_ip as srcip\n|limit 30\n|append\n[[\nappname:vpn tag:cisco vpn.actype:\"allocate vip\"  \n |eval tt=formatdate(timestamp)| table tt,vpn.login_user,vpn.actype,vpn.src_ip,vpn.msg.virtual_ip,vpn.result\n|rename vpn.msg.virtual_ip as vip  \n|rename vpn.src_ip as srcip\n|limit 20\n]]\n|limit 100\n|eval msg=if((vpn.result==\"success\"||vpn.result==\"REMOTE\"),\"成功\",vpn.msg)\n|sort by +tt|table tt,vpn.login_user,srcip,vip,vpn.dst_ip,vpn.dst_port,vpn.result,msg\n|rename tt as \"时间\",vpn.login_user as \"账号\",srcip as \"外网IP\",vip as \"内网VIP\",vpn.result as \"返回状态\",msg as \"返回结果\""}
{"input": "规则禁止最多主机TOP10。", "instruction": "防病毒_SEPM数据，编写查询语句实现如下分析场景", "output": "appname:antivirus_gateway tag:symantec \"规则\" |top 10 antivirus_gateway.symantecserver|append[[appname:antivirus_gateway AND ( tag:symantec OR tag:symantec_app_c OR tag:symantec_risk )| top 10 antivirus_gateway.server_name]]|rename antivirus_gateway.symantecserver as sever,antivirus_gateway.server_name as sever"}
{"input": "规则命中比例图。", "instruction": "防病毒_SEPM数据，编写查询语句实现如下分析场景", "output": "* appname:antivirus_gateway tag:symantec  \"规则\" | top 10 'antivirus_gateway.rulekv.规则'|append[[appname:antivirus_gateway AND ( tag:symantec OR tag:symantec_app_c OR tag:symantec_risk )| top 10 antivirus_gateway.rule_name]]|append[[* appname:antivirus_gateway tag:symantec  \"规则\" | top 10 'antivirus_gateway.msg.规则']]|rename 'antivirus_gateway.rulekv.规则' as rule,antivirus_gateway.rule_name as rule,'antivirus_gateway.msg.规则' as rule"}
{"input": "拦截本地IP_TOP10。", "instruction": "防病毒_SEPM数据，编写查询语句实现如下分析场景", "output": "* appname:antivirus_gateway tag:symantec  \"规则\" | top 10 antivirus_gateway.localip|append[[appname:antivirus_gateway AND ( tag:symantec OR tag:symantec_app_c OR tag:symantec_risk )| top 10 antivirus_gateway.localip]]"}
{"input": "策略拦截远端IP_TOP10。", "instruction": "防病毒_SEPM数据，编写查询语句实现如下分析场景", "output": "* appname:antivirus_gateway tag:symantec  \"规则\" | top 10 antivirus_gateway.remoteip|append[[appname:antivirus_gateway AND ( tag:symantec OR tag:symantec_app_c OR tag:symantec_risk )| top 10 antivirus_gateway.src_ip]]|rename antivirus_gateway.remoteip as src_ip,antivirus_gateway.src_ip as src_ip"}
{"input": "每10分钟统计流量趋势上下行对比。索引可用字段有：ac.ac_ip, ac.action, ac.ap_ip, ac.ap_name, ac.app, ac.app_name, ac.band, ac.client, ac.command, ac.dst_ip, ac.dst_port, ac.event_id, ac.event_name, ac.event_type, ac.kv.app_cat_name, ac.kv.log_level, ac.kv.receive_addr, ac.kv.send_addr, ac.kv.subject, ac.kv.term_device, ac.log_type, ac.mac_addr, ac.mnemonic, ac.msg.app, ac.msg.serv, ac.msg.tm_type, ac.msg.user, ac.operation, ac.policy, ac.request_url, ac.resource, ac.resource_type, ac.result, ac.src_ip, ac.src_mac, ac.ssid, ac.status, ac.time, ac.user, ac.user_agent, ac.user_name, ac.web_app, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "surfilter_ac数据，编写查询语句实现如下分析场景", "output": "appname:ac tag:surfilter ac.event_type:statistic_traffic|eval up=tolong(ac.kv.up)  | bucket timestamp span=10m as ts |stats sum(up) as total_ by ts | eval line=\"上行流量\" | append[[appname:ac tag:surfilter ac.event_type:statistic_traffic|eval down=tolong(ac.kv.down)  | bucket timestamp span=10m as ts |stats sum(down) as total_ by ts | eval line=\"下行流量\"  ]]"}
{"input": "每 10 分钟统计发卡方和受理方的最大耗时与平均耗时趋势。发卡方搜索条件为trancode字段值以UP1开头，受理方搜索条件为trancode字段值以 UP5 开头。。", "instruction": "查询银联前置(cupp)系统数据，进行如下统计", "output": "appname:cupp \"交易耗时\" trancode:UP1*| eval cost=tolong(cost)| bucket timestamp span=10m as ts| stats avg(cost) as _cost by ts| eval TYPE=\"平均耗时\"| eval type=\"发卡方\"| append [[  appname:cupp \"交易耗时\" trancode:UP1* | eval cost=tolong(cost) | bucket timestamp span=10m as ts | stats max(cost) as _cost by ts | eval TYPE=\"最大耗时\" | eval type=\"发卡方\" ]] | append [[   appname:cupp \"交易耗时\" trancode:UP5* | eval cost=tolong(cost) | bucket timestamp span=10m as ts | stats avg(cost) as _cost by ts | eval TYPE=\"平均耗时\" | eval type=\"受理方\" | append [[    appname:cupp \"交易耗时\" trancode:UP5*  | eval cost=tolong(cost)  | bucket timestamp span=10m as ts  | stats max(cost) as _cost by ts  | eval TYPE=\"最大耗时\"  | eval type=\"受理方\" ]]]]"}
{"input": "按每分钟分桶统计最大_最小_平均延时分析。", "instruction": "zookeeper日志数据，编写查询语句实现如下分析场景", "output": "appname:zookeeper tag:zookeeper_health | bucket timestamp span=1m as ts|stats avg(middleware.zkmsg.zk_avg_latency) as avg_ by ts|append [[appname:zookeeper tag:zookeeper_health | bucket timestamp span=1m as ts|stats avg(middleware.zkmsg.zk_max_latency) as max_ by ts]]|append [[appname:zookeeper tag:zookeeper_health | bucket timestamp span=1m as ts|stats avg(middleware.zkmsg.zk_min_latency) as min_ by ts]]"}
{"input": "按每30分钟分桶统计F5_URL访问字节数分析。索引可用字段有：loadbalancing.dst_ip, loadbalancing.level, loadbalancing.listenervs_ip, loadbalancing.msg, loadbalancing.querytype, loadbalancing.responsecode, loadbalancing.severity, loadbalancing.src.geo.province, loadbalancing.src_ip, loadbalancing.status, loadbalancing.type, loadbalancing.user, loadbalancing.username, loadblancing.status, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "F5数据，编写查询语句实现如下分析场景", "output": "appname:loadbalancing tag:f5 AND loadbalancing.type:logger\n|bucket timestamp span=30m as ts |eval a=loadbalancing.byte\n|stats min(a) as byte by ts,a\n|eval line=\"min_byte\"\n|append [[\n\tappname:loadbalancing AND loadbalancing.type:logger\n\t|bucket timestamp span=30m as ts |eval a=loadbalancing.byte\n\t|stats avg(a) as byte by ts,a\n\t|eval line=\"avg_byte\"]]\n|append [[\n\t\tappname:loadbalancing AND loadbalancing.type:logger\n\t|bucket timestamp span=30m as ts |eval a=loadbalancing.byte\n\t|stats max(a) as byte by ts,a\n\t|eval line=\"max_byte\"]]"}
{"input": "按每5分钟分桶统计功能请求排队等待趋势。", "instruction": "通达信数据，编写查询语句实现如下分析场景", "output": "appname:tdx NOT 连接信息 TDX.QUEUE:*  |  bucket timestamp span=5m as ts |  stats avg(TDX.QUEUE) as QUEUE  by ts | eval time=formatdate(ts,\"HH:mm\") | eval type=\"平均排队等待\" \n| append \n[[appname:tdx NOT 连接信息 TDX.QUEUE:*  |  bucket timestamp span=5m as ts |  stats max(TDX.QUEUE) as QUEUE  by ts | eval time=formatdate(ts,\"HH:mm\") | eval type=\"最大排队等待\"]]"}
{"input": "各设备交易量按小时对比发卡方和受理方趋势。", "instruction": "查询银联前置(cupp)系统数据，进行如下统计", "output": "appname:cupp \"收到报文\" trancode:UP1* | bucket timestamp span=1h as ts | stats dc(msgid) as cnt by ip,ts | eval type=\"发卡方\" | sort by ip | append [[ appname:cupp \"收到报文\" trancode:UP5* | bucket timestamp span=1h as ts | stats dc(msgid) as cnt by ip,ts | eval type=\"受理方\"  | sort by ip ]]"}
{"input": "功能请求响应时延趋势图，按平均延时和最大延时分组绘制折线图，X 轴为HH:mm格式。", "instruction": "通达信数据，编写查询语句实现如下分析场景", "output": "appname:tdx  TDX.RESPONSE_TIME_A:*  |  bucket timestamp span=20m as ts |  stats avg(TDX.RESPONSE_TIME_A) as RESPONSE_TIME  by ts | eval time=formatdate(ts,\"HH:mm\") | eval type=\"平均响应延时\" \n| append \n[[appname:tdx TDX.RESPONSE_TIME_A:*  |  bucket timestamp span=20m as ts |  stats max(TDX.RESPONSE_TIME_A) as RESPONSE_TIME  by ts | eval time=formatdate(ts,\"HH:mm\") | eval type=\"最大响应延时\"]]"}
{"input": "索引可用字段有：linux.cmd, linux.command, linux.event_detail.comm, linux.event_detail.exe, linux.event_detail.key, linux.event_detail.pid, linux.event_detail.ppid, linux.event_id, linux.event_msg.terminal, linux.event_name, linux.event_type, linux.log_type, linux.login_time, linux.msg, linux.pid, linux.result, linux.service_name, linux.src_ip, linux.status, linux.terminal, linux.type, linux.use_time, linux.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "Linux操作系统审计_su越权操作事件，包括 su 命令切换用户、用户退出两个操作，分别列出其时间、IP、用户名、操作事件和类型。时间转换为年月日时分秒的人类可读格式", "output": "appname:linux tag:secure  AND type:su AND \"session opened for\"  | eval action=\"su命令切换用户\"  | table ip,action,user,suuser,timestamp  | append [[ appname:linux tag:secure AND type:su AND \"session closed for\"  | eval action=\"用户退出\"  | table ip,action,user,timestamp ]]  | eval time=formatdate(timestamp,\"yyyy-MM-dd HH:mm:ss\")  | sort by +time | fields time,ip,user,suuser,action | rename time as \"时间\",ip as \"IP地址\",action as \"su动作\",user as \"用户\",suuser as \"执行用户\""}
{"input": "五元组。索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "天融信防火墙日志数据，编写查询语句实现如下分析场景", "output": "appname:firewall AND tag:topsec firewall.msg.rule:* \n| eval time=formatdate(timestamp,\"MM-dd HH:mm\") \n|table time,firewall.src_ip,firewall.src_port,firewall.dst_ip,firewall.dst_port,firewall.proto,firewall.msg.rule\n|eval action=if(empty(firewall.msg.rule),deny,firewall.msg.rule) \n|eval src=firewall.src_ip+\":\"+firewall.src_port \n|fields time,src,firewall.dst_ip,firewall.dst_port,firewall.proto,action\n|rename src as \"源地址：端口\",firewall.dst_ip as \"目的地址\",firewall.dst_port as \"目的端口\",firewall.proto as \"协议\",action as \"防火墙动作\"\n|append[[\n\tappname:firewall AND tag:topsec firewall.msg.rule:* \n\t| eval time=formatdate(timestamp,\"MM-dd HH:mm\") \n\t|table time,firewall.src_ip,firewall.src_port,firewall.dst_ip,firewall.dst_port,firewall.proto,firewall.msg.rule\n\t|eval action=if(empty(firewall.msg.rule),\"拒绝\",firewall.msg.rule) \n\t|eval src=firewall.src_ip+\":\"+firewall.src_port \n\t|fields time,src,firewall.dst_ip,firewall.dst_port,firewall.proto,action\n\t|rename src as \"源地址：端口\",firewall.dst_ip as \"目的地址\",firewall.dst_port as \"目的端口\",firewall.proto as \"协议\",action as \"防火墙动作\"]]"}
{"input": "资产总数量。索引可用字段有：windows.EventData.Data, windows.IpAddress, windows.System.EventID.text, windows.System.Level, windows.System.Provider.Name, windows.event_type, windows.level, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "安全态势数据，编写查询语句实现如下分析场景", "output": "* AND (('appname':waf) OR ('appname':firewall) OR ('appname':ips))|stats dc(hostname) as cnt by appname,tag|rename appname as \"设备名\",tag as \"品牌\",cnt as \"数量\"|append [[* AND (('appname':apache) OR ('appname':middleware) OR ('appname':tomcat)) |stats dc(ip) as cnt by appname,tag|rename appname as \"设备名\",tag as \"品牌\",cnt as \"数量\"]]|append [[* AND (('appname':linux) OR ('appname':windows) OR ('appname':aix))|stats dc(ip) as cnt by appname|rename appname as \"设备名\",cnt as \"数量\"]]"}
{"input": "分支机构时延分析。", "instruction": "lingcloud流量数据，编写查询语句实现如下分析场景", "output": "appname:lingcloud AND tag:kpi_permin_site utc |stats avg(lingcloud.data.RTT) as cnt by lingcloud.siteid|eval line=\"总网络延时\" |append [[appname:lingcloud AND tag:kpi_permin_site utc |stats avg(lingcloud.data.transRespTime) as cnt by lingcloud.siteid|eval line=\"应用响应时间\"]]|lookup sitename dclingcloud_site.csv on lingcloud.siteid=siteid|where !empty(sitename)"}
{"input": "会话关闭详情。索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "华为防火墙日志数据，编写查询语句实现如下分析场景", "output": "(appname:firewall AND tag:huawei) firewall.src_ip:* |rename firewall.* as *|rename msg.* as * | table proto,'安全策略','带宽策略','上行流量','下行流量','总流量','入接口','出接口','会话关闭原因','虚拟系统'|append[[(appname:firewall AND tag:huawei) firewall.src_ip:*   | table firewall.proto,firewall.msg.PolicyName,firewall.msg.SendBytes,firewall.msg.RcvBytes,firewall.msg.CloseReason|rename firewall.* as * |rename msg.* as *]]"}
{"input": "前 20 家分支机构速率分析。", "instruction": "lingcloud流量数据，编写查询语句实现如下分析场景", "output": "appname:lingcloud AND tag:kpi_permin_site utc |stats avg(lingcloud.data.totalBytes) as cnt by lingcloud.siteid|eval line=\"平均速率\"|sort by cnt|limit 20 |append [[appname:lingcloud AND tag:kpi_permin_site utc |stats sum(lingcloud.data.totalBytes) as cnt by lingcloud.siteid|eval line=\"峰值速率\"]]|lookup sitename dclingcloud_site.csv on lingcloud.siteid=siteid|where !empty(sitename)"}
{"input": "", "instruction": "关联 CDN 日志 和 nginx 日志，查询来自 223.74.12.16 的请求，列出其请求时间和请求 URL", "output": "appname:nginx_log AND nginx.real_ip.last:\"223.74.12.16\" | rename nginx.request_raw.request_url as \"URL\" | fields timestamp, URL | append [[ appname:cdn_log AND cdn.remote_addr:\"223.74.12.16\" | rename cdn.request_url as \"URL\" | fields timestamp, URL ]]"}
{"input": "发送_接收速率。", "instruction": "zookeeper日志数据，编写查询语句实现如下分析场景", "output": "appname:zookeeper tag:zookeeper_health |sort by +timestamp| table timestamp,middleware.zkmsg.zk_packets_sent|autoregress middleware.zkmsg.zk_packets_sent 1|where middleware.zkmsg.zk_packets_sent_p1>0|eval cnt=middleware.zkmsg.zk_packets_sent-middleware.zkmsg.zk_packets_sent_p1|eval time=tolong(timestamp)|eval line=\"发送\"|append [[appname:zookeeper tag:zookeeper_health |sort by +timestamp| table timestamp,middleware.zkmsg.zk_packets_received|autoregress middleware.zkmsg.zk_packets_received 1|where middleware.zkmsg.zk_packets_received_p1>0|eval cnt=middleware.zkmsg.zk_packets_received-middleware.zkmsg.zk_packets_received_p1|eval time=tolong(timestamp)|eval line=\"接收\"]]"}
{"input": "堆内存使用量变化趋势。计算方法如下：1. 查找2020-04-21 16:00 到 2020-04-21 17:00 时间范围内,appname 为 gc 的日志\n2. 计算 gc.beforeEden 字段的值,并 convert 到 MB,作为 Eden 列的值,标记为 beforeEden 行\n3. 计算 gc.afterEden 字段的值,并 convert 到 MB,作为 Eden 列的值,标记为 afterEden 行\n4. 计算 gc.totalnewgeneration 字段的值,并 convert 到 MB,作为 Eden 列的值,标记为 MAXEden 行\n5. 计算 gc.beforeOld 字段的值,并 convert 到 MB,作为 Eden 列的值,标记为 beforeJVM 行\n6. 计算 gc.afterOld 字段的值,并 convert 到 MB,作为 Eden 列的值,标记为 afterJVM 行\n7. 计算 gc.totalOld 字段的值,并 convert 到 MB,作为 Eden 列的值,标记为 MAXJVM 行\n8. 标记一行 FULL_GC,Eden 列值为 6\n9. 最后使用 table 命令输出 timestamp 和 Eden 两列,以及 line 行标记。索引可用字段有：gc.beforeEden, gc.invocations, gc.stoptime, gc.totalnewgeneration, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "jdk_gc数据，编写查询语句实现如下分析场景", "output": "appname:gc AND gc.beforeEden:*|eval Eden=todouble(gc.beforeEden)/1024/1024|table timestamp,Eden|eval line=\"beforeEden\"|append[[starttime=2020-04-21:16:00:00 endtime=2020-04-21:17:00:00 appname:gc AND gc.beforeEden:*|eval Eden=todouble(gc.afterEden)/1024/1024|table timestamp,Eden|eval line=\"afterEden\"]]|append[[starttime=2020-04-21:16:00:00 endtime=2020-04-21:17:00:00 appname:gc AND gc.totalnewgeneration:*|eval Eden=todouble(gc.totalnewgeneration)/1024/1024|table timestamp,Eden|eval line=\"MAXEden\"]]|append[[starttime=2020-04-21:16:00:00 endtime=2020-04-21:17:00:00 appname:gc AND gc.beforeEden:*|eval Eden=todouble(gc.beforeOld)/1024/1024|table timestamp,Eden|eval line=\"beforeJVM\"]]|append[[starttime=2020-04-21:16:00:00 endtime=2020-04-21:17:00:00 appname:gc AND gc.beforeEden:*|eval Eden=todouble(gc.afterOld)/1024/1024|table timestamp,Eden|eval line=\"afterJVM\"]]|append[[starttime=2020-04-21:16:00:00 endtime=2020-04-21:17:00:00 appname:gc AND gc.beforeEden:*|eval Eden=todouble(gc.totaOldl)/1024/1024|table timestamp,Eden|eval line=\"MAXJVM\"]]|append[[starttime=2020-04-21:16:00:00 endtime=2020-04-21:17:00:00 appname:gc AND gc.beforeEden:*|eval Eden=6|table timestamp,Eden|eval line=\"FULL_GC\"]]"}
{"input": "交易操作记录明细。索引可用字段有：ths_all.ANSTYPE, ths_all.GDZH, ths_all.funccn, ths_all.msg, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "同花顺日志数据，编写查询语句实现如下分析场景", "output": "appname:ths_all tag:ths_all NOT (ths_all.ANSTYPE:1 OR  ths_all.ANSTYPE:0)|eval aaa=formatdate(timestamp)| table aaa,ths_all.GDZH,ths_all.funccn,context_id|eval line=\"请求\"\n |append\n [[\n appname:ths_all tag:ths_all  (ths_all.ANSTYPE:1 OR  ths_all.ANSTYPE:0)|eval aaa=formatdate(timestamp)| table aaa,ths_all.ANSTYPE,ths_all.GDZH,ths_all.funccn,ths_all.msg,context_id\t|eval line=\"返回\"\n ]]\n|eval bbb=case(ths_all.ANSTYPE==\"1\",\"成功\",ths_all.ANSTYPE==\"0\",\"失败\",default,\"\")\n|sort by +aaa,+context_id\t|fields aaa,ths_all.GDZH,ths_all.funccn,bbb,line,ths_all.msg\n|rename aaa as \"时间\"\n|rename ths_all.GDZH as \"股东账号\"\n|rename ths_all.funccn as \"功能类型\"\n|rename bbb as \"返回状态\"\n|rename ths_all.msg as \"返回内容\"\n|rename line as \"操作类型\"\n"}
{"input": "交易量。", "instruction": "查询银联前置(cupp)系统数据，进行如下统计", "output": "appname:cupp \"收到报文\"| stats dc(msgid) as cnt| eval type=\"总交易量\"| append [[ appname:cupp \"收到报文\" trancode:UP1* | stats dc(msgid) as cnt | eval type=\"发卡方\"]]| append [[ appname:cupp \"处理完成\" trancode:UP5* JYLS_FD_INFO5:* | stats dc(msgid) as cnt | eval type=\"受理方\"]]"}
{"input": "各设备统计发卡方和受理方收到报文的交易量。", "instruction": "查询银联前置(cupp)系统数据，进行如下统计", "output": "appname:cupp \"收到报文\" trancode:UP1* | stats dc(msgid) as cnt by ip | eval type=\"发卡方\" | sort by ip | append [[ appname:cupp \"收到报文\" trancode:UP5* | stats dc(msgid) as cnt by ip | eval type=\"受理方\" | sort by ip]]"}
{"input": "最大交易耗时。", "instruction": "查询银联前置(cupp)系统数据，进行如下统计", "output": "appname:cupp trancode:UP1* \"交易耗时\"|eval a=tolong(cost)| stats max(a) as _max| eval type=\"发卡方\"| append [[ appname:cupp trancode:UP5* \"交易耗时\" |eval a=tolong(cost) | stats max(a) as _max | eval type=\"受理方\"]]"}
{"input": "平均耗时。", "instruction": "查询银联前置(cupp)系统数据，进行如下统计", "output": "appname:cupp trancode:UP1* \"交易耗时\"|eval a=tolong(cost)| stats avg(a) as _avg| eval type=\"发卡方\"| append [[ appname:cupp trancode:UP5* \"交易耗时\" |eval a=tolong(cost) | stats avg(a) as _avg | eval type=\"受理方\"]]"}
{"input": "h3c_imc_各类事件占比。索引可用字段有：imc.desc, imc.event_level, imc.level, imc.message, imc.src_ip, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "h3c_imc_数据，编写查询语句实现如下分析场景", "output": "appname:imc  |stats count() as cnt by imc.level|rename imc.level as level |append[[appname:imc AND |stats count() as cnt by imc.event_level|rename imc.event_level as level]]"}
{"input": "zeek与apm关联。具体方案如下：1. 首先搜索appname=npm的日志,统计grg.src_ip和grg.dst_ip的计数,并重命名grg.dst_ip为host\n2. 然后在host字段上join搜索appname=apm的日志,统计grg.src_ip的计数,并重命名grg.src_ip为host\n3. 重命名grg.src_ip为from,host为to,连接两组日志\n4. 重复1-3,加入grg.host.hostname作为join字段\n5. 重复1-4,加入grg.process.title作为join字段\n6. 重复1-5,加入grg.process.pid作为join字段\n7. 连接所有日志,from表示源IP/主机/进程/PID,to表示目的IP/主机/进程/PID,实现从npm日志到apm日志的追踪。", "instruction": "广电运通关联数据，编写查询语句实现如下分析场景", "output": "*  appname:npm grg.src_ip:*\n| stats count() as cnt by grg.src_ip,grg.dst_ip \n|rename grg.dst_ip as host\n|join type=inner host[[\n *   appname:apm\n | stats count() as cnt by grg.src_ip\n |rename grg.src_ip as host]]\n|rename grg.src_ip as from,host as to\n|append[[\n  * AND  appname:npm grg.src_ip:*\n | stats count() as cnt by grg.src_ip,grg.dst_ip \n |rename grg.dst_ip as host\n |join type=inner host[[\n   *   appname:apm\n  | stats count() as cnt by grg.src_ip,grg.host.hostname\n  |rename grg.src_ip as host]]\n |rename host as from,grg.host.hostname as to]]\n|append[[\n    *   appname:npm grg.src_ip:*\n | stats count() as cnt by grg.src_ip,grg.dst_ip \n |rename grg.dst_ip as host\n |join type=inner host[[\n     *   appname:apm\n  | stats count() as cnt by grg.src_ip,grg.host.hostname,grg.process.title\n  |rename grg.src_ip as host]]\n |rename grg.process.title as to,grg.host.hostname as from]]\n|append[[\n      *   appname:npm grg.src_ip:*\n | stats count() as cnt by grg.src_ip,grg.dst_ip \n |rename grg.dst_ip as host\n |join type=inner host[[\n       *   appname:apm\n  | stats count() as cnt by grg.src_ip,grg.host.hostname,grg.process.title,grg.process.pid\n  |rename grg.src_ip as host]]\n |rename grg.process.title as from,grg.process.pid as to]]"}
{"input": "按每小时分桶统计cisco_ios认证趋势。索引可用字段有：switch.IP, switch.action, switch.auth_method, switch.bandwidth, switch.brief, switch.cmd, switch.count, switch.desc, switch.desc.cmd, switch.desc.user, switch.describe, switch.ethernet, switch.event_type, switch.facility, switch.host, switch.host_ip, switch.interface_name, switch.ip, switch.kv.COMMAND, switch.kv.TTY, switch.kv.USER, switch.kvmsg.IpAddress, switch.kvmsg.UserName, switch.level, switch.log_message, switch.log_type, switch.login_method, switch.mode, switch.module, switch.port, switch.port_channel, switch.reason, switch.result, switch.severity, switch.speed, switch.src_ip, switch.src_mac, switch.state, switch.terminal, switch.time, switch.user, switch.vlan, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "交换机_cisco_ios数据，编写查询语句实现如下分析场景", "output": "appname:switch tag:cisco_ios  AND Authentication successful |bucket timestamp span=1h as ts| stats count() as count_ by ts|rename count_ as \"认证次数\"|eval line=\"认证成功\" | append [[appname:switch tag:cisco_ios  AND Authentication failed |bucket timestamp span=1h as ts| stats count() as count_ by ts|rename count_ as \"认证次数\"|eval line=\"认证失败\"]]"}
{"input": "按每小时分桶统计cisco_ios授权趋势。索引可用字段有：switch.IP, switch.action, switch.auth_method, switch.bandwidth, switch.brief, switch.cmd, switch.count, switch.desc, switch.desc.cmd, switch.desc.user, switch.describe, switch.ethernet, switch.event_type, switch.facility, switch.host, switch.host_ip, switch.interface_name, switch.ip, switch.kv.COMMAND, switch.kv.TTY, switch.kv.USER, switch.kvmsg.IpAddress, switch.kvmsg.UserName, switch.level, switch.log_message, switch.log_type, switch.login_method, switch.mode, switch.module, switch.port, switch.port_channel, switch.reason, switch.result, switch.severity, switch.speed, switch.src_ip, switch.src_mac, switch.state, switch.terminal, switch.time, switch.user, switch.vlan, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "交换机_cisco_ios数据，编写查询语句实现如下分析场景", "output": "appname:switch tag:cisco_ios  AND Authorization succeeded |bucket timestamp span=1h as ts| stats count() as count_ by ts|rename count_ as \"授权次数\"|eval line=\"授权成功\" | append [[appname:switch tag:cisco_ios  AND Authorization failed |bucket timestamp span=1h as ts| stats count() as count_ by ts|rename count_ as \"授权次数\"|eval line=\"授权失败\"]]"}
{"input": "按每小时分桶统计登录趋势。索引可用字段有：switch.IP, switch.action, switch.auth_method, switch.bandwidth, switch.brief, switch.cmd, switch.count, switch.desc, switch.desc.cmd, switch.desc.user, switch.describe, switch.ethernet, switch.event_type, switch.facility, switch.host, switch.host_ip, switch.interface_name, switch.ip, switch.kv.COMMAND, switch.kv.TTY, switch.kv.USER, switch.kvmsg.IpAddress, switch.kvmsg.UserName, switch.level, switch.log_message, switch.log_type, switch.login_method, switch.mode, switch.module, switch.port, switch.port_channel, switch.reason, switch.result, switch.severity, switch.speed, switch.src_ip, switch.src_mac, switch.state, switch.terminal, switch.time, switch.user, switch.vlan, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "交换机_华为数据，编写查询语句实现如下分析场景", "output": "appname:switch tag:huawei (switch.brief:LOGIN_OK OR \"succeeded in logging in\" OR switch.brief:LOGINOK) |bucket timestamp span=1h as ts| stats count() as count_ by ts|rename count_ as \"登录次数\"|eval line=\"登录成功\" | append [[appname:switch tag:huawei_S12700 ( (switch.brief:LOGINFAILED OR switch.brief: LOGINFAIL OR switch.brief:LOGINFAILED OR switch.brief:LOGIN_FAIL OR switch.brief:SNMP_FAIL OR switch.brief:SSH_FAIL) ) |bucket timestamp span=1h as ts| stats count() as count_ by ts|rename count_ as \"登录次数\"|eval line=\"登录失败\" ]]"}
{"input": "按每小时分桶分别统计特征码、关联、特征模型三种攻击类型和攻击事件总量的趋势，时间戳改为HH:mm格式，然后 append 在一起进行对比。索引可用字段有：waf.action, waf.attack_name, waf.attack_type, waf.bytes_in, waf.cost, waf.cve_id, waf.dst_city, waf.dst_domain, waf.dst_ip, waf.dst_latitude, waf.dst_longitude, waf.dst_port, waf.error_msg, waf.event_level, waf.event_log_level, waf.event_name, waf.event_type, waf.http_method, waf.http_refer, waf.is_truncated, waf.kv.Evt_level, waf.kv.Evt_type, waf.kv.event_name, waf.kv.http_method, waf.kv.http_refer, waf.kv.http_url, waf.kv.msg, waf.kv.owasp_top, waf.kv.pri, waf.kv.severity_level, waf.kv.status, waf.kv.type, waf.level, waf.log_category, waf.message, waf.message.action, waf.message.event, waf.message.method, waf.message.policy, waf.message.src_ip.geo.ip, waf.message.src_ip.geo.province, waf.message.src_port, waf.message.status, waf.message.threaten, waf.method, waf.module, waf.msg.act, waf.msg.cs, waf.msg.policy_id, waf.msg.src.geo.country, waf.policy_name, waf.proto, waf.referer, waf.risk_level, waf.severity, waf.src.geo.city, waf.src.geo.country, waf.src.geo.ip, waf.src.geo.isp, waf.src.geo.latitude, waf.src.geo.longitude, waf.src.geo.province, waf.src_ip, waf.src_port, waf.status, waf.status_code, waf.threat_level, waf.time, waf.ua_browser, waf.ua_device, waf.ua_os, waf.uri, waf.url, waf.user_agent.browser, waf.user_agent.os, waf.website_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "Imperva_waf数据，编写查询语句实现如下分析场景", "output": "appname:waf  tag:imperva |bucket timestamp span=1h as ts |stats count() by ts | eval hour = formatdate(ts, \"HH:mm\") | eval d=\"事件总量\" |append [[appname:waf  tag:imperva AND waf.attack_type:特征码 |bucket timestamp span=1h as ts |stats count() by ts | eval hour = formatdate(ts, \"HH:mm\") | eval d=\"特征码\"]] |append [[appname:waf AND waf.attack_type:关联 |bucket timestamp span=1h as ts |stats count() by ts | eval hour = formatdate(ts, \"HH:mm\") | eval d=\"关联\"]] |append [[appname:waf AND waf.attack_type:特征模型 |bucket timestamp span=1h as ts |stats count() by ts | eval hour = formatdate(ts, \"HH:mm\") | eval d=\"特征模型\"]]"}
{"input": "按每30分钟分桶统计PaloAlto的 TRAFFIC 流量事件、THREAT 猥亵事件、SYSTEM 系统时间三类事件数的趋势和事件总数的趋势，将时间戳改为 HH:mm 格式后，append 在一起进行对比。索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "FirewallPaloAlto数据，编写查询语句实现如下分析场景", "output": "appname:firewall tag:paloalto |bucket timestamp span=30m as ts |stats count() by ts | eval hour = formatdate(ts, \"HH:mm\") | eval d=\"事件总量\" |append [[appname:firewall  tag:paloalto AND firewall.type:TRAFFIC |bucket timestamp span=30m as ts |stats count() by ts | eval hour = formatdate(ts, \"HH:mm\") | eval d=\"流量事件\"]] |append [[appname:firewall tag:paloalto AND firewall.type:THREAT |bucket timestamp span=30m as ts |stats count() by ts | eval hour = formatdate(ts, \"HH:mm\") | eval d=\"威胁事件\"]] |append [[appname:firewall tag:paloalto AND firewall.type:SYSTEM |bucket timestamp span=30m as ts |stats count() by ts | eval hour = formatdate(ts, \"HH:mm\") | eval d=\"系统事件\"]]"}
{"input": "按每30分钟分桶统计发现病毒变化趋势。", "instruction": "防病毒_SEPM数据，编写查询语句实现如下分析场景", "output": "appname:antivirus_gateway tag:symantec  \"发现病毒\" |bucket timestamp span=30m as ts | stats count() as total by 'antivirus_gateway.msg.风险名称',ts|append[[appname:antivirus_gateway AND ( tag:symantec OR tag:symantec_app_c OR tag:symantec_risk ) \"发现病毒\"|bucket timestamp span=30m as ts | stats count() as total by antivirus_gateway.risk_name,ts]]|append[[appname:antivirus_gateway tag:symantec  \"发现病毒\" |bucket timestamp span=30m as ts | stats count() as total by 'antivirus_gateway.msg.应用类型',ts]]|rename antivirus_gateway.risk_name as risk_name,'antivirus_gateway.msg.风险名称' as risk_name,'antivirus_gateway.msg.应用类型' as risk_name"}
{"input": "按每30分钟分桶统计中间件今日各类错误事件趋势。索引可用字段有：middleware.Error_info, middleware.System_errinfo, middleware.System_errno, middleware.actconn, middleware.action, middleware.backend_queue, middleware.beconn, middleware.clientip, middleware.desc, middleware.dst_ip, middleware.error_level, middleware.error_no, middleware.event_name, middleware.event_type, middleware.feconn, middleware.func_no, middleware.geo.city, middleware.geo.isp, middleware.geo.province, middleware.http_hostname, middleware.http_method, middleware.http_referer, middleware.http_user_agent.browser, middleware.http_user_agent.os, middleware.level, middleware.message, middleware.method, middleware.middleware.nursery_free_after, middleware.module, middleware.msg, middleware.nursery_free_before, middleware.nursery_total, middleware.referer, middleware.referrer, middleware.req_time, middleware.request, middleware.request_method, middleware.request_path, middleware.request_status, middleware.response, middleware.response_code, middleware.retries, middleware.rsp, middleware.server, middleware.severity, middleware.src.geo.country, middleware.src.geo.isp, middleware.src_ip, middleware.src_ip.geo.city, middleware.srv_conn, middleware.srv_queue, middleware.status, middleware.subsystem, middleware.tc, middleware.tenure_free_after, middleware.tenure_free_before, middleware.thread, middleware.tt, middleware.tw, middleware.type, middleware.ua.browser, middleware.ua.device, middleware.ua.os, middleware.uri_query, middleware.uri_stem, middleware.url, middleware.zkmsg.zk_followers, middleware.zkmsg.zk_packets_received, middleware.zkmsg.zk_packets_sent, middleware.zkmsg.zk_server_state, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "安全态势数据，编写查询语句实现如下分析场景", "output": "starttime=\"now/d\" appname:middleware middleware.status:>399 |bucket timestamp span=30m as ts |stats count() as cnt by ts |eval line=\"全部请求错误事件\"| append [[starttime=\"now/d\" (appname:middleware middleware.status:>399 AND middleware.status:<500)|bucket timestamp span=30m as ts |stats count() as cnt  by ts|eval line=\"客户端错误事件\"]] | append [[starttime=\"now/d\" (appname:middleware middleware.status:>499) |bucket timestamp span=30m as ts |stats count() as cnt by ts|eval line=\"服务端错误事件\"]]"}
{"input": "天融信防火墙登入登出趋势。索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "天融信防火墙日志数据，编写查询语句实现如下分析场景", "output": "appname:firewall AND tag:topsec (AUTH) |bucket timestamp span=5m as ts |stats count() as cnt by ts,firewall.msg.op|rename firewall.msg.op as op|append[[ appname:firewall AND tag:topsec firewall.msg.method:* |bucket timestamp span=5m as ts |stats count() as cnt by ts,firewall.msg.description|rename firewall.msg.description as op]]"}
{"input": "PaloAlto_流量、威胁和系统事件的趋势，按 HH:mm 对比每 30 分钟的事件数。索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "FirewallPaloAlto数据，编写查询语句实现如下分析场景", "output": "appname:firewall tag:paloalto |bucket timestamp span=30m as ts |stats count() by ts | eval hour = formatdate(ts, \"HH:mm\") | eval d=\"事件总量\" |append [[appname:firewall  tag:paloalto AND firewall.type:TRAFFIC |bucket timestamp span=30m as ts |stats count() by ts | eval hour = formatdate(ts, \"HH:mm\") | eval d=\"流量事件\"]] |append [[appname:firewall tag:paloalto AND firewall.type:THREAT |bucket timestamp span=30m as ts |stats count() by ts | eval hour = formatdate(ts, \"HH:mm\") | eval d=\"威胁事件\"]] |append [[appname:firewall tag:paloalto AND firewall.type:SYSTEM |bucket timestamp span=30m as ts |stats count() by ts | eval hour = formatdate(ts, \"HH:mm\") | eval d=\"系统事件\"]]"}
{"input": "cisco_ios认证和授权失败分析。索引可用字段有：switch.IP, switch.action, switch.auth_method, switch.bandwidth, switch.brief, switch.cmd, switch.count, switch.desc, switch.desc.cmd, switch.desc.user, switch.describe, switch.ethernet, switch.event_type, switch.facility, switch.host, switch.host_ip, switch.interface_name, switch.ip, switch.kv.COMMAND, switch.kv.TTY, switch.kv.USER, switch.kvmsg.IpAddress, switch.kvmsg.UserName, switch.level, switch.log_message, switch.log_type, switch.login_method, switch.mode, switch.module, switch.port, switch.port_channel, switch.reason, switch.result, switch.severity, switch.speed, switch.src_ip, switch.src_mac, switch.state, switch.terminal, switch.time, switch.user, switch.vlan, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "交换机_cisco_ios数据，编写查询语句实现如下分析场景", "output": "appname:switch tag:cisco_ios  AND fail |stats count() by switch.log_type,switch.log_message |rename switch.log_type as from,switch.log_message as to |append [[appname:switch tag:cisco_ios  AND fail |stats count() by switch.log_message,switch.src_mac |rename switch.log_message  as from,switch.src_mac as to]] |append [[appname:switch tag:cisco_ios  AND fail |stats count() by switch.src_mac,switch.interface_name |rename switch.src_mac as from,switch.interface_name as to]]"}
{"input": "堡垒机登陆(pldrun)。索引可用字段有：fortress.action, fortress.dst_ip, fortress.facility, fortress.host_ip, fortress.input, fortress.ip, fortress.level, fortress.log_type, fortress.loginOK, fortress.login_user, fortress.message, fortress.msg.action, fortress.msg.adlg_type, fortress.msg.begin_time, fortress.msg.command, fortress.msg.date, fortress.msg.mode, fortress.msg.module, fortress.msg.session_guid, fortress.msg.src_ip, fortress.msg.srcip, fortress.msg.srvaddr, fortress.msg.system_user, fortress.msg.sysuser, fortress.node, fortress.protocol, fortress.reason, fortress.remote_addr, fortress.request_msg, fortress.result, fortress.secondary_user, fortress.server, fortress.severity, fortress.src_ip, fortress.src_port, fortress.status, fortress.system_user, fortress.type, fortress.user, fortress.user_agent, fortress.user_name, fortress.username, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "帕拉迪堡垒机数据，编写查询语句实现如下分析场景", "output": "( appname:fortress tag:pldsec ) \"BLJPri pldrun\"|stats count() as ct by fortress.user,fortress.src_ip|rename fortress.user as from,fortress.src_ip as to|append [[( appname:fortress tag:pldsec ) \n \"BLJPri pldrun\"|stats count() as ct by fortress.src_ip,fortress.system_user|rename fortress.src_ip as from,fortress.secondary_user as to]]|append [[( appname:fortress tag:pldsec ) \"BLJPri pldrun\" |stats count() as ct by fortress.secondary_user,fortress.dst_ip|rename fortress.secondary_user as from,fortress.dst_ip as to]]"}
{"input": "堡垒机登陆_UMA。索引可用字段有：fortress.action, fortress.dst_ip, fortress.facility, fortress.host_ip, fortress.input, fortress.ip, fortress.level, fortress.log_type, fortress.loginOK, fortress.login_user, fortress.message, fortress.msg.action, fortress.msg.adlg_type, fortress.msg.begin_time, fortress.msg.command, fortress.msg.date, fortress.msg.mode, fortress.msg.module, fortress.msg.session_guid, fortress.msg.src_ip, fortress.msg.srcip, fortress.msg.srvaddr, fortress.msg.system_user, fortress.msg.sysuser, fortress.node, fortress.protocol, fortress.reason, fortress.remote_addr, fortress.request_msg, fortress.result, fortress.secondary_user, fortress.server, fortress.severity, fortress.src_ip, fortress.src_port, fortress.status, fortress.system_user, fortress.type, fortress.user, fortress.user_agent, fortress.user_name, fortress.username, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "帕拉迪堡垒机数据，编写查询语句实现如下分析场景", "output": "( appname:fortress tag:pldsec ) \"BLJPri UMA\" type=login|stats count() as ct by fortress.msg.src_ip,fortress.msg.system_user|rename fortress.msg.src_ip as from,fortress.msg.system_user as to|append [[( appname:fortress tag:pldsec ) \"BLJPri UMA\" type=login|stats count() as ct by fortress.msg.system_user,fortress.msg.module|rename fortress.msg.system_user as from,fortress.msg.module as to]]|append [[( appname:fortress tag:pldsec ) \"BLJPri UMA\" type=login|parse \"result=(?<result>\\w+)\"|stats count() as ct by fortress.msg.module,result|rename fortress.msg.module as from,result as to]]"}
{"input": "病毒类型分类。", "instruction": "防病毒_SEPM数据，编写查询语句实现如下分析场景", "output": "appname:antivirus_gateway tag:symantec  \"发现病毒\" |stats count() as total by 'antivirus_gateway.msg.类别类型' | append[[appname:antivirus_gateway AND ( tag:symantec OR tag:symantec_app_c OR tag:symantec_risk )   \"发现病毒\" |stats count() as total by 'antivirus_gateway.类别类型']] |append[[appname:antivirus_gateway tag:symantec  \"发现病毒\" |stats count() as total by 'antivirus_gateway.msg.应用类型' ]]| rename 'antivirus_gateway.msg.类别类型' as event_type ,'antivirus_gateway.类别类型' as event_type,'antivirus_gateway.msg.应用类型' as event_type"}
{"input": "病毒的操作分类。", "instruction": "防病毒_SEPM数据，编写查询语句实现如下分析场景", "output": "appname:antivirus_gateway tag:symantec  \"发现病毒\" \n|stats count() as total by 'antivirus_gateway.msg.实际的操作' \n| append[[\n\tappname:antivirus_gateway AND ( tag:symantec OR tag:symantec_app_c OR tag:symantec_risk )   \"发现病毒\" \n\t|stats count() as total by 'antivirus_gateway.实际的操作']] \n| rename 'antivirus_gateway.msg.实际的操作' as action ,'antivirus_gateway.实际的操作' as action"}
{"input": "策略触发域分布。", "instruction": "防病毒_SEPM数据，编写查询语句实现如下分析场景", "output": "* appname:antivirus_gateway tag:symantec  \"规则\" | stats count() as total by 'antivirus_gateway.rulekv.域'|append[[appname:antivirus_gateway AND ( tag:symantec OR tag:symantec_app_c OR tag:symantec_risk )| stats count() as total by 'antivirus_gateway.域']]|append[[* appname:antivirus_gateway tag:symantec  \"规则\" | stats count() as total by 'antivirus_gateway.domain']]|rename 'antivirus_gateway.rulekv.域' as domain,'antivirus_gateway.域' as domain,'antivirus_gateway.domain' as domain"}
{"input": "天融信防火墙配置变更描述排名。索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "天融信防火墙日志数据，编写查询语句实现如下分析场景", "output": "appname:firewall AND tag:topsec config |stats count() as cnt by firewall.msg.msg|rename firewall.msg.msg as msg |append[[appname:firewall AND tag:topsec config |stats count() as cnt by firewall.msg.command|rename firewall.msg.command as msg]]"}
{"input": "飞塔IPS检测攻击三级桑基图，统计来源地址、目的地址、目的端口和攻击类型，依次重命名为 from 和 to。索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "防火墙_飞塔数据，编写查询语句实现如下分析场景", "output": "appname:firewall tag:fortinet  AND firewall.subtype:ips\n| stats count() as _count by firewall.src_ip,firewall.dst_ip,firewall.dst_port,firewall.attack\n|rename firewall.src_ip as from,firewall.attack as to\n| append [[\n\tappname:firewall tag:fortinet AND firewall.subtype:ips\n\t| stats count() as _count by firewall.src_ip,firewall.dst_ip,firewall.dst_port,firewall.attack\n\t|rename firewall.attack as from,firewall.dst_ip as to\n]]\n| append [[\n\tappname:firewall tag:fortinet AND firewall.subtype:ips\n\t| stats count() as _count by firewall.src_ip,firewall.dst_ip,firewall.dst_port,firewall.attack\n\t|rename firewall.dst_ip as from,firewall.dst_port as to\n]]"}
{"input": "流用户数。索引可用字段有：stb_vixtel_sotthas.district, stb_vixtel_sotthas.downloadTime, stb_vixtel_sotthas.freezeTime, stb_vixtel_sotthas.geo.city, stb_vixtel_sotthas.geo.province, stb_vixtel_sotthas.hasQoE, stb_vixtel_sotthas.programName, stb_vixtel_sotthas.stbId, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "机顶盒数据，编写查询语句实现如下分析场景", "output": "appname:stb_vixtel_sotthas |stats count() by stb_vixtel_sotthas.stbId\n|rename stb_vixtel_sotthas.stbId as stbId\n|append\n[[\nappname:stb_vixtel_smpegts |stats count() by stb_vixtel_smpegts.stbId\n|rename stb_vixtel_smpegts.stbId as stbId\n]]\n\n|stats count(stbId) as count_dc by stbId\n|stats count() as count_1 "}
{"input": "交易流程按模块分析。索引可用字段有：gaps.duration, gaps.pub.hostname, gaps.pub.jydm, gaps.pub.respmsg, gaps.pub.subsysname, gaps.req.dkye, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "综合前置_gaps数据，编写查询语句实现如下分析场景", "output": "appname:gaps gaps.pub.respmsg:*  |stats count() as tally by gaps.pub.hostname,gaps.pub.jydm |rename gaps.pub.hostname as src,gaps.pub.jydm  as dst \n|append \n[[\nappname:gaps gaps.pub.respmsg:*  |stats count() as tally by gaps.pub.jydm,gaps.pub.subsysname |rename gaps.pub.jydm as src,gaps.pub.subsysname  as dst\n]]\n|append \n[[\nappname:gaps gaps.pub.respmsg:*  |stats count() as tally by gaps.pub.subsysname,gaps.pub.respmsg |rename gaps.pub.subsysname as src,gaps.pub.respmsg  as dst\n]] "}
{"input": "1. 取出logtype为vpn,动作类型为login,结果为failure的日志,标记为“疑似暴力破解”,统计每个用户名的失败登录次数,根据次数生成aaa字段用于风险级别。\n2. 取出logtype为vpn,动作类型为login,源IP所在城市出现2次以上的日志,标记为“疑似账号共用”,根据城市出现次数生成aaa字段。\n3. 取出logtype为vpn,动作类型为login,源IP不在中国和私有IP范围,标记为“账号登录异常”,根据源IP出现次数生成aaa字段。\n4. 取出logtype为vpn,动作类型为login,登录时间在晚上6点到早上8点,标记为“异常时间登录”,根据出现次数生成aaa字段。\n5. 取出logtype为vpn,动作类型为access resource,结果不为success的第一条日志,标记为“异常访问系统”,生成aaa字段。\n6. 将上述5种情况下的用户名,风险事件类型进行合并,生成最后的结果表,包含“用户名”和“存在的可疑操作”两列。\n7. mvcombine指令用于将app1字段中的多个风险事件类型合并为一个字段,中间用“/”分割。。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "VPN用户可疑操作明细", "output": "appname:vpn vpn.login_user:* vpn.actype:login vpn.result:failure  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,0,cnt==2,10,cnt==3,15,cnt>4,20,default,20) |append [[ appname:vpn vpn.login_user:*  vpn.actype:login  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==2,10,cnt>=3,20,default,20) ]] |append [[ appname:vpn vpn.login_user:*  vpn.actype:login  (NOT vpn.src_ip.geo.country:private)   (NOT vpn.src_ip.geo.country:中国)  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,15,cnt>=4,20,default,20) ]] |append [[ appname:vpn vpn.login_user:*  vpn.actype:login|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,15,cnt>=4,20,default,20) ]] |append [[ appname:vpn vpn.login_user:*  vpn.actype:\"access resource\" vpn.login_user:* (NOT vpn.result:success) vpn.result:*|limit 1|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,15,cnt>=4,20,default,20) ]] |table vpn.login_user,app1 |mvcombine sep=\"/\" app1|rename vpn.login_user as \"用户名\",app1 as \"存在的可疑操作\""}
{"input": "1. 查找周峰登录VPN失败的日志,打上app1=“疑似暴力破解”的标记,统计登录失败次数,根据次数给予不同的权重ccc。\n2. 查找周峰登录VPN,源IP变化次数。如果源IP只变化1次,则 app1=“疑似账号共用”,权重10。源IP变化2次,权重5。源IP变化3次及以上,权重0。\n3. 查找周峰从非中国IP登录VPN的日志。如果异地登录1次,app1=“账号登录异常”,权重10。2次,权重5。4次及以上,权重0。\n4. 查找周峰在非工作时间(18:00-8:00)登录VPN的日志。如果1次,app1=“异常时间登录”,权重10。2次,权重5。4次及以上,权重0。 \n5. 查找周峰访问VPN资源失败的第一条日志。app1=“异常访问系统”,权重10。2次,权重5。4次及以上,权重0。\n6. 如果某类日志不存在,则权重赋值为fs(全选中的权重和)。\n7. 根据app1分类,找出各类日志的最小权重ddd。\n8. 根据app1再分类,求各类日志权重和eee,得到风险等级。。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "VPN用户周峰的风险系数", "output": "appname:vpn vpn.login_user:\"周峰\" vpn.actype:login vpn.result:failure  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,line,logtype|eval aaa=case(cnt==1,20,cnt==2,10,cnt==3,5,cnt>4,0,default,20) |append [[ appname:vpn vpn.login_user:\"周峰\"  vpn.actype:login  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src_ip.geo.ip) as cnt by app1,line|eval aaa=case(cnt==1,10,cnt==2,5,cnt>=3,0,default,20) ]] |append [[ appname:vpn vpn.login_user:\"周峰\"  vpn.actype:login  (NOT vpn.src_ip.geo.country:private)   (NOT vpn.src_ip.geo.country:中国)  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip.geo.ip) as cnt by app1,line|eval aaa=case(cnt==1,10,cnt==2,5,cnt>=4,0,default,20) ]] |append [[ appname:vpn vpn.login_user:\"周峰\"  vpn.actype:login|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,line|eval aaa=case(cnt==1,10,cnt==2,5,cnt>=4,0,default,20) ]] |append [[ appname:vpn vpn.login_user:\"周峰\"  vpn.actype:\"access resource\" vpn.login_user:* (NOT vpn.result:success) vpn.result:*|limit 1|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,line|eval aaa=case(cnt==1,10,cnt==2,5,cnt>=4,0,default,20) ]] |eval ccc=if(empty(cnt),fs,aaa)| stats min(ccc) as ddd by  app1  |stats sum(ddd) as eee"}
{"input": "1. 首先过滤出logtype=vpn,登录用户为周峰,行为类型为login,结果为failure的日志,并添加eval字段app1=\"疑似暴力破解\",line=\"kkk\"。\n2. 然后按app1和line字段聚合,统计计数cnt,并根据cnt的值进行分级,得到aaa字段,表示风险等级。\n3. 附加查询出周峰行为类型为login,且源IP属于非中国和unallocated IP的日志,添加eval字段app1=\"账号登录异常\",line=\"kkk\"。同样进行聚合统计和分级,得到aaa字段。\n4. 附加查询出周峰行为类型为login,且登录时间大于18点或小于8点的日志,添加eval字段app1=\"异常时间登录\",line=\"kkk\"。同样进行聚合统计和分级,得到aaa字段。\n5. 附加查询出周峰行为类型为\"access resource\",结果不为success,限制一行,添加eval字段app1=\"异常访问系统\",line=\"kkk\"。同样进行聚合统计和分级,得到aaa字段。\n6. 根据是否有cnt值,如果为空则取fs(应该为0),否则取aaa的值,得到ccc字段。\n7. 最后按app1和ccc字段聚合,统计计数cnt,输出app1和ccc两个字段。。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "VPN用户周峰的行为画像", "output": "appname:vpn vpn.login_user:\"周峰\" vpn.actype:login vpn.result:failure  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,line,logtype|eval aaa=case(cnt==1,0,cnt==2,5,cnt==3,10,cnt>4,20,default,0) |append [[ appname:vpn vpn.login_user:\"周峰\"  vpn.actype:login  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src_ip.geo.ip) as cnt by app1,line|eval aaa=case(cnt==1,0,cnt==2,5,cnt>=3,20,default,0) ]] |append [[ appname:vpn vpn.login_user:\"周峰\"  vpn.actype:login  (NOT vpn.src_ip.geo.country:private)   (NOT vpn.src_ip.geo.country:中国)  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip.geo.ip) as cnt by app1,line|eval aaa=case(cnt==1,0,cnt==2,5,cnt>=4,20,default,0) ]] |append [[ appname:vpn vpn.login_user:\"周峰\"  vpn.actype:login|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,line|eval aaa=case(cnt==1,0,cnt==2,5,cnt>=4,20,default,0) ]] |append [[ appname:vpn vpn.login_user:\"周峰\"  vpn.actype:\"access resource\" vpn.login_user:* (NOT vpn.result:success) vpn.result:*|limit 1|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,line|eval aaa=case(cnt==1,0,cnt==2,5,cnt>=4,q0,default,0) ]] |eval ccc=if(empty(cnt),fs,aaa)| stats count() as cnt by  app1,ccc |fields app1,ccc"}
{"input": "用户可疑操作明细，展示最近 1 条。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "深信服VPN日志数据，编写查询语句实现如下分析场景", "output": "appname:vpn vpn.login_user:* vpn.actype:login vpn.result:failure  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,0,cnt==2,20,cnt==3,30,cnt>=4,50,default,20)\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==2,20,cnt>=3,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login  (NOT vpn.src.geo.country:private)   (NOT vpn.src.geo.country:中国)  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,30,cnt==2,40,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:\"access resource\" vpn.login_user:* (NOT vpn.result:success) vpn.result:*|limit 1|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|where aaa!=0\n|table vpn.login_user,app1\n|mvcombine sep=\"/\" app1|rename vpn.login_user as \"用户名\",app1 as \"存在的可疑操作\""}
{"input": "用户行为画像，展示最近 1 条。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "深信服VPN日志数据，编写查询语句实现如下分析场景", "output": "appname:vpn vpn.login_user:* vpn.actype:login vpn.result:failure  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,line|eval aaa=case(cnt==1,0,cnt==2,20,cnt==3,30,cnt>=4,50,default,0)\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,line|eval aaa=case(cnt==2,20,cnt>=3,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login  (NOT vpn.src.geo.country:private)   (NOT vpn.src.geo.country:\"中国\")  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,line|eval aaa=case(cnt==1,30,cnt==2,40,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:\"access resource\" vpn.login_user:* (NOT vpn.result:success) vpn.result:*|limit 1|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|eval ccc=if(empty(cnt),fs,aaa)| stats max(ccc) as ddd by  app1 |stats count() as cnt by  app1,ddd |fields app1,ddd"}
{"input": "用户威胁系数，展示最近 1 条。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "深信服VPN日志数据，编写查询语句实现如下分析场景", "output": "appname:vpn vpn.login_user:* vpn.actype:login vpn.result:failure  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,0,cnt==2,20,cnt==3,30,cnt>=4,50,default,0)\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==2,20,cnt>=3,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login  (NOT vpn.src.geo.country:private)   (NOT vpn.src.geo.country:中国)  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,30,cnt==2,40,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:\"access resource\" vpn.login_user:* (NOT vpn.result:success) vpn.result:*|limit 1|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|stats sum(aaa) as all by vpn.login_user"}
{"input": "策略触发最多的10个用户。", "instruction": "防病毒_SEPM数据，编写查询语句实现如下分析场景", "output": "* appname:antivirus_gateway tag:symantec  \"规则\" | stats count() as total by 'antivirus_gateway.rulekv.用户' |limit 10|append[[appname:antivirus_gateway AND ( tag:symantec OR tag:symantec_app_c OR tag:symantec_risk )|  stats count() as total by antivirus_gateway.user |limit 10]]| rename 'antivirus_gateway.rulekv.用户' as user ,antivirus_gateway.user as user"}
{"input": "用户可疑操作明细。分别过滤疑似暴力破解、账号共用、国外 IP 登录、异常时间段登录、访问系统异常的情况，    按规则给出评分，规则是一条记录0 分，两条记录 10 分，大于三条 20 分。然后用 append 追加在一起。。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "sangfor_vpn数据，编写查询语句实现如下分析场景", "output": "appname:vpn vpn.login_user:* vpn.actype:login vpn.result:failure  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,0,cnt==2,10,cnt==3,15,cnt>4,20,default,20)\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==2,10,cnt>=3,20,default,20)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login  (NOT vpn.src_ip.geo.country:private)   (NOT vpn.src_ip.geo.country:中国)  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,15,cnt>=4,20,default,20)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,15,cnt>=4,20,default,20)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:\"access resource\" vpn.login_user:* (NOT vpn.result:success) vpn.result:*|limit 1|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,15,cnt>=4,20,default,20)\n]]\n|table vpn.login_user,app1\n|mvcombine sep=\"/\" app1|rename vpn.login_user as \"用户名\",app1 as \"存在的可疑操作\""}
{"input": "用户可疑操作明细。分别过滤疑似暴力破解、账号共用、国外 IP 登录、异常时间段登录、访问系统异常的情况，按规则给出评分，规则是一条记录0 分，两条记录 10 分，大于三条 20 分。然后用 append 追加在一起展示。。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "Cisco_VPN日志数据，编写查询语句实现如下分析场景", "output": "appname:vpn vpn.login_user:* vpn.actype:login vpn.result:failure  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,0,cnt==2,20,cnt==3,30,cnt>=4,50,default,20)\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==2,20,cnt>=3,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login  (NOT vpn.src.geo.country:private)   (NOT vpn.src.geo.country:中国)  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,30,cnt==2,40,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:\"access resource\" vpn.login_user:* (NOT vpn.result:success) vpn.result:*|limit 1|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|where aaa!=0\n|table vpn.login_user,app1\n|mvcombine sep=\"/\" app1|rename vpn.login_user as \"用户名\",app1 as \"存在的可疑操作\""}
{"input": "用户行为画像分别过滤疑似暴力破解、账号共用、国外 IP 登录、异常时间段登录、访问系统异常的情况，按规则给出评分，规则是一条记录0 分，两条记录 10 分，大于三条 20 分。然后用 append 追加在一起，然后分组统计事件数。。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "Cisco_VPN日志数据，编写查询语句实现如下分析场景", "output": "appname:vpn vpn.login_user:* vpn.actype:login vpn.result:failure  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,line|eval aaa=case(cnt==1,0,cnt==2,20,cnt==3,30,cnt>=4,50,default,0)\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,line|eval aaa=case(cnt==2,20,cnt>=3,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login  (NOT vpn.src.geo.country:private)   (NOT vpn.src.geo.country:\"中国\")  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,line|eval aaa=case(cnt==1,30,cnt==2,40,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:\"access resource\" vpn.login_user:* (NOT vpn.result:success) vpn.result:*|limit 1|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|eval ccc=if(empty(cnt),fs,aaa)| stats max(ccc) as ddd by  app1 |stats count() as cnt by  app1,ddd |fields app1,ddd"}
{"input": "用户威胁系数。分别过滤疑似暴力破解、账号共用、国外 IP 登录、异常时间段登录、访问系统异常的情况，按规则给出评分，规则是一条记录0 分，两条记录 10 分，大于三条 20 分。然后用 append 追加在一起，然后按用户名分组统计总分。。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "Cisco_VPN日志数据，编写查询语句实现如下分析场景", "output": "appname:vpn vpn.login_user:* vpn.actype:login vpn.result:failure  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,0,cnt==2,20,cnt==3,30,cnt>=4,50,default,0)\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==2,20,cnt>=3,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login  (NOT vpn.src.geo.country:private)   (NOT vpn.src.geo.country:中国)  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,30,cnt==2,40,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:\"access resource\" vpn.login_user:* (NOT vpn.result:success) vpn.result:*|limit 1|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|stats sum(aaa) as all by vpn.login_user"}
{"input": "索引可用字段有：audit.MACHINE, audit.OSUSER, audit.PROGRAM, audit.SQL_ID, audit.SQL_TEXT, audit.USERNAME, audit.command, audit.msg.cmd, audit.msg.command, audit.msg.exec_time, audit.msg.info, audit.msg.path, audit.msg.pid, audit.msg.pwd, audit.msg.rhost, audit.msg.ruser, audit.msg.ser, audit.msg.src_ip, audit.msg.src_port, audit.msg.user, audit.up_time, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "linux 审计异常事件详情，展示 IP、数量、异常类型", "output": "tag:linux_boot | parse field=raw_message \".*boot\\s+(?<boot_time>[^\\:]+\\:\\d+)\" | eval current_time=now() | eval dura=current_time-parsedate(boot_time,\"yyyy-MM-dd HH:mm\") | stats count() by ip,dura | where tolong(dura)<300000 | stats dc(ip) as error by ip | eval type=\"系统重启\"  | append [[ tag:rsyslog_status | parse \".*(?<status>running)\"  | where status!=\"running\" | stats dc(ip) as error by ip | eval type=\"rsyslog关闭\" ]] | append [[ appname:audit AND audit.msg.ser:sshd AND \"Failed password for\" | stats count() as error by ip | eval type=\"登录失败\" ]] | append [[ appname:audit AND audit.msg.ser:shell_cmd AND (audit.msg.command:service* OR audit.msg.command:rm* OR audit.msg.command:export* OR audit.msg.command:kill*) | stats count() as error by ip | eval type=\"敏感命令\" ]] "}
{"input": "索引可用字段有：audit.MACHINE, audit.OSUSER, audit.PROGRAM, audit.SQL_ID, audit.SQL_TEXT, audit.USERNAME, audit.command, audit.msg.cmd, audit.msg.command, audit.msg.exec_time, audit.msg.info, audit.msg.path, audit.msg.pid, audit.msg.pwd, audit.msg.rhost, audit.msg.ruser, audit.msg.ser, audit.msg.src_ip, audit.msg.src_port, audit.msg.user, audit.up_time, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "linux异常事件数", "output": "tag:linux_boot | parse field=raw_message \".*boot\\s+(?<boot_time>[^\\:]+\\:\\d+)\" | eval current_time=now() | eval dura=current_time-parsedate(boot_time,\"yyyy-MM-dd HH:mm\") | stats count() by ip,dura | where tolong(dura)<300000 | stats dc(ip) as error by ip | eval type=\"系统重启\"  | append [[ tag:rsyslog_status | dedup 1 ip |  parse \".*(?<status>running)\"  | where status!=\"running\" | stats dc(ip) as error by ip | eval type=\"rsyslog关闭\" ]] | append [[ appname:audit AND audit.msg.ser:sshd AND \"Failed password for\" | stats count() as error by ip | eval type=\"登录失败\" ]] | append [[ appname:audit AND audit.msg.ser:shell_cmd AND (audit.msg.command:service* OR audit.msg.command:rm* OR audit.msg.command:export* OR audit.msg.command:kill*) | stats count() as error by ip | eval type=\"敏感命令\" ]] | stats sum(error) as _sum"}
{"input": "设备配置人员及IP统计。索引可用字段有：switch.IP, switch.action, switch.auth_method, switch.bandwidth, switch.brief, switch.cmd, switch.count, switch.desc, switch.desc.cmd, switch.desc.user, switch.describe, switch.ethernet, switch.event_type, switch.facility, switch.host, switch.host_ip, switch.interface_name, switch.ip, switch.kv.COMMAND, switch.kv.TTY, switch.kv.USER, switch.kvmsg.IpAddress, switch.kvmsg.UserName, switch.level, switch.log_message, switch.log_type, switch.login_method, switch.mode, switch.module, switch.port, switch.port_channel, switch.reason, switch.result, switch.severity, switch.speed, switch.src_ip, switch.src_mac, switch.state, switch.terminal, switch.time, switch.user, switch.vlan, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "交换机_cisco_ios数据，编写查询语句实现如下分析场景", "output": "appname:switch tag:cisco_ios  AND SYS-5-CONFIG_I |parse \"Configured from (?<config_from>\\w+) by (?<config_terminal>\\w+) on (?<vty>\\w+) \\((?<terminal_ip>[^\\)]+)\\)\"  |stats count() by config_from,config_terminal |rename config_from as  from,config_terminal as to |append [[appname:switch tag:cisco_ios  AND SYS-5-CONFIG_I |parse \"Configured from (?<config_from>\\w+) by (?<config_terminal>\\w+) on (?<vty>\\w+) \\((?<terminal_ip>[^\\)]+)\\)\"  |stats count() by config_terminal,terminal_ip|rename config_terminal as from,terminal_ip as to]] "}
{"input": "审计异常事件，展示 IP 地址、数量和异常类型。索引可用字段有：audit.MACHINE, audit.OSUSER, audit.PROGRAM, audit.SQL_ID, audit.SQL_TEXT, audit.USERNAME, audit.command, audit.msg.cmd, audit.msg.command, audit.msg.exec_time, audit.msg.info, audit.msg.path, audit.msg.pid, audit.msg.pwd, audit.msg.rhost, audit.msg.ruser, audit.msg.ser, audit.msg.src_ip, audit.msg.src_port, audit.msg.user, audit.up_time, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "linux审计数据，编写查询语句实现如下分析场景", "output": "tag:linux_boot | parse field=raw_message \".*boot\\s+(?<boot_time>[^\\:]+\\:\\d+)\" | eval current_time=now() | eval dura=current_time-parsedate(boot_time,\"yyyy-MM-dd HH:mm\") | stats count() by ip,dura | where tolong(dura)<300000 | stats dc(ip) as error by ip | eval type=\"系统重启\"  | append [[ tag: rsyslog_status | parse \".*(?<status>running)\"  | where status!=\"running\" | stats dc(ip) as error by ip | eval type=\"rsyslog关闭\" ]] | append [[ appname:audit AND audit.msg.ser:sshd AND \"Failed password for\" | stats count() as error by ip | eval type=\"登录失败\" ]] | append [[ appname:audit AND audit.msg.ser:shell_cmd AND (audit.msg.command:service* OR audit.msg.command:rm* OR audit.msg.command:export* OR audit.msg.command:kill*) | stats count() as error by ip | eval type=\"敏感命令\" ]] | rename ip as \"IP地址\",error as \"数量\",type as \"异常类型\""}
{"input": "linux异常事件按分类计算总数。具体方法如下：1. 先搜索tag为linux_boot的日志,提取boot时间,并计算机器启动后的运行时间dura\n2. 过滤dura小于5分钟的,统计这些机器的IP,标记为error=1,type为\"系统重启\"\n3. 搜索rsyslog日志,找出rsyslog服务不是running状态的机器,统计IP,标记error=1,type为\"rsyslog关闭\"\n4. 搜索审计日志,找出有登录失败记录的机器,统计IP,标记error=1,type为\"登录失败\"\n5. 搜索审计日志,找出执行了敏感命令(service、rm、export、kill)的机器,统计IP,标记error=1, type为\"敏感命令\"\n6. 最后汇总所有error,得到各个机器的安全事件总数_sum。索引可用字段有：audit.MACHINE, audit.OSUSER, audit.PROGRAM, audit.SQL_ID, audit.SQL_TEXT, audit.USERNAME, audit.command, audit.msg.cmd, audit.msg.command, audit.msg.exec_time, audit.msg.info, audit.msg.path, audit.msg.pid, audit.msg.pwd, audit.msg.rhost, audit.msg.ruser, audit.msg.ser, audit.msg.src_ip, audit.msg.src_port, audit.msg.user, audit.up_time, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "linux审计数据，编写查询语句实现如下分析场景", "output": "tag:linux_boot | parse  \".*boot\\s+(?<boot_time>[^\\:]+\\:\\d+)\" | eval current_time=now() | eval dura=current_time-parsedate(boot_time,\"yyyy-MM-dd HH:mm\") | stats count() by ip,dura | where tolong(dura)<300000 | stats dc(ip) as error by ip | eval type=\"系统重启\"  | append [[ tag: rsyslog_status | dedup 1 ip |  parse \".*(?<status>running)\"  | where status!=\"running\" | stats dc(ip) as error by ip | eval type=\"rsyslog关闭\" ]] | append [[ appname:audit AND audit.msg.ser:sshd AND \"Failed password for\" | stats count() as error by ip | eval type=\"登录失败\" ]] | append [[ appname:audit AND audit.msg.ser:shell_cmd AND (audit.msg.command:service* OR audit.msg.command:rm* OR audit.msg.command:export* OR audit.msg.command:kill*) | stats count() as error by ip | eval type=\"敏感命令\" ]] | stats sum(error) as _sum"}
{"input": "用户可疑操作明细。具体方法如下：\n匹配VPN日志中的认证、登录和登出事件\n1. 当失败次数达到一定阈值时,标记为“疑似暴力破解”;\n2. 当同一用户从不同城市登录时,标记为“疑似账号共用”;\n3. 当非中国IP登录时,标记为“账号登录异常”; \n4. 当登录时间为夜间时,标记为“异常时间登录”;\n5. 匹配VPN日志中的访问资源事件,当访问失败时,标记为“异常访问系统”;\n6. 根据上述情况为每个用户打分,当 score 不为0时,输出用户名、存在的可疑操作及触发次数;\n7. 将存在的可疑操作用\"/\"连接,重命名列名,最终输出用户名、存在的可疑操作及触发次数。\n。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "深信服零信任VPN数据，编写查询语句实现如下分析场景", "output": "appname:vpn  (vpn.event_name:auth OR vpn.event_name:login OR vpn.event_name:logout) vpn.result:FAILED  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==1,0,cnt==2,20,cnt==3,30,cnt>=4,50,default,20)\n|append\n[[\nappname:vpn \n (vpn.event_name:auth OR vpn.event_name:login OR vpn.event_name:logout)  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==2,20,cnt>=3,50,default,0)\n]]\n|append\n[[\nappname:vpn \n (vpn.event_name:auth OR vpn.event_name:login OR vpn.event_name:logout)  (NOT vpn.src.geo.country:private)   (NOT vpn.src.geo.country:中国)  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==1,30,cnt==2,40,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn \n (vpn.event_name:auth OR vpn.event_name:login OR vpn.event_name:logout)|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn \n vpn.event_name:\"access_resource\"  (NOT vpn.result:SUCCESS) vpn.result:*|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|where aaa!=0\n|table vpn.user_name,app1,cnt\n|mvcombine sep=\"/\" app1|rename vpn.user_name as \"用户名\",app1 as \"存在的可疑操作\",cnt as \"触发次数\""}
{"input": "用户行为画像。计算方法如下：\n1. 搜索logtype为vpn,用户名为${user}的日志,其中事件名为auth、login或logout且结果为FAILED的日志。统计这些日志的数量cnt,如果cnt==1则aaa=0,cnt==2则aaa=20,cnt==3则aaa=30,cnt>=4则aaa=50。这部分查询用于检测暴力破解行为。\n2. 然后追加另一个查询,${user}的vpn日志中事件名为auth、login或logout,并统计源IP的唯一值cnt。如果cnt==2则aaa=20,cnt>=3则aaa=50。这部分查询用于检测账号共用行为。\n3. 再追加一个查询,搜索${user}的vpn日志中事件名为auth、login或logout,源IP不在中国或私有IP,并统计源IP的唯一值cnt。如果cnt==1则aaa=30,cnt==2则aaa=40,cnt>=4则aaa=50。这部分查询用于检测异常登录行为。\n4. 继续追加一个查询,搜索${user}的vpn日志,时间在18点之后或8点之前,统计日志数量cnt。如果cnt==1则aaa=10,cnt==2则aaa=20,cnt>=4则aaa=50。这部分查询用于检测异常时间的登录行为。\n5. 最后追加一个查询,搜索${user}的vpn日志中事件名为access_resource且结果不为SUCCESS,统计日志数量cnt。如果cnt==1则aaa=10,cnt==2则aaa=20,cnt>=4则aaa=50。这部分查询用于检测异常访问系统行为。\n6. 以上5部分查询得到的aaa的值取最大值ccc,然后以app1和ccc分组统计cnt,最后输出app1和ddd(ccc的最大值)。。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "深信服零信任VPN数据，编写查询语句实现如下分析场景", "output": "appname:vpn vpn.user_name:${user}   (vpn.event_name:auth OR vpn.event_name:login OR vpn.event_name:logout) vpn.result:FAILED  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==1,0,cnt==2,20,cnt==3,30,cnt>=4,50,default,20)\n|append\n[[\nappname:vpn vpn.user_name:${user} \n (vpn.event_name:auth OR vpn.event_name:login OR vpn.event_name:logout)  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==2,20,cnt>=3,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.user_name:${user} \n (vpn.event_name:auth OR vpn.event_name:login OR vpn.event_name:logout)  (NOT vpn.src.geo.country:private)   (NOT vpn.src.geo.country:中国)  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==1,30,cnt==2,40,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.user_name:${user} \n (vpn.event_name:auth OR vpn.event_name:login OR vpn.event_name:logout)|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.user_name:${user} \n vpn.event_name:\"access_resource\"  (NOT vpn.result:SUCCESS) vpn.result:*|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|eval ccc=if(empty(cnt),fs,aaa)| stats max(ccc) as ddd by  app1 |stats count() as cnt by  app1,ddd |fields app1,ddd"}
{"input": "通过5个子查询,主要检测VPN日志中用户“${user}”的以下异常行为:\n1. 疑似暴力破解:vpn 登录失败次数达到一定阈值,判定为暴力破解行为。\n2. 疑似账号共享:同一账号在不同城市登录,判定为账号共享。\n3. 账号登录异常:账号从国外非中国IP登录,判定为账号登录异常。\n4. 异常时间登录:账号在非工作时间登录,判定为异常时间登录。\n5. 异常访问系统:账号访问系统资源失败,判定为异常访问系统。\n每个子查询会给出相应行为的评分,最后将各个行为的评分相加,得出用户${user}的总评分。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "深信服零信任VPN数据查询指定用户威胁系数", "output": "appname:vpn vpn.user_name:${user} (vpn.event_name:auth OR vpn.event_name:login OR vpn.event_name:logout) vpn.result:FAILED  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==1,0,cnt==2,20,cnt==3,30,cnt>=4,50,default,20)\n|append\n[[\nappname:vpn vpn.user_name:${user} \n (vpn.event_name:auth OR vpn.event_name:login OR vpn.event_name:logout)  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==2,20,cnt>=3,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.user_name:${user} \n (vpn.event_name:auth OR vpn.event_name:login OR vpn.event_name:logout)  (NOT vpn.src.geo.country:private)   (NOT vpn.src.geo.country:中国)  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==1,30,cnt==2,40,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.user_name:${user} \n (vpn.event_name:auth OR vpn.event_name:login OR vpn.event_name:logout)|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.user_name:${user} \n vpn.event_name:\"access_resource\"  (NOT vpn.result:SUCCESS) vpn.result:*|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|stats sum(aaa) as all "}
{"input": "按每小时分桶统计各类攻击趋势。索引可用字段有：apt.attack_type, apt.dst_ip, apt.dst_port, apt.event_name, apt.level, apt.src.geo.city, apt.src.geo.country, apt.src.geo.province, apt.src_ip, apt.status, apt.uri, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "安恒APT数据，编写查询语句实现如下分析场景", "output": "appname:apt tag:dbappsecurity | bucket timestamp span=1h as ts | stats count() as cnt by ts|eval line=\"总事件趋势\"|append[[appname:apt tag:dbappsecurity | bucket timestamp span=1h as ts | stats count() as cnt by ts,apt.attack_type|rename apt.attack_type as line]]"}
{"input": "按每小时分桶统计a10事件趋势。", "instruction": "负载均衡_A10数据，编写查询语句实现如下分析场景", "output": "appname:a10 tag:a10 \n|bucket timestamp span=1h as ts\n|stats count() as ct by ts\n|eval line=\"总事件\"\n|append[[\n\tappname:a10 tag:a10 a10.status:down\n\t|bucket timestamp span=1h as ts\n\t|stats count() as ct by ts\n\t|eval line=\"down事件\"]]\n|append[[\n\tappname:a10 tag:a10 a10.status:up\n\t|bucket timestamp span=1h as ts\n\t|stats count() as ct by ts\n\t|eval line=\"up事件\"]]"}
{"input": "按每小时分桶统计ips访问事件趋势。索引可用字段有：ips.action, ips.application, ips.attack_name, ips.attack_type, ips.block_reason, ips.cve, ips.dst.geo.city, ips.dst.geo.ip, ips.dst.geo.latitude, ips.dst.geo.longitude, ips.dst_ip, ips.dst_port, ips.event, ips.event_id, ips.event_level, ips.event_name, ips.inbound_interface, ips.inbound_zone, ips.level, ips.local, ips.msg.seclevel, ips.outbound_interface, ips.outbound_zone, ips.policy, ips.proto, ips.service, ips.severity, ips.src.geo.city, ips.src.geo.country, ips.src.geo.ip, ips.src.geo.latitude, ips.src.geo.longitude, ips.src.geo.province, ips.src_ip, ips.src_port, ips.url, ips.vendor_app, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "ips_mcafee数据，编写查询语句实现如下分析场景", "output": "appname:ips tag:mcafee NOT ips.level:Informational\n|bucket timestamp span=1h as ts\n| stats count() as cnt by ts\n|eval line=\"攻击事件\"\n|append [[\n\tappname:ips tag:mcafee  ips.level:Informational\n\t|bucket timestamp span=1h as ts\n\t| stats count() as cnt by ts\n\t|eval line=\"info事件\"\n]]|append [[\n\tappname:ips tag:mcafee  ips.level:*\n\t|bucket timestamp span=1h as ts\n\t| stats count() as cnt by ts\n\t|eval line=\"所有事件\"\n]]"}
{"input": "按每30分钟分桶统计不同攻击的变化趋势。索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "防火墙_hillstone数据，编写查询语句实现如下分析场景", "output": "(* IPS) AND appname:firewall tag:hillstone \n|bucket timestamp span=30m as ts \n| stats count() as count_ by ts,'firewall.msg.kvs.威胁名称'\n|rename 'firewall.msg.kvs.威胁名称' as event\n|append[[\n\t(* IPS) AND appname:firewall tag:hillstone \n\t|bucket timestamp span=30m as ts \n\t| stats count() as count_ by ts,firewall.event_name\n\t|rename firewall.event_name as event]]"}
{"input": "按每30分钟分桶统计不同级别攻击趋势图。索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "防火墙_hillstone数据，编写查询语句实现如下分析场景", "output": "(* IPS) AND appname:firewall tag:hillstone \n|bucket timestamp span=30m as ts \n| stats count() as count_ by ts,'firewall.msg.kvs.威胁级别'\n|rename 'firewall.msg.kvs.威胁级别' as event\n|append[[\n\t(* IPS) AND appname:firewall tag:hillstone \n\t|bucket timestamp span=30m as ts \n\t| stats count() as count_ by ts,'firewall.msg.threat_severity'\n\t|rename 'firewall.msg.threat_severity' as event]]"}
{"input": "按每30分钟分桶统计linux登录趋势。索引可用字段有：linux.cmd, linux.command, linux.event_detail.comm, linux.event_detail.exe, linux.event_detail.key, linux.event_detail.pid, linux.event_detail.ppid, linux.event_id, linux.event_msg.terminal, linux.event_name, linux.event_type, linux.log_type, linux.login_time, linux.msg, linux.pid, linux.result, linux.service_name, linux.src_ip, linux.status, linux.terminal, linux.type, linux.use_time, linux.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "安全态势数据，编写查询语句实现如下分析场景", "output": "appname:linux AND Authentication OR failure  | bucket timestamp span=30m as ts | stats count() as count_ by ts|rename count_ as \"登录次数\"|eval line=\"登录失败\" | append [[appname:linux Accepted | bucket timestamp span=30m as ts | stats count() as count_ by ts|rename count_ as \"登录次数\"|eval line=\"登录成功\"]]"}
{"input": "按每30分钟分桶统计登录趋势。索引可用字段有：linux.cmd, linux.command, linux.event_detail.comm, linux.event_detail.exe, linux.event_detail.key, linux.event_detail.pid, linux.event_detail.ppid, linux.event_id, linux.event_msg.terminal, linux.event_name, linux.event_type, linux.log_type, linux.login_time, linux.msg, linux.pid, linux.result, linux.service_name, linux.src_ip, linux.status, linux.terminal, linux.type, linux.use_time, linux.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "linux日志数据，编写查询语句实现如下分析场景", "output": "(appname:linux linux.event_name:登录失败事件) OR (appname:linux linux.log_type:auth linux.event_name:登录失败事件)  | bucket timestamp span=30m as ts | stats count() as count_ by ts|rename count_ as \"登录次数\"|eval line=\"登录失败\" | append [[appname:linux linux.event_name:登录成功事件| bucket timestamp span=30m as ts | stats count() as count_ by ts|rename count_ as \"登录次数\"|eval line=\"登录成功\"]]"}
{"input": "按每30分钟分桶统计audit登录趋势。索引可用字段有：linux.cmd, linux.command, linux.event_detail.comm, linux.event_detail.exe, linux.event_detail.key, linux.event_detail.pid, linux.event_detail.ppid, linux.event_id, linux.event_msg.terminal, linux.event_name, linux.event_type, linux.log_type, linux.login_time, linux.msg, linux.pid, linux.result, linux.service_name, linux.src_ip, linux.status, linux.terminal, linux.type, linux.use_time, linux.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "linux日志数据，编写查询语句实现如下分析场景", "output": "((appname:linux tag:audit) OR (appname:linux linux.log_type:audit) ) AND (USER_AUTH OR USER_LOGIN) AND linux.result:failed \n| bucket timestamp span=30m as ts \n| stats count() as count_ by ts\n| eval count_=count_/2\n|rename count_ as \"登录次数\"\n|eval line=\"登录失败\" \n| append [[\n\t((appname:linux tag:audit) OR (appname:linux linux.log_type:audit) ) AND (USER_AUTH OR USER_LOGIN) AND linux.result:success \n\t| bucket timestamp span=30m as ts \n\t| stats count() as count_ by ts\n\t| eval count_=count_/3\n\t|rename count_ as \"登录次数\"\n\t|eval line=\"登录成功\"]]"}
{"input": "按每30分钟分桶统计应用控制事件趋势。索引可用字段有：ac.ac_ip, ac.action, ac.ap_ip, ac.ap_name, ac.app, ac.app_name, ac.band, ac.client, ac.command, ac.dst_ip, ac.dst_port, ac.event_id, ac.event_name, ac.event_type, ac.kv.app_cat_name, ac.kv.log_level, ac.kv.receive_addr, ac.kv.send_addr, ac.kv.subject, ac.kv.term_device, ac.log_type, ac.mac_addr, ac.mnemonic, ac.msg.app, ac.msg.serv, ac.msg.tm_type, ac.msg.user, ac.operation, ac.policy, ac.request_url, ac.resource, ac.resource_type, ac.result, ac.src_ip, ac.src_mac, ac.ssid, ac.status, ac.time, ac.user, ac.user_agent, ac.user_name, ac.web_app, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "奇安信AC数据，编写查询语句实现如下分析场景", "output": "appname:ac tag:qianxin ac.log_type:trc ac.action:阻塞\n|bucket timestamp span=30m as ts \n| stats count() as cnt by ts\n|eval line=\"阻塞\"\n|append[[\n\tappname:ac tag:qianxin ac.log_type:trc ac.action:允许\n\t|bucket timestamp span=30m as ts \n\t| stats count() as cnt by ts\n\t|eval line=\"允许\"]]"}
{"input": "按每5分钟分桶统计dns解析请求与响应趋势对比。索引可用字段有：loadbalancing.dst_ip, loadbalancing.level, loadbalancing.listenervs_ip, loadbalancing.msg, loadbalancing.querytype, loadbalancing.responsecode, loadbalancing.severity, loadbalancing.src.geo.province, loadbalancing.src_ip, loadbalancing.status, loadbalancing.type, loadbalancing.user, loadbalancing.username, loadblancing.status, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "f5_dns日志数据，编写查询语句实现如下分析场景", "output": "appname:loadbalancing tag:f5  from |bucket timestamp span=5m as ts | stats count() by ts\n|eval line=\"实时请求趋势\"\n|append\n[[appname:loadbalancing tag:f5  to |bucket timestamp span=5m as ts | stats count() by ts\n|eval line=\"实时响应趋势\"\n]]"}
{"input": "按每5分钟分桶统计核心交易成功失败对比。索引可用字段有：ensemble.excute_time, ensemble.fuc_name, ensemble.info.programId, ensemble.retCode, ensemble.retMsg, ensemble.trade_type, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "核心交易系统数据，编写查询语句实现如下分析场景", "output": "appname:ensemble ensemble.retCode:000000|bucket timestamp span=5m as ts |stats count() as cnt_ by ts|eval line=\"交易成功趋势\" |append [[appname:ensemble NOT ensemble.retCode:000000 ensemble.retCode:*|bucket timestamp span=5m as ts |stats count() as cnt_ by ts|eval line=\"交易失败趋势\"]]"}
{"input": "按每5分钟分桶统计清算交易成功失败对比。索引可用字段有：accounting.excute_time, accounting.fuc_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "清算系统数据，编写查询语句实现如下分析场景", "output": "appname:accounting accounting.info2.retCode:000000|bucket timestamp span=5m as ts |stats count() as cnt_ by ts|eval line=\"交易成功趋势\" |append [[appname:accounting NOT accounting.info2.retCode:000000 ensemble.retCode:*|bucket timestamp span=5m as ts |stats count() as cnt_ by ts|eval line=\"交易失败趋势\"]]"}
{"input": "checkpoint拒绝趋势_最近一小时。", "instruction": "防火墙checkpoint日志数据，编写查询语句实现如下分析场景", "output": "starttime=\"-1h\" (* AND appname:firewall) AND tag:checkpoint firewall.action:drop |bucket timestamp span=5m as ts |stats count() by ts|append[[(* AND appname:firewall) AND tag:checkpoint firewall.action:Drop |bucket timestamp span=5m as ts |stats count() by ts]]"}
{"input": "ADS攻击事件对比分析。索引可用字段有：ddos.attack_type, ddos.category, ddos.direction, ddos.dst.geo.latitude, ddos.dst.geo.longitude, ddos.dst_ip, ddos.event_type, ddos.load_per, ddos.men_per, ddos.portinfo, ddos.protected_ip, ddos.src.geo.city, ddos.src.geo.latitude, ddos.src.geo.longitude, ddos.src_ip, ddos.src_port, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "ads_nsfocus数据，编写查询语句实现如下分析场景", "output": "starttime=\"-1h/h\" endtime=\"now/h\" appname:ddos tag:nsfocus ddos.attack_type:*|bucket timestamp  span=1m as ts |stats count() as count_ by tag,ts |eval time=formatdate(ts,\"mm\") |eval line=\"上一小时\"| append \n[[starttime=\"now/h\" endtime=\"now\" appname:ddos tag:nsfocus ddos.attack_type:*|bucket timestamp  span=1m as ts |stats count() as count_ by tag,ts |eval time=formatdate(ts,\"mm\") |eval line=\"当前小时\"]]"}
{"input": "最近一小时业务请求与失败量趋势。索引可用字段有：ths_all.ANSTYPE, ths_all.GDZH, ths_all.funccn, ths_all.msg, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "同花顺日志数据，编写查询语句实现如下分析场景", "output": "starttime=\"-1h\" appname:ths_all tag:ths_all NOT (ths_all.ANSTYPE:1 OR  ths_all.ANSTYPE:0)|bucket timestamp span=5m as ts |stats count() by ts|eval line=\"业务请求量\"\n|append\n[[appname:ths_all tag:ths_all ths_all.ANSTYPE:0|bucket timestamp span=5m as ts |stats count() by ts|eval line=\"请求失败量\"\n]]\n"}
{"input": "按每 30 分钟分组统计。索引可用字段有：linux.cmd, linux.command, linux.event_detail.comm, linux.event_detail.exe, linux.event_detail.key, linux.event_detail.pid, linux.event_detail.ppid, linux.event_id, linux.event_msg.terminal, linux.event_name, linux.event_type, linux.log_type, linux.login_time, linux.msg, linux.pid, linux.result, linux.service_name, linux.src_ip, linux.status, linux.terminal, linux.type, linux.use_time, linux.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "linux登录趋势，分别过滤失败事件和成功事件", "output": "appname:linux linux.event_name:登录失败事件 | bucket timestamp span=30m as ts | stats count() as count_ by ts|rename count_ as \"登录次数\"|eval line=\"登录失败\" | append [[appname:linux linux.event_name:登录成功事件| bucket timestamp span=30m as ts | stats count() as count_ by ts|rename count_ as \"登录次数\"|eval line=\"登录成功\"]]"}
{"input": "按每 30 分钟分组统计。索引可用字段有：linux.cmd, linux.command, linux.event_detail.comm, linux.event_detail.exe, linux.event_detail.key, linux.event_detail.pid, linux.event_detail.ppid, linux.event_id, linux.event_msg.terminal, linux.event_name, linux.event_type, linux.log_type, linux.login_time, linux.msg, linux.pid, linux.result, linux.service_name, linux.src_ip, linux.status, linux.terminal, linux.type, linux.use_time, linux.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "linux登录趋势", "output": "appname:linux AND Authentication\\ failure\\ for  | bucket timestamp span=30m as ts | stats count() as count_ by ts|rename count_ as \"登录次数\"|eval line=\"登录失败\" | append [[appname:linux Accepted | bucket timestamp span=30m as ts | stats count() as count_ by ts|rename count_ as \"登录次数\"|eval line=\"登录成功\"]]"}
{"input": "secure、audit 和其他标签分别查询并按每 1 小时分组统计后，append 到一起。索引可用字段有：linux.cmd, linux.command, linux.event_detail.comm, linux.event_detail.exe, linux.event_detail.key, linux.event_detail.pid, linux.event_detail.ppid, linux.event_id, linux.event_msg.terminal, linux.event_name, linux.event_type, linux.log_type, linux.login_time, linux.msg, linux.pid, linux.result, linux.service_name, linux.src_ip, linux.status, linux.terminal, linux.type, linux.use_time, linux.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "linux各事件趋势", "output": "appname:linux tag:secure|bucket timestamp span=1h as ts|stats count() as cnt  by ts|eval line=\"secure\"|append [[appname:linux tag:audit|bucket timestamp span=1h as ts|stats count() as cnt1 by ts|eval line=\"audit\"]]|append [[appname:linux NOT tag:audit NOT tag:secure|bucket timestamp span=1h as ts|stats count() as cnt2 by ts|eval line=\"other\"]]"}
{"input": "按每 30 分钟分组统计。索引可用字段有：linux.cmd, linux.command, linux.event_detail.comm, linux.event_detail.exe, linux.event_detail.key, linux.event_detail.pid, linux.event_detail.ppid, linux.event_id, linux.event_msg.terminal, linux.event_name, linux.event_type, linux.log_type, linux.login_time, linux.msg, linux.pid, linux.result, linux.service_name, linux.src_ip, linux.status, linux.terminal, linux.type, linux.use_time, linux.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "Linux操作系统审计_linux登录趋势", "output": "appname:linux tag:secure AND \"Failed password for\"   | bucket timestamp span=30m as ts  | stats count() as count_ by ts |rename count_ as \"登录次数\" |eval line=\"登录失败\"  | append [[ appname:linux tag:secure \"Accepted password for\"  | bucket timestamp span=30m as ts  | stats count() as count_ by ts |rename count_ as \"登录次数\" |eval line=\"登录成功\"]]"}
{"input": "索引可用字段有：linux.cmd, linux.command, linux.event_detail.comm, linux.event_detail.exe, linux.event_detail.key, linux.event_detail.pid, linux.event_detail.ppid, linux.event_id, linux.event_msg.terminal, linux.event_name, linux.event_type, linux.log_type, linux.login_time, linux.msg, linux.pid, linux.result, linux.service_name, linux.src_ip, linux.status, linux.terminal, linux.type, linux.use_time, linux.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "Linux操作系统审计_linux登录成功和失败的趋势，按每 1h 统计", "output": "appname:linux tag:secure AND \"Failed password for\"   | bucket timestamp span=1h as ts  | stats count() as count_ by ts |rename count_ as \"登录次数\" |eval line=\"登录失败\"  | append [[ appname:linux tag:secure \"Accepted password for\"  | bucket timestamp span=1h as ts  | stats count() as count_ by ts |rename count_ as \"登录次数\" |eval line=\"登录成功\"]]"}
{"input": "索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "用户访问路径追踪", "output": "appname:vpn AND 'tag':sangfor AND vpn.actype:login vpn.login_user:\"周峰\"|stats count() as cnt by vpn.src_ip|join vpn.src_ip[[appname:vpn AND 'tag':sangfor AND vpn.actype:\"allocate vip\" vpn.login_user:\"周峰\"| stats count() as cnt by vpn.src_ip,vpn.msg.virtual_ip]]|rename vpn.src_ip as from,vpn.msg.virtual_ip as to|append[[appname:vpn AND 'tag':sangfor AND vpn.actype:access* vpn.login_user:\"周峰\" | stats count() as cnt by vpn.src_ip,vpn.dst_ip,vpn.dst_port|eval dst=vpn.dst_ip+\":\"+vpn.dst_port | rename vpn.src_ip as from,dst as to]]"}
{"input": "进程外部连接关系。索引可用字段有：process.foreign_addr, process.foreign_port, process.local_addr, process.local_port, process.pid, process.program_name, process.proto, process.state, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "linux性能数据，编写查询语句实现如下分析场景", "output": "appname:process process.local_addr:* process.proto:tcp process.state:ESTABLISHED |where process.foreign_addr!=process.local_addr|eval from=process.foreign_addr+\":\"+process.foreign_port|stats count() as cnt by from, process.local_addr|rename  process.local_addr as to |append [[appname:process process.local_addr:* process.proto:tcp process.state:ESTABLISHED |where process.foreign_addr!=process.local_addr|stats count() as cnt by process.local_addr,process.local_port|rename process.local_addr as from,process.local_port as to]]|append [[appname:process process.local_addr:* process.proto:tcp process.state:ESTABLISHED |where process.foreign_addr!=process.local_addr|eval t=process.pid+\":\"+process.program_name|stats count() as cnt by process.local_port,t|rename process.local_port as from,t as to]]"}
{"input": "IPS攻击应用。索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "防火墙_hillstone数据，编写查询语句实现如下分析场景", "output": "(* IPS) AND appname:firewall tag:hillstone \n|stats count() as total by 'firewall.msg.kvs.应用/协议'\n|rename 'firewall.msg.kvs.应用/协议' as proto \n|append[[\n\t (* IPS) AND appname:firewall tag:hillstone \n\t|stats count() as total by firewall.proto\n\t|rename firewall.proto as proto ]]"}
{"input": "IPS威胁类型。索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "防火墙_hillstone数据，编写查询语句实现如下分析场景", "output": "(* IPS) AND appname:firewall tag:hillstone \n|stats count() as total by 'firewall.msg.kvs.威胁类型'\n|rename 'firewall.msg.kvs.威胁类型' as event\n|append[[\n\t (* IPS) AND appname:firewall tag:hillstone \n\t|stats count() as total by firewall.threat_type\n\t|rename firewall.threat_type as event ]]"}
{"input": "IPS攻击子类型。索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "防火墙_hillstone数据，编写查询语句实现如下分析场景", "output": "(* IPS) AND appname:firewall tag:hillstone \n|stats count() as total by 'firewall.msg.kvs.威胁子类型'\n|rename 'firewall.msg.kvs.威胁子类型' as event_type\n|append[[\n\t (* IPS) AND appname:firewall tag:hillstone \n\t|stats count() as total by firewall.threat_subtype\n\t|rename firewall.threat_subtype as event_type ]]"}
{"input": "IPS威胁策略命中数。索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "防火墙_hillstone数据，编写查询语句实现如下分析场景", "output": "(* IPS) AND appname:firewall tag:hillstone \n|stats count() as total by 'firewall.msg.kvs.策略号' \n|rename 'firewall.msg.kvs.策略号' as policy_id \n|append[[\n\t (* IPS) AND appname:firewall tag:hillstone \n\t|stats count() as total by 'firewall.msg.policy_id' \n\t|rename firewall.msg.policy_id as policy_id ]]"}
{"input": "用户_源地址_目的主机_应用。索引可用字段有：fortress.action, fortress.dst_ip, fortress.facility, fortress.host_ip, fortress.input, fortress.ip, fortress.level, fortress.log_type, fortress.loginOK, fortress.login_user, fortress.message, fortress.msg.action, fortress.msg.adlg_type, fortress.msg.begin_time, fortress.msg.command, fortress.msg.date, fortress.msg.mode, fortress.msg.module, fortress.msg.session_guid, fortress.msg.src_ip, fortress.msg.srcip, fortress.msg.srvaddr, fortress.msg.system_user, fortress.msg.sysuser, fortress.node, fortress.protocol, fortress.reason, fortress.remote_addr, fortress.request_msg, fortress.result, fortress.secondary_user, fortress.server, fortress.severity, fortress.src_ip, fortress.src_port, fortress.status, fortress.system_user, fortress.type, fortress.user, fortress.user_agent, fortress.user_name, fortress.username, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "堡垒机_qizhi数据，编写查询语句实现如下分析场景", "output": "appname:fortress tag:shterm  (NOT fortress.type:*) AND (login) \n|stats count() as total by fortress.user,fortress.src_ip \n|rename fortress.user as from ,fortress.src_ip as to\n| append [[\n\t appname:fortress tag:shterm  (NOT web) AND (login) \n\t|stats count() as total by fortress.src_ip,fortress.dst_ip\n\t|rename fortress.src_ip as from ,fortress.dst_ip as to]]\n| append [[\n\t\t appname:fortress tag:shterm  (NOT web) AND (login) \n\t|stats count() as total by fortress.dst_ip,fortress.server\n\t|rename fortress.dst_ip as from ,fortress.server as to]]"}
{"input": "ips_h3c攻击详情。索引可用字段有：ips.action, ips.application, ips.attack_name, ips.attack_type, ips.block_reason, ips.cve, ips.dst.geo.city, ips.dst.geo.ip, ips.dst.geo.latitude, ips.dst.geo.longitude, ips.dst_ip, ips.dst_port, ips.event, ips.event_id, ips.event_level, ips.event_name, ips.inbound_interface, ips.inbound_zone, ips.level, ips.local, ips.msg.seclevel, ips.outbound_interface, ips.outbound_zone, ips.policy, ips.proto, ips.service, ips.severity, ips.src.geo.city, ips.src.geo.country, ips.src.geo.ip, ips.src.geo.latitude, ips.src.geo.longitude, ips.src.geo.province, ips.src_ip, ips.src_port, ips.url, ips.vendor_app, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "华三入侵防御系统日志数据，编写查询语句实现如下分析场景", "output": "appname:ips tag:h3c | stats count() as cnt by ips.attack_name,ips.src_ip,ips.dst_ip,ips.dst_port,ips.severity,ips.action,ips.application | eval dst=ips.dst_ip+\":\"+ips.dst_port | fields ips.attack_name,ips.src_ip,dst,ips.severity,ips.action,ips.application |rename ips.attack_name as \"攻击名称\",ips.src_ip as \"攻击源地址\",ips.severity as \"事件等级\",ips.application as \"应用名称\",ips.action as \"操作\",dst as \"受攻击地址:端口\" |append[[appname:ips tag:h3c | stats count() as cnt by ips.attack_name,ips.src_ip,ips.dst_ip,ips.dst_port,ips.severity,ips.action | eval dst=ips.dst_ip+\":\"+ips.dst_port | fields ips.attack_name,ips.src_ip,dst,ips.severity,ips.action,ips.application |rename ips.attack_name as \"攻击名称\",ips.src_ip as \"攻击源地址\",ips.severity as \"事件等级\",ips.application as \"应用名称\",ips.action as \"操作\",dst as \"受攻击地址:端口\" ]]"}
{"input": "用户访问路径追踪。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "深信服VPN日志数据，编写查询语句实现如下分析场景", "output": "appname:vpn AND 'tag':sangfor AND vpn.actype:login vpn.login_user:${user}|stats count() as cnt by vpn.src_ip|join vpn.src_ip[[appname:vpn AND 'tag':sangfor AND vpn.actype:\"allocate vip\" vpn.login_user:${user}| stats count() as cnt by vpn.src_ip,vpn.msg.virtual_ip]]|rename vpn.src_ip as from,vpn.msg.virtual_ip as to|append[[appname:vpn AND 'tag':sangfor AND vpn.actype:access* vpn.login_user:${user} | stats count() as cnt by vpn.src_ip,vpn.dst_ip,vpn.dst_port|eval dst=vpn.dst_ip+\":\"+vpn.dst_port | rename vpn.src_ip as from,dst as to]]"}
{"input": "ADS攻击路径分析。索引可用字段有：ddos.attack_type, ddos.category, ddos.direction, ddos.dst.geo.latitude, ddos.dst.geo.longitude, ddos.dst_ip, ddos.event_type, ddos.load_per, ddos.men_per, ddos.portinfo, ddos.protected_ip, ddos.src.geo.city, ddos.src.geo.latitude, ddos.src.geo.longitude, ddos.src_ip, ddos.src_port, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "ads_nsfocus数据，编写查询语句实现如下分析场景", "output": "appname:ddos tag:nsfocus ddos.attack_type:* |stats count() as count_ by ddos.src.geo.city,ddos.src_ip\n|rename ddos.src.geo.city as from|rename ddos.src_ip as to \n|append [[appname:ddos tag:nsfocus ddos.attack_type:* |stats count() as count_ by ddos.src_ip,ddos.src_port \n|rename ddos.src_ip as from|rename ddos.src_port as to ]]\n| append [[appname:ddos tag:nsfocus ddos.attack_type:* |stats count() as count_ by ddos.src_port,ddos.dst_ip \n|rename ddos.src_port as from|rename ddos.dst_ip as to ]]"}
{"input": "本日中风险事件总数。索引可用字段有：waf.action, waf.attack_name, waf.attack_type, waf.bytes_in, waf.cost, waf.cve_id, waf.dst_city, waf.dst_domain, waf.dst_ip, waf.dst_latitude, waf.dst_longitude, waf.dst_port, waf.error_msg, waf.event_level, waf.event_log_level, waf.event_name, waf.event_type, waf.http_method, waf.http_refer, waf.is_truncated, waf.kv.Evt_level, waf.kv.Evt_type, waf.kv.event_name, waf.kv.http_method, waf.kv.http_refer, waf.kv.http_url, waf.kv.msg, waf.kv.owasp_top, waf.kv.pri, waf.kv.severity_level, waf.kv.status, waf.kv.type, waf.level, waf.log_category, waf.message, waf.message.action, waf.message.event, waf.message.method, waf.message.policy, waf.message.src_ip.geo.ip, waf.message.src_ip.geo.province, waf.message.src_port, waf.message.status, waf.message.threaten, waf.method, waf.module, waf.msg.act, waf.msg.cs, waf.msg.policy_id, waf.msg.src.geo.country, waf.policy_name, waf.proto, waf.referer, waf.risk_level, waf.severity, waf.src.geo.city, waf.src.geo.country, waf.src.geo.ip, waf.src.geo.isp, waf.src.geo.latitude, waf.src.geo.longitude, waf.src.geo.province, waf.src_ip, waf.src_port, waf.status, waf.status_code, waf.threat_level, waf.time, waf.ua_browser, waf.ua_device, waf.ua_os, waf.uri, waf.url, waf.user_agent.browser, waf.user_agent.os, waf.website_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "waf_imperva_数据，编写查询语句实现如下分析场景", "output": "starttime=\"now/d\" appname:waf tag:imperva AND waf.level:Medium|stats count()  by waf.level|append[[appname:waf tag:imperva AND waf.level:\"中\"|stats count() by waf.level]]"}
{"input": "本日低风险事件总数。索引可用字段有：waf.action, waf.attack_name, waf.attack_type, waf.bytes_in, waf.cost, waf.cve_id, waf.dst_city, waf.dst_domain, waf.dst_ip, waf.dst_latitude, waf.dst_longitude, waf.dst_port, waf.error_msg, waf.event_level, waf.event_log_level, waf.event_name, waf.event_type, waf.http_method, waf.http_refer, waf.is_truncated, waf.kv.Evt_level, waf.kv.Evt_type, waf.kv.event_name, waf.kv.http_method, waf.kv.http_refer, waf.kv.http_url, waf.kv.msg, waf.kv.owasp_top, waf.kv.pri, waf.kv.severity_level, waf.kv.status, waf.kv.type, waf.level, waf.log_category, waf.message, waf.message.action, waf.message.event, waf.message.method, waf.message.policy, waf.message.src_ip.geo.ip, waf.message.src_ip.geo.province, waf.message.src_port, waf.message.status, waf.message.threaten, waf.method, waf.module, waf.msg.act, waf.msg.cs, waf.msg.policy_id, waf.msg.src.geo.country, waf.policy_name, waf.proto, waf.referer, waf.risk_level, waf.severity, waf.src.geo.city, waf.src.geo.country, waf.src.geo.ip, waf.src.geo.isp, waf.src.geo.latitude, waf.src.geo.longitude, waf.src.geo.province, waf.src_ip, waf.src_port, waf.status, waf.status_code, waf.threat_level, waf.time, waf.ua_browser, waf.ua_device, waf.ua_os, waf.uri, waf.url, waf.user_agent.browser, waf.user_agent.os, waf.website_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "waf_imperva_数据，编写查询语句实现如下分析场景", "output": "starttime=\"now/d\" appname:waf tag:imperva AND waf.level:Low|stats count() by waf.level|append[[appname:waf tag:imperva AND waf.level:\"低\"|stats count() by waf.level]]"}
{"input": "本日高风险事件总数。索引可用字段有：waf.action, waf.attack_name, waf.attack_type, waf.bytes_in, waf.cost, waf.cve_id, waf.dst_city, waf.dst_domain, waf.dst_ip, waf.dst_latitude, waf.dst_longitude, waf.dst_port, waf.error_msg, waf.event_level, waf.event_log_level, waf.event_name, waf.event_type, waf.http_method, waf.http_refer, waf.is_truncated, waf.kv.Evt_level, waf.kv.Evt_type, waf.kv.event_name, waf.kv.http_method, waf.kv.http_refer, waf.kv.http_url, waf.kv.msg, waf.kv.owasp_top, waf.kv.pri, waf.kv.severity_level, waf.kv.status, waf.kv.type, waf.level, waf.log_category, waf.message, waf.message.action, waf.message.event, waf.message.method, waf.message.policy, waf.message.src_ip.geo.ip, waf.message.src_ip.geo.province, waf.message.src_port, waf.message.status, waf.message.threaten, waf.method, waf.module, waf.msg.act, waf.msg.cs, waf.msg.policy_id, waf.msg.src.geo.country, waf.policy_name, waf.proto, waf.referer, waf.risk_level, waf.severity, waf.src.geo.city, waf.src.geo.country, waf.src.geo.ip, waf.src.geo.isp, waf.src.geo.latitude, waf.src.geo.longitude, waf.src.geo.province, waf.src_ip, waf.src_port, waf.status, waf.status_code, waf.threat_level, waf.time, waf.ua_browser, waf.ua_device, waf.ua_os, waf.uri, waf.url, waf.user_agent.browser, waf.user_agent.os, waf.website_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "waf_imperva_数据，编写查询语句实现如下分析场景", "output": "starttime=\"now/d\" appname:waf tag:imperva AND waf.level:High|stats count()  by waf.level|append[[appname:waf tag:imperva AND waf.level:\"高\"|stats count() by waf.level]]"}
{"input": "waf放行事件总数。索引可用字段有：waf.action, waf.attack_name, waf.attack_type, waf.bytes_in, waf.cost, waf.cve_id, waf.dst_city, waf.dst_domain, waf.dst_ip, waf.dst_latitude, waf.dst_longitude, waf.dst_port, waf.error_msg, waf.event_level, waf.event_log_level, waf.event_name, waf.event_type, waf.http_method, waf.http_refer, waf.is_truncated, waf.kv.Evt_level, waf.kv.Evt_type, waf.kv.event_name, waf.kv.http_method, waf.kv.http_refer, waf.kv.http_url, waf.kv.msg, waf.kv.owasp_top, waf.kv.pri, waf.kv.severity_level, waf.kv.status, waf.kv.type, waf.level, waf.log_category, waf.message, waf.message.action, waf.message.event, waf.message.method, waf.message.policy, waf.message.src_ip.geo.ip, waf.message.src_ip.geo.province, waf.message.src_port, waf.message.status, waf.message.threaten, waf.method, waf.module, waf.msg.act, waf.msg.cs, waf.msg.policy_id, waf.msg.src.geo.country, waf.policy_name, waf.proto, waf.referer, waf.risk_level, waf.severity, waf.src.geo.city, waf.src.geo.country, waf.src.geo.ip, waf.src.geo.isp, waf.src.geo.latitude, waf.src.geo.longitude, waf.src.geo.province, waf.src_ip, waf.src_port, waf.status, waf.status_code, waf.threat_level, waf.time, waf.ua_browser, waf.ua_device, waf.ua_os, waf.uri, waf.url, waf.user_agent.browser, waf.user_agent.os, waf.website_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "waf_imperva_数据，编写查询语句实现如下分析场景", "output": "appname:waf AND tag:imperva waf.action:None|stats count() as cn by waf.action|append[[appname:waf AND tag:imperva waf.action:\"无\"|stats count() as cn by waf.action]]"}
{"input": "waf拦截总数。索引可用字段有：waf.action, waf.attack_name, waf.attack_type, waf.bytes_in, waf.cost, waf.cve_id, waf.dst_city, waf.dst_domain, waf.dst_ip, waf.dst_latitude, waf.dst_longitude, waf.dst_port, waf.error_msg, waf.event_level, waf.event_log_level, waf.event_name, waf.event_type, waf.http_method, waf.http_refer, waf.is_truncated, waf.kv.Evt_level, waf.kv.Evt_type, waf.kv.event_name, waf.kv.http_method, waf.kv.http_refer, waf.kv.http_url, waf.kv.msg, waf.kv.owasp_top, waf.kv.pri, waf.kv.severity_level, waf.kv.status, waf.kv.type, waf.level, waf.log_category, waf.message, waf.message.action, waf.message.event, waf.message.method, waf.message.policy, waf.message.src_ip.geo.ip, waf.message.src_ip.geo.province, waf.message.src_port, waf.message.status, waf.message.threaten, waf.method, waf.module, waf.msg.act, waf.msg.cs, waf.msg.policy_id, waf.msg.src.geo.country, waf.policy_name, waf.proto, waf.referer, waf.risk_level, waf.severity, waf.src.geo.city, waf.src.geo.country, waf.src.geo.ip, waf.src.geo.isp, waf.src.geo.latitude, waf.src.geo.longitude, waf.src.geo.province, waf.src_ip, waf.src_port, waf.status, waf.status_code, waf.threat_level, waf.time, waf.ua_browser, waf.ua_device, waf.ua_os, waf.uri, waf.url, waf.user_agent.browser, waf.user_agent.os, waf.website_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "waf_imperva_数据，编写查询语句实现如下分析场景", "output": "appname:waf AND tag:imperva waf.action:*lock|stats count() as cn by appname|append[[appname:waf AND tag:imperva waf.action:\"阻止\"|stats count() as cn by appname]]"}
{"input": "waf_yxlink_外网外国ip攻击情况。索引可用字段有：waf.action, waf.attack_name, waf.attack_type, waf.bytes_in, waf.cost, waf.cve_id, waf.dst_city, waf.dst_domain, waf.dst_ip, waf.dst_latitude, waf.dst_longitude, waf.dst_port, waf.error_msg, waf.event_level, waf.event_log_level, waf.event_name, waf.event_type, waf.http_method, waf.http_refer, waf.is_truncated, waf.kv.Evt_level, waf.kv.Evt_type, waf.kv.event_name, waf.kv.http_method, waf.kv.http_refer, waf.kv.http_url, waf.kv.msg, waf.kv.owasp_top, waf.kv.pri, waf.kv.severity_level, waf.kv.status, waf.kv.type, waf.level, waf.log_category, waf.message, waf.message.action, waf.message.event, waf.message.method, waf.message.policy, waf.message.src_ip.geo.ip, waf.message.src_ip.geo.province, waf.message.src_port, waf.message.status, waf.message.threaten, waf.method, waf.module, waf.msg.act, waf.msg.cs, waf.msg.policy_id, waf.msg.src.geo.country, waf.policy_name, waf.proto, waf.referer, waf.risk_level, waf.severity, waf.src.geo.city, waf.src.geo.country, waf.src.geo.ip, waf.src.geo.isp, waf.src.geo.latitude, waf.src.geo.longitude, waf.src.geo.province, waf.src_ip, waf.src_port, waf.status, waf.status_code, waf.threat_level, waf.time, waf.ua_browser, waf.ua_device, waf.ua_os, waf.uri, waf.url, waf.user_agent.browser, waf.user_agent.os, waf.website_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "WAF_铱迅数据，编写查询语句实现如下分析场景", "output": "appname:waf tag:yxlink NOT waf.src.geo.country:中国 NOT waf.src.geo.country:private NOT waf.src.geo.country:保留地址\n| stats count() by waf.src_ip,waf.src.geo.country\n|rename waf.src_ip as from,waf.src.geo.country as to\n|append [[\n\tappname:waf tag:yxlink NOT waf.src.geo.country:中国 NOT waf.src.geo.country:private NOT waf.src.geo.country:保留地址\n\t| stats count() by waf.src.geo.country,waf.event_name\n\t|rename waf.src_ip.geo.country as from,waf.event_name as to]] \n|append [[\n\t\tappname:waf tag:yxlink NOT waf.src.geo.country:中国 NOT waf.src.geo.country:private NOT waf.src.geo.country:保留地址\n\t| stats count() by waf.event_name,waf.action\n\t|rename waf.event_name as from,waf.action as to]]"}
{"input": "waf_yxlink_外网中国ip攻击情况。索引可用字段有：waf.action, waf.attack_name, waf.attack_type, waf.bytes_in, waf.cost, waf.cve_id, waf.dst_city, waf.dst_domain, waf.dst_ip, waf.dst_latitude, waf.dst_longitude, waf.dst_port, waf.error_msg, waf.event_level, waf.event_log_level, waf.event_name, waf.event_type, waf.http_method, waf.http_refer, waf.is_truncated, waf.kv.Evt_level, waf.kv.Evt_type, waf.kv.event_name, waf.kv.http_method, waf.kv.http_refer, waf.kv.http_url, waf.kv.msg, waf.kv.owasp_top, waf.kv.pri, waf.kv.severity_level, waf.kv.status, waf.kv.type, waf.level, waf.log_category, waf.message, waf.message.action, waf.message.event, waf.message.method, waf.message.policy, waf.message.src_ip.geo.ip, waf.message.src_ip.geo.province, waf.message.src_port, waf.message.status, waf.message.threaten, waf.method, waf.module, waf.msg.act, waf.msg.cs, waf.msg.policy_id, waf.msg.src.geo.country, waf.policy_name, waf.proto, waf.referer, waf.risk_level, waf.severity, waf.src.geo.city, waf.src.geo.country, waf.src.geo.ip, waf.src.geo.isp, waf.src.geo.latitude, waf.src.geo.longitude, waf.src.geo.province, waf.src_ip, waf.src_port, waf.status, waf.status_code, waf.threat_level, waf.time, waf.ua_browser, waf.ua_device, waf.ua_os, waf.uri, waf.url, waf.user_agent.browser, waf.user_agent.os, waf.website_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "WAF_铱迅数据，编写查询语句实现如下分析场景", "output": "appname:waf tag:yxlink waf.src.geo.country:中国 | stats count() by waf.src_ip,waf.src.geo.city|rename waf.src_ip as from,waf.src.geo.city as to|append [[appname:waf tag:yxlink waf.src.geo.country:中国 | stats count() by waf.src.geo.city,waf.event_name|rename waf.src.geo.city as from,waf.event_name as to]] |append [[appname:waf tag:yxlink waf.src.geo.country:中国 | stats count() by waf.event_name,waf.action|rename waf.event_name as from,waf.action as to]]"}
{"input": "waf_yxlink_内网攻击行为情况。索引可用字段有：waf.action, waf.attack_name, waf.attack_type, waf.bytes_in, waf.cost, waf.cve_id, waf.dst_city, waf.dst_domain, waf.dst_ip, waf.dst_latitude, waf.dst_longitude, waf.dst_port, waf.error_msg, waf.event_level, waf.event_log_level, waf.event_name, waf.event_type, waf.http_method, waf.http_refer, waf.is_truncated, waf.kv.Evt_level, waf.kv.Evt_type, waf.kv.event_name, waf.kv.http_method, waf.kv.http_refer, waf.kv.http_url, waf.kv.msg, waf.kv.owasp_top, waf.kv.pri, waf.kv.severity_level, waf.kv.status, waf.kv.type, waf.level, waf.log_category, waf.message, waf.message.action, waf.message.event, waf.message.method, waf.message.policy, waf.message.src_ip.geo.ip, waf.message.src_ip.geo.province, waf.message.src_port, waf.message.status, waf.message.threaten, waf.method, waf.module, waf.msg.act, waf.msg.cs, waf.msg.policy_id, waf.msg.src.geo.country, waf.policy_name, waf.proto, waf.referer, waf.risk_level, waf.severity, waf.src.geo.city, waf.src.geo.country, waf.src.geo.ip, waf.src.geo.isp, waf.src.geo.latitude, waf.src.geo.longitude, waf.src.geo.province, waf.src_ip, waf.src_port, waf.status, waf.status_code, waf.threat_level, waf.time, waf.ua_browser, waf.ua_device, waf.ua_os, waf.uri, waf.url, waf.user_agent.browser, waf.user_agent.os, waf.website_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "WAF_铱迅数据，编写查询语句实现如下分析场景", "output": "appname:waf tag:yxlink waf.src.geo.country:private \n| stats count() by waf.src_ip,waf.event_name\n|rename waf.src_ip as from,waf.event_name as to\n|append [[\n\tappname:waf tag:yxlink waf.src.geo.country:private \n\t| stats count() by waf.event_name,waf.action\n\t|rename waf.event_name as from,waf.action as to]]"}
{"input": "认证失败事件三级桑基图，从 nas ip 地址到 user，从 user 到分组名称，从分组名到认证失败代码，三层关系分别统计后 append 到一起。索引可用字段有：acs.acct_flags, acs.authen_failure_code, acs.author_data, acs.author_failure_code, acs.cmd, acs.event_name, acs.group_name, acs.nas_ip_address, acs.nas_portname, acs.service, acs.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "cisco_acs_数据，编写查询语句实现如下分析场景", "output": "appname:acs tag:cisco acs.event_name:认证失败事件|stats count() as cnt by acs.nas_ip_address,acs.user|rename acs.nas_ip_address as from,acs.user as to|append [[appname:acs tag:cisco acs.event_name:认证失败事件|stats count() as cnt by acs.user,acs.group_name|rename acs.user as from,acs.group_name as to]]|append [[appname:acs tag:cisco acs.event_name:认证失败事件|stats count() as cnt by acs.group_name,acs.authen_failure_code|rename acs.group_name as from,acs.authen_failure_code as to]]"}
{"input": "写入失败事件三级桑基图，从 nas ip 地址到 user，从 user 到 author_data， 从 author_data到author_failure_code，三层关系分别统计后 append 起来。索引可用字段有：acs.acct_flags, acs.authen_failure_code, acs.author_data, acs.author_failure_code, acs.cmd, acs.event_name, acs.group_name, acs.nas_ip_address, acs.nas_portname, acs.service, acs.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "cisco_acs_数据，编写查询语句实现如下分析场景", "output": "appname:acs tag:cisco acs.event_name:写入失败事件|stats count() as cnt by acs.nas_ip_address,acs.user|rename acs.nas_ip_address as from,acs.user as to|append [[appname:acs tag:cisco acs.event_name:写入失败事件|stats count() as cnt by acs.user,acs.author_data|rename acs.user as from,acs.author_data as to]]|append [[appname:acs tag:cisco acs.event_name:写入失败事件|stats count() as cnt by acs.author_data\t,acs.author_failure_code|rename acs.author_data\t as from,acs.author_failure_code as to]]"}
{"input": "windows进程连接关系。索引可用字段有：windows.EventData.Data, windows.IpAddress, windows.System.EventID.text, windows.System.Level, windows.System.Provider.Name, windows.event_type, windows.level, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "windows_process数据，编写查询语句实现如下分析场景", "output": "appname:windows tag:process process.local_addr:* process.proto:TCP process.state:ESTABLISHED|where process.foreign_addr!=process.local_addr|eval from=process.foreign_addr+\":\"+process.foreign_port|stats count() as cnt by from, process.local_addr|rename  process.local_addr as to |append [[appname:windows tag:process process.local_addr:* process.proto:TCP process.state:ESTABLISHED |where process.foreign_addr!=process.local_addr|stats count() as cnt by process.local_addr,process.local_port|rename process.local_addr as from,process.local_port as to]]|append [[appname:windows tag:process process.local_addr:* process.proto:TCP process.state:ESTABLISHED |where process.foreign_addr!=process.local_addr|eval t=process.pid|stats count() as cnt by process.local_port,t| rename t as pid |join type = left pid [[tag:tasklist |table tasklist.pid,tasklist.taskname|rename tasklist.pid as pid]] |eval to = pid+\":\"+tasklist.taskname|rename process.local_port as from |fields from,to,cnt]] "}
{"input": "堡垒机_shterm_登录成功用户连接情况。索引可用字段有：fortress.action, fortress.dst_ip, fortress.facility, fortress.host_ip, fortress.input, fortress.ip, fortress.level, fortress.log_type, fortress.loginOK, fortress.login_user, fortress.message, fortress.msg.action, fortress.msg.adlg_type, fortress.msg.begin_time, fortress.msg.command, fortress.msg.date, fortress.msg.mode, fortress.msg.module, fortress.msg.session_guid, fortress.msg.src_ip, fortress.msg.srcip, fortress.msg.srvaddr, fortress.msg.system_user, fortress.msg.sysuser, fortress.node, fortress.protocol, fortress.reason, fortress.remote_addr, fortress.request_msg, fortress.result, fortress.secondary_user, fortress.server, fortress.severity, fortress.src_ip, fortress.src_port, fortress.status, fortress.system_user, fortress.type, fortress.user, fortress.user_agent, fortress.user_name, fortress.username, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "堡垒机_shterm_数据，编写查询语句实现如下分析场景", "output": "appname:fortress tag:shterm fortress.type:sshd Accepted\n|stats count() by fortress.src_ip,fortress.src_port\n|rename fortress.src_ip as from,fortress.src_port as to\n|append  [[\n\tappname:fortress tag:shterm fortress.type:sshd Accepted\n\t|stats count() by fortress.src_port,fortress.username|rename fortress.src_port as from, fortress.username as to]]"}
{"input": "错误事件访问三级桑基图，从来源地址到请求方法，再到上游地址，最后到事件。。", "instruction": "pf_nginx数据，编写查询语句实现如下分析场景", "output": "appname:pf_nginx tag:error|stats count() as cnt by nginx.src_ip,nginx.method|rename nginx.src_ip as from,nginx.method as to|append [[appname:pf_nginx tag:error|stats count() as cnt by nginx.method,nginx.upstream|rename nginx.method as from,nginx.upstream as to]]|append [[appname:pf_nginx tag:error|stats count() as cnt by nginx.upstream,nginx.event|rename nginx.upstream as from,nginx.event as to]]"}
{"input": "源目ip连接。索引可用字段有：nta.Service_Name, nta.alert.action, nta.alert.category, nta.alert.metadata.former_category, nta.alert.severity, nta.alert.signature, nta.attack_name, nta.attack_type, nta.dest_ip, nta.dest_port, nta.dst.geo.city, nta.dst_ip, nta.dst_ip_city, nta.dst_port, nta.event_level, nta.event_name, nta.event_type, nta.flow.bytes_toclient, nta.flow.bytes_toserver, nta.kill_chain, nta.level, nta.login_user, nta.proto, nta.src.geo.city, nta.src.geo.country, nta.src.geo.province, nta.src_ip, nta.src_ip_city, nta.src_port, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "流量数据，编写查询语句实现如下分析场景", "output": "appname:nta tag:eve nta.src_ip:${src_ip} nta.dst_ip:${dst_ip} nta.dst_port:${dst_port} nta.proto:${proto}|stats count() as cnt by nta.src_ip,nta.dst_ip |rename nta.src_ip as from,nta.dst_ip as to |append [[appname:nta tag:eve nta.src_ip:${src_ip} nta.dst_ip:${dst_ip} nta.dst_port:${dst_port} nta.proto:${proto}|stats count() as cnt by nta.dst_ip,nta.dst_port|rename nta.dst_ip as from,nta.dst_port as to]]"}
{"input": "敏感文件下载。索引可用字段有：dlp.action, dlp.actionType, dlp.channelType, dlp.corporateType, dlp.details, dlp.dst_user, dlp.file_name, dlp.hostname, dlp.login_user, dlp.msg, dlp.policyNames, dlp.recv_mail, dlp.send_mail, dlp.service, dlp.severityType, dlp.src.geo.country, dlp.src_ip, dlp.src_user, dlp.user, dlp.workModeType, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "websense dlp数据，编写查询语句实现如下分析场景", "output": "appname:dlp tag:websense dlp.msg:\"download\" | stats count() as cnt by dlp.src_user,dlp.file_name | lookup desc sensitive_fname.csv on dlp.file_name=fname| where !empty(fname) | fields dlp.src_user,fname,desc,cnt| rename dlp.src_user as \"用户\",fname as \"敏感文件\",desc as \"文件详情\",cnt  as \"出现次数\" | append[[appname:dlp tag:websense dlp.msg:\"download\" | stats count() as cnt by dlp.dst_user,dlp.file_name | lookup desc sensitive_fname.csv on dlp.file_name=fname| where !empty(fname) | fields dlp.dst_user,fname,desc,cnt| rename dlp.dst_user as \"用户\",fname as \"敏感文件\",desc as \"文件详情\",cnt  as \"出现次数\"]]"}
{"input": "被访问的敏感系统记录。", "instruction": "h_poc数据，编写查询语句实现如下分析场景", "output": "appname:h_2 tag:h_2 \n| stats count() as cnt by h_1.uri,h_1.database_user,h_1.database_name,h_1.table_name\n|rename h_1.uri as url \n| join url[[\n\tappname:apache tag:access\n\t| rename middleware.referer as url \n\t|stats count() as cnt1 by url,middleware.clientip ]] \n| rename url as uri \n|lookup desc,u_ip h_url.csv on uri=url \n| fields url,h_1.database_user,middleware.clientip,desc,u_ip,h_1.database_name,h_1.table_name,cnt1\n| rename h_1.database_user as \"用户\",middleware.clientip as from,desc as \"系统名称\",u_ip as \"系统IP\",h_1.database_name as to,h_1.table_name as \"敏感表表名\"\n|append[[\n\t\tappname:h_2 tag:h_2 \n\t| stats count() as cnt by h_1.uri,h_1.database_user,h_1.database_name,h_1.table_name\n\t|rename h_1.uri as url \n\t| join url[[\n\t\t\tappname:apache tag:access\n\t\t| rename middleware.referer as url \n\t\t|stats count() as cnt1 by url,middleware.clientip ]] \n\t| rename h_1.database_user as \"用户\",middleware.clientip as \"源地址\",desc as \"系统名称\",u_ip as \"系统IP\",h_1.database_name as from,h_1.table_name as to]]"}
{"input": "安全策略占比。", "instruction": "联软终端控制数据，编写查询语句实现如下分析场景", "output": "appname:leagsoft tag:tc | stats count() as cnt by tc.msg.kv.strSecPolicyName|rename tc.msg.kv.strSecPolicyName as pn |append[[appname:leagsoft tag:tc | stats count() as cnt by tc.msg.kv.strpolicyname | rename tc.msg.kv.strpolicyname as pn]]"}
{"input": "事件触发最频繁机器TOP10。", "instruction": "联软终端控制数据，编写查询语句实现如下分析场景", "output": "appname:leagsoft tag:tc | stats count() as cnt by tc.msg.kv.strDevIP| rename tc.msg.kv.strDevIP as devip |append[[appname:leagsoft tag:tc | stats count() as cnt by tc.msg.kv.strdevip | rename tc.msg.kv.strdevip as devip]]|limit 10"}
{"input": "总攻击事件数。索引可用字段有：waf.action, waf.attack_name, waf.attack_type, waf.bytes_in, waf.cost, waf.cve_id, waf.dst_city, waf.dst_domain, waf.dst_ip, waf.dst_latitude, waf.dst_longitude, waf.dst_port, waf.error_msg, waf.event_level, waf.event_log_level, waf.event_name, waf.event_type, waf.http_method, waf.http_refer, waf.is_truncated, waf.kv.Evt_level, waf.kv.Evt_type, waf.kv.event_name, waf.kv.http_method, waf.kv.http_refer, waf.kv.http_url, waf.kv.msg, waf.kv.owasp_top, waf.kv.pri, waf.kv.severity_level, waf.kv.status, waf.kv.type, waf.level, waf.log_category, waf.message, waf.message.action, waf.message.event, waf.message.method, waf.message.policy, waf.message.src_ip.geo.ip, waf.message.src_ip.geo.province, waf.message.src_port, waf.message.status, waf.message.threaten, waf.method, waf.module, waf.msg.act, waf.msg.cs, waf.msg.policy_id, waf.msg.src.geo.country, waf.policy_name, waf.proto, waf.referer, waf.risk_level, waf.severity, waf.src.geo.city, waf.src.geo.country, waf.src.geo.ip, waf.src.geo.isp, waf.src.geo.latitude, waf.src.geo.longitude, waf.src.geo.province, waf.src_ip, waf.src_port, waf.status, waf.status_code, waf.threat_level, waf.time, waf.ua_browser, waf.ua_device, waf.ua_os, waf.uri, waf.url, waf.user_agent.browser, waf.user_agent.os, waf.website_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "WAF_F5数据，编写查询语句实现如下分析场景", "output": "appname:waf tag:f5 NOT waf.is_truncated:truncated NOT waf.attack_type:\"\" \n|stats count() as cnt \n|append[[\n\tappname:waf tag:f5  waf.is_truncated:truncated  \n\t|stats count() as cnt ]]\n|stats sum(cnt) as sum_"}
{"input": "攻击源地图。索引可用字段有：waf.action, waf.attack_name, waf.attack_type, waf.bytes_in, waf.cost, waf.cve_id, waf.dst_city, waf.dst_domain, waf.dst_ip, waf.dst_latitude, waf.dst_longitude, waf.dst_port, waf.error_msg, waf.event_level, waf.event_log_level, waf.event_name, waf.event_type, waf.http_method, waf.http_refer, waf.is_truncated, waf.kv.Evt_level, waf.kv.Evt_type, waf.kv.event_name, waf.kv.http_method, waf.kv.http_refer, waf.kv.http_url, waf.kv.msg, waf.kv.owasp_top, waf.kv.pri, waf.kv.severity_level, waf.kv.status, waf.kv.type, waf.level, waf.log_category, waf.message, waf.message.action, waf.message.event, waf.message.method, waf.message.policy, waf.message.src_ip.geo.ip, waf.message.src_ip.geo.province, waf.message.src_port, waf.message.status, waf.message.threaten, waf.method, waf.module, waf.msg.act, waf.msg.cs, waf.msg.policy_id, waf.msg.src.geo.country, waf.policy_name, waf.proto, waf.referer, waf.risk_level, waf.severity, waf.src.geo.city, waf.src.geo.country, waf.src.geo.ip, waf.src.geo.isp, waf.src.geo.latitude, waf.src.geo.longitude, waf.src.geo.province, waf.src_ip, waf.src_port, waf.status, waf.status_code, waf.threat_level, waf.time, waf.ua_browser, waf.ua_device, waf.ua_os, waf.uri, waf.url, waf.user_agent.browser, waf.user_agent.os, waf.website_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "WAF_F5数据，编写查询语句实现如下分析场景", "output": "appname:waf tag:f5 NOT waf.is_truncated:truncated NOT waf.attack_type:\"\" \n|stats count() as cnt by waf.src.geo.country,waf.src.geo.province,waf.src.geo.city\n|append[[\n\tappname:waf tag:f5  waf.is_truncated:truncated  \n\t|stats count() as cnt by waf.src.geo.country,waf.src.geo.province,waf.src.geo.city]]"}
{"input": "规则匹配结果分布。索引可用字段有：nas.dst_ip, nas.kv.Category, nas.kv.Match, nas.kv.Rule, nas.src_ip, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "nas_forescout数据，编写查询语句实现如下分析场景", "output": "appname:nas tag:forescout nas.kv.Match:*Match*|stats count() as cnt |eval line=\"匹配成功\"|append[[appname:nas tag:forescout nas.kv.Match:*Unmatch*|stats count() as cnt |eval line=\"匹配失败\"]]"}
{"input": "用户访问路径追踪。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "深信服零信任VPN数据，编写查询语句实现如下分析场景", "output": "appname:vpn AND tag:sangfor_0trust AND (vpn.event_name:auth OR vpn.event_name:login) vpn.user_name:${user} \n|stats count() as cnt by vpn.actor.displayName,vpn.src_ip\n|rename vpn.src_ip as to,vpn.actor.displayName as from\n|append[[appname:vpn AND tag:sangfor_0trust AND vpn.event_name:access* vpn.user_name:${user}  \n\t| stats count() as cnt by vpn.src_ip,vpn.app.upstream.host,vpn.app.upstream.port\n\t|eval dst=vpn.app.upstream.host+\":\"+vpn.app.upstream.port\n\t| rename vpn.src_ip as from,dst as to]]"}
{"input": "用户访问路径追踪。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "Cisco_VPN日志数据，编写查询语句实现如下分析场景", "output": "appname:vpn AND 'tag':cisco AND vpn.actype:login vpn.login_user:${user}|stats count() as cnt by vpn.src_ip|join vpn.src_ip[[appname:vpn AND 'tag':cisco AND vpn.actype:\"allocate vip\" vpn.login_user:${user}| stats count() as cnt by vpn.src_ip,vpn.msg.virtual_ip]]|rename vpn.src_ip as from,vpn.msg.virtual_ip as to|append[[appname:vpn AND 'tag':cisco AND vpn.actype:access* vpn.login_user:${user} | stats count() as cnt by vpn.src_ip,vpn.dst_ip,vpn.dst_port|eval dst=vpn.dst_ip+\":\"+vpn.dst_port | rename vpn.src_ip as from,dst as to]]"}
{"input": "威胁来源分布。", "instruction": "天际友盟威胁网关数据，编写查询语句实现如下分析场景", "output": "appname:leon tag:tjym NOT iocs.src.geo.country:中国  NOT iocs.src.geo.country:private\n| stats count() as cnt\n|eval line=\"境外或云服务器\"\n|append [[\n\tappname:leon tag:tjym  iocs.src.geo.country:中国 \n\t| stats count() as cnt\n\t|eval line=\"国内\"\n]]"}
{"input": "连接中断访问关系图，从netscaler.content.Source和netscaler.content.Destination字段里分别正则提取来源 IP 端口和目的 IP 端口，并展示最近 20 条数据。", "instruction": "CitrixNetscaler日志数据，编写查询语句实现如下分析场景", "output": "((* AND appname:citrix) AND tag:netscaler) AND 'netscaler.action':CONN_TERMINATE | parse field=netscaler.content.Source\t\"(?<srcip>\\d+\\.\\d+\\.\\d+\\.\\d+)\\:(?<srcport>\\d+)\"| limit 20\n|parse field=netscaler.content.Destination\t\"(?<dstip>\\d+\\.\\d+\\.\\d+\\.\\d+)\\:(?<dstport>\\d+)\"\n|stats count() as cnt by srcip,srcport | rename srcip as from ,srcport as to \n|append [[((* AND appname:citrix) AND tag:netscaler) AND 'netscaler.action':CONN_TERMINATE | parse field=netscaler.content.Source\t\"(?<srcip>\\d+\\.\\d+\\.\\d+\\.\\d+)\\:(?<srcport>\\d+)\"| limit 20\n|parse field=netscaler.content.Destination\t\"(?<dstip>\\d+\\.\\d+\\.\\d+\\.\\d+)\\:(?<dstport>\\d+)\"\n|stats count() as cnt by srcport ,dstip\n|rename srcport as from ,dstip as to]]\n|append [[((* AND appname:citrix) AND tag:netscaler) AND 'netscaler.action':CONN_TERMINATE | parse field=netscaler.content.Source\t\"(?<srcip>\\d+\\.\\d+\\.\\d+\\.\\d+)\\:(?<srcport>\\d+)\"| limit 20\n|parse field=netscaler.content.Destination\t\"(?<dstip>\\d+\\.\\d+\\.\\d+\\.\\d+)\\:(?<dstport>\\d+)\"\n|stats count() as cnt by dstip,dstport\n|rename dstip as from ,dstport as to]]"}
{"input": "从攻击源地址到目的地址和目的端口的访问关系统计，展示 200 条记录。索引可用字段有：waf.action, waf.attack_name, waf.attack_type, waf.bytes_in, waf.cost, waf.cve_id, waf.dst_city, waf.dst_domain, waf.dst_ip, waf.dst_latitude, waf.dst_longitude, waf.dst_port, waf.error_msg, waf.event_level, waf.event_log_level, waf.event_name, waf.event_type, waf.http_method, waf.http_refer, waf.is_truncated, waf.kv.Evt_level, waf.kv.Evt_type, waf.kv.event_name, waf.kv.http_method, waf.kv.http_refer, waf.kv.http_url, waf.kv.msg, waf.kv.owasp_top, waf.kv.pri, waf.kv.severity_level, waf.kv.status, waf.kv.type, waf.level, waf.log_category, waf.message, waf.message.action, waf.message.event, waf.message.method, waf.message.policy, waf.message.src_ip.geo.ip, waf.message.src_ip.geo.province, waf.message.src_port, waf.message.status, waf.message.threaten, waf.method, waf.module, waf.msg.act, waf.msg.cs, waf.msg.policy_id, waf.msg.src.geo.country, waf.policy_name, waf.proto, waf.referer, waf.risk_level, waf.severity, waf.src.geo.city, waf.src.geo.country, waf.src.geo.ip, waf.src.geo.isp, waf.src.geo.latitude, waf.src.geo.longitude, waf.src.geo.province, waf.src_ip, waf.src_port, waf.status, waf.status_code, waf.threat_level, waf.time, waf.ua_browser, waf.ua_device, waf.ua_os, waf.uri, waf.url, waf.user_agent.browser, waf.user_agent.os, waf.website_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "WAF_网御星云数据，编写查询语句实现如下分析场景", "output": "appname:waf tag:leadsec NOT (waf.Evt_level:非攻击事件 OR waf.kv.Evt_level:10) AND (NOT \"黑名单\" ) AND (waf.Evt_type:* OR waf.kv.Evt_type:*)\n| rename waf.* as *,kv.* as *  \n| stats count() as cnt by src_ip,dst_ip|rename src_ip as from,dst_ip as to | append[[appname:waf tag:leadsec NOT (waf.Evt_level:非攻击事件 OR waf.kv.Evt_level:10) AND (NOT \"黑名单\" ) AND (waf.Evt_type:* OR waf.kv.Evt_type:*)\n| rename waf.* as *,kv.* as *  \n| stats count() as cnt by dst_ip,dst_port|rename dst_ip as from,dst_port as to]] |limit 200"}
{"input": "攻击源地址到目的地址和目的端口的统计排名前 200 条结果。索引可用字段有：ids.action, ids.attack_name, ids.attack_type, ids.brief, ids.dst_ip, ids.dst_port, ids.event_level, ids.event_name, ids.kv.event_name, ids.level, ids.login_user, ids.module, ids.msg, ids.proto, ids.severity_id, ids.signature, ids.src.geo.city, ids.src_ip, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "网御星云ids日志数据，编写查询语句实现如下分析场景", "output": "appname:ids tag:leadsec NOT (ids.event_level:非攻击事件 OR ids.level:10) AND (NOT \"黑名单\" ) AND (ids.event_name:* OR ids.kv.event_name:*)\n| rename ids.* as *,kv.* as *  \n| stats count() as cnt by src_ip,dst_ip|rename src_ip as from,dst_ip as to | append[[appname:ids tag:leadsec NOT (ids.event_level:非攻击事件 OR ids.level:10) AND (NOT \"黑名单\" ) AND (ids.event_name:* OR ids.kv.event_name:*)\n| rename ids.* as *,kv.* as *  \n| stats count() as cnt by dst_ip,dst_port|rename dst_ip as from,dst_port as to]] |limit 200"}
{"input": "", "instruction": "sdc上传成功率。计算总数量和 code 等于零的数量，通过 appendcols 命令放到同一行内，二者相除。", "output": "appname:sdc msg:*  |stats count() as cnt1  | appendcols [[appname:sdc msg:* |where code==0 |stats count() as cnt2 ]]  |eval per=cnt2/cnt1"}
{"input": "索引可用字段有：aix.class_dec, aix.dst_host, aix.facility, aix.login_time, aix.login_way, aix.net, aix.resource_name, aix.severity, aix.span_h, aix.span_m, aix.src_ip, aix.src_port, aix.type, aix.type_dec, aix.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "aix异常IP登录列表_IP在黑名单列表中则认为是异常IP", "output": "tag:last appname:aix | stats count(hostname) as count_ by hostname,aix.user,aix.type,timestamp,aix.span_h,aix.span_m,aix.src_ip,aix.net |eval login_date = formatdate(timestamp)  |lookup ip blacklist_ip.csv on aix.net=ip |eval bl_ip =if(empty(ip),0,1)  |where bl_ip >0  |eval span_h=(todouble(aix.span_h))*3600 |eval span_m=(todouble(aix.span_m))*60 |eval login_cost=span_h+span_m  |fields hostname,aix.user,aix.type,login_date,login_cost,aix.src_ip |rename hostname as login_host, aix.user as login_user, aix.way as login_way, aix.span_m as login_cost, aix.src_ip as login_srcip |eval line=\"line1\" |append [[tag:who | stats count(hostname) by hostname,aix.user,aix.type,aix.login_time,aix.src_ip,aix.net  |lookup ip ip.csv on aix.net=ip |eval bl_ip =if(empty(ip),0,1)  |where bl_ip >0 |fields hostname,aix.user,aix.type,aix.login_time,aix.src_ip |rename hostname as login_host, aix.user as login_user, aix.type as login_way, aix.login_time as login_date, aix.src_ip as login_srcip |eval line=\"line2\"]] |fields login_host,login_user,login_way,login_cost,login_srcip,login_date |rename login_host as \"登录主机\", login_user as \"登录用户\", login_way as  \"登录方式\", login_srcip as \"登录ip\", login_cost as \"登录时长_秒\", login_date as \"登录时间\""}
{"input": "异常IP登录列表_IP在黑名单列表中则认为是异常IP。", "instruction": "aix日志数据，编写查询语句实现如下分析场景", "output": "tag:last appname:aix\n| stats count(hostname) as count_ by hostname,aix.user,aix.type,timestamp,aix.span_h,aix.span_m,aix.src_ip,aix.net\n|eval login_date = formatdate(timestamp) \n|lookup ip ip.csv on aix.net=ip\n|eval bl_ip =if(empty(ip),0,1) \n|where bl_ip >0\n\n|eval span_h=(todouble(aix.span_h))*3600\n|eval span_m=(todouble(aix.span_m))*60\n|eval login_cost=span_h+span_m\n\n|fields hostname,aix.user,aix.type,login_date,login_cost,aix.src_ip |rename hostname as login_host, aix.user as login_user, aix.way as login_way, aix.span_m as login_cost, aix.src_ip as login_srcip\n|eval line=\"line1\"\n|append [[tag:who\n| stats count(hostname) by hostname,aix.user,aix.type,aix.login_time,aix.src_ip,aix.net \n|lookup ip ip.csv on aix.net=ip\n|eval bl_ip =if(empty(ip),0,1) \n|where bl_ip >0\n|fields hostname,aix.user,aix.type,aix.login_time,aix.src_ip |rename hostname as login_host, aix.user as login_user, aix.type as login_way, aix.login_time as login_date, aix.src_ip as login_srcip\n|eval line=\"line2\"]]\n|fields login_host,login_user,login_way,login_cost,login_srcip,login_date, login_host as \"登录主机\", login_user as \"登录用户\", login_way as  \"登录方式\", login_srcip as \"登录ip\", login_cost as \"登录时长_秒\", login_date as \"登录时间\""}
{"input": "交换机端口速率模式状态分析。索引可用字段有：switch.IP, switch.action, switch.auth_method, switch.bandwidth, switch.brief, switch.cmd, switch.count, switch.desc, switch.desc.cmd, switch.desc.user, switch.describe, switch.ethernet, switch.event_type, switch.facility, switch.host, switch.host_ip, switch.interface_name, switch.ip, switch.kv.COMMAND, switch.kv.TTY, switch.kv.USER, switch.kvmsg.IpAddress, switch.kvmsg.UserName, switch.level, switch.log_message, switch.log_type, switch.login_method, switch.mode, switch.module, switch.port, switch.port_channel, switch.reason, switch.result, switch.severity, switch.speed, switch.src_ip, switch.src_mac, switch.state, switch.terminal, switch.time, switch.user, switch.vlan, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "交换机_cisco_nexus数据，编写查询语句实现如下分析场景", "output": "appname:switch AND tag:cisco_nexus AND  ETHPORT-5-IF_UP |stats count() by switch.port_channel,switch.state |rename switch.port_channel as from,switch.state as to |append [[appname:switch AND tag:cisco_nexus AND  ETHPORT-5-IF_UP |stats count() by switch.state,switch.mode |rename switch.state as  from,switch.mode as to]] |append [[appname:switch AND tag:cisco_nexus AND  ETHPORT-5-SPEED |stats count() by switch.ethernet,switch.speed |rename switch.ethernet as to,switch.speed as from]]"}
{"input": "认证失败时间IP方式统计。索引可用字段有：switch.IP, switch.action, switch.auth_method, switch.bandwidth, switch.brief, switch.cmd, switch.count, switch.desc, switch.desc.cmd, switch.desc.user, switch.describe, switch.ethernet, switch.event_type, switch.facility, switch.host, switch.host_ip, switch.interface_name, switch.ip, switch.kv.COMMAND, switch.kv.TTY, switch.kv.USER, switch.kvmsg.IpAddress, switch.kvmsg.UserName, switch.level, switch.log_message, switch.log_type, switch.login_method, switch.mode, switch.module, switch.port, switch.port_channel, switch.reason, switch.result, switch.severity, switch.speed, switch.src_ip, switch.src_mac, switch.state, switch.terminal, switch.time, switch.user, switch.vlan, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "交换机_cisco_nexus数据，编写查询语句实现如下分析场景", "output": "appname:switch AND tag:cisco_nexus AND AUTHPRIV-3-SYSTEM_MSG |stats count() by switch.time,switch.ip |rename switch.time as from,switch.ip as to |append [[appname:switch AND tag:cisco_nexus AND AUTHPRIV-3-SYSTEM_MSG |stats count() by switch.ip,switch.auth_method |rename switch.ip as from,switch.auth_method as to]]"}
{"input": "1. 从dlp中提取src_ip,重命名为src,并统计count\n2. 从h_1中提取local_ip和src_ip,重命名为dst_ip和src,join到第1步的结果,并统计count\n3. 从h_1中过滤local_ip=2.1.1.11,提取local_ip和src_ip,重命名为dst_ip和src,join到第2步的结果,并统计count \n4. 从h_1中过滤NOT local_ip=2.1.1.11,提取local_ip和src_ip,重命名为dst_ip和src,join到第3步的结果,eval from=\"综合前置\",重命名de为to\n5. 从h_1中过滤NOT local_ip=2.1.1.11,提取local_ip和src_ip,重命名为dst_ip和src,join到第4步的结果\n6. 从apache中提取clientip和referer,join到第5步的结果,重命名middleware.referer为to,de为from\n7. 从h_2中提取uri、SQL和database_name,join到第6步的结果,lookup dbname.csv,重命名h_1.uri为from,name为to \n8. 从h_2中提取uri、SQL和database_name,join到第7步的结果,eval all=name+\"-> \"+h_1.SQL,重命名name为from,all为to \n9. 从h_2中提取uri、SQL和database_name,filter tag=\"oral2\",join到第8步的结果,eval from=\"前置数据库\",重命名name为to\n10. 从h_2中提取uri、SQL和database_name,filter tag=\"oral2\",join到第9步的结果,eval all=name+\"-> \"+h_1.SQL,重命名name为from,all为to。索引可用字段有：dlp.action, dlp.actionType, dlp.channelType, dlp.corporateType, dlp.details, dlp.dst_user, dlp.file_name, dlp.hostname, dlp.login_user, dlp.msg, dlp.policyNames, dlp.recv_mail, dlp.send_mail, dlp.service, dlp.severityType, dlp.src.geo.country, dlp.src_ip, dlp.src_user, dlp.user, dlp.workModeType, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "企业bg数据查询分析实现敏感SQL溯源", "output": "appname:dlp tag:websense\n|rename dlp.src_ip as src\n| stats count() as cnt by src \n|join src[[\n appname:h_1 \n |rename h_1.loacl_ip as dst_ip,h_1.src_ip as src\n |stats count() as cnt by dst_ip,src\n |lookup de webip.csv on dst_ip=ipaddr]]\n|append[[\n  appname:h_1 (h_1.loacl_ip:\"2.1.1.11\")\n |rename h_1.loacl_ip as dst_ip,h_1.src_ip as src\n |stats count() as cnt by dst_ip,src\n |lookup de webip.csv on dst_ip=ipaddr ]]\n|rename src as from,de as to\n|append[[\n   appname:h_1 (NOT h_1.loacl_ip:\"2.1.1.11\")\n |rename h_1.loacl_ip as dst_ip,h_1.src_ip as src\n |stats count() as cnt by dst_ip,src\n |lookup de webip.csv on dst_ip=ipaddr \n |eval from=\"综合前置\"\n |rename de as to ]]\n|append[[\n    appname:h_1 (NOT h_1.loacl_ip:\"2.1.1.11\")\n |rename h_1.loacl_ip as dst_ip,h_1.src_ip as src\n |stats count() as cnt by dst_ip,src\n |lookup de webip.csv on dst_ip=ipaddr \n |rename src as from,de as to]]\n|append[[\n     appname:apache tag:access \n |stats count() as cnt by middleware.clientip,middleware.referer\n |lookup de webip.csv on middleware.clientip=ipaddr\n |rename middleware.referer as to,de as from ]]\n|append[[\n      appname:h_2 tag:h_2 \"oral1\"\n | stats count() as cnt by h_1.uri,h_1.SQL,h_1.database_name \n | lookup name dbname.csv on h_1.database_name=db \n | rename h_1.uri as from ,name as to ]]\n|append[[\n       appname:h_2 tag:h_2 \"oral1\"\n | stats count() as cnt by h_1.uri,h_1.SQL,h_1.database_name \n | lookup name dbname.csv on h_1.database_name=db \n |eval all=name+\"-> \"+h_1.SQL\n | rename name  as from ,all as to ]]\n|append[[\n        appname:h_2 tag:h_2 \"oral2\"\n | stats count() as cnt by h_1.uri,h_1.SQL,h_1.database_name \n | lookup name dbname.csv on h_1.database_name=db \n |eval all=name+\"-> \"+h_1.SQL\n |eval from=\"前置数据库\"\n | rename name as to ]]\n|append[[\n         appname:h_2 tag:h_2 \"oral2\"\n | stats count() as cnt by h_1.uri,h_1.SQL,h_1.database_name \n | lookup name dbname.csv on h_1.database_name=db \n |eval all=name+\"-> \"+h_1.SQL\n | rename name as from,all as to ]]"}
{"input": "1. 首先过滤掉h_1.loacl_ip=2.1.1.11的数据\n2. 重命名h_1.loacl_ip为dst_ip,h_1.src_ip为src\n3. 根据dst_ip统计cnt计数,并join webip.csv表获取dst_ip对应的to信息\n4. 给首个查询语句添加appname:apache tag:access和from=\"综合前置\"字段\n5. 之后有5个append查询语句,分别:\n- 根据middleware.clientip和middleware.referer统计cnt计数,join h_url.csv和webip.csv获取to和from信息\n- 根据middleware.referer统计cnt计数,join h_url.csv获取from和to信息\n- 根据middleware.referer过滤u_ip=2.1.1.3,设置to信息,获取from信息\n- 根据middleware.referer过滤u_ip=2.1.1.2,设置to信息,获取from信息 \n- 根据middleware.referer过滤u_ip=2.1.1.1,设置to信息,获取from信息 \n- 根据middleware.referer过滤u_ip=2.1.1.1,设置to信息,获取from信息 \n- 根据middleware.referer过滤u_ip=2.1.1.4,设置to信息,获取from信息\n6. 最后将6个查询结果append在一起。索引可用字段有：apache.clientip, apache.domain, apache.geo.country, apache.geo.isp, apache.method, apache.referer, apache.request_path, apache.request_query, apache.resp_time, apache.status, apache.ua, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "企业bg数据敏感文件溯源", "output": "appname:h_1 (NOT h_1.loacl_ip:\"2.1.1.11\")\n|rename h_1.loacl_ip as dst_ip,h_1.src_ip as src\n|stats count() as cnt by dst_ip,src\n|lookup de webip.csv on dst_ip=ipaddr \n|eval from=\"综合前置\"\n|rename de as to \n|append[[\n  appname:apache tag:access \n |stats count() as cnt by middleware.clientip,middleware.referer \n |lookup url h_url.csv on middleware.referer=url \n |lookup de webip.csv on middleware.clientip=ipaddr \n |rename url as to,de as from  ]]\n|append[[\n    appname:apache tag:access \n |stats count() as cnt by middleware.referer \n |lookup u_ip h_url.csv on middleware.referer=url \n |rename url as from,u_ip as to  ]] \n|append[[\n      appname:apache tag:access  \n |stats count() as cnt by middleware.referer \n |lookup u_ip h_url.csv on middleware.referer=url \n |where u_ip==\"2.1.1.3\"\n |eval to=\"/data/rizhiyi/mysql/account/account.myd\" \n |rename u_ip as from ]]\n|append[[\n       appname:apache tag:access  \n |stats count() as cnt by middleware.referer \n |lookup u_ip h_url.csv on middleware.referer=url \n |where u_ip==\"2.1.1.2\"\n |eval to=\"C:\\\\Program Files (x86)\\\\Sangfor\\\\SSL\\\\Backup\\\\user.csv\" \n |rename u_ip as from ]]\n|append[[\n        appname:apache tag:access  \n |stats count() as cnt by middleware.referer \n |lookup u_ip h_url.csv on middleware.referer=url \n |where u_ip==\"2.1.1.1\"\n |eval to=\"D:\\\\Files\\\\financial\\\\compensation.xlxs\" \n |rename u_ip as from ]]\n|append[[\n         appname:apache tag:access  \n |stats count() as cnt by middleware.referer \n |lookup u_ip h_url.csv on middleware.referer=url \n |where u_ip==\"2.1.1.1\"\n |eval to=\"D:\\\\Files\\\\financial\\\\Q1\\\\financial_statement.xlxs\" \n |rename u_ip as from ]]\n|append[[\n         appname:apache tag:access  \n |stats count() as cnt by middleware.referer \n |lookup u_ip h_url.csv on middleware.referer=url \n |where u_ip==\"2.1.1.4\"\n |eval to=\"D:\\\\Files\\\\financial\\\\Q2\\\\financial_statement.xlxs\" \n |rename u_ip as from ]]"}
{"input": "\n1. 查询appname为dlp,tag为websense的数据,将dlp.src_ip重命名为src,按src进行分组统计count()的值,得到每台源IP访问次数\n2. 查询appname为h_1的数据,将h_1.local_ip重命名为dst_ip,h_1.src_ip重命名为src,按dst_ip和src进行分组统计count()的值,得到每个目的IP和源IP的访问次数,然后在webip.csv中根据dst_ip查ipaddr值,得到to字段\n3. 对步骤2的结果进行补充,对h_1.local_ip不等于\"2.1.1.11\"的记录,src重命名为from,de重命名为to,from设置为\"综合前置\"\n4. 对步骤3的结果再进行补充,对h_1.local_ip不等于\"2.1.1.11\"的记录,src重命名为from,de重命名为to\n5. 查询appname为apache,tag为access的数据,按middleware.clientip和middleware.request_path进行分组统计count()的值,然后在api_list.csv中根据middleware.request_path查api的值,在webip.csv中根据middleware.clientip查ipaddr的值,得到from和to字段,只保留api不为空的记录\n6. 将上述5个步骤的结果组合在一起,得到最终的from和to映射关系\n。索引可用字段有：dlp.action, dlp.actionType, dlp.channelType, dlp.corporateType, dlp.details, dlp.dst_user, dlp.file_name, dlp.hostname, dlp.login_user, dlp.msg, dlp.policyNames, dlp.recv_mail, dlp.send_mail, dlp.service, dlp.severityType, dlp.src.geo.country, dlp.src_ip, dlp.src_user, dlp.user, dlp.workModeType, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "企业bg数据查询分析实现敏感api溯源分析", "output": "appname:dlp tag:websense\n|rename dlp.src_ip as src\n| stats count() as cnt by src \n|join src[[\n\tappname:h_1 \n\t|rename h_1.loacl_ip as dst_ip,h_1.src_ip as src\n\t|stats count() as cnt by dst_ip,src \n\t|lookup de webip.csv on dst_ip=ipaddr ]]|append[[\n\t\tappname:h_1 (h_1.loacl_ip:\"2.1.1.11\")\n\t|rename h_1.loacl_ip as dst_ip,h_1.src_ip as src\n\t|stats count() as cnt by dst_ip,src\n\t|lookup de webip.csv on dst_ip=ipaddr ]]\n|rename src as from,de as to\n|append[[\n\t\t\tappname:h_1 (NOT h_1.loacl_ip:\"2.1.1.11\")\n\t|rename h_1.loacl_ip as dst_ip,h_1.src_ip as src\n\t|stats count() as cnt by dst_ip,src\n\t|lookup de webip.csv on dst_ip=ipaddr \n\t|eval from=\"综合前置\"\n\t|rename de as to ]]\n|append[[\n\t\t\t\tappname:h_1 (NOT h_1.loacl_ip:\"2.1.1.11\")\n\t|rename h_1.loacl_ip as dst_ip,h_1.src_ip as src\n\t|stats count() as cnt by dst_ip,src\n\t|lookup de webip.csv on dst_ip=ipaddr \n\t|rename src as from,de as to]]\n|append[[\n\t\tappname:apache tag:access\n\t|stats count() as cnt by middleware.clientip,middleware.request_path\n\t| lookup api api_list.csv on middleware.request_path=api\n\t|lookup de webip.csv on middleware.clientip=ipaddr\n\t|where !empty(api)  \n\t|rename de as from,api as to ]]"}
{"input": "防火墙访问关系，统计来源地址和端口，到目标端口的数据。然后追加目标端口到目标地址的统计数据。最后 limit 取前 200 条。。索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "天融信防火墙日志数据，编写查询语句实现如下分析场景", "output": "appname:firewall AND tag:topsec  | stats count() as cnt by firewall.src_ip,firewall.src_port,firewall.dst_port|eval from=firewall.src_ip+\":\"+firewall.src_port | eval to=firewall.dst_port|append [[appname:firewall AND tag:topsec  | stats count() as cnt by firewall.dst_ip,firewall.dst_port|eval from=firewall.dst_port|eval to=firewall.dst_ip]]|limit 200"}
{"input": "威胁TOP10。索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "防火墙_hillstone数据，编写查询语句实现如下分析场景", "output": "(* IPS) AND tag:hillstone |stats count() as total by 'firewall.msg.msg.威胁名称' \n|rename 'firewall.msg.kvs.威胁名称' as event| limit 10\n|append[[\n\t (* IPS) AND appname:firewall tag:hillstone \n\t|stats count() as total by firewall.event_name\n\t|rename firewall.event_name as event |limit 10]]"}
{"input": "触发告警事件TOP10。索引可用字段有：dbaudit.alert_type, dbaudit.app_name, dbaudit.dataSubType, dbaudit.databaseName, dbaudit.dst_ip, dbaudit.dst_port, dbaudit.level, dbaudit.payload, dbaudit.rule, dbaudit.ruleName, dbaudit.rule_name, dbaudit.src_ip, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "安恒数据库审计数据，编写查询语句实现如下分析场景", "output": "(appname:dbaudit AND tag:dbappsecurity) \n| stats count() as cnt by dbaudit.rule_name\n|where len(dbaudit.rule_name)>1\n|rename dbaudit.rule_name as rule_name\n|limit 10\n|append[[\n\t(appname:dbaudit AND tag:dbappsecurity) \n\t| stats count() as cnt by dbaudit.ruleName\n\t|where len(dbaudit.ruleName)>1\n\t|rename dbaudit.ruleName as rule_name\n\t|limit 10]]"}
{"input": "银联前置-成功率指标。", "instruction": "查询银联前置(cupp)系统数据，进行如下统计", "output": "sourcetype:cupp |stats count(retcode) as total  |appendcols [[ appname:cupp NOT retcode:0000000|stats count(retcode) as faile  ]] |eval _rate=abs(total-faile)/total*100"}
{"input": "h3c_imc_事件详情。索引可用字段有：imc.desc, imc.event_level, imc.level, imc.message, imc.src_ip, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "h3c_imc_数据，编写查询语句实现如下分析场景", "output": "appname:imc  | stats count() as cnt by imc.src_ip,imc.level,imc.desc|fields imc.src_ip,imc.level,imc.desc | rename imc.src_ip as \"设备IP\",imc.level as \"事件等级\",imc.desc as \"事件详情\"|append[[appname:imc AND | stats count() as cnt by imc.src_ip,imc.event_level,imc.message|fields imc.src_ip,imc.event_level,imc.message|sort by +imc.event_level | rename imc.src_ip as \"设备IP\",imc.event_level as \"事件等级\",imc.message as \"事件详情\"]]"}
{"input": "单个网络设备端口流量曲线图，从 switchperf 类型日志中搜索最近 1 条网卡ifdescr数据，通过 map 指令传递获取这个 ifdescr 对应的 ifindex 和 value；然后用 map 指令传递获取这个 ifindex 的 ifInOctets 和 ifOutOctets 数据，按 5 分钟趋势统计 switchperf.value 流量值的总和，并使用 autoregress获取相邻日志相减，分别得到进、出和总的bps实时流量。注意流量值会溢出重计数，需要判断。索引可用字段有：switchperf.devip, switchperf.ifindex, switchperf.type, switchperf.value, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "网络设备接口数据数据，编写查询语句实现如下分析场景", "output": "appname:switchperf | limit 1| eval aaa=\"ifdescr\" | parse field=aaa \"(?<ifdescr>[^\\_]+)\" | map \"appname:switchperf switchperf.type:ifDescr switchperf.value:\"$ifdescr$\" | stats count() by switchperf.ifindex,switchperf.value | rename switchperf.ifindex as ifindex | rename switchperf.value as value | eval value=tostring(value)\"\n| map \n\"appname:switchperf AND switchperf.type:ifInOctets switchperf.ifindex:$ifindex$ | bucket timestamp span=5m as ts | stats sum(switchperf.value) as _totalOctets by ts,switchperf.devip,switchperf.ifindex  | sort by switchperf.ifindex,+ts | autoregress _totalOctets as last_totalOctets p=1 | autoregress switchperf.ifindex as lastifindex p=1 | where\tswitchperf.ifindex==lastifindex | eval Bps=case(_totalOctets-last_totalOctets<0,(_totalOctets-last_totalOctets+4294967296)/300,default,(_totalOctets-last_totalOctets)/300) | eval Bps=tolong(Bps) | eval type=\"InBps\" | eval ifdescr=\"$value$\"\n| append\n[[appname:switchperf AND switchperf.type:ifOutOctets switchperf.ifindex:$ifindex$ | bucket timestamp span=5m as ts | stats sum(switchperf.value) as _totalOctets by ts,switchperf.devip,switchperf.ifindex  | sort by switchperf.ifindex,+ts | autoregress _totalOctets as last_totalOctets p=1 | autoregress switchperf.ifindex as lastifindex p=1 | where\tswitchperf.ifindex==lastifindex | eval Bps=case(_totalOctets-last_totalOctets<0,(_totalOctets-last_totalOctets+4294967296)/300,default,(_totalOctets-last_totalOctets)/300) | eval Bps=tolong(Bps) | eval type=\"OutBps\" | eval ifdescr=\"$value$\"]]\n| append\n[[appname:switchperf AND switchperf.ifindex:$ifindex$ AND (switchperf.type:ifOutOctets OR switchperf.type:ifInOctets)| bucket timestamp span=5m as ts | stats sum(switchperf.value) as _totalOctets by ts,switchperf.devip,switchperf.ifindex,switchperf.type | sort by switchperf.ifindex,switchperf.type,+ts | autoregress _totalOctets as last_totalOctets p=1 | autoregress switchperf.ifindex as lastifindex p=1 | autoregress switchperf.type as lasttype p=1 | where switchperf.ifindex==lastifindex| where switchperf.type==lasttype | eval Bps=case(_totalOctets-last_totalOctets<0,(_totalOctets-last_totalOctets+4294967296)/300,default,(_totalOctets-last_totalOctets)/300) | eval Bps=tolong(Bps)| stats sum(Bps) as Bps by ts,switchperf.devip,switchperf.ifindex | eval type=\"TotalBps\" | eval ifdescr=\"$value$\"]]\""}
{"input": "计算方法如下：1. 针对VPN登录失败事件,判断失败次数,如果超过某个阈值,则标记为“疑似暴力破解”,并给予相应的分数,失败次数越多,分数越低。\n2. 针对VPN登录事件,判断同一个用户从不同地理位置登录的次数,如果超过某个阈值,则标记为“疑似账号共用”,并给予相应的分数,共用次数越多,分数越低。\n3. 针对VPN登录事件,判断非中国IP和非私有IP登录的次数,如果超过某个阈值,则标记为“账号登录异常”,并给予相应的分数,异常次数越多,分数越低。\n4. 针对VPN登录事件,判断在18点以后和8点以前的登录次数,如果超过某个阈值,则标记为“异常时间登录”,并给予相应的分数,异常次数越多,分数越低。\n5. 针对VPN资源访问失败事件,如果有1次失败记录,则标记为“异常访问系统”,并给相应的分数。\n6. 根据各个事件给出的分数,计算每个用户的总分和相应的风险等级。\n7. 输出结果,显示每个用户的风险状况,存在的可操作事件,健康评分和风险等级。。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "VPN用户账号操作异常评分", "output": "appname:vpn vpn.login_user:* vpn.actype:login vpn.result:failure  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,0,cnt==2,10,cnt==3,15,cnt>4,20,default,20) |append [[ appname:vpn vpn.login_user:*  vpn.actype:login  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,0,cnt==2,10,cnt>=3,20,default,20) ]] |append [[ appname:vpn vpn.login_user:*  vpn.actype:login  (NOT vpn.src_ip.geo.country:private)   (NOT vpn.src_ip.geo.country:中国)  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,15,cnt>=4,20,default,20) ]] |append [[ appname:vpn vpn.login_user:*  vpn.actype:login|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,15,cnt>=4,20,default,20) ]] |append [[ appname:vpn vpn.login_user:*  vpn.actype:\"access resource\" vpn.login_user:* (NOT vpn.result:success) vpn.result:*|limit 1|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,15,cnt>=4,20,default,20) ]] |stats sum(aaa) as total by vpn.login_user,app1 | eval final=100-total  |mvcombine sep=\"/\" app1 |sort by +final |fields vpn.login_user,app1,final  | eval level=if(final==100,\"健康\",if(final>=80,\"轻危\",if(final>=60,\"中危\",if(final<60,\"高危\",null))))|rename vpn.login_user as \"用户名\",app1 as \"存在的可以操作\",final as \"健康评分\",level as \"危险等级\""}
{"input": "用户账号操作异常评分，展示最新 1 条。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "深信服VPN日志数据，编写查询语句实现如下分析场景", "output": "appname:vpn vpn.login_user:* vpn.actype:login vpn.result:failure  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,0,cnt==2,20,cnt==3,30,cnt>=4,50,default,20)\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==2,20,cnt>=3,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login  (NOT vpn.src.geo.country:private)   (NOT vpn.src.geo.country:中国)  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,30,cnt==2,40,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:\"access resource\" vpn.login_user:* (NOT vpn.result:success) vpn.result:*|limit 1|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|stats sum(aaa) as all by vpn.login_user|sort by all|where all!=0\n|fields vpn.login_user,app1,all \n| eval level=if(all==0,\"健康\",if(all>=80,\"高危\",if(all>=60,\"中危\",if(all<60,\"危\",null))))|rename vpn.login_user as \"用户名\",app1 as \"存在的可以操作\",all as \"威胁评分\",level as \"危险等级\""}
{"input": "用户账号操作异常评分。分别过滤疑似暴力破解、账号共用、国外 IP 登录、异常时间段登录、访问系统异常的情况，按规则给出评分，规则是一条记录0 分，两条记录 10 分，大于三条 20 分。然后用 append 追加在一起，然后分组统计评分总数，用 100 减去总分就是最后健康评分。并按最终健康评分做低中高危等级判定。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "sangfor_vpn数据，编写查询语句实现如下分析场景", "output": "appname:vpn vpn.login_user:* vpn.actype:login vpn.result:failure  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,0,cnt==2,10,cnt==3,15,cnt>4,20,default,20)\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,0,cnt==2,10,cnt>=3,20,default,20)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login  (NOT vpn.src_ip.geo.country:private)   (NOT vpn.src_ip.geo.country:中国)  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,15,cnt>=4,20,default,20)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,15,cnt>=4,20,default,20)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:\"access resource\" vpn.login_user:* (NOT vpn.result:success) vpn.result:*|limit 1|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,15,cnt>=4,20,default,20)\n]]\n|stats sum(aaa) as total by vpn.login_user,app1\n| eval final=100-total \n|mvcombine sep=\"/\" app1\n|sort by +final\n|fields vpn.login_user,app1,final \n| eval level=if(final==100,\"健康\",if(final>=80,\"轻危\",if(final>=60,\"中危\",if(final<60,\"高危\",null))))|rename vpn.login_user as \"用户名\",app1 as \"存在的可以操作\",final as \"健康评分\",level as \"危险等级\""}
{"input": "用户账号操作异常评分。分别过滤疑似暴力破解、账号共用、国外 IP 登录、异常时间段登录、访问系统异常的情况，按规则给出评分，规则是一条记录0 分，两条记录 10 分，大于三条 20 分。然后用 append 追加在一起，然后分组统计评分总数，用 100 减去总分就是最后健康评分。并按最终健康评分做低中高危等级判定。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "Cisco_VPN日志数据，编写查询语句实现如下分析场景", "output": "appname:vpn vpn.login_user:* vpn.actype:login vpn.result:failure  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,0,cnt==2,20,cnt==3,30,cnt>=4,50,default,20)\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==2,20,cnt>=3,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login  (NOT vpn.src.geo.country:private)   (NOT vpn.src.geo.country:中国)  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,30,cnt==2,40,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:login|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn vpn.login_user:*\n vpn.actype:\"access resource\" vpn.login_user:* (NOT vpn.result:success) vpn.result:*|limit 1|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|stats sum(aaa) as all by vpn.login_user|sort by all|where all!=0\n|fields vpn.login_user,app1,all \n| eval level=if(all==0,\"健康\",if(all>=80,\"高危\",if(all>=60,\"中危\",if(all<60,\"危\",null))))|rename vpn.login_user as \"用户名\",app1 as \"存在的可以操作\",all as \"威胁评分\",level as \"危险等级\""}
{"input": "用户账号操作异常评分。计算方法如下：\n1. 查询VPN日志中认证(auth)、登录(login)和登出(logout)事件\n2. 对查询结果评分:\n    - 同一用户在短时间内出现大量失败登录尝试,评分较高,判断为“疑似暴力破解”\n    - 同一用户在不同城市短时间内登录,评分较高,判断为“疑似账号共用”\n    - 同一用户在国外未知IP登录,评分较高,判断为“账号登录异常”\n    - 在异常时间(晚上18点后,早上8点前)登录,评分较高,判断为“异常时间登录”\n    - 访问系统资源失败次数较多,评分较高,判断为“异常访问系统”\n3. 根据不同情景的评分总和,判断该用户的威胁等级,并输出结果,包括:\n    - 用户名\n    - 存在的威胁情况(app1)\n    - 威胁评分(all)\n    - 危险等级(level)\n4. 只输出评分不为0的用户结果\n。索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "深信服零信任VPN数据，编写查询语句实现如下分析场景", "output": "appname:vpn  (vpn.event_name:auth OR vpn.event_name:login OR vpn.event_name:logout) vpn.result:FAILED  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==1,0,cnt==2,20,cnt==3,30,cnt>=4,50,default,20)\n|append\n[[\nappname:vpn \n (vpn.event_name:auth OR vpn.event_name:login OR vpn.event_name:logout)  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==2,20,cnt>=3,50,default,0)\n]]\n|append\n[[\nappname:vpn \n (vpn.event_name:auth OR vpn.event_name:login OR vpn.event_name:logout)  (NOT vpn.src.geo.country:private)   (NOT vpn.src.geo.country:中国)  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==1,30,cnt==2,40,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn \n (vpn.event_name:auth OR vpn.event_name:login OR vpn.event_name:logout)|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|append\n[[\nappname:vpn \n vpn.event_name:\"access_resource\"  (NOT vpn.result:SUCCESS) vpn.result:*|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)\n]]\n|stats sum(aaa) as all by vpn.user_name|sort by all|where all!=0\n|fields vpn.user_name,app1,all \n| eval level=if(all==0,\"健康\",if(all>=80,\"高危\",if(all>=60,\"中危\",if(all<60,\"危\",null))))|rename vpn.user_name as \"用户名\",app1 as \"存在的可以操作\",all as \"威胁评分\",level as \"危险等级\""}
{"input": "按每5分钟分桶统计WASJDK7_GC过程堆内存趋势分析。方法如下：1. 第一段查询新生代内存使用情况(before和after full GC)并统计5分钟时间窗口内的平均使用量,命名为新占用_before和新占用_after。2. 第二段查询老年代内存使用情况(before和after full GC)并统计5分钟时间窗口内的平均使用量,命名为老占用_before和老占用_after。3. 第三段查询5分钟时间窗口内新生代和老年代的总内存使用量,命名为新生代_total和老年代_total。4. 第四段查询5分钟时间窗口内Java堆的使用量,命名为堆内存占用。5. 第五段定义一个变量aaa=4,用于在5分钟时间窗口内统计平均值,命名为堆总内存。6. 第六段查询5分钟时间窗口内Full GC的次数,命名为FullGC次数。7. 第七段查询5分钟时间窗口内Full GC的平均耗时,单位为秒,命名为FullGC耗时。8. 最后对结果按时间戳ts排序。。索引可用字段有：gc.beforeEden, gc.invocations, gc.stoptime, gc.totalnewgeneration, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "middle_ibm_was_数据，编写查询语句实现如下分析场景", "output": "appname:gc tag:ibm_was middleware.nursery_total:>=0 middleware.nursery_free_before:>=0|bucket timestamp span=5m as ts\n|eval nursery_use_before=middleware.nursery_total-middleware.nursery_free_before\n|stats avg(nursery_use_before) as count_1 by ts|eval line=\"新占用_before\"\n|append\n[[\nappname:gc tag:ibm_was middleware.nursery_total:>=0 middleware.middleware.nursery_free_after:>=0|bucket timestamp span=5m as ts\n|eval nursery_use_after=middleware.nursery_total-middleware.middleware.nursery_free_after\n|stats avg(nursery_use_after) as count_1 by ts|eval line=\"新占用_after\"\n]]\n|append\n[[\nappname:gc tag:ibm_was middleware.nursery_total:>=0 middleware.tenure_free_before:>=0|bucket timestamp span=5m as ts\n|eval tenure_use_before=middleware.tenure_total-middleware.tenure_free_before\n|stats avg(tenure_use_before) as count_1 by ts|eval line=\"老占用_before\"\n]]\n\n|append\n[[\nappname:gc tag:ibm_was middleware.nursery_total:>=0 middleware.tenure_free_after:>=0|bucket timestamp span=5m as ts\n|eval tenure_use_after=middleware.tenure_total-middleware.tenure_free_after\n|stats avg(tenure_use_after) as count_1 by ts|eval line=\"老占用_after\"\n]]\n\n|append\n[[\nappname:gc tag:ibm_was|bucket timestamp span=5m as ts|stats avg(middleware.tenure_total) as count_1 by ts|eval line=\"老年代_total\"\n]]\n|append\n[[\nappname:gc tag:ibm_was|bucket timestamp span=5m as ts|stats avg(middleware.nursery_total) as count_1 by ts|eval line=\"新生代_total\"\n]]\n|append\n[[\nappname:gc tag:ibm_was|bucket timestamp span=5m as ts|stats avg(middleware.heap) as count_1 by ts|eval line=\"堆内存占用\"\n]]\n|append\n[[\nappname:gc tag:ibm_was|bucket timestamp span=5m as ts|eval aaa=4|stats avg(aaa) as count_1 by ts|eval line=\"堆总内存\"\n]]\n|append\n[[\nappname:gc tag:ibm_was middleware.type:global |bucket timestamp span=5m as ts|stats count()  as count_2 by ts|eval line=\"FullGC次数\"\n]]\n|append\n[[\nappname:gc tag:ibm_was middleware.type:global|bucket timestamp span=5m as ts|eval cost=middleware.cost/1000 |stats avg(cost) as count_2 by ts|eval line=\"FullGC耗时(单位:秒)\"\n]]\n|sort by +ts"}
{"input": "8.1, 8.2。索引可用字段有：signal.green_time, signal.lane_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "统计出不同车道的绿灯平均时间间隔，用于交通系统的分析。具体方法是：先过滤出signal数据源中lane_name=XX的数据，对上一步结果进行统计,统计每个车道绿灯亮起的次数，根据时间戳排序，使用 autoregress 计算上一次绿灯时间和上一次时间戳,赋值给last_green_time和last_time字段。 计算这次绿灯与上次绿灯的时间间隔interval,并按车道分组计算时间间隔的平均值，再格式化为mm:ss格式avg_interval_time。选择返回的字段, signal.lane_name表示车道,avg_interval_time表示平均绿灯时间间隔。本次待分析的车道名称为：", "output": "appname:signal signal.lane_name:8.1\n|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n|sort by +timestamp\n|autoregress signal.green_time as last_green_time p=1\n|autoregress timestamp as last_time p=1\n|sort by timestamp\n|eval interval=timestamp-last_time\n|eval interval_time=formatdate(interval,\"mm:ss\")\n|stats avg(interval) as cnt by signal.lane_name\n|eval avg_=tolong(cnt)\n|eval avg_interval_time=formatdate(avg_,\"mm:ss\")\n|append [[\n\tappname:signal signal.lane_name:8.2\n\t|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n\t|sort by +timestamp\n\t|autoregress signal.green_time as last_green_time p=1\n\t|autoregress timestamp as last_time p=1\n\t|sort by timestamp\n\t|eval interval=timestamp-last_time\n\t|eval interval_time=formatdate(interval,\"mm:ss\")\n\t|stats avg(interval) as cnt by signal.lane_name\n\t|eval avg_=tolong(cnt)\n\t|eval avg_interval_time=formatdate(avg_,\"mm:ss\")]]\n |fields signal.lane_name,avg_interval_time"}
{"input": "7.1, 7.2。索引可用字段有：signal.green_time, signal.lane_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "统计出不同车道的绿灯平均时间间隔，用于交通系统的分析。具体方法是：先过滤出signal数据源中lane_name=XX的数据，对上一步结果进行统计,统计每个车道绿灯亮起的次数，根据时间戳排序，使用 autoregress 计算上一次绿灯时间和上一次时间戳,赋值给last_green_time和last_time字段。 计算这次绿灯与上次绿灯的时间间隔interval,并按车道分组计算时间间隔的平均值，再格式化为mm:ss格式avg_interval_time。选择返回的字段, signal.lane_name表示车道,avg_interval_time表示平均绿灯时间间隔。本次待分析的车道名称为：", "output": "appname:signal signal.lane_name:7.1\n|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n|sort by +timestamp\n|autoregress signal.green_time as last_green_time p=1\n|autoregress timestamp as last_time p=1\n|sort by timestamp\n|eval interval=timestamp-last_time\n|eval interval_time=formatdate(interval,\"mm:ss\")\n|stats avg(interval) as cnt by signal.lane_name\n|eval avg_=tolong(cnt)\n|eval avg_interval_time=formatdate(avg_,\"mm:ss\")\n|append [[\n\tappname:signal signal.lane_name:7.2\n\t|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n\t|sort by +timestamp\n\t|autoregress signal.green_time as last_green_time p=1\n\t|autoregress timestamp as last_time p=1\n\t|sort by timestamp\n\t|eval interval=timestamp-last_time\n\t|eval interval_time=formatdate(interval,\"mm:ss\")\n\t|stats avg(interval) as cnt by signal.lane_name\n\t|eval avg_=tolong(cnt)\n\t|eval avg_interval_time=formatdate(avg_,\"mm:ss\")]]\n |fields signal.lane_name,avg_interval_time"}
{"input": "6.1, 6.2。索引可用字段有：signal.green_time, signal.lane_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "统计出不同车道的绿灯平均时间间隔，用于交通系统的分析。具体方法是：先过滤出signal数据源中lane_name=XX的数据，对上一步结果进行统计,统计每个车道绿灯亮起的次数，根据时间戳排序，使用 autoregress 计算上一次绿灯时间和上一次时间戳,赋值给last_green_time和last_time字段。 计算这次绿灯与上次绿灯的时间间隔interval,并按车道分组计算时间间隔的平均值，再格式化为mm:ss格式avg_interval_time。选择返回的字段, signal.lane_name表示车道,avg_interval_time表示平均绿灯时间间隔。本次待分析的车道名称为：", "output": "appname:signal signal.lane_name:6.1\n|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n|sort by +timestamp\n|autoregress signal.green_time as last_green_time p=1\n|autoregress timestamp as last_time p=1\n|sort by timestamp\n|eval interval=timestamp-last_time\n|eval interval_time=formatdate(interval,\"mm:ss\")\n|stats avg(interval) as cnt by signal.lane_name\n|eval avg_=tolong(cnt)\n|eval avg_interval_time=formatdate(avg_,\"mm:ss\")\n|append [[\n\tappname:signal signal.lane_name:6.2\n\t|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n\t|sort by +timestamp\n\t|autoregress signal.green_time as last_green_time p=1\n\t|autoregress timestamp as last_time p=1\n\t|sort by timestamp\n\t|eval interval=timestamp-last_time\n\t|eval interval_time=formatdate(interval,\"mm:ss\")\n\t|stats avg(interval) as cnt by signal.lane_name\n\t|eval avg_=tolong(cnt)\n\t|eval avg_interval_time=formatdate(avg_,\"mm:ss\")]]\n |fields signal.lane_name,avg_interval_time"}
{"input": "5.1, 5.2。索引可用字段有：signal.green_time, signal.lane_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "统计出不同车道的绿灯平均时间间隔，用于交通系统的分析。具体方法是：先过滤出signal数据源中lane_name=XX的数据，对上一步结果进行统计,统计每个车道绿灯亮起的次数，根据时间戳排序，使用 autoregress 计算上一次绿灯时间和上一次时间戳,赋值给last_green_time和last_time字段。 计算这次绿灯与上次绿灯的时间间隔interval,并按车道分组计算时间间隔的平均值，再格式化为mm:ss格式avg_interval_time。选择返回的字段, signal.lane_name表示车道,avg_interval_time表示平均绿灯时间间隔。本次待分析的车道名称为：", "output": "appname:signal signal.lane_name:5.1\n|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n|sort by +timestamp\n|autoregress signal.green_time as last_green_time p=1\n|autoregress timestamp as last_time p=1\n|sort by timestamp\n|eval interval=timestamp-last_time\n|eval interval_time=formatdate(interval,\"mm:ss\")\n|stats avg(interval) as cnt by signal.lane_name\n|eval avg_=tolong(cnt)\n|eval avg_interval_time=formatdate(avg_,\"mm:ss\")\n|append [[\n\tappname:signal signal.lane_name:5.2\n\t|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n\t|sort by +timestamp\n\t|autoregress signal.green_time as last_green_time p=1\n\t|autoregress timestamp as last_time p=1\n\t|sort by timestamp\n\t|eval interval=timestamp-last_time\n\t|eval interval_time=formatdate(interval,\"mm:ss\")\n\t|stats avg(interval) as cnt by signal.lane_name\n\t|eval avg_=tolong(cnt)\n\t|eval avg_interval_time=formatdate(avg_,\"mm:ss\")]]\n |fields signal.lane_name,avg_interval_time"}
{"input": "4.1, 4.2。索引可用字段有：signal.green_time, signal.lane_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "统计出不同车道的绿灯平均时间间隔，用于交通系统的分析。具体方法是：先过滤出signal数据源中lane_name=XX的数据，对上一步结果进行统计,统计每个车道绿灯亮起的次数，根据时间戳排序，使用 autoregress 计算上一次绿灯时间和上一次时间戳,赋值给last_green_time和last_time字段。 计算这次绿灯与上次绿灯的时间间隔interval,并按车道分组计算时间间隔的平均值，再格式化为mm:ss格式avg_interval_time。选择返回的字段, signal.lane_name表示车道,avg_interval_time表示平均绿灯时间间隔。本次待分析的车道名称为：", "output": "appname:signal signal.lane_name:4.1\n|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n|sort by +timestamp\n|autoregress signal.green_time as last_green_time p=1\n|autoregress timestamp as last_time p=1\n|sort by timestamp\n|eval interval=timestamp-last_time\n|eval interval_time=formatdate(interval,\"mm:ss\")\n|stats avg(interval) as cnt by signal.lane_name\n|eval avg_=tolong(cnt)\n|eval avg_interval_time=formatdate(avg_,\"mm:ss\")\n|append [[\n\tappname:signal signal.lane_name:4.2\n\t|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n\t|sort by +timestamp\n\t|autoregress signal.green_time as last_green_time p=1\n\t|autoregress timestamp as last_time p=1\n\t|sort by timestamp\n\t|eval interval=timestamp-last_time\n\t|eval interval_time=formatdate(interval,\"mm:ss\")\n\t|stats avg(interval) as cnt by signal.lane_name\n\t|eval avg_=tolong(cnt)\n\t|eval avg_interval_time=formatdate(avg_,\"mm:ss\")]]\n |fields signal.lane_name,avg_interval_time"}
{"input": "3.1, 3.2。索引可用字段有：signal.green_time, signal.lane_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "统计出不同车道的绿灯平均时间间隔，用于交通系统的分析。具体方法是：先过滤出signal数据源中lane_name=XX的数据，对上一步结果进行统计,统计每个车道绿灯亮起的次数，根据时间戳排序，使用 autoregress 计算上一次绿灯时间和上一次时间戳,赋值给last_green_time和last_time字段。 计算这次绿灯与上次绿灯的时间间隔interval,并按车道分组计算时间间隔的平均值，再格式化为mm:ss格式avg_interval_time。选择返回的字段, signal.lane_name表示车道,avg_interval_time表示平均绿灯时间间隔。本次待分析的车道名称为：", "output": "appname:signal signal.lane_name:3.1\n|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n|sort by +timestamp\n|autoregress signal.green_time as last_green_time p=1\n|autoregress timestamp as last_time p=1\n|sort by timestamp\n|eval interval=timestamp-last_time\n|eval interval_time=formatdate(interval,\"mm:ss\")\n|stats avg(interval) as cnt by signal.lane_name\n|eval avg_=tolong(cnt)\n|eval avg_interval_time=formatdate(avg_,\"mm:ss\")\n|append [[\n\tappname:signal signal.lane_name:3.2\n\t|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n\t|sort by +timestamp\n\t|autoregress signal.green_time as last_green_time p=1\n\t|autoregress timestamp as last_time p=1\n\t|sort by timestamp\n\t|eval interval=timestamp-last_time\n\t|eval interval_time=formatdate(interval,\"mm:ss\")\n\t|stats avg(interval) as cnt by signal.lane_name\n\t|eval avg_=tolong(cnt)\n\t|eval avg_interval_time=formatdate(avg_,\"mm:ss\")]]\n |fields signal.lane_name,avg_interval_time"}
{"input": "2.1, 2.2。索引可用字段有：signal.green_time, signal.lane_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "统计出不同车道的绿灯平均时间间隔，用于交通系统的分析。具体方法是：先过滤出signal数据源中lane_name=XX的数据，对上一步结果进行统计,统计每个车道绿灯亮起的次数，根据时间戳排序，使用 autoregress 计算上一次绿灯时间和上一次时间戳,赋值给last_green_time和last_time字段。 计算这次绿灯与上次绿灯的时间间隔interval,并按车道分组计算时间间隔的平均值，再格式化为mm:ss格式avg_interval_time。选择返回的字段, signal.lane_name表示车道,avg_interval_time表示平均绿灯时间间隔。本次待分析的车道名称为：", "output": "appname:signal signal.lane_name:2.1\n|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n|sort by +timestamp\n|autoregress signal.green_time as last_green_time p=1\n|autoregress timestamp as last_time p=1\n|sort by timestamp\n|eval interval=timestamp-last_time\n|eval interval_time=formatdate(interval,\"mm:ss\")\n|stats avg(interval) as cnt by signal.lane_name\n|eval avg_=tolong(cnt)\n|eval avg_interval_time=formatdate(avg_,\"mm:ss\")\n|append [[\n\tappname:signal signal.lane_name:2.2\n\t|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n\t|sort by +timestamp\n\t|autoregress signal.green_time as last_green_time p=1\n\t|autoregress timestamp as last_time p=1\n\t|sort by timestamp\n\t|eval interval=timestamp-last_time\n\t|eval interval_time=formatdate(interval,\"mm:ss\")\n\t|stats avg(interval) as cnt by signal.lane_name\n\t|eval avg_=tolong(cnt)\n\t|eval avg_interval_time=formatdate(avg_,\"mm:ss\")]]\n |fields signal.lane_name,avg_interval_time"}
{"input": "8.1，8.2。索引可用字段有：signal.green_time, signal.lane_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "统计出不同车道的绿灯时间以及绿灯时间间隔，用于交通系统的分析。具体方法是：先过滤出signal数据源中lane_name=XX的数据，对上一步结果进行统计,统计每个车道绿灯亮起的次数，根据时间戳排序，使用 autoregress 计算上一次绿灯时间和上一次时间戳,赋值给last_green_time和last_time字段。 计算这次绿灯与上次绿灯的时间间隔interval,并格式化为mm:ss格式interval_time。选择返回的字段, signal.green_time表示这次绿灯的时间,signal.lane_name表示车道,last_green_time表示上次绿灯时间,interval_time表示两次绿灯时间间隔。本次待分析的车道名称为：", "output": "appname:signal signal.lane_name:8.1\n|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n|sort by +timestamp\n|autoregress signal.green_time as last_green_time p=1\n|autoregress timestamp as last_time p=1\n|sort by timestamp\n|eval interval=timestamp-last_time\n|eval interval_time=formatdate(interval,\"mm:ss\")\n|sort by interval\n|where !empty(interval)\n|limit 1\n|append [[\n\tappname:signal signal.lane_name:8.2\n\t|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n\t|sort by +timestamp\n\t|autoregress signal.green_time as last_green_time p=1\n\t|autoregress timestamp as last_time p=1\n\t|sort by timestamp\n\t|eval interval=timestamp-last_time\n\t|eval interval_time=formatdate(interval,\"mm:ss\")\n\t|sort by interval\n\t|where !empty(interval)\n\t|limit 1]]\n|fields signal.green_time,signal.lane_name,last_green_time,interval_time"}
{"input": "7.1，7.2。索引可用字段有：signal.green_time, signal.lane_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "统计出不同车道的绿灯时间以及绿灯时间间隔，用于交通系统的分析。按步骤实现如下：先过滤出signal数据源中lane_name=XX的数据，对上一步结果进行统计,统计每个车道绿灯亮起的次数，根据时间戳排序，使用 autoregress 计算上一次绿灯时间和上一次时间戳,赋值给last_green_time和last_time字段。 计算这次绿灯与上次绿灯的时间间隔interval,并格式化为mm:ss格式interval_time。选择返回的字段, signal.green_time表示这次绿灯的时间,signal.lane_name表示车道,last_green_time表示上次绿灯时间,interval_time表示两次绿灯时间间隔。本次待分析的车道名称为：", "output": "appname:signal signal.lane_name:7.1\n|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n|sort by +timestamp\n|autoregress signal.green_time as last_green_time p=1\n|autoregress timestamp as last_time p=1\n|sort by timestamp\n|eval interval=timestamp-last_time\n|eval interval_time=formatdate(interval,\"mm:ss\")\n|sort by interval\n|where !empty(interval)\n|limit 1\n|append [[\n\tappname:signal signal.lane_name:7.2\n\t|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n\t|sort by +timestamp\n\t|autoregress signal.green_time as last_green_time p=1\n\t|autoregress timestamp as last_time p=1\n\t|sort by timestamp\n\t|eval interval=timestamp-last_time\n\t|eval interval_time=formatdate(interval,\"mm:ss\")\n\t|sort by interval\n\t|where !empty(interval)\n\t|limit 1]]\n|fields signal.green_time,signal.lane_name,last_green_time,interval_time"}
{"input": "6.1，6.2。索引可用字段有：signal.green_time, signal.lane_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "统计出不同车道的绿灯时间以及绿灯时间间隔，用于交通系统的分析。具体方法是：先过滤出signal数据源中lane_name=XX的数据，对上一步结果进行统计,统计每个车道绿灯亮起的次数，根据时间戳排序，使用 autoregress 计算上一次绿灯时间和上一次时间戳,赋值给last_green_time和last_time字段。 计算这次绿灯与上次绿灯的时间间隔interval,并格式化为mm:ss格式interval_time。选择返回的字段, signal.green_time表示这次绿灯的时间,signal.lane_name表示车道,last_green_time表示上次绿灯时间,interval_time表示两次绿灯时间间隔。本次待分析的车道名称为：", "output": "appname:signal signal.lane_name:6.1\n|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n|sort by +timestamp\n|autoregress signal.green_time as last_green_time p=1\n|autoregress timestamp as last_time p=1\n|sort by timestamp\n|eval interval=timestamp-last_time\n|eval interval_time=formatdate(interval,\"mm:ss\")\n|sort by interval\n|where !empty(interval)\n|limit 1\n|append [[\n\tappname:signal signal.lane_name:6.2\n\t|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n\t|sort by +timestamp\n\t|autoregress signal.green_time as last_green_time p=1\n\t|autoregress timestamp as last_time p=1\n\t|sort by timestamp\n\t|eval interval=timestamp-last_time\n\t|eval interval_time=formatdate(interval,\"mm:ss\")\n\t|sort by interval\n\t|where !empty(interval)\n\t|limit 1]]\n|fields signal.green_time,signal.lane_name,last_green_time,interval_time"}
{"input": "5.1，5.2。索引可用字段有：signal.green_time, signal.lane_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "统计出不同车道的绿灯时间以及绿灯时间间隔，用于交通系统的分析。一步一步来计算：先过滤出signal数据源中lane_name=XX的数据，对上一步结果进行统计,统计每个车道绿灯亮起的次数，根据时间戳排序，使用 autoregress 计算上一次绿灯时间和上一次时间戳,赋值给last_green_time和last_time字段。 计算这次绿灯与上次绿灯的时间间隔interval,并格式化为mm:ss格式interval_time。选择返回的字段, signal.green_time表示这次绿灯的时间,signal.lane_name表示车道,last_green_time表示上次绿灯时间,interval_time表示两次绿灯时间间隔。本次待分析的车道名称为：", "output": "appname:signal signal.lane_name:5.1\n|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n|sort by +timestamp\n|autoregress signal.green_time as last_green_time p=1\n|autoregress timestamp as last_time p=1\n|sort by timestamp\n|eval interval=timestamp-last_time\n|eval interval_time=formatdate(interval,\"mm:ss\")\n|sort by interval\n|where !empty(interval)\n|limit 1\n|append [[\n\tappname:signal signal.lane_name:5.2\n\t|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n\t|sort by +timestamp\n\t|autoregress signal.green_time as last_green_time p=1\n\t|autoregress timestamp as last_time p=1\n\t|sort by timestamp\n\t|eval interval=timestamp-last_time\n\t|eval interval_time=formatdate(interval,\"mm:ss\")\n\t|sort by interval\n\t|where !empty(interval)\n\t|limit 1]]\n|fields signal.green_time,signal.lane_name,last_green_time,interval_time"}
{"input": "4.1，4.2。索引可用字段有：signal.green_time, signal.lane_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "统计出不同车道的绿灯时间以及绿灯时间间隔，用于交通系统的分析。具体方法是：先过滤出signal数据源中lane_name=XX的数据，对上一步结果进行统计,统计每个车道绿灯亮起的次数，根据时间戳排序，使用 autoregress 计算上一次绿灯时间和上一次时间戳,赋值给last_green_time和last_time字段。 计算这次绿灯与上次绿灯的时间间隔interval,并格式化为mm:ss格式interval_time。选择返回的字段, signal.green_time表示这次绿灯的时间,signal.lane_name表示车道,last_green_time表示上次绿灯时间,interval_time表示两次绿灯时间间隔。本次待分析的车道名称为：", "output": "appname:signal signal.lane_name:4.1\n|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n|sort by +timestamp\n|autoregress signal.green_time as last_green_time p=1\n|autoregress timestamp as last_time p=1\n|sort by timestamp\n|eval interval=timestamp-last_time\n|eval interval_time=formatdate(interval,\"mm:ss\")\n|sort by interval\n|where !empty(interval)\n|limit 1\n|append [[\n\tappname:signal signal.lane_name:4.2\n\t|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n\t|sort by +timestamp\n\t|autoregress signal.green_time as last_green_time p=1\n\t|autoregress timestamp as last_time p=1\n\t|sort by timestamp\n\t|eval interval=timestamp-last_time\n\t|eval interval_time=formatdate(interval,\"mm:ss\")\n\t|sort by interval\n\t|where !empty(interval)\n\t|limit 1]]\n|fields signal.green_time,signal.lane_name,last_green_time,interval_time"}
{"input": "3.1，3.2。索引可用字段有：signal.green_time, signal.lane_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "统计出不同车道的绿灯时间以及绿灯时间间隔，用于交通系统的分析。具体步骤为：先过滤出signal数据源中lane_name=XX的数据，对上一步结果进行统计,统计每个车道绿灯亮起的次数，根据时间戳排序，使用 autoregress 计算上一次绿灯时间和上一次时间戳,赋值给last_green_time和last_time字段。 计算这次绿灯与上次绿灯的时间间隔interval,并格式化为mm:ss格式interval_time。选择返回的字段, signal.green_time表示这次绿灯的时间,signal.lane_name表示车道,last_green_time表示上次绿灯时间,interval_time表示两次绿灯时间间隔。本次待分析的车道名称为：", "output": "appname:signal signal.lane_name:3.1\n|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n|sort by +timestamp\n|autoregress signal.green_time as last_green_time p=1\n|autoregress timestamp as last_time p=1\n|sort by timestamp\n|eval interval=timestamp-last_time\n|eval interval_time=formatdate(interval,\"mm:ss\")\n|sort by interval\n|where !empty(interval)\n|limit 1\n|append [[\n\tappname:signal signal.lane_name:3.2\n\t|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n\t|sort by +timestamp\n\t|autoregress signal.green_time as last_green_time p=1\n\t|autoregress timestamp as last_time p=1\n\t|sort by timestamp\n\t|eval interval=timestamp-last_time\n\t|eval interval_time=formatdate(interval,\"mm:ss\")\n\t|sort by interval\n\t|where !empty(interval)\n\t|limit 1]]\n|fields signal.green_time,signal.lane_name,last_green_time,interval_time"}
{"input": "2.1，2.2。索引可用字段有：signal.green_time, signal.lane_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "统计出不同车道的绿灯时间以及绿灯时间间隔，用于交通系统的分析。按步骤每条指令实现：先过滤出signal数据源中lane_name=XX的数据，对上一步结果进行统计,统计每个车道绿灯亮起的次数，根据时间戳排序，使用 autoregress 计算上一次绿灯时间和上一次时间戳,赋值给last_green_time和last_time字段。 计算这次绿灯与上次绿灯的时间间隔interval,并格式化为mm:ss格式interval_time。选择返回的字段, signal.green_time表示这次绿灯的时间,signal.lane_name表示车道,last_green_time表示上次绿灯时间,interval_time表示两次绿灯时间间隔。本次待分析的车道名称为：", "output": "appname:signal signal.lane_name:2.1\n|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n|sort by +timestamp\n|autoregress signal.green_time as last_green_time p=1\n|autoregress timestamp as last_time p=1\n|sort by timestamp\n|eval interval=timestamp-last_time\n|eval interval_time=formatdate(interval,\"mm:ss\")\n|sort by interval\n|where !empty(interval)\n|limit 1\n|append [[\n\tappname:signal signal.lane_name:2.2\n\t|stats count() as cnt by timestamp,signal.green_time,signal.lane_name\n\t|sort by +timestamp\n\t|autoregress signal.green_time as last_green_time p=1\n\t|autoregress timestamp as last_time p=1\n\t|sort by timestamp\n\t|eval interval=timestamp-last_time\n\t|eval interval_time=formatdate(interval,\"mm:ss\")\n\t|sort by interval\n\t|where !empty(interval)\n\t|limit 1]]\n|fields signal.green_time,signal.lane_name,last_green_time,interval_time"}
{"input": "索引可用字段有：aix.class_dec, aix.dst_host, aix.facility, aix.login_time, aix.login_way, aix.net, aix.resource_name, aix.severity, aix.span_h, aix.span_m, aix.src_ip, aix.src_port, aix.type, aix.type_dec, aix.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "aix异常用户登录列表_不在白名单列表的用户进行登录则认为是异常用户", "output": "appname:aix tag:last  | stats count(hostname) as count_ by hostname,aix.user,aix.type,timestamp,aix.span_h,aix.span_m,aix.src_ip  |eval login_date = formatdate(timestamp)  |lookup user whitelist_user.csv on  hostname=host,aix.login_user=user   |eval bl_user =if(empty(user),0,1)   |eval span_h=(todouble(aix.span_h))*3600 |eval span_m=(todouble(aix.span_m))*60 |eval login_cost=span_h+span_m  |fields hostname,aix.user,aix.type,login_date,login_cost,aix.src_ip,bl_user |rename hostname as login_host, aix.user as login_user, aix.type as login_way, aix.src_ip as login_srcip |eval line=\"line1\" |where bl_user <1 |append [[tab:who appname:aix | stats count(hostname) by hostname,aix.user,aix.type,aix.login_time,aix.src_ip  |fields hostname,aix.user,aix.login_way,aix.login_time,aix.src_ip |lookup user user.csv on hostname=host,aix.login_user=user  |eval bl_user =if(empty(user),0,1) |fields hostname,aix.user,aix.type,aix.login_time,aix.src_ip,bl_user |rename hostname as login_host, aix.user as login_user, aix.type as login_way, aix.login_time as login_date, aix.src_ip as login_srcip |where bl_user <1 |eval line=\"line2\"]] |fields login_host,login_user,login_way,login_cost,login_srcip,login_date |sort by login_cost |rename login_host as \"登录主机\", login_user as \"登录用户\", login_way as  \"登录方式\", login_srcip as \"登录ip\", login_cost as \"登录时长_秒\", login_date as \"登录时间\""}
{"input": "异常用户登录列表_不在白名单列表的用户进行登录则认为是异常用户。索引可用字段有：aix.class_dec, aix.dst_host, aix.facility, aix.login_time, aix.login_way, aix.net, aix.resource_name, aix.severity, aix.span_h, aix.span_m, aix.src_ip, aix.src_port, aix.type, aix.type_dec, aix.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "aix日志数据，编写查询语句实现如下分析场景", "output": "appname:aix tag:last \n| stats count(hostname) as count_ by hostname,aix.user,aix.type,timestamp,aix.span_h,aix.span_m,aix.src_ip \n|eval login_date = formatdate(timestamp) \n|lookup user user.csv on  hostname=host,aix.login_user=user  \n|eval bl_user =if(empty(user),0,1) \n\n|eval span_h=(todouble(aix.span_h))*3600\n|eval span_m=(todouble(aix.span_m))*60\n|eval login_cost=span_h+span_m\n\n|fields hostname,aix.user,aix.type,login_date,login_cost,aix.src_ip,bl_user\n|rename hostname as login_host, aix.user as login_user, aix.type as login_way, aix.src_ip as login_srcip\n|eval line=\"line1\"\n|where bl_user <1\n|append [[tab:who appname:aix\n| stats count(hostname) by hostname,aix.user,aix.type,aix.login_time,aix.src_ip \n|fields hostname,aix.user,aix.login_way,aix.login_time,aix.src_ip\n|lookup user user.csv on hostname=host,aix.login_user=user \n|eval bl_user =if(empty(user),0,1)\n|fields hostname,aix.user,aix.type,aix.login_time,aix.src_ip,bl_user\n|rename hostname as login_host, aix.user as login_user, aix.type as login_way, aix.login_time as login_date, aix.src_ip as login_srcip\n|where bl_user <1\n|eval line=\"line2\"]]\n|fields login_host,login_user,login_way,login_cost,login_srcip,login_date\n|sort by login_cost\n|rename login_host as \"登录主机\", login_user as \"登录用户\", login_way as \"登录方式\", login_srcip as \"登录ip\", login_cost as \"登录时长_秒\", login_date as \"登录时间\""}
{"input": "索引可用字段有：loadbalancing.dst_ip, loadbalancing.level, loadbalancing.listenervs_ip, loadbalancing.msg, loadbalancing.querytype, loadbalancing.responsecode, loadbalancing.severity, loadbalancing.src.geo.province, loadbalancing.src_ip, loadbalancing.status, loadbalancing.type, loadbalancing.user, loadbalancing.username, loadblancing.status, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想询问关于 F5 应用的负载平衡情况以及相关时间序列数据。", "output": "appname:loadbalancing tag:f5  from |bucket timestamp span=5m as ts | stats count() by ts|eval line=\"实时请求趋势\"|append[[appname:loadbalancing tag:f5  to |bucket timestamp span=5m as ts | stats count() by ts|eval line=\"实时响应趋势\"]]"}
{"input": "索引可用字段有：accounting.excute_time, accounting.fuc_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想跟踪我们的公司的财务状况，并寻找一些可能导致营业额下降的因素。查询涉及到两个应用（“accounting”和“ensemble”）以及两个错误代码（“accounting.info2.retCode:000000”和“ensemble.retCode:*”）。此外，还要求在时间范围内为每个分桶计算计数、将结果与行“交易成功趋势”或“交易失败趋势”相连接。", "output": "appname:accounting accounting.info2.retCode:000000|bucket timestamp span=5m as ts |stats count() as cnt_ by ts|eval line=\"交易成功趋势\" |append [[appname:accounting NOT accounting.info2.retCode:000000 ensemble.retCode:*|bucket timestamp span=5m as ts |stats count() as cnt_ by ts|eval line=\"交易失败趋势\"]]"}
{"input": "索引可用字段有：ips.action, ips.application, ips.attack_name, ips.attack_type, ips.block_reason, ips.cve, ips.dst.geo.city, ips.dst.geo.ip, ips.dst.geo.latitude, ips.dst.geo.longitude, ips.dst_ip, ips.dst_port, ips.event, ips.event_id, ips.event_level, ips.event_name, ips.inbound_interface, ips.inbound_zone, ips.level, ips.local, ips.msg.seclevel, ips.outbound_interface, ips.outbound_zone, ips.policy, ips.proto, ips.service, ips.severity, ips.src.geo.city, ips.src.geo.country, ips.src.geo.ip, ips.src.geo.latitude, ips.src.geo.longitude, ips.src.geo.province, ips.src_ip, ips.src_port, ips.url, ips.vendor_app, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想要知道使用Mcafee应用的主机之间有多少个TCP连接。请提供前二十名通信双方的信息以及它们之间的数量。", "output": "appname:ips tag:mcafee NOT ips.level:Informational| stats count() as cnt by ips.src_ip,ips.dst_ip,ips.dst_port|sort by cnt|limit 20|rename ips.src_ip as from,ips.dst_ip as to|append [[ appname:ips tag:mcafee NOT ips.level:Informational | stats count() as cnt by ips.src_ip,ips.dst_ip,ips.dst_port |sort by cnt |limit 20 |rename ips.dst_ip as from,ips.dst_port as to]]|fields from,to,cnt"}
{"input": "索引可用字段有：ips.action, ips.application, ips.attack_name, ips.attack_type, ips.block_reason, ips.cve, ips.dst.geo.city, ips.dst.geo.ip, ips.dst.geo.latitude, ips.dst.geo.longitude, ips.dst_ip, ips.dst_port, ips.event, ips.event_id, ips.event_level, ips.event_name, ips.inbound_interface, ips.inbound_zone, ips.level, ips.local, ips.msg.seclevel, ips.outbound_interface, ips.outbound_zone, ips.policy, ips.proto, ips.service, ips.severity, ips.src.geo.city, ips.src.geo.country, ips.src.geo.ip, ips.src.geo.latitude, ips.src.geo.longitude, ips.src.geo.province, ips.src_ip, ips.src_port, ips.url, ips.vendor_app, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想问的是，有多少个来自于 Mcafee 的应用发出了警告信息，并且这些警告消息的级别不是 Informational 级别的信息吗？", "output": "appname:ips tag:mcafee NOT ips.level:Informational| stats count() as cnt by ips.src_ip,ips.dst_ip,ips.event_name|sort by cnt|limit 20|rename ips.src_ip as from,ips.dst_ip as to|append [[ appname:ips tag:mcafee NOT ips.level:Informational | stats count() as cnt by ips.src_ip,ips.dst_ip,ips.event_name |sort by cnt |limit 20 |rename ips.dst_ip as from,ips.event_name as to]]|fields from,to,cnt"}
{"input": "索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想问的是，有没有大量的 IP 在访问我们的网站，这些 IP 是从哪些地方来的呢？可以把结果按数量排序，前 20 个IP地址和访问次数分别是多少？", "output": "appname:firewall Deny|stats count() as cnt by firewall.src_ip|rename firewall.src_ip as src_ip|append [[appname:ips |stats count() as cnt by ips.src_ip|rename ips.src_ip as src_ip]]|append [[appname:waf|stats count() as cnt by waf.src_ip|rename waf.src_ip as src_ip]]|sort by cnt |limit 20"}
{"input": "索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想问的是，有没有发生过大量的 DDoS 攻击吗？如果有的话，那些 IP 是谁呢？", "output": "appname:firewall Deny|stats count() as cnt by firewall.dst_ip|rename firewall.dst_ip as dst_ip|append [[appname:ips |stats count() as cnt by ips.dst_ip|rename ips.dst_ip as dst_ip]]|append [[appname:waf|stats count() as cnt by waf.dst_ip|rename waf.dst_ip as dst_ip]]|sort by cnt |limit 20"}
{"input": "索引可用字段有：waf.action, waf.attack_name, waf.attack_type, waf.bytes_in, waf.cost, waf.cve_id, waf.dst_city, waf.dst_domain, waf.dst_ip, waf.dst_latitude, waf.dst_longitude, waf.dst_port, waf.error_msg, waf.event_level, waf.event_log_level, waf.event_name, waf.event_type, waf.http_method, waf.http_refer, waf.is_truncated, waf.kv.Evt_level, waf.kv.Evt_type, waf.kv.event_name, waf.kv.http_method, waf.kv.http_refer, waf.kv.http_url, waf.kv.msg, waf.kv.owasp_top, waf.kv.pri, waf.kv.severity_level, waf.kv.status, waf.kv.type, waf.level, waf.log_category, waf.message, waf.message.action, waf.message.event, waf.message.method, waf.message.policy, waf.message.src_ip.geo.ip, waf.message.src_ip.geo.province, waf.message.src_port, waf.message.status, waf.message.threaten, waf.method, waf.module, waf.msg.act, waf.msg.cs, waf.msg.policy_id, waf.msg.src.geo.country, waf.policy_name, waf.proto, waf.referer, waf.risk_level, waf.severity, waf.src.geo.city, waf.src.geo.country, waf.src.geo.ip, waf.src.geo.isp, waf.src.geo.latitude, waf.src.geo.longitude, waf.src.geo.province, waf.src_ip, waf.src_port, waf.status, waf.status_code, waf.threat_level, waf.time, waf.ua_browser, waf.ua_device, waf.ua_os, waf.uri, waf.url, waf.user_agent.browser, waf.user_agent.os, waf.website_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想问的是，有多少个访问了 F5 标签的 WAF 应用，并且没有被攻击的网站，并按访问量从高到低排序，返回前 20 个 IP 地址和访问次数。", "output": "appname:waf tag:f5 NOT waf.is_truncated:truncated NOT waf.attack_type:\"\" |stats count() as cnt by waf.src_ip|append[[ appname:waf tag:f5  waf.is_truncated:truncated   |stats count() as cnt by waf.src_ip ]]|sort by cnt |limit 20"}
{"input": "索引可用字段有：middleware.Error_info, middleware.System_errinfo, middleware.System_errno, middleware.actconn, middleware.action, middleware.backend_queue, middleware.beconn, middleware.clientip, middleware.desc, middleware.dst_ip, middleware.error_level, middleware.error_no, middleware.event_name, middleware.event_type, middleware.feconn, middleware.func_no, middleware.geo.city, middleware.geo.isp, middleware.geo.province, middleware.http_hostname, middleware.http_method, middleware.http_referer, middleware.http_user_agent.browser, middleware.http_user_agent.os, middleware.level, middleware.message, middleware.method, middleware.middleware.nursery_free_after, middleware.module, middleware.msg, middleware.nursery_free_before, middleware.nursery_total, middleware.referer, middleware.referrer, middleware.req_time, middleware.request, middleware.request_method, middleware.request_path, middleware.request_status, middleware.response, middleware.response_code, middleware.retries, middleware.rsp, middleware.server, middleware.severity, middleware.src.geo.country, middleware.src.geo.isp, middleware.src_ip, middleware.src_ip.geo.city, middleware.srv_conn, middleware.srv_queue, middleware.status, middleware.subsystem, middleware.tc, middleware.tenure_free_after, middleware.tenure_free_before, middleware.thread, middleware.tt, middleware.tw, middleware.type, middleware.ua.browser, middleware.ua.device, middleware.ua.os, middleware.uri_query, middleware.uri_stem, middleware.url, middleware.zkmsg.zk_followers, middleware.zkmsg.zk_packets_received, middleware.zkmsg.zk_packets_sent, middleware.zkmsg.zk_server_state, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想问的是，在过去一天内，公司有哪些主机上运行着 Apache、Tomcat 和 Linux 等软件的情况吗？", "output": "* AND (('appname':waf) OR ('appname':firewall) OR ('appname':ips))|stats dc(hostname) as cnt by appname,tag|rename appname as \"设备名\",tag as \"品牌\",cnt as \"数量\"|append [[* AND (('appname':apache) OR ('appname':middleware) OR ('appname':tomcat)) |stats dc(ip) as cnt by appname,tag|rename appname as \"设备名\",tag as \"品牌\",cnt as \"数量\"]]|append [[* AND (('appname':linux) OR ('appname':windows) OR ('appname':aix))|stats dc(ip) as cnt by appname|rename appname as \"设备名\",cnt as \"数量\"]]"}
{"input": "", "instruction": "我有以下几个需求：1. 汇总某天所有 cupp 应用发送的消息数量；2. 根据某个字段的值（比如 msgid）统计出不同消息值的数量并展示在图表中；3. 从两个不同的应用（比如 cupp 和 JYLS_FD_INFO5）的数据源中获取信息，并将结果合并显示。", "output": "appname:cupp \"收到报文\"| stats dc(msgid) as cnt| eval type=\"总交易量\"| append [[ appname:cupp \"收到报文\" trancode:UP1* | stats dc(msgid) as cnt | eval type=\"发卡方\"]]| append [[ appname:cupp \"处理完成\" trancode:UP5* JYLS_FD_INFO5:* | stats dc(msgid) as cnt | eval type=\"受理方\"]]"}
{"input": "索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想知道有没有人在使用 VPN 服务进行不正常的活动，比如暴力破解、账号共享和异常登录等。", "output": "appname:vpn vpn.login_user:* vpn.actype:login vpn.result:failure  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,0,cnt==2,20,cnt==3,30,cnt>=4,50,default,0)|append[[appname:vpn vpn.login_user:* vpn.actype:login  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==2,20,cnt>=3,50,default,0)]]|append[[appname:vpn vpn.login_user:* vpn.actype:login  (NOT vpn.src.geo.country:private)   (NOT vpn.src.geo.country:中国)  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,30,cnt==2,40,cnt>=4,50,default,0)]]|append[[appname:vpn vpn.login_user:* vpn.actype:login|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)]]|append[[appname:vpn vpn.login_user:* vpn.actype:\"access resource\" vpn.login_user:* (NOT vpn.result:success) vpn.result:*|limit 1|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)]]|stats sum(aaa) as all by vpn.login_user"}
{"input": "索引可用字段有：waf.action, waf.attack_name, waf.attack_type, waf.bytes_in, waf.cost, waf.cve_id, waf.dst_city, waf.dst_domain, waf.dst_ip, waf.dst_latitude, waf.dst_longitude, waf.dst_port, waf.error_msg, waf.event_level, waf.event_log_level, waf.event_name, waf.event_type, waf.http_method, waf.http_refer, waf.is_truncated, waf.kv.Evt_level, waf.kv.Evt_type, waf.kv.event_name, waf.kv.http_method, waf.kv.http_refer, waf.kv.http_url, waf.kv.msg, waf.kv.owasp_top, waf.kv.pri, waf.kv.severity_level, waf.kv.status, waf.kv.type, waf.level, waf.log_category, waf.message, waf.message.action, waf.message.event, waf.message.method, waf.message.policy, waf.message.src_ip.geo.ip, waf.message.src_ip.geo.province, waf.message.src_port, waf.message.status, waf.message.threaten, waf.method, waf.module, waf.msg.act, waf.msg.cs, waf.msg.policy_id, waf.msg.src.geo.country, waf.policy_name, waf.proto, waf.referer, waf.risk_level, waf.severity, waf.src.geo.city, waf.src.geo.country, waf.src.geo.ip, waf.src.geo.isp, waf.src.geo.latitude, waf.src.geo.longitude, waf.src.geo.province, waf.src_ip, waf.src_port, waf.status, waf.status_code, waf.threat_level, waf.time, waf.ua_browser, waf.ua_device, waf.ua_os, waf.uri, waf.url, waf.user_agent.browser, waf.user_agent.os, waf.website_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想问的是，在一天内，同样是访问了“waf”这个应用的网站，使用了“yxlink”这个攻击方式，不同国家的用户分别从哪些城市发起的呢？", "output": "appname:waf tag:yxlink waf.src.geo.country:中国 | stats count() by waf.src_ip,waf.src.geo.city|rename waf.src_ip as from,waf.src.geo.city as to|append [[appname:waf tag:yxlink waf.src.geo.country:中国 | stats count() by waf.src.geo.city,waf.event_name|rename waf.src.geo.city as from,waf.event_name as to]] |append [[appname:waf tag:yxlink waf.src.geo.country:中国 | stats count() by waf.event_name,waf.action|rename waf.event_name as from,waf.action as to]]"}
{"input": "索引可用字段有：waf.action, waf.attack_name, waf.attack_type, waf.bytes_in, waf.cost, waf.cve_id, waf.dst_city, waf.dst_domain, waf.dst_ip, waf.dst_latitude, waf.dst_longitude, waf.dst_port, waf.error_msg, waf.event_level, waf.event_log_level, waf.event_name, waf.event_type, waf.http_method, waf.http_refer, waf.is_truncated, waf.kv.Evt_level, waf.kv.Evt_type, waf.kv.event_name, waf.kv.http_method, waf.kv.http_refer, waf.kv.http_url, waf.kv.msg, waf.kv.owasp_top, waf.kv.pri, waf.kv.severity_level, waf.kv.status, waf.kv.type, waf.level, waf.log_category, waf.message, waf.message.action, waf.message.event, waf.message.method, waf.message.policy, waf.message.src_ip.geo.ip, waf.message.src_ip.geo.province, waf.message.src_port, waf.message.status, waf.message.threaten, waf.method, waf.module, waf.msg.act, waf.msg.cs, waf.msg.policy_id, waf.msg.src.geo.country, waf.policy_name, waf.proto, waf.referer, waf.risk_level, waf.severity, waf.src.geo.city, waf.src.geo.country, waf.src.geo.ip, waf.src.geo.isp, waf.src.geo.latitude, waf.src.geo.longitude, waf.src.geo.province, waf.src_ip, waf.src_port, waf.status, waf.status_code, waf.threat_level, waf.time, waf.ua_browser, waf.ua_device, waf.ua_os, waf.uri, waf.url, waf.user_agent.browser, waf.user_agent.os, waf.website_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想问的是，在上周五到上周日的每天中，哪个国家、省份和城市最多有用户使用 F5 WAF 服务进行攻击？", "output": "appname:waf tag:f5 NOT waf.is_truncated:truncated NOT waf.attack_type:\"\" |stats count() as cnt by waf.src.geo.country,waf.src.geo.province,waf.src.geo.city|append[[ appname:waf tag:f5  waf.is_truncated:truncated   |stats count() as cnt by waf.src.geo.country,waf.src.geo.province,waf.src.geo.city]]"}
{"input": "", "instruction": "我想问的是，有多少人使用 aix 用户在访问系统，并且知道他们的 IP 是什么吗？", "output": "tag:last appname:aix| stats count(hostname) as count_ by hostname,aix.user,aix.type,timestamp,aix.span_h,aix.span_m,aix.src_ip,aix.net|eval login_date = formatdate(timestamp) |lookup ip ip.csv on aix.net=ip|eval bl_ip =if(empty(ip),0,1) |where bl_ip >0|eval span_h=(todouble(aix.span_h))*3600|eval span_m=(todouble(aix.span_m))*60|eval login_cost=span_h+span_m|fields hostname,aix.user,aix.type,login_date,login_cost,aix.src_ip |rename hostname as login_host, aix.user as login_user, aix.way as login_way, aix.span_m as login_cost, aix.src_ip as login_srcip|eval line=\"line1\"|append [[tag:who| stats count(hostname) by hostname,aix.user,aix.type,aix.login_time,aix.src_ip,aix.net |lookup ip ip.csv on aix.net=ip|eval bl_ip =if(empty(ip),0,1) |where bl_ip >0|fields hostname,aix.user,aix.type,aix.login_time,aix.src_ip |rename hostname as login_host, aix.user as login_user, aix.type as login_way, aix.login_time as login_date, aix.src_ip as login_srcip|eval line=\"line2\"]]|fields login_host,login_user,login_way,login_cost,login_srcip,login_date, login_host as \"登录主机\", login_user as \"登录用户\", login_way as  \"登录方式\", login_srcip as \"登录ip\", login_cost as \"登录时长_秒\", login_date as \"登录时间\""}
{"input": "索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想知道有没有人在使用 VPN 服务进行不正常的活动，比如暴力破解、账号共享和异常登录或访问资源。你能帮我列出这些情况吗？", "output": "appname:vpn vpn.login_user:* vpn.actype:login vpn.result:failure  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,0,cnt==2,10,cnt==3,15,cnt>4,20,default,20)|append[[appname:vpn vpn.login_user:* vpn.actype:login  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,0,cnt==2,10,cnt>=3,20,default,20)]]|append[[appname:vpn vpn.login_user:* vpn.actype:login  (NOT vpn.src_ip.geo.country:private)   (NOT vpn.src_ip.geo.country:中国)  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,15,cnt>=4,20,default,20)]]|append[[appname:vpn vpn.login_user:* vpn.actype:login|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,15,cnt>=4,20,default,20)]]|append[[appname:vpn vpn.login_user:* vpn.actype:\"access resource\" vpn.login_user:* (NOT vpn.result:success) vpn.result:*|limit 1|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,15,cnt>=4,20,default,20)]]|stats sum(aaa) as total by vpn.login_user,app1| eval final=100-total |mvcombine sep=\"/\" app1|sort by +final|fields vpn.login_user,app1,final | eval level=if(final==100,\"健康\",if(final>=80,\"轻危\",if(final>=60,\"中危\",if(final<60,\"高危\",null))))|rename vpn.login_user as \"用户名\",app1 as \"存在的可以操作\",final as \"健康评分\",level as \"危险等级\""}
{"input": "索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想问的是，从哪些城市的防火墙出去访问谁呢？", "output": "appname:firewall tag:dc   firewall.src.geo.city:private |stats count() as cnt by firewall.src_ip,firewall.src_port,firewall.dst_ip,firewall.dst.geo.country,firewall.dst.geo.city| eval dst=firewall.dst_ip+\"_\"+firewall.dst.geo.city|eval from=firewall.src_ip|eval to=firewall.src_port|sort by cnt|limit 20|fields from,to,cnt|append[[ appname:firewall tag:dc firewall.src.geo.city:private  |stats count() as cnt by firewall.src_ip,firewall.src_port,firewall.dst_ip,firewall.dst.geo.country,firewall.dst.geo.city | eval dst=firewall.dst_ip+\"_\"+firewall.dst.geo.country+\"_\"+firewall.dst.geo.city |eval from=firewall.src_port |eval to=dst |sort by cnt |limit 20 |fields from,to,cnt]]"}
{"input": "索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想问的是，最近在国内各大城市的 Dc 机房到底有哪些 IP 和端口被扫描过最多？", "output": "appname:firewall tag:dc   NOT firewall.src.geo.city:private |stats count() as cnt by firewall.src_ip,firewall.dst_port,firewall.dst_ip,firewall.src.geo.province,firewall.src.geo.city| eval src=firewall.src_ip+\"_\"+firewall.src.geo.province+\"_\"+firewall.src.geo.city|eval from=src|eval to=firewall.dst_ip|fields from,to,cnt |sort by cnt |limit 20 |fields from,to,cnt|append[[ appname:firewall tag:dc NOT firewall.src.geo.city:private  |stats count() as cnt by firewall.src_ip,firewall.dst_port,firewall.dst_ip,firewall.src.geo.province,firewall.src.geo.city |eval from=firewall.dst_ip |eval to=firewall.dst_port |sort by cnt |limit 20 |fields from,to,cnt]]"}
{"input": "索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想问的是，最近有没有人在使用 Sangfor VPN 进行访问资源的行为吗？可以列出前十名用户和他们所访问的资源吗？", "output": "appname:vpn tag:sangfor_0trust  vpn.event_name:access_resource|stats count() as cnt by vpn.resource_name|rename vpn.resource_name as resource_name| append [[ appname:vpn tag:sangfor_0trust  vpn.event_name:app |stats count() as cnt by vpn.target.displayName | rename vpn.target.displayName as resource_name]]|stats sum(cnt) as cnt by resource_name|sort by cnt|limit 10"}
{"input": "索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "过滤Cisco ASA日志里的failure、teardown或blocked的事件。根据源IP、目的IP、目的端口统计数量并获取量最大的前 20 组。保留源IP、目的IP、数量cnt字段并重命名源IP为from,目的IP为to。然后追加一个同样的查询,但统计目的IP和端口，重命名目的IP为from,目的端口为to。", "output": "appname:firewall tag:cisco_asa (firewall.action:failure OR firewall.action:teardown OR firewall.action:blocked) | stats count() as cnt by firewall.src.geo.ip,firewall.dst.geo.ip,firewall.dst_port|sort by cnt|limit 20|fields firewall.src.geo.ip,firewall.dst.geo.ip,cnt|rename  firewall.src.geo.ip as from,firewall.dst.geo.ip as to| append [[appname:firewall tag:cisco_asa (firewall.action:failure OR firewall.action:teardown OR firewall.action:blocked) | stats count() as cnt by firewall.src.geo.ip,firewall.dst.geo.ip,firewall.dst_port|sort by cnt|limit 20|fields firewall.dst.geo.ip,firewall.dst_port,cnt|rename firewall.dst.geo.ip as from,firewall.dst_port as to]]"}
{"input": "索引可用字段有：nta.Service_Name, nta.alert.action, nta.alert.category, nta.alert.metadata.former_category, nta.alert.severity, nta.alert.signature, nta.attack_name, nta.attack_type, nta.dest_ip, nta.dest_port, nta.dst.geo.city, nta.dst_ip, nta.dst_ip_city, nta.dst_port, nta.event_level, nta.event_name, nta.event_type, nta.flow.bytes_toclient, nta.flow.bytes_toserver, nta.kill_chain, nta.level, nta.login_user, nta.proto, nta.src.geo.city, nta.src.geo.country, nta.src.geo.province, nta.src_ip, nta.src_ip_city, nta.src_port, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想问的是，从哪些 IP 地址到端口号为 80 的服务器的访问量最高呢？你可以把结果限制在前 20 个IP地址上吗？", "output": "appname:nta tag:chaitin | stats count() as cnt by nta.src_ip,nta.dst_ip,nta.dst_port|sort by cnt|limit 20|rename nta.src_ip as from,nta.dst_ip as to|append [[ appname:nta tag:chaitin  | stats count() as cnt by nta.src_ip,nta.dst_ip,nta.dst_port |sort by cnt |limit 20 |rename nta.dst_ip as from,nta.dst_port as to]]|fields from,to,cnt"}
{"input": "", "instruction": "我想要知道从哪些IP地址发送流量到哪些IP地址的机器上，并按数量排序。最多显示前20个结果。", "output": "appname:fireeye tag:nx| stats count() as cnt by nx.src_ip,nx.dst_ip,nx.sname|sort by cnt|limit 20|rename nx.src_ip as from,nx.dst_ip as to|append [[ appname:fireeye tag:nx  | stats count() as cnt by nx.src_ip,nx.dst_ip,nx.sname |sort by cnt |limit 20 |rename nx.dst_ip as from,nx.sname as to]]|fields from,to,cnt"}
{"input": "", "instruction": "我想知道从哪些IP地址发送到了哪些目的地的TCP端口为2183的流量有多大。", "output": "appname:fireeye tag:nx | stats count() as cnt by nx.src_ip,nx.dst_ip,nx.dst_port|sort by cnt|limit 20|rename nx.src_ip as from,nx.dst_ip as to|append [[ appname:fireeye tag:nx  | stats count() as cnt by nx.src_ip,nx.dst_ip,nx.dst_port |sort by cnt |limit 20 |rename nx.dst_ip as from,nx.dst_port as to]]|fields from,to,cnt"}
{"input": "", "instruction": "我想询问关于 DNS 查询的一些信息，比如源 IP 和搜索类型等：这个查询首先从所有索引中检索包含 `appname:dns` 和 `tag:bind9` 字段的所有事件，然后使用STATS聚合函数计算每个源 IP 和搜索类型的数量，并将结果重命名为 `from` 和 `to`，最后以降序排列并限制到前 30 个结果。", "output": "appname:dns tag:bind9 |stats count() as cnt by dns.src_ip,dns.search_type|rename dns.src_ip as from,dns.search_type as to|sort by cnt |limit 30|append [[appname:dns tag:bind9 |stats count() as cnt by dns.search_type,dns.query |rename dns.search_type as from,dns.query as to|sort by cnt |limit 30]]"}
{"input": "索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想询问最近一段时间的防火墙审计信息中是否存在某些特定的关键词或命令，例如“TopSec”和“配置”。", "output": "appname:firewall AND tag:topsec (AUTH OR firewall.recorder:config)| table firewall.time,firewall.msg.fw,firewall.msg.user,firewall.src_ip,firewall.msg.msg|rename firewall.msg.msg as msg  |append[[ appname:firewall AND tag:topsec config  |table  firewall.time,firewall.msg.fw,firewall.msg.user,firewall.src_ip,firewall.msg.command |rename firewall.msg.command as msg]]"}
{"input": "索引可用字段有：ths_all.ANSTYPE, ths_all.GDZH, ths_all.funccn, ths_all.msg, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "帮我分析一段同花顺交易系统的访问日志，并发现其中有些操作是错误的或异常的。找所有在`appname`为`ths_all`且`tag`为`ths_all`的日志中，其`ANSTYPE`不等于1或0（表示成功或失败）的行。然后，使用一个`eval`函数将时间字段转换成字符串格式，并对结果进行排序和分组。最后，显示了一些列，包括时间、合约代码、功能码、操作状态（成功/失败）以及操作类型（请求/响应）。", "output": "appname:ths_all tag:ths_all NOT (ths_all.ANSTYPE:1 OR  ths_all.ANSTYPE:0)|eval time=formatdate(timestamp)| table time,ths_all.GDZH,ths_all.funccn|eval line=\"请求\" |append [[ appname:ths_all tag:ths_all  (ths_all.ANSTYPE:1 OR  ths_all.ANSTYPE:0)|eval time=formatdate(timestamp)| table time,ths_all.ANSTYPE,ths_all.GDZH,ths_all.funccn,ths_all.msg |eval line=\"返回\" ]]|eval bbb=case(ths_all.ANSTYPE==\"1\",\"成功\",ths_all.ANSTYPE==\"0\",\"失败\",default,\"\")|sort by +time |fields time,ths_all.GDZH,ths_all.funccn,bbb,line,ths_all.msg"}
{"input": "索引可用字段有：ths_all.ANSTYPE, ths_all.GDZH, ths_all.funccn, ths_all.msg, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "根据ths_all.ANSTYPE值做判断，为 1 表示成功，为 0 表示失败。然后按时间排序", "output": "appname:ths_all tag:ths_all NOT (ths_all.ANSTYPE:1 OR  ths_all.ANSTYPE:0)|eval time=formatdate(timestamp)| table time,ths_all.GDZH,ths_all.funccn|eval line=\"请求\" |append [[ appname:ths_all tag:ths_all  (ths_all.ANSTYPE:1 OR  ths_all.ANSTYPE:0)|eval time=formatdate(timestamp)| table time,ths_all.ANSTYPE,ths_all.GDZH,ths_all.funccn,ths_all.msg |eval line=\"返回\" ]]|eval bbb=case(ths_all.ANSTYPE==\"1\",\"成功\",ths_all.ANSTYPE==\"0\",\"失败\",default,\"\")|sort by +time |fields time,ths_all.GDZH,ths_all.funccn,bbb,line,ths_all.msg"}
{"input": "索引可用字段有：ths_all.ANSTYPE, ths_all.GDZH, ths_all.funccn, ths_all.msg, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想知道的是：在同花顺交易系统中，用户使用某些功能后会产生相应的访问和返回记录，这些记录包括时间、股东账户、功能类型、返回状态（是否成功）以及其他相关信息。", "output": "appname:ths_all tag:ths_all NOT (ths_all.ANSTYPE:1 OR  ths_all.ANSTYPE:0)|eval time=formatdate(timestamp)| table time,ths_all.GDZH,ths_all.funccn|eval line=\"请求\" |append [[ appname:ths_all tag:ths_all  (ths_all.ANSTYPE:1 OR  ths_all.ANSTYPE:0)|eval time=formatdate(timestamp)| table time,ths_all.ANSTYPE,ths_all.GDZH,ths_all.funccn,ths_all.msg |eval line=\"返回\" ]]|eval bbb=case(ths_all.ANSTYPE==\"1\",\"成功\",ths_all.ANSTYPE==\"0\",\"失败\",default,\"\")|sort by +time |fields time,ths_all.GDZH,ths_all.funccn,bbb,line,ths_all.msg|rename time as \"时间\", ths_all.GDZH as \"股东账号\", ths_all.funccn as \"功能类型\", bbb as \"返回状态\", ths_all.msg as \"返回内容\", line as \"操作类型\""}
{"input": "", "instruction": "希望了解的是Zookeeper服务的运行状况以及与其通信时所产生的数据包数量。", "output": "appname:zookeeper tag:zookeeper_health |sort by +timestamp| table timestamp,middleware.zkmsg.zk_packets_sent|autoregress middleware.zkmsg.zk_packets_sent 1|where middleware.zkmsg.zk_packets_sent_p1>0|eval cnt=middleware.zkmsg.zk_packets_sent-middleware.zkmsg.zk_packets_sent_p1|eval time=tolong(timestamp)|eval line=\"发送\"|append [[appname:zookeeper tag:zookeeper_health |sort by +timestamp| table timestamp,middleware.zkmsg.zk_packets_received|autoregress middleware.zkmsg.zk_packets_received 1|where middleware.zkmsg.zk_packets_received_p1>0|eval cnt=middleware.zkmsg.zk_packets_received-middleware.zkmsg.zk_packets_received_p1|eval time=tolong(timestamp)|eval line=\"接收\"]]"}
{"input": "", "instruction": "我想问如何编写SPL（Search Processing Language）查询以获取关于Antivirus Gateway应用中Symantec安全产品的使用情况统计信息和相关用户列表的信息。", "output": "* appname:antivirus_gateway tag:symantec  \"规则\" | stats count() as total by 'antivirus_gateway.rulekv.用户' |limit 10|append[[appname:antivirus_gateway AND ( tag:symantec OR tag:symantec_app_c OR tag:symantec_risk )|  stats count() as total by antivirus_gateway.user |limit 10]]| rename 'antivirus_gateway.rulekv.用户' as user,antivirus_gateway.user as user"}
{"input": "索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想知道最近有没有人在使用暴力破解软件来尝试登陆我的VPN账户。如果他们的IP地址和地理位置不符合常规，那就更加担心了。而且，他们为什么会在非工作时间进行这些活动呢？这可能是一个安全风险。", "output": "appname:vpn vpn.login_user:* vpn.actype:login vpn.result:failure  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,line|eval aaa=case(cnt==1,0,cnt==2,20,cnt==3,30,cnt>=4,50,default,0)|append[[appname:vpn vpn.login_user:* vpn.actype:login  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,line|eval aaa=case(cnt==2,20,cnt>=3,50,default,0)]]|append[[appname:vpn vpn.login_user:* vpn.actype:login  (NOT vpn.src.geo.country:private)   (NOT vpn.src.geo.country:\"中国\")  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,line|eval aaa=case(cnt==1,30,cnt==2,40,cnt>=4,50,default,0)]]|append[[appname:vpn vpn.login_user:* vpn.actype:login|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)]]|append[[appname:vpn vpn.login_user:* vpn.actype:\"access resource\" vpn.login_user:* (NOT vpn.result:success) vpn.result:*|limit 1|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)]]|eval ccc=if(empty(cnt),fs,aaa)| stats max(ccc) as ddd by  app1 |stats count() as cnt by  app1,ddd |fields app1,ddd"}
{"input": "索引可用字段有：audit.MACHINE, audit.OSUSER, audit.PROGRAM, audit.SQL_ID, audit.SQL_TEXT, audit.USERNAME, audit.command, audit.msg.cmd, audit.msg.command, audit.msg.exec_time, audit.msg.info, audit.msg.path, audit.msg.pid, audit.msg.pwd, audit.msg.rhost, audit.msg.ruser, audit.msg.ser, audit.msg.src_ip, audit.msg.src_port, audit.msg.user, audit.up_time, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想问的是服务器上有没有出现过异常的情况，比如系统崩溃、服务不可用等问题。根据你提供的信息，我看到以下可能的问题：1. rsyslog服务未正常运行，这可能会导致一些重要的系统消息无法记录到文件中，从而影响系统的安全性和稳定性。2. SSH服务受到了攻击，用户在尝试登录时可能使用错误的密码或其他方式进行了攻击，这可能会导致SSH服务被拒绝访问或者其他类似的问题。3. 用户执行了某些敏感操作，例如修改了系统配置、删除了文件等，这些操作可能会破坏系统的安全性和可用性。因此，您可以询问服务器管理员是否已经处理了以上问题，并采取适当措施防止再次发生。", "output": "tag:linux_boot | parse field=raw_message \".*boot\\s+(?<boot_time>[^\\:]+\\:\\d+)\" | eval current_time=now() | eval dura=current_time-parsedate(boot_time,\"yyyy-MM-dd HH:mm\") | stats count() by ip,dura | where tolong(dura)<300000 | stats dc(ip) as error by ip | eval type=\"系统重启\"  | append [[ tag:rsyslog_status | dedup 1 ip |  parse \".*(?<status>running)\"  | where status!=\"running\" | stats dc(ip) as error by ip | eval type=\"rsyslog关闭\" ]] | append [[ appname:audit AND audit.msg.ser:sshd AND \"Failed password for\" | stats count() as error by ip | eval type=\"登录失败\" ]] | append [[ appname:audit AND audit.msg.ser:shell_cmd AND (audit.msg.command:service* OR audit.msg.command:rm* OR audit.msg.command:export* OR audit.msg.command:kill*) | stats count() as error by ip | eval type=\"敏感命令\" ]] | stats sum(error) as _sum"}
{"input": "索引可用字段有：switch.IP, switch.action, switch.auth_method, switch.bandwidth, switch.brief, switch.cmd, switch.count, switch.desc, switch.desc.cmd, switch.desc.user, switch.describe, switch.ethernet, switch.event_type, switch.facility, switch.host, switch.host_ip, switch.interface_name, switch.ip, switch.kv.COMMAND, switch.kv.TTY, switch.kv.USER, switch.kvmsg.IpAddress, switch.kvmsg.UserName, switch.level, switch.log_message, switch.log_type, switch.login_method, switch.mode, switch.module, switch.port, switch.port_channel, switch.reason, switch.result, switch.severity, switch.speed, switch.src_ip, switch.src_mac, switch.state, switch.terminal, switch.time, switch.user, switch.vlan, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我正在寻找所有由名为 'Cisco IOS'、标签为'switch' 的应用生成的 Syslog 消息，其中包含一条以 'Configured from' 为前缀并使用正则表达式 '(?<config_from>\\w+)' 来获取源地址、'by' 和 'on' 后跟随的字符串作为目标地址和登录设备 IP 地址，然后将这些字段用作新列重命名并追加到现有数据集中。”", "output": "appname:switch tag:cisco_ios  AND SYS-5-CONFIG_I |parse \"Configured from (?<config_from>\\w+) by (?<config_terminal>\\w+) on (?<vty>\\w+) \\((?<terminal_ip>[^\\)]+)\\)\"  |stats count() by config_from,config_terminal |rename config_from as  from,config_terminal as to |append [[appname:switch tag:cisco_ios  AND SYS-5-CONFIG_I |parse \"Configured from (?<config_from>\\w+) by (?<config_terminal>\\w+) on (?<vty>\\w+) \\((?<terminal_ip>[^\\)]+)\\)\"  |stats count() by config_terminal,terminal_ip|rename config_terminal as from,terminal_ip as to]] "}
{"input": "索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想要知道有多少条记录匹配上述条件，并按应用和协议进行分组汇总。请在每个分组中显示总数以及各个应用或协议的数量。", "output": "(* IPS) AND appname:firewall tag:hillstone |stats count() as total by 'firewall.msg.kvs.应用/协议'|rename 'firewall.msg.kvs.应用/协议' as proto |append[[  (* IPS) AND appname:firewall tag:hillstone  |stats count() as total by firewall.proto |rename firewall.proto as proto ]]"}
{"input": "索引可用字段有：waf.action, waf.attack_name, waf.attack_type, waf.bytes_in, waf.cost, waf.cve_id, waf.dst_city, waf.dst_domain, waf.dst_ip, waf.dst_latitude, waf.dst_longitude, waf.dst_port, waf.error_msg, waf.event_level, waf.event_log_level, waf.event_name, waf.event_type, waf.http_method, waf.http_refer, waf.is_truncated, waf.kv.Evt_level, waf.kv.Evt_type, waf.kv.event_name, waf.kv.http_method, waf.kv.http_refer, waf.kv.http_url, waf.kv.msg, waf.kv.owasp_top, waf.kv.pri, waf.kv.severity_level, waf.kv.status, waf.kv.type, waf.level, waf.log_category, waf.message, waf.message.action, waf.message.event, waf.message.method, waf.message.policy, waf.message.src_ip.geo.ip, waf.message.src_ip.geo.province, waf.message.src_port, waf.message.status, waf.message.threaten, waf.method, waf.module, waf.msg.act, waf.msg.cs, waf.msg.policy_id, waf.msg.src.geo.country, waf.policy_name, waf.proto, waf.referer, waf.risk_level, waf.severity, waf.src.geo.city, waf.src.geo.country, waf.src.geo.ip, waf.src.geo.isp, waf.src.geo.latitude, waf.src.geo.longitude, waf.src.geo.province, waf.src_ip, waf.src_port, waf.status, waf.status_code, waf.threat_level, waf.time, waf.ua_browser, waf.ua_device, waf.ua_os, waf.uri, waf.url, waf.user_agent.browser, waf.user_agent.os, waf.website_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想问的是，在这个时间段内，有哪些请求没有被拦截到。", "output": "appname:waf AND tag:imperva waf.action:None|stats count() as cn by waf.action|append[[appname:waf AND tag:imperva waf.action:\"无\"|stats count() as cn by waf.action]]"}
{"input": "索引可用字段有：waf.action, waf.attack_name, waf.attack_type, waf.bytes_in, waf.cost, waf.cve_id, waf.dst_city, waf.dst_domain, waf.dst_ip, waf.dst_latitude, waf.dst_longitude, waf.dst_port, waf.error_msg, waf.event_level, waf.event_log_level, waf.event_name, waf.event_type, waf.http_method, waf.http_refer, waf.is_truncated, waf.kv.Evt_level, waf.kv.Evt_type, waf.kv.event_name, waf.kv.http_method, waf.kv.http_refer, waf.kv.http_url, waf.kv.msg, waf.kv.owasp_top, waf.kv.pri, waf.kv.severity_level, waf.kv.status, waf.kv.type, waf.level, waf.log_category, waf.message, waf.message.action, waf.message.event, waf.message.method, waf.message.policy, waf.message.src_ip.geo.ip, waf.message.src_ip.geo.province, waf.message.src_port, waf.message.status, waf.message.threaten, waf.method, waf.module, waf.msg.act, waf.msg.cs, waf.msg.policy_id, waf.msg.src.geo.country, waf.policy_name, waf.proto, waf.referer, waf.risk_level, waf.severity, waf.src.geo.city, waf.src.geo.country, waf.src.geo.ip, waf.src.geo.isp, waf.src.geo.latitude, waf.src.geo.longitude, waf.src.geo.province, waf.src_ip, waf.src_port, waf.status, waf.status_code, waf.threat_level, waf.time, waf.ua_browser, waf.ua_device, waf.ua_os, waf.uri, waf.url, waf.user_agent.browser, waf.user_agent.os, waf.website_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想问的是，在过去一小时内，有多少次访问了 Imperva WAF 的应用名称为“waf”并且带上了标签“imperva”的请求中包含了“锁定”或者“统计”两个词汇的 HTTP 操作？", "output": "appname:waf AND tag:imperva waf.action:*lock|stats count() as cn by appname|append[[appname:waf AND tag:imperva waf.action:\"阻止\"|stats count() as cn by appname]]"}
{"input": "", "instruction": "我想问的是：在 leagsoft 这个应用中，有多少条数据包含了 strDevIP 字段的值？并且将这些数据的数量统计并按 devip 分组后再输出前十个结果。", "output": "appname:leagsoft tag:tc | stats count() as cnt by tc.msg.kv.strDevIP| rename tc.msg.kv.strDevIP as devip |append[[appname:leagsoft tag:tc | stats count() as cnt by tc.msg.kv.strdevip | rename tc.msg.kv.strdevip as devip]]|limit 10"}
{"input": "索引可用字段有：nas.dst_ip, nas.kv.Category, nas.kv.Match, nas.kv.Rule, nas.src_ip, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想要知道最近 Forescout 应用的访问记录中包含或不包含 'Match' 这个关键字的数量对比？", "output": "appname:nas tag:forescout nas.kv.Match:*Match*|stats count() as cnt |eval line=\"匹配成功\"|append[[appname:nas tag:forescout nas.kv.Match:*Unmatch*|stats count() as cnt |eval line=\"匹配失败\"]]"}
{"input": "索引可用字段有：switch.IP, switch.action, switch.auth_method, switch.bandwidth, switch.brief, switch.cmd, switch.count, switch.desc, switch.desc.cmd, switch.desc.user, switch.describe, switch.ethernet, switch.event_type, switch.facility, switch.host, switch.host_ip, switch.interface_name, switch.ip, switch.kv.COMMAND, switch.kv.TTY, switch.kv.USER, switch.kvmsg.IpAddress, switch.kvmsg.UserName, switch.level, switch.log_message, switch.log_type, switch.login_method, switch.mode, switch.module, switch.port, switch.port_channel, switch.reason, switch.result, switch.severity, switch.speed, switch.src_ip, switch.src_mac, switch.state, switch.terminal, switch.time, switch.user, switch.vlan, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想询问Cisco Nexus交换机的状态和端口信息。", "output": "appname:switch AND tag:cisco_nexus AND  ETHPORT-5-IF_UP |stats count() by switch.port_channel,switch.state |rename switch.port_channel as from,switch.state as to |append [[appname:switch AND tag:cisco_nexus AND  ETHPORT-5-IF_UP |stats count() by switch.state,switch.mode |rename switch.state as  from,switch.mode as to]] |append [[appname:switch AND tag:cisco_nexus AND  ETHPORT-5-SPEED |stats count() by switch.ethernet,switch.speed |rename switch.ethernet as to,switch.speed as from]]"}
{"input": "索引可用字段有：dlp.action, dlp.actionType, dlp.channelType, dlp.corporateType, dlp.details, dlp.dst_user, dlp.file_name, dlp.hostname, dlp.login_user, dlp.msg, dlp.policyNames, dlp.recv_mail, dlp.send_mail, dlp.service, dlp.severityType, dlp.src.geo.country, dlp.src_ip, dlp.src_user, dlp.user, dlp.workModeType, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想知道网站访问情况，你能帮我把相关的统计结果整理一下吗？我需要了解哪些网站被访问到了，以及这些网站分别从哪些IP地址访问过来的。", "output": "appname:dlp tag:websense|rename dlp.src_ip as src| stats count() as cnt by src |join src[[ appname:h_1  |rename h_1.loacl_ip as dst_ip,h_1.src_ip as src |stats count() as cnt by dst_ip,src  |lookup de webip.csv on dst_ip=ipaddr ]]|append[[  appname:h_1 (h_1.loacl_ip:\"2.1.1.11\") |rename h_1.loacl_ip as dst_ip,h_1.src_ip as src |stats count() as cnt by dst_ip,src |lookup de webip.csv on dst_ip=ipaddr ]]|rename src as from,de as to|append[[   appname:h_1 (NOT h_1.loacl_ip:\"2.1.1.11\") |rename h_1.loacl_ip as dst_ip,h_1.src_ip as src |stats count() as cnt by dst_ip,src |lookup de webip.csv on dst_ip=ipaddr  |eval from=\"综合前置\" |rename de as to ]]|append[[    appname:h_1 (NOT h_1.loacl_ip:\"2.1.1.11\") |rename h_1.loacl_ip as dst_ip,h_1.src_ip as src |stats count() as cnt by dst_ip,src |lookup de webip.csv on dst_ip=ipaddr  |rename src as from,de as to]]|append[[  appname:apache tag:access |stats count() as cnt by middleware.clientip,middleware.request_path | lookup api api_list.csv on middleware.request_path=api |lookup de webip.csv on middleware.clientip=ipaddr |where!empty(api)   |rename de as from,api as to ]]"}
{"input": "", "instruction": "寻找关于“Hillstone”和防火墙（`appname:firewall`）之间的关系以及该事件发生的次数。因此，我的建议是：1. 使用 `tag:hillstone` 查询所有与 Hillstone 有关的记录；2. 使用 `stats count()` 命令统计这些记录中的事件数量并将其按 `firewall.msg.msg.威胁名称` 分组；3. 将结果重命名为 `event`，并使用 `limit 10` 对结果进行限制；4. 添加一个新的过滤器以查找具有相同标签 (`tag:hillstone`) 和应用名 (`appname:firewall`)的所有记录，然后重复步骤 2-4 以获得第二个分组的数据。", "output": "(* IPS) AND tag:hillstone |stats count() as total by 'firewall.msg.msg.威胁名称' |rename 'firewall.msg.kvs.威胁名称' as event| limit 10|append[[  (* IPS) AND appname:firewall tag:hillstone  |stats count() as total by firewall.event_name |rename firewall.event_name as event |limit 10]]"}
{"input": "", "instruction": "我想询问关于CUPP应用的失败率的信息：1. sourcetype: cupp 表示要检索的数据源类型为CUPP应用；2. stats count (retcode) as total 汇总所有返回代码（retcode）的数量并将结果命名为total；3. appendcols [[appname: cupp not retcode: 0000000 | stats count (retcode) as fail]] 使用子查询添加新列，如果retcode不等于0000000，则统计fail列中的返回代码数量；4. eval _rate = abs (total - fail) / total * 100 对比total和fail列的值，计算出失败率的百分比并将其命名为_rate。", "output": "sourcetype:cupp |stats count(retcode) as total  |appendcols [[ appname:cupp NOT retcode:0000000|stats count(retcode) as faile  ]] |eval _rate=abs(total-faile)/total*100"}
{"input": "索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "用户：我想知道最近有没有人在使用VPN进行暴力破解我们的服务器。", "output": "appname:vpn vpn.login_user:* vpn.actype:login vpn.result:failure  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,0,cnt==2,20,cnt==3,30,cnt>=4,50,default,20)|append[[appname:vpn vpn.login_user:* vpn.actype:login  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==2,20,cnt>=3,50,default,0)]]|append[[appname:vpn vpn.login_user:* vpn.actype:login  (NOT vpn.src.geo.country:private)   (NOT vpn.src.geo.country:中国)  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,30,cnt==2,40,cnt>=4,50,default,0)]]|append[[appname:vpn vpn.login_user:* vpn.actype:login|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)]]|append[[appname:vpn vpn.login_user:* vpn.actype:\"access resource\" vpn.login_user:* (NOT vpn.result:success) vpn.result:*|limit 1|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)]]|stats sum(aaa) as all by vpn.login_user|sort by all|where all!=0|fields vpn.login_user,app1,all | eval level=if(all==0,\"健康\",if(all>=80,\"高危\",if(all>=60,\"中危\",if(all<60,\"危\",null))))|rename vpn.login_user as \"用户名\",app1 as \"存在的可以操作\",all as \"威胁评分\",level as \"危险等级\""}
{"input": "索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我正在使用 VPN 进行网络连接，但突然发现我的流量明显增多了，而且速度变慢了。这可能是一个安全问题吗？", "output": "appname:vpn vpn.login_user:* vpn.actype:login vpn.result:failure  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,0,cnt==2,20,cnt==3,30,cnt>=4,50,default,20)|append[[appname:vpn vpn.login_user:* vpn.actype:login  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==2,20,cnt>=3,50,default,0)]]|append[[appname:vpn vpn.login_user:* vpn.actype:login  (NOT vpn.src.geo.country:private)   (NOT vpn.src.geo.country:中国)  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,30,cnt==2,40,cnt>=4,50,default,0)]]|append[[appname:vpn vpn.login_user:* vpn.actype:login|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)]]|append[[appname:vpn vpn.login_user:* vpn.actype:\"access resource\" vpn.login_user:* (NOT vpn.result:success) vpn.result:*|limit 1|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.login_user,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)]]|stats sum(aaa) as all by vpn.login_user|sort by all|where all!=0|fields vpn.login_user,app1,all | eval level=if(all==0,\"健康\",if(all>=80,\"高危\",if(all>=60,\"中危\",if(all<60,\"危\",null))))|rename vpn.login_user as \"用户名\",app1 as \"存在的可以操作\",all as \"威胁评分\",level as \"危险等级\""}
{"input": "索引可用字段有：vpn.action, vpn.actor.displayName, vpn.actype, vpn.app.upstream.host, vpn.app.upstream.port, vpn.app.web.request.url, vpn.auth_dst, vpn.dst.geo.city, vpn.dst.geo.country, vpn.dst.geo.ip, vpn.dst.geo.isp, vpn.dst.geo.latitude, vpn.dst.geo.longitude, vpn.dst.geo.province, vpn.dst_ip, vpn.dst_nt_host, vpn.dst_port, vpn.event_level, vpn.event_name, vpn.kv.dst.geo.country, vpn.kv.dst.geo.latitude, vpn.kv.dst.geo.longitude, vpn.kv.msg, vpn.kv.proto, vpn.kv.src.geo.city, vpn.kv.src.geo.country, vpn.kv.src.geo.latitude, vpn.kv.src.geo.longitude, vpn.kv.user, vpn.login_user, vpn.msg, vpn.msg.virtual_ip, vpn.proto, vpn.reason, vpn.resource_name, vpn.result, vpn.seconds, vpn.src._ip, vpn.src.geo.city, vpn.src.geo.country, vpn.src.geo.ip, vpn.src.geo.isp, vpn.src.geo.latitude, vpn.src.geo.longitude, vpn.src.geo.province, vpn.src_ip, vpn.src_ip.geo.city, vpn.src_ip.geo.country, vpn.src_port, vpn.state, vpn.target.displayName, vpn.time, vpn.transport, vpn.user, vpn.user_name, vpn.vpn.login_user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想找的是 VPN 应用的一些失败或者异常的信息，比如用户使用错误的密码连不上服务器、或多次尝试登陆失败、甚至有人试图通过暴力破解的方式获取账户和密码等信息。你能帮我把这些关键词整理成一系列的 SPL 查询吗？", "output": "appname:vpn  (vpn.event_name:auth OR vpn.event_name:login OR vpn.event_name:logout) vpn.result:FAILED  |eval app1=\"疑似暴力破解\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==1,0,cnt==2,20,cnt==3,30,cnt>=4,50,default,20)|append[[appname:vpn  (vpn.event_name:auth OR vpn.event_name:login OR vpn.event_name:logout)  |eval app1=\"疑似账号共用\"|eval line=\"kkk\" | stats dc(vpn.src.geo.city) as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==2,20,cnt>=3,50,default,0)]]|append[[appname:vpn  (vpn.event_name:auth OR vpn.event_name:login OR vpn.event_name:logout)  (NOT vpn.src.geo.country:private)   (NOT vpn.src.geo.country:中国)  |eval app1=\"账号登录异常\"|eval line=\"kkk\" | stats dc(vpn.src_ip) as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==1,30,cnt==2,40,cnt>=4,50,default,0)]]|append[[appname:vpn  (vpn.event_name:auth OR vpn.event_name:login OR vpn.event_name:logout)|eval time1=tolong(formatdate(timestamp,\"HH\"))|where time1>18 || time1<8  |eval app1=\"异常时间登录\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)]]|append[[appname:vpn  vpn.event_name:\"access_resource\"  (NOT vpn.result:SUCCESS) vpn.result:*|eval app1=\"异常访问系统\"|eval line=\"kkk\" | stats count() as cnt by app1,vpn.user_name,line|eval aaa=case(cnt==1,10,cnt==2,20,cnt>=4,50,default,0)]]|stats sum(aaa) as all by vpn.user_name|sort by all|where all!=0|fields vpn.user_name,app1,all | eval level=if(all==0,\"健康\",if(all>=80,\"高危\",if(all>=60,\"中危\",if(all<60,\"危\",null))))|rename vpn.user_name as \"用户名\",app1 as \"存在的可以操作\",all as \"威胁评分\",level as \"危险等级\""}
{"input": "索引可用字段有：signal.green_time, signal.lane_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想问的是，上行车道 7.1 和 7.2 有什么不同吗？你能告诉我它们之间相对于其他车道的延迟时间有多大吗？", "output": "appname:signal signal.lane_name:7.1|stats count() as cnt by timestamp,signal.green_time,signal.lane_name|sort by +timestamp|autoregress signal.green_time as last_green_time p=1|autoregress timestamp as last_time p=1|sort by timestamp|eval interval=timestamp-last_time|eval interval_time=formatdate(interval,\"mm:ss\")|stats avg(interval) as cnt by signal.lane_name|eval avg_=tolong(cnt)|eval avg_interval_time=formatdate(avg_,\"mm:ss\")|append [[ appname:signal signal.lane_name:7.2 |stats count() as cnt by timestamp,signal.green_time,signal.lane_name |sort by +timestamp |autoregress signal.green_time as last_green_time p=1 |autoregress timestamp as last_time p=1 |sort by timestamp |eval interval=timestamp-last_time |eval interval_time=formatdate(interval,\"mm:ss\") |stats avg(interval) as cnt by signal.lane_name |eval avg_=tolong(cnt) |eval avg_interval_time=formatdate(avg_,\"mm:ss\")]] |fields signal.lane_name,avg_interval_time"}
{"input": "索引可用字段有：signal.green_time, signal.lane_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想问的是，从第五个红绿灯到下一次的第五个红绿灯之间，车道上的平均停留时间有多长？", "output": "appname:signal signal.lane_name:5.1|stats count() as cnt by timestamp,signal.green_time,signal.lane_name|sort by +timestamp|autoregress signal.green_time as last_green_time p=1|autoregress timestamp as last_time p=1|sort by timestamp|eval interval=timestamp-last_time|eval interval_time=formatdate(interval,\"mm:ss\")|stats avg(interval) as cnt by signal.lane_name|eval avg_=tolong(cnt)|eval avg_interval_time=formatdate(avg_,\"mm:ss\")|append [[ appname:signal signal.lane_name:5.2 |stats count() as cnt by timestamp,signal.green_time,signal.lane_name |sort by +timestamp |autoregress signal.green_time as last_green_time p=1 |autoregress timestamp as last_time p=1 |sort by timestamp |eval interval=timestamp-last_time |eval interval_time=formatdate(interval,\"mm:ss\") |stats avg(interval) as cnt by signal.lane_name |eval avg_=tolong(cnt) |eval avg_interval_time=formatdate(avg_,\"mm:ss\")]] |fields signal.lane_name,avg_interval_time"}
{"input": "索引可用字段有：signal.green_time, signal.lane_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想问的是，上一次信号灯变绿到这次的间隔时间是多少？请告诉我这个数字，并以“xx分钟和yy秒”的形式展示。", "output": "appname:signal signal.lane_name:8.1|stats count() as cnt by timestamp,signal.green_time,signal.lane_name|sort by +timestamp|autoregress signal.green_time as last_green_time p=1|autoregress timestamp as last_time p=1|sort by timestamp|eval interval=timestamp-last_time|eval interval_time=formatdate(interval,\"mm:ss\")|sort by interval|where!empty(interval)|limit 1|append [[ appname:signal signal.lane_name:8.2 |stats count() as cnt by timestamp,signal.green_time,signal.lane_name |sort by +timestamp |autoregress signal.green_time as last_green_time p=1 |autoregress timestamp as last_time p=1 |sort by timestamp |eval interval=timestamp-last_time |eval interval_time=formatdate(interval,\"mm:ss\") |sort by interval |where!empty(interval) |limit 1]]|fields signal.green_time,signal.lane_name,last_green_time,interval_time"}
{"input": "索引可用字段有：signal.green_time, signal.lane_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想询问交通信号数据中某车道的绿灯时长分布情况。对`signal`表中的`appname`，`signal.lane_name`和`timestamp`字段进行统计分析，并计算出每个时间段内的绿灯时长分布。", "output": "appname:signal signal.lane_name:4.1|stats count() as cnt by timestamp,signal.green_time,signal.lane_name|sort by +timestamp|autoregress signal.green_time as last_green_time p=1|autoregress timestamp as last_time p=1|sort by timestamp|eval interval=timestamp-last_time|eval interval_time=formatdate(interval,\"mm:ss\")|sort by interval|where!empty(interval)|limit 1|append [[ appname:signal signal.lane_name:4.2 |stats count() as cnt by timestamp,signal.green_time,signal.lane_name |sort by +timestamp |autoregress signal.green_time as last_green_time p=1 |autoregress timestamp as last_time p=1 |sort by timestamp |eval interval=timestamp-last_time |eval interval_time=formatdate(interval,\"mm:ss\") |sort by interval |where!empty(interval) |limit 1]]|fields signal.green_time,signal.lane_name,last_green_time,interval_time"}
{"input": "", "instruction": "我想表达的意思是：在一天前发生的反恶意软件事件中，使用了Symantec、Norton AntiVirus和 Endpoint Protection的产品；并且包含了“发现病毒”这个关键词或者描述信息。", "output": "starttime=\"-1d\" appname:antivirus_gateway tag:symantec  \"发现病毒\" |table 'antivirus_gateway.src_ip','antivirus_gateway.msg.计算机名','antivirus_gateway.msg.风险名称','antivirus_gateway.msg.流行程度','antivirus_gateway.msg.应用类型'|append[[appname:antivirus_gateway AND ( tag:symantec OR tag:symantec_app_c OR tag:symantec_risk ) \"发现病毒\" | table antivirus_gateway.src_ip,antivirus_gateway.host_name,antivirus_gateway.risk_name]]"}
{"input": "索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想询问如何使用日志易SPL（Search Processing Language）编写搜索查询：- 从 Palo Alto Networks Firewall 应用中检索具有“标签”为 paloalto、“桶”和时间戳的记录；- 查询结果将被分组并按时间间隔计算，以获取每个小时发生的事件数量；- 根据不同的防火墙类型（TRAFFIC、THREAT 和 SYSTEM），分别生成三个子查询，然后将其追加到同一搜索中；- 生成的最终报告包括三列：时间（hour）、事件总量（d）以及来自不同类型的事件的计数。", "output": "appname:firewall tag:paloalto |bucket timestamp span=30m as ts |stats count() by ts | eval hour = formatdate(ts, \"HH:mm\") | eval d=\"事件总量\" |append [[appname:firewall  tag:paloalto AND firewall.type:TRAFFIC |bucket timestamp span=30m as ts |stats count() by ts | eval hour = formatdate(ts, \"HH:mm\") | eval d=\"流量事件\"]] |append [[appname:firewall tag:paloalto AND firewall.type:THREAT |bucket timestamp span=30m as ts |stats count() by ts | eval hour = formatdate(ts, \"HH:mm\") | eval d=\"威胁事件\"]] |append [[appname:firewall tag:paloalto AND firewall.type:SYSTEM |bucket timestamp span=30m as ts |stats count() by ts | eval hour = formatdate(ts, \"HH:mm\") | eval d=\"系统事件\"]]"}
{"input": "索引可用字段有：linux.cmd, linux.command, linux.event_detail.comm, linux.event_detail.exe, linux.event_detail.key, linux.event_detail.pid, linux.event_detail.ppid, linux.event_id, linux.event_msg.terminal, linux.event_name, linux.event_type, linux.log_type, linux.login_time, linux.msg, linux.pid, linux.result, linux.service_name, linux.src_ip, linux.status, linux.terminal, linux.type, linux.use_time, linux.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我在询问我关于某些 Linux 系统的登录失败和登录成功事件数量的信息。使用日志易查询语言（ SPL）编写两个搜索查询：1. `appname:linux linux.event_name:\"登录失败事件\"` 或 `appname:linux linux.log_type:auth linux.event_name:\"登录失败事件\"`2. `appname:linux linux.event_name:\"登录成功事件\"`然后将这两条查询结果合并到一起并计算出总共有多少条记录以及每分钟发生的登录次数。最后，将结果以直观的方式展示给用户。", "output": "(appname:linux linux.event_name:登录失败事件) OR (appname:linux linux.log_type:auth linux.event_name:登录失败事件)  | bucket timestamp span=30m as ts | stats count() as count_ by ts|rename count_ as \"登录次数\"|eval line=\"登录失败\" | append [[appname:linux linux.event_name:登录成功事件| bucket timestamp span=30m as ts | stats count() as count_ by ts|rename count_ as \"登录次数\"|eval line=\"登录成功\"]]"}
{"input": "索引可用字段有：gc.beforeEden, gc.invocations, gc.stoptime, gc.totalnewgeneration, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想问的是，我的应用在运行过程中，每隔五分钟就会发生一次垃圾回收吗？如果是这样的话，那么在过去的三小时的垃圾回收中，有多少次是 Full GC（全堆垃圾回收）呢？此外，在这三个小时内，Java 堆空间的平均使用量是多少 MB？此外，整个 JVM 的内存情况如何？", "output": "appname:gc tag:ibm_was middleware.nursery_total:>=0 middleware.nursery_free_before:>=0|bucket timestamp span=5m as ts|eval nursery_use_before=middleware.nursery_total-middleware.nursery_free_before|stats avg(nursery_use_before) as count_1 by ts|eval line=\"新占用_before\"|append[[appname:gc tag:ibm_was middleware.nursery_total:>=0 middleware.middleware.nursery_free_after:>=0|bucket timestamp span=5m as ts|eval nursery_use_after=middleware.nursery_total-middleware.middleware.nursery_free_after|stats avg(nursery_use_after) as count_1 by ts|eval line=\"新占用_after\"]]|append[[appname:gc tag:ibm_was middleware.nursery_total:>=0 middleware.tenure_free_before:>=0|bucket timestamp span=5m as ts|eval tenure_use_before=middleware.tenure_total-middleware.tenure_free_before|stats avg(tenure_use_before) as count_1 by ts|eval line=\"老占用_before\"]]|append[[appname:gc tag:ibm_was middleware.nursery_total:>=0 middleware.tenure_free_after:>=0|bucket timestamp span=5m as ts|eval tenure_use_after=middleware.tenure_total-middleware.tenure_free_after|stats avg(tenure_use_after) as count_1 by ts|eval line=\"老占用_after\"]]|append[[appname:gc tag:ibm_was|bucket timestamp span=5m as ts|stats avg(middleware.tenure_total) as count_1 by ts|eval line=\"老年代_total\"]]|append[[appname:gc tag:ibm_was|bucket timestamp span=5m as ts|stats avg(middleware.nursery_total) as count_1 by ts|eval line=\"新生代_total\"]]|append[[appname:gc tag:ibm_was|bucket timestamp span=5m as ts|stats avg(middleware.heap) as count_1 by ts|eval line=\"堆内存占用\"]]|append[[appname:gc tag:ibm_was|bucket timestamp span=5m as ts|eval aaa=4|stats avg(aaa) as count_1 by ts|eval line=\"堆总内存\"]]|append[[appname:gc tag:ibm_was middleware.type:global |bucket timestamp span=5m as ts|stats count()  as count_2 by ts|eval line=\"FullGC次数\"]]|append[[appname:gc tag:ibm_was middleware.type:global|bucket timestamp span=5m as ts|eval cost=middleware.cost/1000 |stats avg(cost) as count_2 by ts|eval line=\"FullGC耗时(单位:秒)\"]]|sort by +ts"}
{"input": "", "instruction": "我想问的是，appname 为 a10, tag 为 a10 下发生的状态为 down 和 up 的情况每小时有多少个？", "output": "appname:a10 tag:a10 |bucket timestamp span=1h as ts|stats count() as ct by ts|eval line=\"总事件\"|append[[ appname:a10 tag:a10 a10.status:down |bucket timestamp span=1h as ts |stats count() as ct by ts |eval line=\"down事件\"]]|append[[ appname:a10 tag:a10 a10.status:up |bucket timestamp span=1h as ts |stats count() as ct by ts |eval line=\"up事件\"]]"}
{"input": "", "instruction": "我想问的是 Zookeeper 服务的运行状态和性能指标，比如延迟的最大值最小值平均值的趋势图？", "output": "appname:zookeeper tag:zookeeper_health | bucket timestamp span=1m as ts|stats avg(middleware.zkmsg.zk_avg_latency) as avg_ by ts|append [[appname:zookeeper tag:zookeeper_health | bucket timestamp span=1m as ts|stats avg(middleware.zkmsg.zk_max_latency) as max_ by ts]]|append [[appname:zookeeper tag:zookeeper_health | bucket timestamp span=1m as ts|stats avg(middleware.zkmsg.zk_min_latency) as min_ by ts]]"}
{"input": "索引可用字段有：loadbalancing.dst_ip, loadbalancing.level, loadbalancing.listenervs_ip, loadbalancing.msg, loadbalancing.querytype, loadbalancing.responsecode, loadbalancing.severity, loadbalancing.src.geo.province, loadbalancing.src_ip, loadbalancing.status, loadbalancing.type, loadbalancing.user, loadbalancing.username, loadblancing.status, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想要知道在 f5 负载平衡的用量趋势，你能告诉我最小、平均和最大的字节数吗？", "output": "appname:loadbalancing tag:f5 AND loadbalancing.type:logger|bucket timestamp span=30m as ts |eval a=loadbalancing.byte|stats min(a) as byte by ts,a|eval line=\"min_byte\"|append [[ appname:loadbalancing AND loadbalancing.type:logger |bucket timestamp span=30m as ts |eval a=loadbalancing.byte |stats avg(a) as byte by ts,a |eval line=\"avg_byte\"]]|append [[  appname:loadbalancing AND loadbalancing.type:logger |bucket timestamp span=30m as ts |eval a=loadbalancing.byte |stats max(a) as byte by ts,a |eval line=\"max_byte\"]]"}
{"input": "索引可用字段有：switch.IP, switch.action, switch.auth_method, switch.bandwidth, switch.brief, switch.cmd, switch.count, switch.desc, switch.desc.cmd, switch.desc.user, switch.describe, switch.ethernet, switch.event_type, switch.facility, switch.host, switch.host_ip, switch.interface_name, switch.ip, switch.kv.COMMAND, switch.kv.TTY, switch.kv.USER, switch.kvmsg.IpAddress, switch.kvmsg.UserName, switch.level, switch.log_message, switch.log_type, switch.login_method, switch.mode, switch.module, switch.port, switch.port_channel, switch.reason, switch.result, switch.severity, switch.speed, switch.src_ip, switch.src_mac, switch.state, switch.terminal, switch.time, switch.user, switch.vlan, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "在某个叫做`switch`、标签为`cisco_ios`并且认证通过（即登录成功）的设备上，使用`1小时`的时间间隔对系统进行统计，并将结果以`Authorization times`和`line`两个字段分别表示的表格中返回，其中`line`字段的值分别为`Authorization success`和`Authorization failure`。", "output": "appname:switch tag:cisco_ios  AND Authorization succeeded |bucket timestamp span=1h as ts| stats count() as count_ by ts|rename count_ as \"授权次数\"|eval line=\"授权成功\" | append [[appname:switch tag:cisco_ios  AND Authorization failed |bucket timestamp span=1h as ts| stats count() as count_ by ts|rename count_ as \"授权次数\"|eval line=\"授权失败\"]]"}
{"input": "索引可用字段有：waf.action, waf.attack_name, waf.attack_type, waf.bytes_in, waf.cost, waf.cve_id, waf.dst_city, waf.dst_domain, waf.dst_ip, waf.dst_latitude, waf.dst_longitude, waf.dst_port, waf.error_msg, waf.event_level, waf.event_log_level, waf.event_name, waf.event_type, waf.http_method, waf.http_refer, waf.is_truncated, waf.kv.Evt_level, waf.kv.Evt_type, waf.kv.event_name, waf.kv.http_method, waf.kv.http_refer, waf.kv.http_url, waf.kv.msg, waf.kv.owasp_top, waf.kv.pri, waf.kv.severity_level, waf.kv.status, waf.kv.type, waf.level, waf.log_category, waf.message, waf.message.action, waf.message.event, waf.message.method, waf.message.policy, waf.message.src_ip.geo.ip, waf.message.src_ip.geo.province, waf.message.src_port, waf.message.status, waf.message.threaten, waf.method, waf.module, waf.msg.act, waf.msg.cs, waf.msg.policy_id, waf.msg.src.geo.country, waf.policy_name, waf.proto, waf.referer, waf.risk_level, waf.severity, waf.src.geo.city, waf.src.geo.country, waf.src.geo.ip, waf.src.geo.isp, waf.src.geo.latitude, waf.src.geo.longitude, waf.src.geo.province, waf.src_ip, waf.src_port, waf.status, waf.status_code, waf.threat_level, waf.time, waf.ua_browser, waf.ua_device, waf.ua_os, waf.uri, waf.url, waf.user_agent.browser, waf.user_agent.os, waf.website_name, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想问的是，在每小时内，有多少条记录属于这些攻击类型：特征码、关联和特征模型。", "output": "appname:waf  tag:imperva |bucket timestamp span=1h as ts |stats count() by ts | eval hour = formatdate(ts, \"HH:mm\") | eval d=\"事件总量\" |append [[appname:waf  tag:imperva AND waf.attack_type:特征码 |bucket timestamp span=1h as ts |stats count() by ts | eval hour = formatdate(ts, \"HH:mm\") | eval d=\"特征码\"]] |append [[appname:waf AND waf.attack_type:关联 |bucket timestamp span=1h as ts |stats count() by ts | eval hour = formatdate(ts, \"HH:mm\") | eval d=\"关联\"]] |append [[appname:waf AND waf.attack_type:特征模型 |bucket timestamp span=1h as ts |stats count() by ts | eval hour = formatdate(ts, \"HH:mm\") | eval d=\"特征模型\"]]"}
{"input": "索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想询问的是以下内容：这段代码的功能是将某些时间间隔内的访问记录进行分桶、统计并按操作和 URL 分组，然后将其结果与另一张表中的数据合并。", "output": "appname:firewall AND tag:topsec (AUTH) |bucket timestamp span=5m as ts |stats count() as cnt by ts,firewall.msg.op|rename firewall.msg.op as op|append[[ appname:firewall AND tag:topsec firewall.msg.method:* |bucket timestamp span=5m as ts |stats count() as cnt by ts,firewall.msg.description|rename firewall.msg.description as op]]"}
{"input": "索引可用字段有：ips.action, ips.application, ips.attack_name, ips.attack_type, ips.block_reason, ips.cve, ips.dst.geo.city, ips.dst.geo.ip, ips.dst.geo.latitude, ips.dst.geo.longitude, ips.dst_ip, ips.dst_port, ips.event, ips.event_id, ips.event_level, ips.event_name, ips.inbound_interface, ips.inbound_zone, ips.level, ips.local, ips.msg.seclevel, ips.outbound_interface, ips.outbound_zone, ips.policy, ips.proto, ips.service, ips.severity, ips.src.geo.city, ips.src.geo.country, ips.src.geo.ip, ips.src.geo.latitude, ips.src.geo.longitude, ips.src.geo.province, ips.src_ip, ips.src_port, ips.url, ips.vendor_app, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想知道在每小时内，有多少个应用为“Mcafee”并且不是信息性级别的警告。", "output": "appname:ips tag:mcafee NOT ips.level:Informational|bucket timestamp span=1h as ts| stats count() as cnt by ts|eval line=\"攻击事件\"|append [[ appname:ips tag:mcafee  ips.level:Informational |bucket timestamp span=1h as ts | stats count() as cnt by ts |eval line=\"info事件\"]]|append [[ appname:ips tag:mcafee  ips.level:* |bucket timestamp span=1h as ts | stats count() as cnt by ts |eval line=\"所有事件\"]]"}
{"input": "索引可用字段有：firewall.action, firewall.alarm_ip, firewall.app, firewall.app_name, firewall.app_type, firewall.appcat, firewall.application_type, firewall.apprisk, firewall.attack, firewall.attack_message, firewall.attack_name, firewall.brief, firewall.dip, firewall.dst.geo.city, firewall.dst.geo.country, firewall.dst.geo.ip, firewall.dst.geo.province, firewall.dst.geo.latitude, firewall.dst.geo.longitude, firewall.dst_ip, firewall.dst_port, firewall.dst_zone, firewall.dup_add, firewall.event_level, firewall.event_name, firewall.event_type, firewall.facility, firewall.flow.application, firewall.flow.dst_ip.geo.city, firewall.flow.policy, firewall.flow.proto, firewall.fw_ip, firewall.grade, firewall.host, firewall.ingress_if, firewall.interface, firewall.kv.proto, firewall.kv.rule, firewall.level, firewall.locip, firewall.log_level, firewall.message, firewall.mod, firewall.module, firewall.msg, firewall.msg.CloseReason, firewall.msg.PolicyName, firewall.msg.RcvBytes, firewall.msg.SendBytes, firewall.msg.action, firewall.msg.command, firewall.msg.description, firewall.msg.dst_addr.geo.city, firewall.msg.dst_addr.geo.latitude, firewall.msg.dst_addr.geo.longitude, firewall.msg.dst_port, firewall.msg.fw, firewall.msg.method, firewall.msg.msg, firewall.msg.op, firewall.msg.pri, firewall.msg.proto, firewall.msg.reason, firewall.msg.result, firewall.msg.rule, firewall.msg.src_addr.geo.city, firewall.msg.src_addr.geo.country, firewall.msg.src_addr.geo.latitude, firewall.msg.src_addr.geo.longitude, firewall.msg.user, firewall.op, firewall.policy, firewall.policy_id, firewall.pri, firewall.pri_cn, firewall.proto, firewall.rcvd_pkt, firewall.reason, firewall.receive_byte, firewall.recorder, firewall.rem_ip.geo.city, firewall.rem_ip.geo.country, firewall.rem_ip.geo.province, firewall.remip, firewall.result, firewall.rule, firewall.rule_name, firewall.send_byte, firewall.sent, firewall.service, firewall.session_type, firewall.severity, firewall.severity_level, firewall.sip, firewall.source, firewall.src.geo.city, firewall.src.geo.country, firewall.src.geo.ip, firewall.src.geo.province, firewall.src.geo.latitude, firewall.src.geo.longitude, firewall.src_ip, firewall.src_port, firewall.src_zone, firewall.status, firewall.subtype, firewall.sys_info_id, firewall.sys_notify_traffic, firewall.threat_name, firewall.threat_subtype, firewall.threat_type, firewall.time, firewall.transport, firewall.type, firewall.url, firewall.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我想要知道在每三十分钟内，有多少条记录的事件类型为“IPS”、应用名为“firewall”并且包含标签“hillstone”。", "output": "(* IPS) AND appname:firewall tag:hillstone |bucket timestamp span=30m as ts | stats count() as count_ by ts,'firewall.msg.kvs.威胁级别'|rename 'firewall.msg.kvs.威胁级别' as event|append[[ (* IPS) AND appname:firewall tag:hillstone  |bucket timestamp span=30m as ts  | stats count() as count_ by ts,'firewall.msg.threat_severity' |rename 'firewall.msg.threat_severity' as event]]"}
{"input": "索引可用字段有：linux.cmd, linux.command, linux.event_detail.comm, linux.event_detail.exe, linux.event_detail.key, linux.event_detail.pid, linux.event_detail.ppid, linux.event_id, linux.event_msg.terminal, linux.event_name, linux.event_type, linux.log_type, linux.login_time, linux.msg, linux.pid, linux.result, linux.service_name, linux.src_ip, linux.status, linux.terminal, linux.type, linux.use_time, linux.user, appname, tag, logtype, ip, hostname, timestamp, source。请仅使用所需要的字段。", "instruction": "我在寻找 Linux 系统中应用为 `linux` 和错误消息包含 `Authentication failure` 的访问记录的数量统计信息。", "output": "appname:linux AND Authentication\\ failure\\ for  | bucket timestamp span=30m as ts | stats count() as count_ by ts|rename count_ as \"登录次数\"|eval line=\"登录失败\" | append [[appname:linux Accepted | bucket timestamp span=30m as ts | stats count() as count_ by ts|rename count_ as \"登录次数\"|eval line=\"登录成功\"]]"}
{"input": "", "instruction": "我想问的是，每小时内，每五分钟就有多少条记录的tag为checkpoint firewall.action:drop,并且同时满足appname为firewall的日志？", "output": "starttime=\"-1h\" (* AND appname:firewall) AND tag:checkpoint firewall.action:drop |bucket timestamp span=5m as ts |stats count() by ts|append[[(* AND appname:firewall) AND tag:checkpoint firewall.action:Drop |bucket timestamp span=5m as ts |stats count() by ts]]"}
